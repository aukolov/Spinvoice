<?xml version="1.0"?>
<doc>
    <assembly>
        <name>itext.kernel</name>
    </assembly>
    <members>
        <member name="T:iText.Kernel.Colors.Color">
            <summary>Represents a color</summary>
        </member>
        <member name="F:iText.Kernel.Colors.Color.BLACK">
            <summary>Predefined black DeviceRgb color</summary>
        </member>
        <member name="F:iText.Kernel.Colors.Color.BLUE">
            <summary>Predefined blue  DeviceRgb color</summary>
        </member>
        <member name="F:iText.Kernel.Colors.Color.CYAN">
            <summary>Predefined cyan DeviceRgb color</summary>
        </member>
        <member name="F:iText.Kernel.Colors.Color.DARK_GRAY">
            <summary>Predefined dark gray DeviceRgb color</summary>
        </member>
        <member name="F:iText.Kernel.Colors.Color.GRAY">
            <summary>Predefined gray DeviceRgb color</summary>
        </member>
        <member name="F:iText.Kernel.Colors.Color.GREEN">
            <summary>Predefined green DeviceRgb color</summary>
        </member>
        <member name="F:iText.Kernel.Colors.Color.LIGHT_GRAY">
            <summary>Predefined light gray DeviceRgb color</summary>
        </member>
        <member name="F:iText.Kernel.Colors.Color.MAGENTA">
            <summary>Predefined magenta DeviceRgb color</summary>
        </member>
        <member name="F:iText.Kernel.Colors.Color.ORANGE">
            <summary>Predefined orange DeviceRgb color</summary>
        </member>
        <member name="F:iText.Kernel.Colors.Color.PINK">
            <summary>Predefined pink DeviceRgb color</summary>
        </member>
        <member name="F:iText.Kernel.Colors.Color.RED">
            <summary>Predefined red DeviceRgb color</summary>
        </member>
        <member name="F:iText.Kernel.Colors.Color.WHITE">
            <summary>Predefined white DeviceRgb color</summary>
        </member>
        <member name="F:iText.Kernel.Colors.Color.YELLOW">
            <summary>Predefined yellow DeviceRgb color</summary>
        </member>
        <member name="F:iText.Kernel.Colors.Color.colorSpace">
            <summary>The color space of the color</summary>
        </member>
        <member name="F:iText.Kernel.Colors.Color.colorValue">
            <summary>The color value of the color</summary>
        </member>
        <member name="M:iText.Kernel.Colors.Color.#ctor(iText.Kernel.Pdf.Colorspace.PdfColorSpace,System.Single[])">
            <summary>Creates a Color of certain color space and color value.</summary>
            <remarks>
            Creates a Color of certain color space and color value.
            If color value is set in null, all value components will be initialised with zeroes.
            </remarks>
            <param name="colorSpace">the color space to which the created Color object relates</param>
            <param name="colorValue">the color value of the created Color object</param>
        </member>
        <member name="M:iText.Kernel.Colors.Color.MakeColor(iText.Kernel.Pdf.Colorspace.PdfColorSpace)">
            <summary>Makes a Color of certain color space.</summary>
            <remarks>
            Makes a Color of certain color space.
            All color value components will be initialised with zeroes.
            </remarks>
            <param name="colorSpace">the color space to which the returned Color object relates</param>
        </member>
        <member name="M:iText.Kernel.Colors.Color.MakeColor(iText.Kernel.Pdf.Colorspace.PdfColorSpace,System.Single[])">
            <summary>Makes a Color of certain color space and color value.</summary>
            <remarks>
            Makes a Color of certain color space and color value.
            If color value is set in null, all value components will be initialised with zeroes.
            </remarks>
            <param name="colorSpace">the color space to which the returned Color object relates</param>
            <param name="colorValue">the color value of the returned Color object</param>
        </member>
        <member name="M:iText.Kernel.Colors.Color.ConvertCmykToRgb(iText.Kernel.Colors.DeviceCmyk)">
            <summary>
            Converts
            <see cref="T:iText.Kernel.Colors.DeviceCmyk">DeviceCmyk</see>
            color to
            <see cref="T:iText.Kernel.Colors.DeviceRgb">DeviceRgb</see>
            color
            </summary>
            <param name="cmykColor">the DeviceCmyk color which will be converted to DeviceRgb color</param>
            <returns>converted color</returns>
        </member>
        <member name="M:iText.Kernel.Colors.Color.ConvertRgbToCmyk(iText.Kernel.Colors.DeviceRgb)">
            <summary>
            Converts
            <see cref="T:iText.Kernel.Colors.DeviceRgb">DeviceRgb</see>
            color to
            <see cref="T:iText.Kernel.Colors.DeviceCmyk">DeviceCmyk</see>
            color
            </summary>
            <param name="rgbColor">the DeviceRgb color which will be converted to DeviceCmyk color</param>
            <returns>converted color</returns>
        </member>
        <member name="M:iText.Kernel.Colors.Color.GetNumberOfComponents">
            <summary>Returns the number of color value components</summary>
            <returns>the number of color value components</returns>
        </member>
        <member name="M:iText.Kernel.Colors.Color.GetColorSpace">
            <summary>
            Returns the
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfColorSpace">color space</see>
            to which the color is related.
            </summary>
            <returns>the color space of the color</returns>
        </member>
        <member name="M:iText.Kernel.Colors.Color.GetColorValue">
            <summary>Returns the color value of the color</summary>
            <returns>the color value</returns>
        </member>
        <member name="M:iText.Kernel.Colors.Color.SetColorValue(System.Single[])">
            <summary>Sets the color value of the color</summary>
            <param name="value">new color value</param>
        </member>
        <member name="M:iText.Kernel.Colors.Color.Equals(System.Object)">
            <summary>Indicates whether the color is equal to the given color.</summary>
            <remarks>
            Indicates whether the color is equal to the given color.
            The
            <see cref="F:iText.Kernel.Colors.Color.colorSpace">color space</see>
            and
            <see cref="F:iText.Kernel.Colors.Color.colorValue">color value</see>
            are considered during the comparison.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Colors.Color.GetHashCode">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Colors.DeviceCmyk">
            <summary>Color space to specify colors according to CMYK color model.</summary>
        </member>
        <member name="F:iText.Kernel.Colors.DeviceCmyk.CYAN">
            <summary>Predefined cyan DeviceCmyk color</summary>
        </member>
        <member name="F:iText.Kernel.Colors.DeviceCmyk.MAGENTA">
            <summary>Predefined magenta DeviceCmyk color</summary>
        </member>
        <member name="F:iText.Kernel.Colors.DeviceCmyk.YELLOW">
            <summary>Predefined yellow DeviceCmyk color</summary>
        </member>
        <member name="F:iText.Kernel.Colors.DeviceCmyk.BLACK">
            <summary>Predefined black DeviceCmyk color</summary>
        </member>
        <member name="M:iText.Kernel.Colors.DeviceCmyk.#ctor">
            <summary>Creates DeviceCmyk color with all colorants intensities initialised as zeroes.</summary>
        </member>
        <member name="M:iText.Kernel.Colors.DeviceCmyk.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Creates DeviceCmyk color by intensities of cyan, magenta, yellow and black colorants.</summary>
            <remarks>
            Creates DeviceCmyk color by intensities of cyan, magenta, yellow and black colorants.
            The intensities are considered to be in [0, 100] gap, if not,
            the intensity will be considered as 100 (when colorant's value is bigger than 100)
            or 0 (when colorant's value is less than 0).
            </remarks>
            <param name="c">the intensity of cyan colorant</param>
            <param name="m">the intensity of magenta colorant</param>
            <param name="y">the intensity of yellow colorant</param>
            <param name="k">the intensity of black colorant</param>
        </member>
        <member name="M:iText.Kernel.Colors.DeviceCmyk.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>Creates DeviceCmyk color by intensities of cyan, magenta, yellow and black colorants.</summary>
            <remarks>
            Creates DeviceCmyk color by intensities of cyan, magenta, yellow and black colorants.
            The intensities are considered to be in [0, 1] interval, if not,
            the intensity will be considered as 1 (when colorant's value is bigger than 1)
            or 0 (when colorant's value is less than 0).
            </remarks>
            <param name="c">the intensity of cyan colorant</param>
            <param name="m">the intensity of magenta colorant</param>
            <param name="y">the intensity of yellow colorant</param>
            <param name="k">the intensity of black colorant</param>
        </member>
        <member name="M:iText.Kernel.Colors.DeviceCmyk.MakeLighter(iText.Kernel.Colors.DeviceCmyk)">
            <summary>
            Returns
            <see cref="T:iText.Kernel.Colors.DeviceCmyk">DeviceCmyk</see>
            color which is lighter than given one
            </summary>
            <param name="cmykColor">the DeviceCmyk color to be made lighter</param>
            <returns>lighter color</returns>
        </member>
        <member name="M:iText.Kernel.Colors.DeviceCmyk.MakeDarker(iText.Kernel.Colors.DeviceCmyk)">
            <summary>
            Returns
            <see cref="T:iText.Kernel.Colors.DeviceCmyk">DeviceCmyk</see>
            color which is darker than given one
            </summary>
            <param name="cmykColor">the DeviceCmyk color to be made darker</param>
            <returns>darker color</returns>
        </member>
        <member name="T:iText.Kernel.Colors.DeviceGray">
            <summary>Color space to specify shades of gray color.</summary>
        </member>
        <member name="F:iText.Kernel.Colors.DeviceGray.WHITE">
            <summary>Predefined white DeviceGray color.</summary>
        </member>
        <member name="F:iText.Kernel.Colors.DeviceGray.GRAY">
            <summary>Predefined gray DeviceGray color.</summary>
        </member>
        <member name="F:iText.Kernel.Colors.DeviceGray.BLACK">
            <summary>Predefined black DeviceGray color.</summary>
        </member>
        <member name="M:iText.Kernel.Colors.DeviceGray.#ctor(System.Single)">
            <summary>Creates DeviceGray color by given grayscale.</summary>
            <remarks>
            Creates DeviceGray color by given grayscale.
            The grayscale is considered to be in [0, 1] interval, if not,
            the grayscale will be considered as 1 (when grayscale's value is bigger than 1)
            or 0 (when grayscale's value is less than 0).
            </remarks>
            <param name="value">the grayscale value</param>
        </member>
        <member name="M:iText.Kernel.Colors.DeviceGray.#ctor">
            <summary>Creates DeviceGray color with grayscale value initialised as zero.</summary>
        </member>
        <member name="M:iText.Kernel.Colors.DeviceGray.MakeLighter(iText.Kernel.Colors.DeviceGray)">
            <summary>
            Returns
            <see cref="T:iText.Kernel.Colors.DeviceGray">DeviceGray</see>
            color which is lighter than given one
            </summary>
            <param name="grayColor">the DeviceGray color to be made lighter</param>
            <returns>lighter color</returns>
        </member>
        <member name="M:iText.Kernel.Colors.DeviceGray.MakeDarker(iText.Kernel.Colors.DeviceGray)">
            <summary>
            Returns
            <see cref="T:iText.Kernel.Colors.DeviceGray">DeviceGray</see>
            color which is darker than given one
            </summary>
            <param name="grayColor">the DeviceGray color to be made darker</param>
            <returns>darker color</returns>
        </member>
        <member name="T:iText.Kernel.Colors.DeviceRgb">
            <summary>Color space to specify colors according to RGB color model.</summary>
        </member>
        <member name="M:iText.Kernel.Colors.DeviceRgb.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>Creates DeviceRgb color by intensities of red, green and blue colorants.</summary>
            <remarks>
            Creates DeviceRgb color by intensities of red, green and blue colorants.
            The intensities are considered to be in [0, 255] gap, if not,
            the intensity will be considered as 255 (when colorant's value is bigger than 255)
            or 0 (when colorant's value is less than 0).
            </remarks>
            <param name="r">the intensity of red colorant</param>
            <param name="g">the intensity of green colorant</param>
            <param name="b">the intensity of blue colorant</param>
        </member>
        <member name="M:iText.Kernel.Colors.DeviceRgb.#ctor(System.Single,System.Single,System.Single)">
            <summary>Creates DeviceRgb color by intensities of red, green and blue colorants.</summary>
            <remarks>
            Creates DeviceRgb color by intensities of red, green and blue colorants.
            The intensities are considered to be in [0, 1] interval, if not,
            the intensity will be considered as 1 (when colorant's value is bigger than 1)
            or 0 (when colorant's value is less than 0).
            </remarks>
            <param name="r">the intensity of red colorant</param>
            <param name="g">the intensity of green colorant</param>
            <param name="b">the intensity of blue colorant</param>
        </member>
        <member name="M:iText.Kernel.Colors.DeviceRgb.#ctor">
            <summary>Creates DeviceRgb color with all colorants intensities initialised as zeroes.</summary>
        </member>
        <member name="M:iText.Kernel.Colors.DeviceRgb.MakeLighter(iText.Kernel.Colors.DeviceRgb)">
            <summary>
            Returns
            <see cref="T:iText.Kernel.Colors.DeviceRgb">DeviceRgb</see>
            color which is lighter than given one
            </summary>
            <param name="rgbColor">the DeviceRgb color to be made lighter</param>
            <returns>lighter color</returns>
        </member>
        <member name="M:iText.Kernel.Colors.DeviceRgb.MakeDarker(iText.Kernel.Colors.DeviceRgb)">
            <summary>
            Returns
            <see cref="T:iText.Kernel.Colors.DeviceRgb">DeviceRgb</see>
            color which is darker than given one
            </summary>
            <param name="rgbColor">the DeviceRgb color to be made darker</param>
            <returns>darker color</returns>
        </member>
        <member name="M:iText.Kernel.Colors.IccBased.#ctor(System.IO.Stream)">
            <summary>Creates IccBased color.</summary>
            <param name="iccStream">ICC profile stream. User is responsible for closing the stream.</param>
        </member>
        <member name="M:iText.Kernel.Colors.IccBased.#ctor(System.IO.Stream,System.Single[])">
            <summary>Creates IccBased color.</summary>
            <param name="iccStream">ICC profile stream. User is responsible for closing the stream.</param>
            <param name="value">color value.</param>
        </member>
        <member name="T:iText.Kernel.Colors.WebColors">
            <summary>
            This class is a HashMap that contains the names of colors as a key and the
            corresponding RGB color as value.
            </summary>
            <remarks>
            This class is a HashMap that contains the names of colors as a key and the
            corresponding RGB color as value. (Source: Wikipedia
            http://en.wikipedia.org/wiki/Web_colors )
            </remarks>
        </member>
        <member name="F:iText.Kernel.Colors.WebColors.NAMES">
            <summary>HashMap containing all the names and corresponding color values.</summary>
        </member>
        <member name="M:iText.Kernel.Colors.WebColors.GetRGBColor(System.String)">
            <summary>Gives you a DeviceRgb based on a name.</summary>
            <param name="name">
            a name such as black, violet, cornflowerblue or #RGB or
            #RRGGBB or RGB or RRGGBB or rgb(R,G,B)
            </param>
            <returns>the corresponding DeviceRgb object. Never returns null.</returns>
        </member>
        <member name="M:iText.Kernel.Colors.WebColors.GetRGBAColor(System.String)">
            <summary>Gives an array of four floats that contain RGBA values, each value is between 0 and 1.</summary>
            <param name="name">
            a name such as black, violet, cornflowerblue or #RGB or
            #RRGGBB or RGB or RRGGBB or rgb(R,G,B) or rgb(R,G,B,A)
            </param>
            <returns>the corresponding array of four floats, or <code>null</code> if parsing failed.</returns>
        </member>
        <member name="M:iText.Kernel.Colors.WebColors.MissingHashColorFormat(System.String)">
            <summary>
            A web color string without the leading # will be 3 or 6 characters long
            and all those characters will be hex digits.
            </summary>
            <remarks>
            A web color string without the leading # will be 3 or 6 characters long
            and all those characters will be hex digits. NOTE: colStr must be all
            lower case or the current hex letter test will fail.
            </remarks>
            <param name="colStr">
            A non-null, lower case string that might describe an RGB color
            in hex.
            </param>
            <returns>Is this a web color hex string without the leading #?</returns>
        </member>
        <member name="T:iText.Kernel.Crypto.AESCipher">
            <summary>Creates an AES Cipher with CBC and padding PKCS5/7.</summary>
            <author>Paulo Soares</author>
        </member>
        <member name="M:iText.Kernel.Crypto.AESCipher.#ctor(System.Boolean,System.Byte[],System.Byte[])">
            <summary>Creates a new instance of AESCipher</summary>
        </member>
        <member name="T:iText.Kernel.Crypto.AESCipherCBCnoPad">
            <summary>Creates an AES Cipher with CBC and no padding.</summary>
            <author>Paulo Soares</author>
        </member>
        <member name="M:iText.Kernel.Crypto.AESCipherCBCnoPad.#ctor(System.Boolean,System.Byte[])">
            <summary>Creates a new instance of AESCipher</summary>
        </member>
        <member name="M:iText.Kernel.Crypto.AesDecryptor.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>Creates a new instance of AesDecryption</summary>
        </member>
        <member name="M:iText.Kernel.Crypto.ARCFOUREncryption.#ctor">
            <summary>Creates a new instance of ARCFOUREncryption</summary>
        </member>
        <member name="T:iText.Kernel.Crypto.BadPasswordException">
            <summary>Bad password exception.</summary>
        </member>
        <member name="T:iText.Kernel.PdfException">
            <summary>Exception class for exceptions in kernel module.</summary>
        </member>
        <member name="F:iText.Kernel.PdfException.object">
            <summary>Object for more details</summary>
        </member>
        <member name="M:iText.Kernel.PdfException.#ctor(System.String)">
            <summary>Creates a new instance of PdfException.</summary>
            <param name="message">the detail message.</param>
        </member>
        <member name="M:iText.Kernel.PdfException.#ctor(System.Exception)">
            <summary>Creates a new instance of PdfException.</summary>
            <param name="cause">
            the cause (which is saved for later retrieval by
            <see cref="P:System.Exception.InnerException"/>
            method).
            </param>
        </member>
        <member name="M:iText.Kernel.PdfException.#ctor(System.String,System.Object)">
            <summary>Creates a new instance of PdfException.</summary>
            <param name="message">the detail message.</param>
            <param name="obj">an object for more details.</param>
        </member>
        <member name="M:iText.Kernel.PdfException.#ctor(System.String,System.Exception)">
            <summary>Creates a new instance of PdfException.</summary>
            <param name="message">the detail message.</param>
            <param name="cause">
            the cause (which is saved for later retrieval by
            <see cref="P:System.Exception.InnerException"/>
            method).
            </param>
        </member>
        <member name="M:iText.Kernel.PdfException.#ctor(System.String,System.Exception,System.Object)">
            <summary>Creates a new instance of PdfException.</summary>
            <param name="message">the detail message.</param>
            <param name="cause">
            the cause (which is saved for later retrieval by
            <see cref="P:System.Exception.InnerException"/>
            method).
            </param>
            <param name="obj">an object for more details.</param>
        </member>
        <member name="M:iText.Kernel.PdfException.SetMessageParams(System.Object[])">
            <summary>Sets additional params for Exception message.</summary>
            <param name="messageParams">additional params.</param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.PdfException.GetMessageParams">
            <summary>Gets additional params for Exception message.</summary>
        </member>
        <member name="M:iText.Kernel.Crypto.BadPasswordException.#ctor(System.String,System.Exception)">
            <summary>Creates a new BadPasswordException.</summary>
            <param name="message">the detail message.</param>
            <param name="cause">
            the cause (which is saved for later retrieval by
            <see cref="P:System.Exception.InnerException"/>
            method).
            </param>
        </member>
        <member name="M:iText.Kernel.Crypto.BadPasswordException.#ctor(System.String)">
            <summary>Creates a new BadPasswordException.</summary>
            <param name="message">the detail message.</param>
        </member>
        <member name="T:iText.Kernel.Crypto.CryptoUtil">
            <summary>
            This file is a helper class for internal usage only.
            Be aware that it's API and functionality may be changed in future.
            </summary>
        </member>
        <member name="M:iText.Kernel.Crypto.CryptoUtil.ReadPrivateKeyFromPkcs12KeyStore(System.IO.Stream,System.String,System.Char[])">
            <exception cref="T:Org.BouncyCastle.Security.GeneralSecurityException"/>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.Kernel.Crypto.IVGenerator">
            <summary>An initialization vector generator for a CBC block encryption.</summary>
            <remarks>An initialization vector generator for a CBC block encryption. It's a random generator based on ARCFOUR.
                </remarks>
            <author>Paulo Soares</author>
        </member>
        <member name="M:iText.Kernel.Crypto.IVGenerator.#ctor">
            <summary>Creates a new instance of IVGenerator</summary>
        </member>
        <member name="M:iText.Kernel.Crypto.IVGenerator.GetIV">
            <summary>Gets a 16 byte random initialization vector.</summary>
            <returns>a 16 byte random initialization vector</returns>
        </member>
        <member name="M:iText.Kernel.Crypto.IVGenerator.GetIV(System.Int32)">
            <summary>Gets a random initialization vector.</summary>
            <param name="len">the length of the initialization vector</param>
            <returns>a random initialization vector</returns>
        </member>
        <member name="M:iText.Kernel.Crypto.OutputStreamEncryption.#ctor(System.IO.Stream)">
            <summary>Creates a new instance of OutputStreamCounter</summary>
        </member>
        <member name="M:iText.Kernel.Crypto.OutputStreamEncryption.Dispose(System.Boolean)">
            <summary>
            Closes this output stream and releases any system resources
            associated with this stream.
            </summary>
            <remarks>
            Closes this output stream and releases any system resources
            associated with this stream. The general contract of
            <c>close</c>
            is that it closes the output stream. A closed stream cannot perform
            output operations and cannot be reopened.
            <p/>
            The
            <c>close</c>
            method of
            <c>OutputStream</c>
            does nothing.
            </remarks>
            <exception cref="T:System.IO.IOException">if an I/O error occurs.</exception>
        </member>
        <member name="M:iText.Kernel.Crypto.OutputStreamEncryption.Flush">
            <summary>
            Flushes this output stream and forces any buffered output bytes
            to be written out.
            </summary>
            <remarks>
            Flushes this output stream and forces any buffered output bytes
            to be written out. The general contract of
            <c>flush</c>
            is
            that calling it is an indication that, if any bytes previously
            written have been buffered by the implementation of the output
            stream, such bytes should immediately be written to their
            intended destination.
            <p/>
            The
            <c>flush</c>
            method of
            <c>OutputStream</c>
            does nothing.
            </remarks>
            <exception cref="T:System.IO.IOException">if an I/O error occurs.</exception>
        </member>
        <member name="M:iText.Kernel.Crypto.OutputStreamEncryption.Write(System.Byte[])">
            <summary>
            Writes
            <c>b.length</c>
            bytes from the specified byte array
            to this output stream. The general contract for
            <c>write(b)</c>
            is that it should have exactly the same effect as the call
            <c>write(b, 0, b.length)</c>
            .
            </summary>
            <param name="b">the data.</param>
            <exception cref="T:System.IO.IOException">if an I/O error occurs.</exception>
            <seealso cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:iText.Kernel.Crypto.OutputStreamEncryption.Write(System.Int32)">
            <summary>Writes the specified byte to this output stream.</summary>
            <remarks>
            Writes the specified byte to this output stream. The general
            contract for
            <c>write</c>
            is that one byte is written
            to the output stream. The byte to be written is the eight
            low-order bits of the argument
            <paramref name="b"/>
            . The 24
            high-order bits of
            <paramref name="b"/>
            are ignored.
            <p/>
            Subclasses of
            <c>OutputStream</c>
            must provide an
            implementation for this method.
            </remarks>
            <param name="b">
            the
            <c>byte</c>
            .
            </param>
            <exception cref="T:System.IO.IOException">
            if an I/O error occurs. In particular, an
            <c>IOException</c>
            may be thrown if the
            output stream has been closed.
            </exception>
        </member>
        <member name="M:iText.Kernel.Crypto.OutputStreamEncryption.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes
            <paramref name="len"/>
            bytes from the specified byte array
            starting at offset
            <paramref name="off"/>
            to this output stream.
            The general contract for
            <c>write(b, off, len)</c>
            is that
            some of the bytes in the array
            <paramref name="b"/>
            are written to the
            output stream in order; element
            <c>b[off]</c>
            is the first
            byte written and
            <c>b[off+len-1]</c>
            is the last byte written
            by this operation.
            <p/>
            The
            <c>write</c>
            method of
            <c>OutputStream</c>
            calls
            the write method of one argument on each of the bytes to be
            written out. Subclasses are encouraged to override this method and
            provide a more efficient implementation.
            <p/>
            If
            <paramref name="b"/>
            is
            <see langword="null"/>
            , a
            <c>NullPointerException</c>
            is thrown.
            <p/>
            If
            <paramref name="off"/>
            is negative, or
            <paramref name="len"/>
            is negative, or
            <c>off+len</c>
            is greater than the length of the array
            <paramref name="b"/>
            , then an <tt>IndexOutOfBoundsException</tt> is thrown.
            </summary>
            <param name="b">the data.</param>
            <param name="off">the start offset in the data.</param>
            <param name="len">the number of bytes to write.</param>
            <exception cref="T:System.IO.IOException">
            if an I/O error occurs. In particular,
            an
            <c>IOException</c>
            is thrown if the output
            stream is closed.
            </exception>
        </member>
        <member name="M:iText.Kernel.Crypto.OutputStreamAesEncryption.#ctor(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>Creates a new instance of OutputStreamCounter</summary>
        </member>
        <member name="M:iText.Kernel.Crypto.OutputStreamAesEncryption.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes
            <paramref name="len"/>
            bytes from the specified byte array
            starting at offset
            <paramref name="off"/>
            to this output stream.
            The general contract for
            <c>write(b, off, len)</c>
            is that
            some of the bytes in the array
            <paramref name="b"/>
            are written to the
            output stream in order; element
            <c>b[off]</c>
            is the first
            byte written and
            <c>b[off+len-1]</c>
            is the last byte written
            by this operation.
            <p/>
            The
            <c>write</c>
            method of
            <c>OutputStream</c>
            calls
            the write method of one argument on each of the bytes to be
            written out. Subclasses are encouraged to override this method and
            provide a more efficient implementation.
            <p/>
            If
            <paramref name="b"/>
            is
            <see langword="null"/>
            , a
            <c>NullPointerException</c>
            is thrown.
            <p/>
            If
            <paramref name="off"/>
            is negative, or
            <paramref name="len"/>
            is negative, or
            <c>off+len</c>
            is greater than the length of the array
            <paramref name="b"/>
            , then an <tt>IndexOutOfBoundsException</tt> is thrown.
            </summary>
            <param name="b">the data.</param>
            <param name="off">the start offset in the data.</param>
            <param name="len">the number of bytes to write.</param>
            <exception cref="T:System.IO.IOException">
            if an I/O error occurs. In particular,
            an
            <c>IOException</c>
            is thrown if the output
            stream is closed.
            </exception>
        </member>
        <member name="M:iText.Kernel.Crypto.OutputStreamStandardEncryption.#ctor(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>Creates a new instance of OutputStreamStandardEncryption</summary>
        </member>
        <member name="M:iText.Kernel.Crypto.OutputStreamStandardEncryption.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes
            <paramref name="len"/>
            bytes from the specified byte array
            starting at offset
            <paramref name="off"/>
            to this output stream.
            The general contract for
            <c>write(b, off, len)</c>
            is that
            some of the bytes in the array
            <paramref name="b"/>
            are written to the
            output stream in order; element
            <c>b[off]</c>
            is the first
            byte written and
            <c>b[off+len-1]</c>
            is the last byte written
            by this operation.
            <p/>
            The
            <c>write</c>
            method of
            <c>OutputStream</c>
            calls
            the write method of one argument on each of the bytes to be
            written out. Subclasses are encouraged to override this method and
            provide a more efficient implementation.
            <p/>
            If
            <paramref name="b"/>
            is
            <see langword="null"/>
            , a
            <c>NullPointerException</c>
            is thrown.
            <p/>
            If
            <paramref name="off"/>
            is negative, or
            <paramref name="len"/>
            is negative, or
            <c>off+len</c>
            is greater than the length of the array
            <paramref name="b"/>
            , then an <tt>IndexOutOfBoundsException</tt> is thrown.
            </summary>
            <param name="b">the data.</param>
            <param name="off">the start offset in the data.</param>
            <param name="len">the number of bytes to write.</param>
            <exception cref="T:System.IO.IOException">
            if an I/O error occurs. In particular,
            an
            <c>IOException</c>
            is thrown if the output
            stream is closed.
            </exception>
        </member>
        <member name="M:iText.Kernel.Crypto.Securityhandler.EncryptionUtils.CipherBytes(Org.BouncyCastle.X509.X509Certificate,System.Byte[],Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier)">
            <exception cref="T:Org.BouncyCastle.Security.GeneralSecurityException"/>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Crypto.Securityhandler.EncryptionUtils.CalculateDERForRecipientParams(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
            <exception cref="T:Org.BouncyCastle.Security.GeneralSecurityException"/>
        </member>
        <member name="T:iText.Kernel.Crypto.Securityhandler.PubKeySecurityHandler">
            <author>Aiken Sam (aikensam@ieee.org)</author>
        </member>
        <member name="F:iText.Kernel.Crypto.Securityhandler.SecurityHandler.mkey">
            <summary>The global encryption key</summary>
        </member>
        <member name="F:iText.Kernel.Crypto.Securityhandler.SecurityHandler.nextObjectKey">
            <summary>The encryption key for a particular object/generation.</summary>
            <remarks>
            The encryption key for a particular object/generation.
            It is recalculated with
            <see cref="M:iText.Kernel.Crypto.Securityhandler.SecurityHandler.SetHashKeyForNextObject(System.Int32,System.Int32)"/>
            for every object individually based in its object/generation.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Crypto.Securityhandler.SecurityHandler.nextObjectKeySize">
            <summary>
            The encryption key length for a particular object/generation
            It is recalculated with
            <see cref="M:iText.Kernel.Crypto.Securityhandler.SecurityHandler.SetHashKeyForNextObject(System.Int32,System.Int32)"/>
            for every object individually based in its object/generation.
            </summary>
        </member>
        <member name="F:iText.Kernel.Crypto.Securityhandler.SecurityHandler.extra">
            <summary>Work area to prepare the object/generation bytes</summary>
        </member>
        <member name="M:iText.Kernel.Crypto.Securityhandler.SecurityHandler.SetHashKeyForNextObject(System.Int32,System.Int32)">
            <summary>
            Note: For most of the supported security handlers algorithm to calculate encryption key for particular object
            is the same.
            </summary>
            <param name="objNumber"/>
            <param name="objGeneration"/>
        </member>
        <member name="M:iText.Kernel.Crypto.Securityhandler.PubKeySecurityHandler.GetEncodedRecipient(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
            <exception cref="T:Org.BouncyCastle.Security.GeneralSecurityException"/>
        </member>
        <member name="M:iText.Kernel.Crypto.Securityhandler.PubKeySecurityHandler.GetEncodedRecipients">
            <exception cref="T:System.IO.IOException"/>
            <exception cref="T:Org.BouncyCastle.Security.GeneralSecurityException"/>
        </member>
        <member name="M:iText.Kernel.Crypto.Securityhandler.PubKeySecurityHandler.CreateDERForRecipient(System.Byte[],Org.BouncyCastle.X509.X509Certificate)">
            <exception cref="T:System.IO.IOException"/>
            <exception cref="T:Org.BouncyCastle.Security.GeneralSecurityException"/>
        </member>
        <member name="M:iText.Kernel.Crypto.Securityhandler.PubKeySecurityHandler.ComputeRecipientInfo(Org.BouncyCastle.X509.X509Certificate,System.Byte[])">
            <exception cref="T:Org.BouncyCastle.Security.GeneralSecurityException"/>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Crypto.Securityhandler.StandardSecurityHandler.GetIsoBytes(iText.Kernel.Pdf.PdfString)">
            <summary>Gets bytes of String-value without considering encoding.</summary>
            <returns>byte array</returns>
        </member>
        <member name="M:iText.Kernel.Crypto.StandardDecryptor.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>Creates a new instance of StandardDecryption</summary>
        </member>
        <member name="T:iText.Kernel.Events.Event">
            <summary>Describes abstract event.</summary>
        </member>
        <member name="F:iText.Kernel.Events.Event.type">
            <summary>A type of event.</summary>
        </member>
        <member name="M:iText.Kernel.Events.Event.#ctor(System.String)">
            <summary>Creates an event of the specified type.</summary>
            <param name="type">type of event</param>
        </member>
        <member name="M:iText.Kernel.Events.Event.GetEventType">
            <summary>Returns the type of this event.</summary>
            <returns>type of this event</returns>
        </member>
        <member name="T:iText.Kernel.Events.EventDispatcher">
            <summary>
            IEventDispatcher implementation that forwards Events to registered
            <see cref="T:iText.Kernel.Events.IEventHandler"/>
            implementations.
            </summary>
        </member>
        <member name="T:iText.Kernel.Events.IEventDispatcher">
            <summary>Event dispatcher interface.</summary>
        </member>
        <member name="M:iText.Kernel.Events.IEventDispatcher.AddEventHandler(System.String,iText.Kernel.Events.IEventHandler)">
            <summary>Adds new event handler.</summary>
            <param name="type">a type of event to be handled.</param>
            <param name="handler">event handler.</param>
        </member>
        <member name="M:iText.Kernel.Events.IEventDispatcher.DispatchEvent(iText.Kernel.Events.Event)">
            <summary>Dispatches an event.</summary>
            <param name="event"/>
        </member>
        <member name="M:iText.Kernel.Events.IEventDispatcher.DispatchEvent(iText.Kernel.Events.Event,System.Boolean)">
            <summary>Dispatches a delayed event.</summary>
            <remarks>
            Dispatches a delayed event.
            Sometimes event cannot be handled immediately because event handler has not been set yet.
            In this case event is placed into event ques of dispatcher and is waiting until handler is assigned.
            </remarks>
            <param name="event"/>
            <param name="delayed"/>
        </member>
        <member name="M:iText.Kernel.Events.IEventDispatcher.HasEventHandler(System.String)">
            <summary>Checks if event dispatcher as an event handler assigned for a certain event type.</summary>
            <param name="type"/>
        </member>
        <member name="M:iText.Kernel.Events.IEventDispatcher.RemoveEventHandler(System.String,iText.Kernel.Events.IEventHandler)">
            <summary>Removes event handler.</summary>
            <param name="type"/>
            <param name="handler"/>
        </member>
        <member name="M:iText.Kernel.Events.IEventDispatcher.RemoveAllHandlers">
            <summary>Remove all event handlers.</summary>
        </member>
        <member name="T:iText.Kernel.Events.IEventHandler">
            <summary>Interface for handling events.</summary>
            <remarks>
            Interface for handling events. EventHandlers are added to the
            <see cref="T:iText.Kernel.Events.EventDispatcher"/>
            .
            </remarks>
        </member>
        <member name="M:iText.Kernel.Events.IEventHandler.HandleEvent(iText.Kernel.Events.Event)">
            <summary>Hook for handling events.</summary>
            <remarks>
            Hook for handling events. Implementations can access the PdfDocument instance
            associated to the specified Event or, if available, the PdfPage instance.
            </remarks>
            <param name="event">the Event that needs to be processed</param>
        </member>
        <member name="T:iText.Kernel.Events.PdfDocumentEvent">
            <summary>Event dispatched by PdfDocument.</summary>
        </member>
        <member name="F:iText.Kernel.Events.PdfDocumentEvent.START_PAGE">
            <summary>Dispatched after page is created.</summary>
        </member>
        <member name="F:iText.Kernel.Events.PdfDocumentEvent.INSERT_PAGE">
            <summary>Dispatched after page is inserted/added into document.</summary>
        </member>
        <member name="F:iText.Kernel.Events.PdfDocumentEvent.REMOVE_PAGE">
            <summary>Dispatched after page is removed from document.</summary>
        </member>
        <member name="F:iText.Kernel.Events.PdfDocumentEvent.END_PAGE">
            <summary>Dispatched before page is closed and written.</summary>
        </member>
        <member name="F:iText.Kernel.Events.PdfDocumentEvent.page">
            <summary>The PdfPage associated with this event.</summary>
        </member>
        <member name="F:iText.Kernel.Events.PdfDocumentEvent.document">
            <summary>The PdfDocument associated with this event.</summary>
        </member>
        <member name="M:iText.Kernel.Events.PdfDocumentEvent.#ctor(System.String,iText.Kernel.Pdf.PdfDocument)">
            <summary>Creates a PdfDocumentEvent.</summary>
            <param name="type">type of the event that fired this event</param>
            <param name="document">document that fired this event</param>
        </member>
        <member name="M:iText.Kernel.Events.PdfDocumentEvent.#ctor(System.String,iText.Kernel.Pdf.PdfPage)">
            <summary>Creates a PdfDocumentEvent.</summary>
            <param name="type">type of the event that fired this event</param>
            <param name="page">page that fired this event</param>
        </member>
        <member name="M:iText.Kernel.Events.PdfDocumentEvent.GetDocument">
            <summary>Returns the PdfDocument associated with this event.</summary>
            <returns>the PdfDocument associated with this event</returns>
        </member>
        <member name="M:iText.Kernel.Events.PdfDocumentEvent.GetPage">
            <summary>Returns the PdfPage associated with this event.</summary>
            <remarks>Returns the PdfPage associated with this event. Warning: this can be null.</remarks>
            <returns>the PdfPage associated with this event</returns>
        </member>
        <member name="T:iText.Kernel.Font.DocFontEncoding">
            <summary>This class allow to parse document font's encoding.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfObjectWrapper`1.MakeIndirect(iText.Kernel.Pdf.PdfDocument,iText.Kernel.Pdf.PdfIndirectReference)">
            <summary>Marks object behind wrapper to be saved as indirect.</summary>
            <param name="document">a document the indirect reference will belong to.</param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfObjectWrapper`1.MakeIndirect(iText.Kernel.Pdf.PdfDocument)">
            <summary>Marks object behind wrapper to be saved as indirect.</summary>
            <param name="document">a document the indirect reference will belong to.</param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfObjectWrapper`1.IsWrappedObjectMustBeIndirect">
            <summary>
            Defines if the object behind this wrapper must be an indirect object in the
            resultant document.
            </summary>
            <remarks>
            Defines if the object behind this wrapper must be an indirect object in the
            resultant document.
            <br /><br />
            If this method returns <i>true</i> it doesn't necessarily mean that object
            must be in the indirect state at any moment, but rather defines that
            when the object will be written to the document it will be transformed into
            indirect object if it's not indirect yet.
            <br /><br />
            Return value of this method shouldn't depend on any logic, it should return
            always <i>true</i> or <i>false</i>.
            </remarks>
            <returns>
            <i>true</i> if in the resultant document the object behind the wrapper
            must be indirect, otherwise <i>false</i>.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfObjectWrapper`1.EnsureObjectIsAddedToDocument(iText.Kernel.Pdf.PdfObject)">
            <summary>
            Some wrappers use object's indirect reference to obtain the
            <c>PdfDocument</c>
            to which the object belongs to. For this matter, for these wrappers it is implicitly defined
            that they work with indirect objects only. Commonly these wrappers have two constructors: one with
            <c>PdfDocument</c>
            as parameter to create a new object, and the other one which
            wraps around the given
            <c>PdfObject</c>
            . This method should be used in the second
            type of constructors to ensure that wrapper will able to obtain the
            <c>PdfDocument</c>
            instance.
            </summary>
            <param name="object">
            the
            <c>PdfObject</c>
            to be checked if it is indirect.
            </param>
        </member>
        <member name="F:iText.Kernel.Font.PdfFont.newFont">
            <summary>false, if the font comes from PdfDocument.</summary>
        </member>
        <member name="F:iText.Kernel.Font.PdfFont.embedded">
            <summary>true if the font is to be embedded in the PDF.</summary>
        </member>
        <member name="F:iText.Kernel.Font.PdfFont.subset">
            <summary>Indicates if all the glyphs and widths for that particular encoding should be included in the document.
                </summary>
        </member>
        <member name="M:iText.Kernel.Font.PdfFont.GetGlyph(System.Int32)">
            <summary>Get glyph by unicode</summary>
            <param name="unicode">a unicode code point</param>
            <returns>
            
            <see cref="T:iText.IO.Font.Otf.Glyph"/>
            if it exists or .NOTDEF if supported, otherwise
            <see langword="null"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Font.PdfFont.ContainsGlyph(System.Char)">
            <summary>Check whether font contains glyph with specified unicode.</summary>
            <param name="unicode">a unicode code point</param>
            <returns>
            true if font contains glyph, represented with the unicode code point,
            otherwise false.
            </returns>
        </member>
        <member name="M:iText.Kernel.Font.PdfFont.ContainsGlyph(System.Int32)">
            <summary>Check whether font contains glyph with specified unicode.</summary>
            <param name="unicode">a unicode code point</param>
            <returns>
            true if font contains glyph, represented with the unicode code point,
            otherwise false.
            </returns>
        </member>
        <member name="M:iText.Kernel.Font.PdfFont.ContainsGlyph(System.String,System.Int32)">
            <summary>Check whether font contains glyph with specified unicode.</summary>
            <param name="text">a java unicode string</param>
            <param name="from">start index. one or two char may be used.</param>
            <returns>
            true if font contains glyph, represented with the unicode code point,
            otherwise false.
            </returns>
        </member>
        <member name="M:iText.Kernel.Font.PdfFont.AppendGlyphs(System.String,System.Int32,System.Int32,System.Collections.Generic.IList{iText.IO.Font.Otf.Glyph})">
            <summary>Append all supported glyphs and return number of processed chars.</summary>
            <remarks>
            Append all supported glyphs and return number of processed chars.
            Composite font supports surrogate pairs.
            </remarks>
            <param name="text">String to convert to glyphs.</param>
            <param name="from">from index of the text.</param>
            <param name="to">to index of the text.</param>
            <param name="glyphs">array for a new glyphs, shall not be null.</param>
            <returns>number of processed chars from text.</returns>
        </member>
        <member name="M:iText.Kernel.Font.PdfFont.AppendAnyGlyph(System.String,System.Int32,System.Collections.Generic.IList{iText.IO.Font.Otf.Glyph})">
            <summary>Append any single glyph, even notdef.</summary>
            <remarks>
            Append any single glyph, even notdef.
            Returns number of processed chars: 2 in case surrogate pair, otherwise 1.
            </remarks>
            <param name="text">String to convert to glyphs.</param>
            <param name="from">from index of the text.</param>
            <param name="glyphs">array for a new glyph, shall not be null.</param>
            <returns>number of processed chars: 2 in case surrogate pair, otherwise 1</returns>
        </member>
        <member name="M:iText.Kernel.Font.PdfFont.ConvertToBytes(System.String)">
            <summary>Converts the text into bytes to be placed in the document.</summary>
            <remarks>
            Converts the text into bytes to be placed in the document.
            The conversion is done according to the font and the encoding and the characters
            used are stored.
            </remarks>
            <param name="text">the text to convert</param>
            <returns>the conversion</returns>
        </member>
        <member name="M:iText.Kernel.Font.PdfFont.DecodeIntoGlyphLine(iText.Kernel.Pdf.PdfString)">
            <summary>
            Decodes a given
            <see cref="T:iText.Kernel.Pdf.PdfString"/>
            containing encoded string (e.g. from content stream) into a
            <see cref="T:iText.IO.Font.Otf.GlyphLine"/>
            </summary>
            <param name="content">the encoded string</param>
            <returns>
            the
            <see cref="T:iText.IO.Font.Otf.GlyphLine"/>
            containing the glyphs encoded by the passed string
            </returns>
        </member>
        <member name="M:iText.Kernel.Font.PdfFont.GetWidth(System.Int32)">
            <summary>Returns the width of a certain character of this font in 1000 normalized units.</summary>
            <param name="unicode">a certain character.</param>
            <returns>a width in Text Space.</returns>
        </member>
        <member name="M:iText.Kernel.Font.PdfFont.GetWidth(System.Int32,System.Single)">
            <summary>Returns the width of a certain character of this font in points.</summary>
            <param name="unicode">a certain character.</param>
            <param name="fontSize">the font size.</param>
            <returns>a width in points.</returns>
        </member>
        <member name="M:iText.Kernel.Font.PdfFont.GetWidth(System.String)">
            <summary>Returns the width of a string of this font in 1000 normalized units.</summary>
            <param name="text">a string content.</param>
            <returns>a width of string in Text Space.</returns>
        </member>
        <member name="M:iText.Kernel.Font.PdfFont.GetWidth(System.String,System.Single)">
            <summary>
            Gets the width of a
            <c>String</c>
            in points.
            </summary>
            <param name="text">
            the
            <c>String</c>
            to get the width of
            </param>
            <param name="fontSize">the font size</param>
            <returns>the width in points</returns>
        </member>
        <member name="M:iText.Kernel.Font.PdfFont.GetDescent(System.String,System.Single)">
            <summary>
            Gets the descent of a
            <c>String</c>
            in points. The descent will always be
            less than or equal to zero even if all the characters have an higher descent.
            </summary>
            <param name="text">
            the
            <c>String</c>
            to get the descent of
            </param>
            <param name="fontSize">the font size</param>
            <returns>the descent in points</returns>
        </member>
        <member name="M:iText.Kernel.Font.PdfFont.GetDescent(System.Int32,System.Single)">
            <summary>Gets the descent of a char code in points.</summary>
            <remarks>
            Gets the descent of a char code in points. The descent will always be
            less than or equal to zero even if all the characters have an higher descent.
            </remarks>
            <param name="unicode">the char code to get the descent of</param>
            <param name="fontSize">the font size</param>
            <returns>the descent in points</returns>
        </member>
        <member name="M:iText.Kernel.Font.PdfFont.GetAscent(System.String,System.Single)">
            <summary>
            Gets the ascent of a
            <c>String</c>
            in points. The ascent will always be
            greater than or equal to zero even if all the characters have a lower ascent.
            </summary>
            <param name="text">
            the
            <c>String</c>
            to get the ascent of
            </param>
            <param name="fontSize">the font size</param>
            <returns>the ascent in points</returns>
        </member>
        <member name="M:iText.Kernel.Font.PdfFont.GetAscent(System.Int32,System.Single)">
            <summary>Gets the ascent of a char code in normalized 1000 units.</summary>
            <remarks>
            Gets the ascent of a char code in normalized 1000 units. The ascent will always be
            greater than or equal to zero even if all the characters have a lower ascent.
            </remarks>
            <param name="unicode">the char code to get the ascent of</param>
            <param name="fontSize">the font size</param>
            <returns>the ascent in points</returns>
        </member>
        <member name="M:iText.Kernel.Font.PdfFont.IsSubset">
            <summary>
            Indicates if all the glyphs and widths for that particular
            encoding should be included in the document.
            </summary>
            <returns><CODE>false</CODE> to include all the glyphs and widths.</returns>
        </member>
        <member name="M:iText.Kernel.Font.PdfFont.SetSubset(System.Boolean)">
            <summary>
            Indicates if all the glyphs and widths for that particular
            encoding should be included in the document.
            </summary>
            <remarks>
            Indicates if all the glyphs and widths for that particular
            encoding should be included in the document. When set to <CODE>true</CODE>
            only the glyphs used will be included in the font. When set to <CODE>false</CODE>
            and
            <see cref="M:iText.Kernel.Font.PdfFont.AddSubsetRange(System.Int32[])"/>
            was not called the full font will be included
            otherwise just the characters ranges will be included.
            </remarks>
            <param name="subset">new value of property subset</param>
        </member>
        <member name="M:iText.Kernel.Font.PdfFont.AddSubsetRange(System.Int32[])">
            <summary>Adds a character range when subsetting.</summary>
            <remarks>
            Adds a character range when subsetting. The range is an <CODE>int</CODE> array
            where the first element is the start range inclusive and the second element is the
            end range inclusive. Several ranges are allowed in the same array.
            </remarks>
            <param name="range">the character range</param>
        </member>
        <member name="M:iText.Kernel.Font.PdfFont.Flush">
            <summary>
            To manually flush a
            <c>PdfObject</c>
            behind this wrapper, you have to ensure
            that this object is added to the document, i.e. it has an indirect reference.
            Basically this means that before flushing you need to explicitly call
            <see cref="M:iText.Kernel.Pdf.PdfObjectWrapper`1.MakeIndirect(iText.Kernel.Pdf.PdfDocument)"/>
            .
            For example: wrapperInstance.makeIndirect(document).flush();
            Note that not every wrapper require this, only those that have such warning in documentation.
            </summary>
        </member>
        <member name="M:iText.Kernel.Font.PdfFont.CreateSubsetPrefix">
            <summary>Creates a unique subset prefix to be added to the font name when the font is embedded and subset.
                </summary>
            <returns>the subset prefix</returns>
        </member>
        <member name="M:iText.Kernel.Font.PdfFont.GetPdfFontStream(System.Byte[],System.Int32[])">
            <summary>
            Create
            <c>PdfStream</c>
            based on
            <paramref name="fontStreamBytes"/>
            .
            </summary>
            <param name="fontStreamBytes">original font data, must be not null.</param>
            <param name="fontStreamLengths">
            array to generate
            <c>Length*</c>
            keys, must be not null.
            </param>
            <returns>
            the PdfStream containing the font or
            <see langword="null"/>
            , if there is an error reading the font.
            </returns>
            <exception cref="T:iText.Kernel.PdfException">
            Method will throw exception if
            <paramref name="fontStreamBytes"/>
            is
            <see langword="null"/>
            .
            </exception>
        </member>
        <member name="M:iText.Kernel.Font.PdfFont.MakeObjectIndirect(iText.Kernel.Pdf.PdfObject)">
            <summary>Helper method for making an object indirect, if the object already is indirect.</summary>
            <remarks>
            Helper method for making an object indirect, if the object already is indirect.
            Useful for FontDescriptor and FontFile to make possible immediate flushing.
            If there is no PdfDocument, mark the object as
            <c>MUST_BE_INDIRECT</c>
            .
            </remarks>
            <param name="obj">an object to make indirect.</param>
            <returns>
            if current object isn't indirect, returns
            <see langword="false"/>
            , otherwise
            <c>tree</c>
            </returns>
        </member>
        <member name="T:iText.Kernel.Font.PdfFontFactory">
            <summary>
            This class provides helpful methods for creating fonts ready to be used in a
            <see cref="T:iText.Kernel.Pdf.PdfDocument"/>
            Note, just created
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            is almost empty until it will be flushed,
            because it is impossible to fulfill font data until flush.
            </summary>
        </member>
        <member name="F:iText.Kernel.Font.PdfFontFactory.DEFAULT_ENCODING">
            <summary>This is the default encoding to use.</summary>
        </member>
        <member name="F:iText.Kernel.Font.PdfFontFactory.DEFAULT_EMBEDDING">
            <summary>This is the default value of the <VAR>embedded</VAR> variable.</summary>
        </member>
        <member name="F:iText.Kernel.Font.PdfFontFactory.DEFAULT_CACHED">
            <summary>This is the default value of the <VAR>cached</VAR> variable.</summary>
        </member>
        <member name="M:iText.Kernel.Font.PdfFontFactory.CreateFont">
            <summary>
            Creates a new instance of default font, namely
            <see cref="F:iText.IO.Font.FontConstants.HELVETICA"/>
            standard font
            with
            <see cref="F:iText.IO.Font.PdfEncodings.WINANSI"/>
            encoding.
            Note, if you want to reuse the same instance of default font, you may use
            <see cref="M:iText.Kernel.Pdf.PdfDocument.GetDefaultFont"/>
            .
            </summary>
            <returns>created font</returns>
            <exception cref="T:System.IO.IOException">if error occurred while creating the font, e.g. metrics loading failure
                </exception>
        </member>
        <member name="M:iText.Kernel.Font.PdfFontFactory.CreateFont(iText.Kernel.Pdf.PdfDictionary)">
            <summary>
            Creates a
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            by already existing font dictionary.
            Note, the font won't be added to any document,
            until you add it to
            <see cref="T:iText.Kernel.Pdf.Canvas.PdfCanvas"/>
            .
            While adding to
            <see cref="T:iText.Kernel.Pdf.Canvas.PdfCanvas"/>
            , or to
            <see cref="T:iText.Kernel.Pdf.PdfResources"/>
            the font will be made indirect implicitly.
            <see cref="M:iText.Kernel.Pdf.PdfDocument.GetFont(iText.Kernel.Pdf.PdfDictionary)"/>
            method is strongly recommended if you want to get PdfFont by both
            existing font dictionary, or just created and hasn't flushed yet.
            </summary>
            <param name="fontDictionary">the font dictionary to create the font from</param>
            <returns>
            created
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            instance
            </returns>
        </member>
        <member name="M:iText.Kernel.Font.PdfFontFactory.CreateFont(System.String)">
            <summary>
            Creates a
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            instance by the path of the font program file
            </summary>
            <param name="fontProgram">the path of the font program file</param>
            <returns>
            created
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            instance
            </returns>
            <exception cref="T:System.IO.IOException">exception is thrown in case an I/O error occurs when reading the file
                </exception>
        </member>
        <member name="M:iText.Kernel.Font.PdfFontFactory.CreateFont(System.String,System.String)">
            <summary>
            Creates a
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            instance by the path of the font program file and given encoding.
            </summary>
            <param name="fontProgram">the path of the font program file</param>
            <param name="encoding">
            the font encoding. See
            <see cref="T:iText.IO.Font.PdfEncodings"/>
            </param>
            <returns>
            created
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            instance
            </returns>
            <exception cref="T:System.IO.IOException">exception is thrown in case an I/O error occurs when reading the file
                </exception>
        </member>
        <member name="M:iText.Kernel.Font.PdfFontFactory.CreateTtcFont(System.Byte[],System.Int32,System.String,System.Boolean,System.Boolean)">
            <summary>
            Creates a
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            instance from the TrueType Collection represented by its byte contents.
            </summary>
            <param name="ttc">the byte contents of the TrueType Collection</param>
            <param name="ttcIndex">the index of the font in the collection, zero-based</param>
            <param name="encoding">
            the encoding of the font to be created. See
            <see cref="T:iText.IO.Font.PdfEncodings"/>
            </param>
            <param name="embedded">indicates whether the font is to be embedded into the target document</param>
            <param name="cached">indicates whether the font will be cached</param>
            <returns>
            created
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            instance
            </returns>
            <exception cref="T:System.IO.IOException">in case the contents of the TrueType Collection is mal-formed or an error occurred during reading the font
                </exception>
        </member>
        <member name="M:iText.Kernel.Font.PdfFontFactory.CreateTtcFont(System.String,System.Int32,System.String,System.Boolean,System.Boolean)">
            <summary>
            Creates a
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            instance from the TrueType Collection given by the path to the .ttc file.
            </summary>
            <param name="ttc">the path of the .ttc file</param>
            <param name="ttcIndex">the index of the font in the collection, zero-based</param>
            <param name="encoding">
            the encoding of the font to be created. See
            <see cref="T:iText.IO.Font.PdfEncodings"/>
            </param>
            <param name="embedded">indicates whether the font is to be embedded into the target document</param>
            <param name="cached">indicates whether the font will be cached</param>
            <returns>
            created
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            instance
            </returns>
            <exception cref="T:System.IO.IOException">
            in case the file is not found, contents of the TrueType Collection is mal-formed
            or an error occurred during reading the font
            </exception>
        </member>
        <member name="M:iText.Kernel.Font.PdfFontFactory.CreateFont(System.String,System.Boolean)">
            <summary>
            Created a
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            instance given the path to the font file.
            </summary>
            <param name="fontProgram">the font program file</param>
            <param name="embedded">indicates whether the font is to be embedded into the target document</param>
            <returns>
            created
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            instance
            </returns>
            <exception cref="T:System.IO.IOException">in case the file is not found or the contents of the font file is mal-formed
                </exception>
        </member>
        <member name="M:iText.Kernel.Font.PdfFontFactory.CreateFont(System.String,System.String,System.Boolean)">
            <summary>
            Created a
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            instance given the path to the font file.
            </summary>
            <param name="fontProgram">the font program file</param>
            <param name="encoding">
            the encoding of the font to be created. See
            <see cref="T:iText.IO.Font.PdfEncodings"/>
            </param>
            <param name="embedded">indicates whether the font is to be embedded into the target document</param>
            <returns>
            created
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            instance
            </returns>
            <exception cref="T:System.IO.IOException">in case the file is not found or the contents of the font file is mal-formed
                </exception>
        </member>
        <member name="M:iText.Kernel.Font.PdfFontFactory.CreateFont(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Created a
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            instance given the path to the font file.
            </summary>
            <param name="fontProgram">the font program file</param>
            <param name="encoding">
            the encoding of the font to be created. See
            <see cref="T:iText.IO.Font.PdfEncodings"/>
            </param>
            <param name="embedded">indicates whether the font is to be embedded into the target document</param>
            <param name="cached">indicates whether the font will be cached</param>
            <returns>
            created
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            instance
            </returns>
            <exception cref="T:System.IO.IOException">in case the file is not found or the contents of the font file is mal-formed
                </exception>
        </member>
        <member name="M:iText.Kernel.Font.PdfFontFactory.CreateFont(iText.IO.Font.FontProgram,System.String,System.Boolean)">
            <summary>
            Created a
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            instance given the given underlying
            <see cref="T:iText.IO.Font.FontProgram"/>
            instance.
            </summary>
            <param name="fontProgram">
            the font program of the
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            instance to be created
            </param>
            <param name="encoding">
            the encoding of the font to be created. See
            <see cref="T:iText.IO.Font.PdfEncodings"/>
            </param>
            <param name="embedded">indicates whether the font is to be embedded into the target document</param>
            <returns>
            created
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            instance
            </returns>
            <exception cref="T:System.IO.IOException">this exception is actually never thrown and will be removed in 7.1.
                </exception>
        </member>
        <member name="M:iText.Kernel.Font.PdfFontFactory.CreateFont(iText.IO.Font.FontProgram,System.String)">
            <summary>
            Created a
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            instance given the given underlying
            <see cref="T:iText.IO.Font.FontProgram"/>
            instance.
            </summary>
            <param name="fontProgram">
            the font program of the
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            instance to be created
            </param>
            <param name="encoding">
            the encoding of the font to be created. See
            <see cref="T:iText.IO.Font.PdfEncodings"/>
            </param>
            <returns>
            created
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            instance
            </returns>
            <exception cref="T:System.IO.IOException">this exception is actually never thrown and will be removed in 7.1.
                </exception>
        </member>
        <member name="M:iText.Kernel.Font.PdfFontFactory.CreateFont(iText.IO.Font.FontProgram)">
            <summary>
            Created a
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            instance given the given underlying
            <see cref="T:iText.IO.Font.FontProgram"/>
            instance.
            </summary>
            <param name="fontProgram">
            the font program of the
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            instance to be created
            </param>
            <returns>
            created
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            instance
            </returns>
            <exception cref="T:System.IO.IOException">this exception is actually never thrown and will be removed in 7.1.
                </exception>
        </member>
        <member name="M:iText.Kernel.Font.PdfFontFactory.CreateFont(System.Byte[],System.String)">
            <summary>
            Created a
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            instance by the bytes of the underlying font program.
            </summary>
            <param name="fontProgram">the bytes of the underlying font program</param>
            <returns>
            created
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            instance
            </returns>
            <exception cref="T:System.IO.IOException">this exception is actually never thrown. Will be removed in 7.1.</exception>
        </member>
        <member name="M:iText.Kernel.Font.PdfFontFactory.CreateFont(System.Byte[],System.Boolean)">
            <summary>
            Created a
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            instance by the bytes of the underlying font program.
            </summary>
            <param name="fontProgram">the bytes of the underlying font program</param>
            <param name="embedded">indicates whether the font is to be embedded into the target document</param>
            <returns>
            created
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            instance
            </returns>
            <exception cref="T:System.IO.IOException">this exception is actually never thrown. Will be removed in 7.1.</exception>
        </member>
        <member name="M:iText.Kernel.Font.PdfFontFactory.CreateFont(System.Byte[],System.String,System.Boolean)">
            <summary>
            Created a
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            instance by the bytes of the underlying font program.
            </summary>
            <param name="fontProgram">the bytes of the underlying font program</param>
            <param name="encoding">
            the encoding of the font to be created. See
            <see cref="T:iText.IO.Font.PdfEncodings"/>
            </param>
            <param name="embedded">indicates whether the font is to be embedded into the target document</param>
            <returns>
            created
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            instance
            </returns>
            <exception cref="T:System.IO.IOException">this exception is actually never thrown. Will be removed in 7.1.</exception>
        </member>
        <member name="M:iText.Kernel.Font.PdfFontFactory.CreateFont(System.Byte[],System.String,System.Boolean,System.Boolean)">
            <summary>
            Created a
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            instance by the bytes of the underlying font program.
            </summary>
            <param name="fontProgram">the bytes of the underlying font program</param>
            <param name="encoding">
            the encoding of the font to be created. See
            <see cref="T:iText.IO.Font.PdfEncodings"/>
            </param>
            <param name="embedded">indicates whether the font is to be embedded into the target document</param>
            <param name="cached">indicates whether the font will be cached</param>
            <returns>
            created
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            instance
            </returns>
            <exception cref="T:System.IO.IOException">this exception is actually never thrown. Will be removed in 7.1.</exception>
        </member>
        <member name="M:iText.Kernel.Font.PdfFontFactory.CreateType3Font(iText.Kernel.Pdf.PdfDocument,System.Boolean)">
            <summary>
            Creates a new instance of
            <see cref="T:iText.Kernel.Font.PdfType3Font"/>
            </summary>
            <param name="document">the target document of the new font</param>
            <param name="colorized">indicates whether the font will be colorized</param>
            <returns>created font</returns>
            <exception cref="T:System.IO.IOException">actually this exception is never thrown. This will be removed in 7.1.
                </exception>
        </member>
        <member name="M:iText.Kernel.Font.PdfFontFactory.CreateRegisteredFont(System.String,System.String,System.Boolean,System.Int32,System.Boolean)">
            <summary>
            Creates
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            based on registered
            <see cref="T:iText.IO.Font.FontProgram"/>
            's.
            </summary>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.Register(System.String)"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.Register(System.String,System.String)"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.RegisterFamily(System.String,System.String,System.String)"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.RegisterDirectory(System.String)"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.RegisterSystemDirectories"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.GetRegisteredFamilies"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.GetRegisteredFonts"/>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Font.PdfFontFactory.CreateRegisteredFont(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Creates
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            based on registered
            <see cref="T:iText.IO.Font.FontProgram"/>
            's.
            </summary>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.Register(System.String)"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.Register(System.String,System.String)"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.RegisterFamily(System.String,System.String,System.String)"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.RegisterDirectory(System.String)"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.RegisterSystemDirectories"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.GetRegisteredFamilies"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.GetRegisteredFonts"/>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Font.PdfFontFactory.CreateRegisteredFont(System.String,System.String,System.Boolean)">
            <summary>
            Creates
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            based on registered
            <see cref="T:iText.IO.Font.FontProgram"/>
            's.
            </summary>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.Register(System.String)"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.Register(System.String,System.String)"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.RegisterFamily(System.String,System.String,System.String)"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.RegisterDirectory(System.String)"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.RegisterSystemDirectories"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.GetRegisteredFamilies"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.GetRegisteredFonts"/>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Font.PdfFontFactory.CreateRegisteredFont(System.String,System.String,System.Boolean,System.Int32)">
            <summary>
            Creates
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            based on registered
            <see cref="T:iText.IO.Font.FontProgram"/>
            's.
            </summary>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.Register(System.String)"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.Register(System.String,System.String)"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.RegisterFamily(System.String,System.String,System.String)"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.RegisterDirectory(System.String)"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.RegisterSystemDirectories"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.GetRegisteredFamilies"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.GetRegisteredFonts"/>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Font.PdfFontFactory.CreateRegisteredFont(System.String,System.String)">
            <summary>
            Creates
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            based on registered
            <see cref="T:iText.IO.Font.FontProgram"/>
            's.
            </summary>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.Register(System.String)"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.Register(System.String,System.String)"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.RegisterFamily(System.String,System.String,System.String)"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.RegisterDirectory(System.String)"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.RegisterSystemDirectories"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.GetRegisteredFamilies"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.GetRegisteredFonts"/>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Font.PdfFontFactory.CreateRegisteredFont(System.String)">
            <summary>
            Creates
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            based on registered
            <see cref="T:iText.IO.Font.FontProgram"/>
            's.
            </summary>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.Register(System.String)"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.Register(System.String,System.String)"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.RegisterFamily(System.String,System.String,System.String)"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.RegisterDirectory(System.String)"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.RegisterSystemDirectories"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.GetRegisteredFamilies"/>
            <seealso cref="M:iText.Kernel.Font.PdfFontFactory.GetRegisteredFonts"/>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Font.PdfFontFactory.RegisterFamily(System.String,System.String,System.String)">
            <summary>Register a font by giving explicitly the font family and name.</summary>
            <param name="familyName">the font family</param>
            <param name="fullName">the font name</param>
            <param name="path">the font path</param>
        </member>
        <member name="M:iText.Kernel.Font.PdfFontFactory.Register(System.String)">
            <summary>Registers a .ttf, .otf, .afm, .pfm, or a .ttc font file.</summary>
            <remarks>
            Registers a .ttf, .otf, .afm, .pfm, or a .ttc font file.
            In case if TrueType Collection (.ttc), an additional parameter may be specified defining the index of the font
            to be registered, e.g. "path/to/font/collection.ttc,0". The index is zero-based.
            </remarks>
            <param name="path">the path to a font file</param>
        </member>
        <member name="M:iText.Kernel.Font.PdfFontFactory.Register(System.String,System.String)">
            <summary>Register a font file and use an alias for the font contained in it.</summary>
            <param name="path">the path to a font file</param>
            <param name="alias">the alias you want to use for the font</param>
        </member>
        <member name="M:iText.Kernel.Font.PdfFontFactory.RegisterDirectory(System.String)">
            <summary>Registers all the fonts in a directory.</summary>
            <param name="dirPath">the directory path to be registered as a font directory path</param>
            <returns>the number of fonts registered</returns>
        </member>
        <member name="M:iText.Kernel.Font.PdfFontFactory.RegisterSystemDirectories">
            <summary>Register fonts in some probable directories.</summary>
            <remarks>
            Register fonts in some probable directories. It usually works in Windows,
            Linux and Solaris.
            </remarks>
            <returns>the number of fonts registered</returns>
        </member>
        <member name="M:iText.Kernel.Font.PdfFontFactory.GetRegisteredFonts">
            <summary>Gets a set of registered font names.</summary>
            <returns>a set of registered fonts</returns>
        </member>
        <member name="M:iText.Kernel.Font.PdfFontFactory.GetRegisteredFamilies">
            <summary>Gets a set of registered font families.</summary>
            <returns>a set of registered font families</returns>
        </member>
        <member name="M:iText.Kernel.Font.PdfFontFactory.IsRegistered(System.String)">
            <summary>Checks if a certain font is registered.</summary>
            <param name="fontName">the name of the font that has to be checked.</param>
            <returns><code>true</code> if the font is found, <code>false</code> otherwise</returns>
        </member>
        <member name="M:iText.Kernel.Font.PdfFontFactory.CheckFontDictionary(iText.Kernel.Pdf.PdfDictionary,iText.Kernel.Pdf.PdfName,System.Boolean)">
            <summary>Checks if the provided dictionary is a valid font dictionary of the provided font type.</summary>
            <returns><code>true</code> if the passed dictionary is a valid dictionary, <code>false</code> otherwise</returns>
        </member>
        <member name="F:iText.Kernel.Font.PdfSimpleFont`1.forceWidthsOutput">
            <summary>Forces the output of the width array.</summary>
            <remarks>Forces the output of the width array. Only matters for the 14 built-in fonts.</remarks>
        </member>
        <member name="F:iText.Kernel.Font.PdfSimpleFont`1.shortTag">
            <summary>The array used with single byte encodings.</summary>
        </member>
        <member name="M:iText.Kernel.Font.PdfSimpleFont`1.IsAppendableGlyph(iText.IO.Font.Otf.Glyph)">
            <summary>Checks whether the glyph is appendable, i.e.</summary>
            <remarks>Checks whether the glyph is appendable, i.e. has valid unicode and code values</remarks>
            <param name="glyph">
            not-null
            <see cref="T:iText.IO.Font.Otf.Glyph"/>
            </param>
        </member>
        <member name="M:iText.Kernel.Font.PdfSimpleFont`1.DecodeIntoGlyphLine(iText.Kernel.Pdf.PdfString)">
            <summary><inheritDoc/></summary>
        </member>
        <member name="M:iText.Kernel.Font.PdfSimpleFont`1.IsForceWidthsOutput">
            <summary>Gets the state of the property.</summary>
            <returns>value of property forceWidthsOutput</returns>
        </member>
        <member name="M:iText.Kernel.Font.PdfSimpleFont`1.SetForceWidthsOutput(System.Boolean)">
            <summary>
            Set to
            <see langword="true"/>
            to force the generation of the widths array.
            </summary>
            <param name="forceWidthsOutput">
            
            <see langword="true"/>
            to force the generation of the widths array
            </param>
        </member>
        <member name="M:iText.Kernel.Font.PdfSimpleFont`1.GetFontDescriptor(System.String)">
            <summary>
            Generates the font descriptor for this font or
            <see langword="null"/>
            if it is one of the 14 built in fonts.
            </summary>
            <returns>
            the PdfDictionary containing the font descriptor or
            <see langword="null"/>
            .
            </returns>
        </member>
        <member name="T:iText.Kernel.Font.PdfTrueTypeFont">
            <summary>Note.</summary>
            <remarks>Note. For TrueType FontNames.getStyle() is the same to Subfamily(). So, we shouldn't add style to /BaseFont.
                </remarks>
        </member>
        <member name="M:iText.Kernel.Font.PdfType0Font.DecodeIntoGlyphLine(iText.Kernel.Pdf.PdfString)">
            <summary><inheritDoc/></summary>
        </member>
        <member name="M:iText.Kernel.Font.PdfType0Font.GetToUnicode(System.Object[])">
            <summary>Creates a ToUnicode CMap to allow copy and paste from Acrobat.</summary>
            <param name="metrics">
            metrics[0] contains the glyph index and metrics[2]
            contains the Unicode code
            </param>
            <returns>the stream representing this CMap or <CODE>null</CODE></returns>
        </member>
        <member name="M:iText.Kernel.Font.PdfType0Font.GetCidFontType2(iText.IO.Font.TrueTypeFont,iText.Kernel.Pdf.PdfDictionary,System.String,System.Int32[][])">
            <summary>Generates the CIDFontTyte2 dictionary.</summary>
            <param name="fontDescriptor">the indirect reference to the font descriptor</param>
            <param name="fontName">a name of the font</param>
            <param name="metrics">the horizontal width metrics</param>
            <returns>fully initialized CIDFont</returns>
        </member>
        <member name="M:iText.Kernel.Font.PdfType0Font.MetricComparator.Compare(System.Int32[],System.Int32[])">
            <summary>The method used to sort the metrics array.</summary>
            <param name="o1">the first element</param>
            <param name="o2">the second element</param>
            <returns>the comparison</returns>
        </member>
        <member name="M:iText.Kernel.Font.PdfType1Font.AddFontStream(iText.Kernel.Pdf.PdfDictionary)">
            <summary>
            If the embedded flag is
            <see langword="false"/>
            or if the font is one of the 14 built in types, it returns
            <see langword="null"/>
            ,
            otherwise the font is read and output in a PdfStream object.
            </summary>
        </member>
        <member name="T:iText.Kernel.Font.PdfType3Font">
            <summary>Low-level API class for Type 3 fonts.</summary>
            <remarks>
            Low-level API class for Type 3 fonts.
            <p/>
            In Type 3 fonts, glyphs are defined by streams of PDF graphics operators.
            These streams are associated with character names. A separate encoding entry
            maps character codes to the appropriate character names for the glyphs.
            <br/><br/>
            To be able to be wrapped with this
            <see cref="T:iText.Kernel.Pdf.PdfObjectWrapper`1"/>
            the
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            must be indirect.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Font.PdfType3Font.#ctor(iText.Kernel.Pdf.PdfDocument,System.Boolean)">
            <summary>Creates a Type3 font.</summary>
            <param name="colorized">defines whether the glyph color is specified in the glyph descriptions in the font.
                </param>
        </member>
        <member name="M:iText.Kernel.Font.PdfType3Font.#ctor(iText.Kernel.Pdf.PdfDictionary)">
            <summary>Creates a Type3 font based on an existing font dictionary, which must be an indirect object.</summary>
            <param name="fontDictionary">a dictionary of type <code>/Font</code>, must have an indirect reference.</param>
        </member>
        <member name="M:iText.Kernel.Font.PdfType3Font.AddGlyph(System.Char,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Defines a glyph.</summary>
            <remarks>Defines a glyph. If the character was already defined it will return the same content</remarks>
            <param name="c">the character to match this glyph.</param>
            <param name="wx">the advance this character will have</param>
            <param name="llx">
            the X lower left corner of the glyph bounding box. If the <CODE>colorize</CODE> option is
            <CODE>true</CODE> the value is ignored
            </param>
            <param name="lly">
            the Y lower left corner of the glyph bounding box. If the <CODE>colorize</CODE> option is
            <CODE>true</CODE> the value is ignored
            </param>
            <param name="urx">
            the X upper right corner of the glyph bounding box. If the <CODE>colorize</CODE> option is
            <CODE>true</CODE> the value is ignored
            </param>
            <param name="ury">
            the Y upper right corner of the glyph bounding box. If the <CODE>colorize</CODE> option is
            <CODE>true</CODE> the value is ignored
            </param>
            <returns>a content where the glyph can be defined</returns>
        </member>
        <member name="M:iText.Kernel.Font.PdfType3Font.GetFirstEmptyCode">
            <summary>
            Gets first empty code, that could use with
            <seealso>addSymbol()</seealso>
            </summary>
            <returns>code from 1 to 255 or -1 if all slots are busy.</returns>
        </member>
        <member name="T:iText.Kernel.Font.Type3Glyph">
            <summary>The content where Type3 glyphs are written to.</summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.PdfCanvas">
            <summary>PdfCanvas class represents an algorithm for writing data into content stream.</summary>
            <remarks>
            PdfCanvas class represents an algorithm for writing data into content stream.
            To write into page content, create PdfCanvas from a page instance.
            To write into form XObject, create PdfCanvas from a form XObject instance.
            Make sure to call PdfCanvas.release() after you finished writing to the canvas.
            It will save some memory.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.PdfCanvas.gsStack">
            <summary>a LIFO stack of graphics state saved states.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.PdfCanvas.currentGs">
            <summary>the current graphics state.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.PdfCanvas.contentStream">
            <summary>the content stream for this canvas object.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.PdfCanvas.resources">
            <summary>the resources for the page that this canvas belongs to.</summary>
            <seealso cref="T:iText.Kernel.Pdf.PdfResources"/>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.PdfCanvas.document">
            <summary>the document that the resulting content stream of this canvas will be written to.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.PdfCanvas.mcDepth">
            <summary>a counter variable for the marked content stack.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.PdfCanvas.layerDepth">
            <summary>The list where we save/restore the layer depth.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.#ctor(iText.Kernel.Pdf.PdfStream,iText.Kernel.Pdf.PdfResources,iText.Kernel.Pdf.PdfDocument)">
            <summary>Creates PdfCanvas from content stream of page, form XObject, pattern etc.</summary>
            <param name="contentStream">@see PdfStream.</param>
            <param name="resources">the resources, a specialized dictionary that can be used by PDF instructions in the content stream
                </param>
            <param name="document">the document that the resulting content stream will be written to</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.#ctor(iText.Kernel.Pdf.PdfPage)">
            <summary>Convenience method for fast PdfCanvas creation by a certain page.</summary>
            <param name="page">page to create canvas from.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.#ctor(iText.Kernel.Pdf.PdfPage,System.Boolean)">
            <summary>Convenience method for fast PdfCanvas creation by a certain page.</summary>
            <param name="page">page to create canvas from.</param>
            <param name="wrapOldContent">
            true to wrap all old content streams into q/Q operators so that the state of old
            content streams would not affect the new one
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.#ctor(iText.Kernel.Pdf.Xobject.PdfFormXObject,iText.Kernel.Pdf.PdfDocument)">
            <summary>Creates a PdfCanvas from a PdfFormXObject.</summary>
            <param name="xObj">the PdfFormXObject used to create the PdfCanvas</param>
            <param name="document">the document to which the resulting content stream will be written</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.#ctor(iText.Kernel.Pdf.PdfDocument,System.Int32)">
            <summary>Convenience method for fast PdfCanvas creation by a certain page.</summary>
            <param name="doc">@see PdfDocument.</param>
            <param name="pageNum">page number.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.GetResources">
            <summary>Get the resources of the page that this canvas belongs to..</summary>
            <returns>PdfResources of the page that this canvas belongs to..</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.AttachContentStream(iText.Kernel.Pdf.PdfStream)">
            <summary>Attaches new content stream to the canvas.</summary>
            <remarks>
            Attaches new content stream to the canvas.
            This method is supposed to be used when you want to write in different PdfStream keeping context (gsStack, currentGs, ...) the same.
            </remarks>
            <param name="contentStream">a content stream to attach.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.GetGraphicsState">
            <summary>
            Gets current
            <see cref="T:iText.Kernel.Pdf.Canvas.CanvasGraphicsState"/>
            .
            </summary>
            <returns>container containing properties for the current state of the canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.Release">
            <summary>Releases the canvas.</summary>
            <remarks>
            Releases the canvas.
            Use this method after you finished working with canvas.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.SaveState">
            <summary>Saves graphics state.</summary>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.RestoreState">
            <summary>Restores graphics state.</summary>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.ConcatMatrix(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Concatenates the 2x3 affine transformation matrix to the current matrix
            in the content stream managed by this Canvas.
            </summary>
            <remarks>
            Concatenates the 2x3 affine transformation matrix to the current matrix
            in the content stream managed by this Canvas.
            Contrast with
            <see cref="M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetTextMatrix(iText.Kernel.Geom.AffineTransform)"/>
            </remarks>
            <param name="a">operand 1,1 in the matrix.</param>
            <param name="b">operand 1,2 in the matrix.</param>
            <param name="c">operand 2,1 in the matrix.</param>
            <param name="d">operand 2,2 in the matrix.</param>
            <param name="e">operand 3,1 in the matrix.</param>
            <param name="f">operand 3,2 in the matrix.</param>
            <returns>current canvas</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.ConcatMatrix(iText.Kernel.Pdf.PdfArray)">
            <summary>
            Concatenates the 2x3 affine transformation matrix to the current matrix
            in the content stream managed by this Canvas.
            </summary>
            <remarks>
            Concatenates the 2x3 affine transformation matrix to the current matrix
            in the content stream managed by this Canvas.
            If an array not containing the 6 values of the matrix is passed,
            The current canvas is returned unchanged.
            </remarks>
            <param name="array">affine transformation stored as a PdfArray with 6 values</param>
            <returns>current canvas</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.ConcatMatrix(iText.Kernel.Geom.AffineTransform)">
            <summary>
            Concatenates the affine transformation matrix to the current matrix
            in the content stream managed by this Canvas.
            </summary>
            <remarks>
            Concatenates the affine transformation matrix to the current matrix
            in the content stream managed by this Canvas.
            See also
            <see cref="M:iText.Kernel.Pdf.Canvas.PdfCanvas.ConcatMatrix(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)"/>
            </remarks>
            <returns>current canvas</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.BeginText">
            <summary>Begins text block (PDF BT operator).</summary>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.EndText">
            <summary>Ends text block (PDF ET operator).</summary>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.BeginVariableText">
            <summary>Begins variable text block</summary>
            <returns>current canvas</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.EndVariableText">
            <summary>Ends variable text block</summary>
            <returns>current canvas</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetFontAndSize(iText.Kernel.Font.PdfFont,System.Single)">
            <summary>Sets font and size (PDF Tf operator).</summary>
            <param name="font">@see PdfFont.</param>
            <param name="size">Font size.</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.MoveText(System.Double,System.Double)">
            <summary>Moves text by shifting text line matrix (PDF Td operator).</summary>
            <param name="x">x coordinate.</param>
            <param name="y">y coordinate.</param>
            <returns>current canvas.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetLeading(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Pdf.Canvas.PdfCanvas.MoveTextWithLeading(System.Single,System.Single)" -->
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.NewlineText">
            <summary>Moves to the start of the next line.</summary>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.NewlineShowText(System.String)">
            <summary>
            Moves to the next line and shows
            <paramref name="text"/>
            .
            </summary>
            <param name="text">the text to write</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.NewlineShowText(System.Single,System.Single,System.String)">
            <summary>Moves to the next line and shows text string, using the given values of the character and word spacing parameters.
                </summary>
            <param name="wordSpacing">a parameter</param>
            <param name="charSpacing">a parameter</param>
            <param name="text">the text to write</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetTextRenderingMode(System.Int32)">
            <summary>Sets text rendering mode.</summary>
            <param name="textRenderingMode">text rendering mode @see PdfCanvasConstants.</param>
            <returns>current canvas.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetTextRise(System.Single)" -->
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetWordSpacing(System.Single)">
            <summary>Sets the word spacing parameter.</summary>
            <param name="wordSpacing">a parameter</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetCharacterSpacing(System.Single)">
            <summary>Sets the character spacing parameter.</summary>
            <param name="charSpacing">a parameter</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetHorizontalScaling(System.Single)">
            <summary>Sets the horizontal scaling parameter.</summary>
            <param name="scale">a parameter.</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetTextMatrix(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>Replaces the text matrix.</summary>
            <remarks>
            Replaces the text matrix. Contrast with
            <see cref="M:iText.Kernel.Pdf.Canvas.PdfCanvas.ConcatMatrix(iText.Kernel.Pdf.PdfArray)"/>
            </remarks>
            <param name="a">operand 1,1 in the matrix.</param>
            <param name="b">operand 1,2 in the matrix.</param>
            <param name="c">operand 2,1 in the matrix.</param>
            <param name="d">operand 2,2 in the matrix.</param>
            <param name="x">operand 3,1 in the matrix.</param>
            <param name="y">operand 3,2 in the matrix.</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetTextMatrix(iText.Kernel.Geom.AffineTransform)">
            <summary>Replaces the text matrix.</summary>
            <remarks>
            Replaces the text matrix. Contrast with
            <see cref="M:iText.Kernel.Pdf.Canvas.PdfCanvas.ConcatMatrix(iText.Kernel.Pdf.PdfArray)"/>
            </remarks>
            <param name="transform">new textmatrix as transformation</param>
            <returns>current canvas</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetTextMatrix(System.Single,System.Single)">
            <summary>Changes the text matrix.</summary>
            <param name="x">operand 3,1 in the matrix.</param>
            <param name="y">operand 3,2 in the matrix.</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.ShowText(System.String)">
            <summary>Shows text (operator Tj).</summary>
            <param name="text">text to show.</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.ShowText(iText.IO.Font.Otf.GlyphLine)">
            <summary>Shows text (operator Tj).</summary>
            <param name="text">text to show.</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.ShowText(iText.IO.Font.Otf.GlyphLine,System.Collections.Generic.IEnumerator{iText.IO.Font.Otf.GlyphLine.GlyphLinePart})">
            <summary>Shows text (operator Tj).</summary>
            <param name="text">text to show.</param>
            <param name="iterator">
            iterator over parts of the glyph line that should be wrapped into some marked content groups,
            e.g. /ActualText or /ReversedChars
            </param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.ShowText(iText.Kernel.Pdf.PdfArray)">
            <summary>Shows text (operator TJ)</summary>
            <param name="textArray">
            the text array. Each element of array can be a string or a number.
            If the element is a string, this operator shows the string.
            If it is a number, the operator adjusts the text position by that amount.
            The number is expressed in thousandths of a unit of text space.
            This amount is subtracted from the current horizontal or vertical coordinate, depending on the writing mode.
            </param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.MoveTo(System.Double,System.Double)">
            <summary>Move the current point <i>(x, y)</i>, omitting any connecting line segment.</summary>
            <param name="x">x coordinate.</param>
            <param name="y">y coordinate.</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.LineTo(System.Double,System.Double)">
            <summary>Appends a straight line segment from the current point <i>(x, y)</i>.</summary>
            <remarks>
            Appends a straight line segment from the current point <i>(x, y)</i>. The new current
            point is <i>(x, y)</i>.
            </remarks>
            <param name="x">x coordinate.</param>
            <param name="y">y coordinate.</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.CurveTo(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Appends a B&#xea;zier curve to the path, starting from the current point.</summary>
            <param name="x1">x coordinate of the first control point.</param>
            <param name="y1">y coordinate of the first control point.</param>
            <param name="x2">x coordinate of the second control point.</param>
            <param name="y2">y coordinate of the second control point.</param>
            <param name="x3">x coordinate of the ending point.</param>
            <param name="y3">y coordinate of the ending point.</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.CurveTo(System.Double,System.Double,System.Double,System.Double)">
            <summary>Appends a B??zier curve to the path, starting from the current point.</summary>
            <param name="x2">x coordinate of the second control point.</param>
            <param name="y2">y coordinate of the second control point.</param>
            <param name="x3">x coordinate of the ending point.</param>
            <param name="y3">y coordinate of the ending point.</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.CurveFromTo(System.Double,System.Double,System.Double,System.Double)">
            <summary>Appends a B??zier curve to the path, starting from the current point.</summary>
            <param name="x1">x coordinate of the first control point.</param>
            <param name="y1">y coordinate of the first control point.</param>
            <param name="x3">x coordinate of the ending point.</param>
            <param name="y3">y coordinate of the ending point.</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.Arc(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Draws a partial ellipse inscribed within the rectangle x1,y1,x2,y2,
            starting at startAng degrees and covering extent degrees.
            </summary>
            <remarks>
            Draws a partial ellipse inscribed within the rectangle x1,y1,x2,y2,
            starting at startAng degrees and covering extent degrees. Angles
            start with 0 to the right (+x) and increase counter-clockwise.
            </remarks>
            <param name="x1">a corner of the enclosing rectangle.</param>
            <param name="y1">a corner of the enclosing rectangle.</param>
            <param name="x2">a corner of the enclosing rectangle.</param>
            <param name="y2">a corner of the enclosing rectangle.</param>
            <param name="startAng">starting angle in degrees.</param>
            <param name="extent">angle extent in degrees.</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.Ellipse(System.Double,System.Double,System.Double,System.Double)">
            <summary>Draws an ellipse inscribed within the rectangle x1,y1,x2,y2.</summary>
            <param name="x1">a corner of the enclosing rectangle</param>
            <param name="y1">a corner of the enclosing rectangle</param>
            <param name="x2">a corner of the enclosing rectangle</param>
            <param name="y2">a corner of the enclosing rectangle</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.BezierArc(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Generates an array of bezier curves to draw an arc.</summary>
            <remarks>
            Generates an array of bezier curves to draw an arc.
            <p/>
            (x1, y1) and (x2, y2) are the corners of the enclosing rectangle.
            Angles, measured in degrees, start with 0 to the right (the positive X
            axis) and increase counter-clockwise.  The arc extends from startAng
            to startAng+extent.  i.e. startAng=0 and extent=180 yields an openside-down
            semi-circle.
            <p/>
            The resulting coordinates are of the form double[]{x1,y1,x2,y2,x3,y3, x4,y4}
            such that the curve goes from (x1, y1) to (x4, y4) with (x2, y2) and
            (x3, y3) as their respective Bezier control points.
            <p/>
            Note: this code was taken from ReportLab (www.reportlab.org), an excellent
            PDF generator for Python (BSD license: http://www.reportlab.org/devfaq.html#1.3 ).
            </remarks>
            <param name="x1">a corner of the enclosing rectangle.</param>
            <param name="y1">a corner of the enclosing rectangle.</param>
            <param name="x2">a corner of the enclosing rectangle.</param>
            <param name="y2">a corner of the enclosing rectangle.</param>
            <param name="startAng">starting angle in degrees.</param>
            <param name="extent">angle extent in degrees.</param>
            <returns>a list of double[] with the bezier curves.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.Rectangle(System.Double,System.Double,System.Double,System.Double)">
            <summary>Draws a rectangle.</summary>
            <param name="x">x coordinate of the starting point.</param>
            <param name="y">y coordinate of the starting point.</param>
            <param name="width">width.</param>
            <param name="height">height.</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.Rectangle(iText.Kernel.Geom.Rectangle)">
            <summary>Draws a rectangle.</summary>
            <param name="rectangle">a rectangle to be drawn</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.RoundRectangle(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Draws rounded rectangle.</summary>
            <param name="x">x coordinate of the starting point.</param>
            <param name="y">y coordinate of the starting point.</param>
            <param name="width">width.</param>
            <param name="height">height.</param>
            <param name="radius">radius of the arc corner.</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.Circle(System.Double,System.Double,System.Double)">
            <summary>Draws a circle.</summary>
            <remarks>Draws a circle. The endpoint will (x+r, y).</remarks>
            <param name="x">x center of circle.</param>
            <param name="y">y center of circle.</param>
            <param name="r">radius of circle.</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.PaintShading(iText.Kernel.Pdf.Colorspace.PdfShading)">
            <summary>Paints a shading object and adds it to the resources of this canvas</summary>
            <param name="shading"/>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.ClosePath">
            <summary>
            Closes the current subpath by appending a straight line segment from the current point
            to the starting point of the subpath.
            </summary>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.ClosePathEoFillStroke">
            <summary>Closes the path, fills it using the even-odd rule to determine the region to fill and strokes it.
                </summary>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.ClosePathFillStroke">
            <summary>Closes the path, fills it using the non-zero winding number rule to determine the region to fill and strokes it.
                </summary>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.NewPath">
            <summary>Ends the path without filling or stroking it.</summary>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.Stroke">
            <summary>Strokes the path.</summary>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.Clip">
            <summary>
            Modify the current clipping path by intersecting it with the current path, using the
            nonzero winding rule to determine which regions lie inside the clipping path.
            </summary>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.EoClip">
            <summary>
            Modify the current clipping path by intersecting it with the current path, using the
            even-odd rule to determine which regions lie inside the clipping path.
            </summary>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.ClosePathStroke">
            <summary>Closes the path and strokes it.</summary>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.Fill">
            <summary>Fills current path.</summary>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.FillStroke">
            <summary>Fills the path using the non-zero winding number rule to determine the region to fill and strokes it.
                </summary>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.EoFill">
            <summary>EOFills current path.</summary>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.EoFillStroke">
            <summary>Fills the path, using the even-odd rule to determine the region to fill and strokes it.</summary>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetLineWidth(System.Single)">
            <summary>Sets line width.</summary>
            <param name="lineWidth">line width.</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetLineCapStyle(System.Int32)">
            <summary>
            Sets the line cap style, the shape to be used at the ends of open subpaths
            when they are stroked.
            </summary>
            <param name="lineCapStyle"/>
            <returns>current canvas.</returns>
            <seealso cref="!:LineCapStyle">for possible values.</seealso>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetLineJoinStyle(System.Int32)">
            <summary>
            Sets the line join style, the shape to be used at the corners of paths
            when they are stroked.
            </summary>
            <param name="lineJoinStyle"/>
            <returns>current canvas.</returns>
            <seealso cref="!:LineJoinStyle">for possible values.</seealso>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetMiterLimit(System.Single)">
            <summary>
            Sets the miter limit, a parameter specifying the maximum length a miter join
            may extend beyond the join point, relative to the angle of the line segments.
            </summary>
            <param name="miterLimit"/>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetLineDash(System.Single)">
            <summary>Changes the value of the <VAR>line dash pattern</VAR>.</summary>
            <remarks>
            Changes the value of the <VAR>line dash pattern</VAR>.
            <p/>
            The line dash pattern controls the pattern of dashes and gaps used to stroke paths.
            It is specified by an <I>array</I> and a <I>phase</I>. The array specifies the length
            of the alternating dashes and gaps. The phase specifies the distance into the dash
            pattern to start the dash.
            </remarks>
            <param name="phase">the value of the phase</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetLineDash(System.Single,System.Single)">
            <summary>Changes the value of the <VAR>line dash pattern</VAR>.</summary>
            <remarks>
            Changes the value of the <VAR>line dash pattern</VAR>.
            <p/>
            The line dash pattern controls the pattern of dashes and gaps used to stroke paths.
            It is specified by an <I>array</I> and a <I>phase</I>. The array specifies the length
            of the alternating dashes and gaps. The phase specifies the distance into the dash
            pattern to start the dash.
            </remarks>
            <param name="phase">the value of the phase</param>
            <param name="unitsOn">the number of units that must be 'on' (equals the number of units that must be 'off').
                </param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetLineDash(System.Single,System.Single,System.Single)">
            <summary>Changes the value of the <VAR>line dash pattern</VAR>.</summary>
            <remarks>
            Changes the value of the <VAR>line dash pattern</VAR>.
            <p/>
            The line dash pattern controls the pattern of dashes and gaps used to stroke paths.
            It is specified by an <I>array</I> and a <I>phase</I>. The array specifies the length
            of the alternating dashes and gaps. The phase specifies the distance into the dash
            pattern to start the dash.
            </remarks>
            <param name="phase">the value of the phase</param>
            <param name="unitsOn">the number of units that must be 'on'</param>
            <param name="unitsOff">the number of units that must be 'off'</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetLineDash(System.Single[],System.Single)">
            <summary>Changes the value of the <VAR>line dash pattern</VAR>.</summary>
            <remarks>
            Changes the value of the <VAR>line dash pattern</VAR>.
            <p/>
            The line dash pattern controls the pattern of dashes and gaps used to stroke paths.
            It is specified by an <I>array</I> and a <I>phase</I>. The array specifies the length
            of the alternating dashes and gaps. The phase specifies the distance into the dash
            pattern to start the dash.
            </remarks>
            <param name="array">length of the alternating dashes and gaps</param>
            <param name="phase">the value of the phase</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetRenderingIntent(iText.Kernel.Pdf.PdfName)">
            <summary>Set the rendering intent.</summary>
            <remarks>
            Set the rendering intent. possible values are: PdfName.AbsoluteColorimetric,
            PdfName.RelativeColorimetric, PdfName.Saturation, PdfName.Perceptual.
            </remarks>
            <param name="renderingIntent">a PdfName containing a color metric</param>
            <returns>current canvas.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetFlatnessTolerance(System.Single)" -->
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetFillColor(iText.Kernel.Colors.Color)">
            <summary>Changes the current color for filling paths.</summary>
            <param name="color">fill color.</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetStrokeColor(iText.Kernel.Colors.Color)">
            <summary>Changes the current color for stroking paths.</summary>
            <param name="color">stroke color.</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetColor(iText.Kernel.Colors.Color,System.Boolean)">
            <summary>Changes the current color for paths.</summary>
            <param name="color">the new color.</param>
            <param name="fill">set fill color (<code>true</code>) or stroke color (<code>false</code>)</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetColor(iText.Kernel.Pdf.Colorspace.PdfColorSpace,System.Single[],System.Boolean)">
            <summary>Changes the current color for paths.</summary>
            <param name="colorSpace">the color space of the new color</param>
            <param name="colorValue">a list of numerical values with a length corresponding to the specs of the color space. Values should be in the range [0,1]
                </param>
            <param name="fill">set fill color (<code>true</code>) or stroke color (<code>false</code>)</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetColor(iText.Kernel.Pdf.Colorspace.PdfColorSpace,System.Single[],iText.Kernel.Pdf.Colorspace.PdfPattern,System.Boolean)">
            <summary>Changes the current color for paths with an explicitly defined pattern.</summary>
            <param name="colorSpace">the color space of the new color</param>
            <param name="colorValue">a list of numerical values with a length corresponding to the specs of the color space. Values should be in the range [0,1]
                </param>
            <param name="pattern">a pattern for the colored line or area</param>
            <param name="fill">set fill color (<code>true</code>) or stroke color (<code>false</code>)</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetFillColorGray(System.Single)">
            <summary>Changes the current color for filling paths to a grayscale value.</summary>
            <param name="g">a grayscale value in the range [0,1]</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetStrokeColorGray(System.Single)">
            <summary>Changes the current color for stroking paths to a grayscale value.</summary>
            <param name="g">a grayscale value in the range [0,1]</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.ResetFillColorGray">
            <summary>Changes the current color for filling paths to black.</summary>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.ResetStrokeColorGray">
            <summary>Changes the current color for stroking paths to black.</summary>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetFillColorRgb(System.Single,System.Single,System.Single)">
            <summary>Changes the current color for filling paths to an RGB value.</summary>
            <param name="r">a red value in the range [0,1]</param>
            <param name="g">a green value in the range [0,1]</param>
            <param name="b">a blue value in the range [0,1]</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetStrokeColorRgb(System.Single,System.Single,System.Single)">
            <summary>Changes the current color for stroking paths to an RGB value.</summary>
            <param name="r">a red value in the range [0,1]</param>
            <param name="g">a green value in the range [0,1]</param>
            <param name="b">a blue value in the range [0,1]</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetFillColorShading(iText.Kernel.Pdf.Colorspace.PdfPattern.Shading)">
            <summary>Adds or changes the shading of the current fill color path.</summary>
            <param name="shading">the shading</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetStrokeColorShading(iText.Kernel.Pdf.Colorspace.PdfPattern.Shading)">
            <summary>Adds or changes the shading of the current stroke color path.</summary>
            <param name="shading">the shading</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.ResetFillColorRgb">
            <summary>Changes the current color for filling paths to black.</summary>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.ResetStrokeColorRgb">
            <summary>Changes the current color for stroking paths to black.</summary>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetFillColorCmyk(System.Single,System.Single,System.Single,System.Single)">
            <summary>Changes the current color for filling paths to a CMYK value.</summary>
            <param name="c">a cyan value in the range [0,1]</param>
            <param name="m">a magenta value in the range [0,1]</param>
            <param name="y">a yellow value in the range [0,1]</param>
            <param name="k">a key (black) value in the range [0,1]</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetStrokeColorCmyk(System.Single,System.Single,System.Single,System.Single)">
            <summary>Changes the current color for stroking paths to a CMYK value.</summary>
            <param name="c">a cyan value in the range [0,1]</param>
            <param name="m">a magenta value in the range [0,1]</param>
            <param name="y">a yellow value in the range [0,1]</param>
            <param name="k">a key (black) value in the range [0,1]</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.ResetFillColorCmyk">
            <summary>Changes the current color for filling paths to black.</summary>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.ResetStrokeColorCmyk">
            <summary>Changes the current color for stroking paths to black.</summary>
            <returns>current canvas.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Pdf.Canvas.PdfCanvas.BeginLayer(iText.Kernel.Pdf.Layer.IPdfOCG)" -->
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.EndLayer">
            <summary>Ends OCG layer.</summary>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.AddImage(iText.IO.Image.ImageData,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>Creates Image XObject from image and adds it to canvas (as Image XObject).</summary>
            <param name="image">
            the
            <c>PdfImageXObject</c>
            object
            </param>
            <param name="a">an element of the transformation matrix</param>
            <param name="b">an element of the transformation matrix</param>
            <param name="c">an element of the transformation matrix</param>
            <param name="d">an element of the transformation matrix</param>
            <param name="e">an element of the transformation matrix</param>
            <param name="f">an element of the transformation matrix</param>
            <returns>created Image XObject.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.AddImage(iText.IO.Image.ImageData,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>Creates Image XObject from image and adds it to canvas.</summary>
            <param name="image">
            the
            <c>PdfImageXObject</c>
            object
            </param>
            <param name="a">an element of the transformation matrix</param>
            <param name="b">an element of the transformation matrix</param>
            <param name="c">an element of the transformation matrix</param>
            <param name="d">an element of the transformation matrix</param>
            <param name="e">an element of the transformation matrix</param>
            <param name="f">an element of the transformation matrix</param>
            <param name="asInline">true if to add image as in-line.</param>
            <returns>created Image XObject or null in case of in-line image (asInline = true).</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.AddImage(iText.IO.Image.ImageData,iText.Kernel.Geom.Rectangle,System.Boolean)">
            <summary>Creates Image XObject from image and adds it to canvas.</summary>
            <param name="image"/>
            <param name="rect"/>
            <param name="asInline">true if to add image as in-line.</param>
            <returns>created XObject or null in case of in-line image (asInline = true).</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.AddImage(iText.IO.Image.ImageData,System.Single,System.Single,System.Boolean)">
            <summary>Creates Image XObject from image and adds it to canvas.</summary>
            <param name="image"/>
            <param name="x"/>
            <param name="y"/>
            <param name="asInline">true if to add image as in-line.</param>
            <returns>created XObject or null in case of in-line image (asInline = true).</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.AddImage(iText.IO.Image.ImageData,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>Creates Image XObject from image and adds it to the specified position with specified width preserving aspect ratio.
                </summary>
            <param name="image"/>
            <param name="x"/>
            <param name="y"/>
            <param name="width"/>
            <param name="asInline">true if to add image as in-line.</param>
            <returns>created XObject or null in case of in-line image (asInline = true).</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.AddImage(iText.IO.Image.ImageData,System.Single,System.Single,System.Single,System.Boolean,System.Boolean)">
            <summary>Creates Image XObject from image and adds it to the specified position with specified width preserving aspect ratio.
                </summary>
            <param name="image"/>
            <param name="x"/>
            <param name="y"/>
            <param name="height"/>
            <param name="asInline">true if to add image as in-line.</param>
            <param name="dummy"/>
            <returns>created XObject or null in case of in-line image (asInline = true).</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.AddXObject(iText.Kernel.Pdf.Xobject.PdfXObject,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Adds
            <c>PdfXObject</c>
            to canvas.
            </summary>
            <param name="xObject">
            the
            <c>PdfImageXObject</c>
            object
            </param>
            <param name="a">an element of the transformation matrix</param>
            <param name="b">an element of the transformation matrix</param>
            <param name="c">an element of the transformation matrix</param>
            <param name="d">an element of the transformation matrix</param>
            <param name="e">an element of the transformation matrix</param>
            <param name="f">an element of the transformation matrix</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.AddXObject(iText.Kernel.Pdf.Xobject.PdfXObject,System.Single,System.Single)">
            <summary>
            Adds
            <c>PdfXObject</c>
            to the specified position.
            </summary>
            <param name="xObject"/>
            <param name="x"/>
            <param name="y"/>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.AddXObject(iText.Kernel.Pdf.Xobject.PdfXObject,iText.Kernel.Geom.Rectangle)">
            <summary>
            Adds
            <c>PdfXObject</c>
            to specified rectangle on canvas.
            </summary>
            <param name="xObject"/>
            <param name="rect"/>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.AddXObject(iText.Kernel.Pdf.Xobject.PdfXObject,System.Single,System.Single,System.Single)">
            <summary>
            Adds
            <c>PdfXObject</c>
            to the specified position with specified width preserving aspect ratio.
            </summary>
            <param name="xObject"/>
            <param name="x"/>
            <param name="y"/>
            <param name="width"/>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.AddXObject(iText.Kernel.Pdf.Xobject.PdfXObject,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
            Adds
            <c>PdfXObject</c>
            to the specified position with specified height preserving aspect ratio.
            </summary>
            <param name="xObject"/>
            <param name="x"/>
            <param name="y"/>
            <param name="height"/>
            <param name="dummy"/>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetExtGState(iText.Kernel.Pdf.Extgstate.PdfExtGState)">
            <summary>Sets the ExtGState dictionary for the current graphics state</summary>
            <param name="extGState">a dictionary that maps resource names to graphics state parameter dictionaries</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.SetExtGState(iText.Kernel.Pdf.PdfDictionary)">
            <summary>Sets the ExtGState dictionary for the current graphics state</summary>
            <param name="extGState">a dictionary that maps resource names to graphics state parameter dictionaries</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.BeginMarkedContent(iText.Kernel.Pdf.PdfName)">
            <summary>Manually start a Marked Content sequence.</summary>
            <remarks>Manually start a Marked Content sequence. Used primarily for Tagged PDF</remarks>
            <param name="tag">the type of content contained</param>
            <returns>current canvas</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.BeginMarkedContent(iText.Kernel.Pdf.PdfName,iText.Kernel.Pdf.PdfDictionary)">
            <summary>Manually start a Marked Content sequence with properties.</summary>
            <remarks>Manually start a Marked Content sequence with properties. Used primarily for Tagged PDF</remarks>
            <param name="tag">the type of content that will be contained</param>
            <param name="properties">the properties of the content, including Marked Content ID. If null, the PDF marker is BMC, else it is BDC
                </param>
            <returns>current canvas</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.EndMarkedContent">
            <summary>Manually end a Marked Content sequence.</summary>
            <remarks>Manually end a Marked Content sequence. Used primarily for Tagged PDF</remarks>
            <returns>current canvas</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.OpenTag(iText.Kernel.Pdf.Canvas.CanvasTag)">
            <summary>Manually open a canvas tag, beginning a Marked Content sequence.</summary>
            <remarks>Manually open a canvas tag, beginning a Marked Content sequence. Used primarily for Tagged PDF</remarks>
            <param name="tag">the type of content that will be contained</param>
            <returns>current canvas</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.OpenTag(iText.Kernel.Pdf.Tagutils.TagReference)">
            <summary>Open a tag, beginning a Marked Content sequence.</summary>
            <remarks>
            Open a tag, beginning a Marked Content sequence. This MC sequence will belong to the tag from the document
            logical structure.
            <br />
            CanvasTag will be automatically created with assigned mcid(Marked Content id) to it. Mcid serves as a reference
            between Marked Content sequence and logical structure element.
            </remarks>
            <param name="tagReference">reference to the tag from the document logical structure</param>
            <returns>current canvas</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.CloseTag">
            <summary>Manually close a tag, ending a Marked Content sequence.</summary>
            <remarks>Manually close a tag, ending a Marked Content sequence. Used primarily for Tagged PDF</remarks>
            <returns>current canvas</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.WriteLiteral(System.String)">
            <summary>
            Outputs a
            <c>String</c>
            directly to the content.
            </summary>
            <param name="s">
            the
            <c>String</c>
            </param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.WriteLiteral(System.Char)">
            <summary>
            Outputs a
            <c>char</c>
            directly to the content.
            </summary>
            <param name="c">
            the
            <c>char</c>
            </param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.WriteLiteral(System.Single)">
            <summary>
            Outputs a
            <c>float</c>
            directly to the content.
            </summary>
            <param name="n">
            the
            <c>float</c>
            </param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.GetContentStream">
            <summary>Please, use this method with caution and only if you know what you are doing.</summary>
            <remarks>
            Please, use this method with caution and only if you know what you are doing.
            Manipulating with underlying stream object of canvas could lead to corruption of it's data.
            </remarks>
            <returns>the content stream to which this canvas object writes.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.AddInlineImage(iText.Kernel.Pdf.Xobject.PdfImageXObject,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Adds
            <c>PdfImageXObject</c>
            to canvas.
            </summary>
            <param name="imageXObject">
            the
            <c>PdfImageXObject</c>
            object
            </param>
            <param name="a">an element of the transformation matrix</param>
            <param name="b">an element of the transformation matrix</param>
            <param name="c">an element of the transformation matrix</param>
            <param name="d">an element of the transformation matrix</param>
            <param name="e">an element of the transformation matrix</param>
            <param name="f">an element of the transformation matrix</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.AddForm(iText.Kernel.Pdf.Xobject.PdfFormXObject,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Adds
            <c>PdfFormXObject</c>
            to canvas.
            </summary>
            <param name="form">
            the
            <c>PdfImageXObject</c>
            object
            </param>
            <param name="a">an element of the transformation matrix</param>
            <param name="b">an element of the transformation matrix</param>
            <param name="c">an element of the transformation matrix</param>
            <param name="d">an element of the transformation matrix</param>
            <param name="e">an element of the transformation matrix</param>
            <param name="f">an element of the transformation matrix</param>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.AddForm(iText.Kernel.Pdf.Xobject.PdfFormXObject,System.Single,System.Single)">
            <summary>
            Adds
            <c>PdfFormXObject</c>
            to the specified position.
            </summary>
            <param name="form"/>
            <param name="x"/>
            <param name="y"/>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.AddForm(iText.Kernel.Pdf.Xobject.PdfFormXObject,iText.Kernel.Geom.Rectangle)">
            <summary>
            Adds
            <c>PdfFormXObject</c>
            to specified rectangle on canvas.
            </summary>
            <param name="form"/>
            <param name="rect"/>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.AddForm(iText.Kernel.Pdf.Xobject.PdfFormXObject,System.Single,System.Single,System.Single)">
            <summary>
            Adds I
            <c>PdfFormXObject</c>
            to the specified position with specified width preserving aspect ratio.
            </summary>
            <param name="form"/>
            <param name="x"/>
            <param name="y"/>
            <param name="width"/>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.AddForm(iText.Kernel.Pdf.Xobject.PdfFormXObject,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
            Adds
            <c>PdfFormXObject</c>
            to the specified position with specified height preserving aspect ratio.
            </summary>
            <param name="form"/>
            <param name="x"/>
            <param name="y"/>
            <param name="height"/>
            <param name="dummy"/>
            <returns>current canvas</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.AddImage(iText.Kernel.Pdf.Xobject.PdfImageXObject,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Adds
            <c>PdfImageXObject</c>
            to canvas.
            </summary>
            <param name="image">
            the
            <c>PdfImageXObject</c>
            object
            </param>
            <param name="a">an element of the transformation matrix</param>
            <param name="b">an element of the transformation matrix</param>
            <param name="c">an element of the transformation matrix</param>
            <param name="d">an element of the transformation matrix</param>
            <param name="e">an element of the transformation matrix</param>
            <param name="f">an element of the transformation matrix</param>
            <returns>canvas a reference to this object.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.AddImage(iText.Kernel.Pdf.Xobject.PdfImageXObject,System.Single,System.Single)">
            <summary>
            Adds
            <c>PdfImageXObject</c>
            to the specified position.
            </summary>
            <param name="image"/>
            <param name="x"/>
            <param name="y"/>
            <returns>current canvas</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.AddImage(iText.Kernel.Pdf.Xobject.PdfImageXObject,iText.Kernel.Geom.Rectangle)">
            <summary>
            Adds
            <c>PdfImageXObject</c>
            to specified rectangle on canvas.
            </summary>
            <param name="image"/>
            <param name="rect"/>
            <returns>current canvas</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.AddImage(iText.Kernel.Pdf.Xobject.PdfImageXObject,System.Single,System.Single,System.Single)">
            <summary>
            Adds
            <c>PdfImageXObject</c>
            to the specified position with specified width preserving aspect ratio.
            </summary>
            <param name="image"/>
            <param name="x"/>
            <param name="y"/>
            <param name="width"/>
            <returns>current canvas</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.AddImage(iText.Kernel.Pdf.Xobject.PdfImageXObject,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
            Adds
            <c>PdfImageXObject</c>
            to the specified position with specified height preserving aspect ratio.
            </summary>
            <param name="image"/>
            <param name="x"/>
            <param name="y"/>
            <param name="height"/>
            <param name="dummy"/>
            <returns>current canvas.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfCanvas.ShowTextInt(System.String)">
            <summary>
            A helper to insert into the content stream the
            <paramref name="text"/>
            converted to bytes according to the font's encoding.
            </summary>
            <param name="text">the text to write.</param>
        </member>
        <member name="M:iText.Kernel.Font.Type3Glyph.#ctor(iText.Kernel.Pdf.PdfDocument,System.Single,System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>Creates a Type3Glyph canvas with a new Content Stream.</summary>
            <param name="pdfDocument">the document that this canvas is created for</param>
        </member>
        <member name="M:iText.Kernel.Font.Type3Glyph.#ctor(iText.Kernel.Pdf.PdfStream,iText.Kernel.Pdf.PdfDocument)">
            <summary>Creates a Type3Glyph canvas with a non-empty Content Stream.</summary>
            <param name="pdfStream">
            
            <c>PdfStream</c>
            from existed document.
            </param>
            <param name="document">
            document to which
            <c>PdfStream</c>
            belongs.
            </param>
        </member>
        <member name="M:iText.Kernel.Font.Type3Glyph.IsColor">
            <summary>Indicates if the glyph color specified in the glyph description or not.</summary>
            <returns>whether the glyph color is specified in the glyph description or not</returns>
        </member>
        <member name="M:iText.Kernel.Font.Type3Glyph.WriteMetrics(System.Single,System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>Writes the width and optionally the bounding box parameters for a glyph</summary>
            <param name="wx">the advance this character will have</param>
            <param name="llx">
            the X lower left corner of the glyph bounding box. If the <CODE>isColor</CODE> option is
            <CODE>true</CODE> the value is ignored
            </param>
            <param name="lly">
            the Y lower left corner of the glyph bounding box. If the <CODE>isColor</CODE> option is
            <CODE>true</CODE> the value is ignored
            </param>
            <param name="urx">
            the X upper right corner of the glyph bounding box. If the <CODE>isColor</CODE> option is
            <CODE>true</CODE> the value is ignored
            </param>
            <param name="ury">
            the Y upper right corner of the glyph bounding box. If the <CODE>isColor</CODE> option is
            <CODE>true</CODE> the value is ignored
            </param>
            <param name="isColor">
            defines whether the glyph color is specified in the glyph description in the font.
            The consequence of value <CODE>true</CODE> is that the bounding box parameters are ignored.
            </param>
        </member>
        <member name="M:iText.Kernel.Font.Type3Glyph.AddImage(iText.IO.Image.ImageData,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>Creates Image XObject from image and adds it to canvas.</summary>
            <remarks>
            Creates Image XObject from image and adds it to canvas. Performs additional checks to make
            sure that we only add mask images to not colorized type 3 fonts.
            </remarks>
            <param name="image">
            the
            <c>PdfImageXObject</c>
            object
            </param>
            <param name="a">an element of the transformation matrix</param>
            <param name="b">an element of the transformation matrix</param>
            <param name="c">an element of the transformation matrix</param>
            <param name="d">an element of the transformation matrix</param>
            <param name="e">an element of the transformation matrix</param>
            <param name="f">an element of the transformation matrix</param>
            <param name="inlineImage">true if to add image as in-line.</param>
            <returns>created Image XObject or null in case of in-line image (asInline = true).</returns>
        </member>
        <member name="F:iText.Kernel.Geom.AffineTransform.TYPE_IDENTITY">
            <summary>The type of affine transformation.</summary>
            <remarks>
            The type of affine transformation. See
            <see cref="M:iText.Kernel.Geom.AffineTransform.GetTransformType"/>
            .
            </remarks>
        </member>
        <member name="F:iText.Kernel.Geom.AffineTransform.TYPE_TRANSLATION">
            <summary>The type of affine transformation.</summary>
            <remarks>
            The type of affine transformation. See
            <see cref="M:iText.Kernel.Geom.AffineTransform.GetTransformType"/>
            .
            </remarks>
        </member>
        <member name="F:iText.Kernel.Geom.AffineTransform.TYPE_UNIFORM_SCALE">
            <summary>The type of affine transformation.</summary>
            <remarks>
            The type of affine transformation. See
            <see cref="M:iText.Kernel.Geom.AffineTransform.GetTransformType"/>
            .
            </remarks>
        </member>
        <member name="F:iText.Kernel.Geom.AffineTransform.TYPE_GENERAL_SCALE">
            <summary>The type of affine transformation.</summary>
            <remarks>
            The type of affine transformation. See
            <see cref="M:iText.Kernel.Geom.AffineTransform.GetTransformType"/>
            .
            </remarks>
        </member>
        <member name="F:iText.Kernel.Geom.AffineTransform.TYPE_QUADRANT_ROTATION">
            <summary>The type of affine transformation.</summary>
            <remarks>
            The type of affine transformation. See
            <see cref="M:iText.Kernel.Geom.AffineTransform.GetTransformType"/>
            .
            </remarks>
        </member>
        <member name="F:iText.Kernel.Geom.AffineTransform.TYPE_GENERAL_ROTATION">
            <summary>The type of affine transformation.</summary>
            <remarks>
            The type of affine transformation. See
            <see cref="M:iText.Kernel.Geom.AffineTransform.GetTransformType"/>
            .
            </remarks>
        </member>
        <member name="F:iText.Kernel.Geom.AffineTransform.TYPE_GENERAL_TRANSFORM">
            <summary>The type of affine transformation.</summary>
            <remarks>
            The type of affine transformation. See
            <see cref="M:iText.Kernel.Geom.AffineTransform.GetTransformType"/>
            .
            </remarks>
        </member>
        <member name="F:iText.Kernel.Geom.AffineTransform.TYPE_FLIP">
            <summary>The type of affine transformation.</summary>
            <remarks>
            The type of affine transformation. See
            <see cref="M:iText.Kernel.Geom.AffineTransform.GetTransformType"/>
            .
            </remarks>
        </member>
        <member name="F:iText.Kernel.Geom.AffineTransform.TYPE_MASK_SCALE">
            <summary>The type of affine transformation.</summary>
            <remarks>
            The type of affine transformation. See
            <see cref="M:iText.Kernel.Geom.AffineTransform.GetTransformType"/>
            .
            </remarks>
        </member>
        <member name="F:iText.Kernel.Geom.AffineTransform.TYPE_MASK_ROTATION">
            <summary>The type of affine transformation.</summary>
            <remarks>
            The type of affine transformation. See
            <see cref="M:iText.Kernel.Geom.AffineTransform.GetTransformType"/>
            .
            </remarks>
        </member>
        <member name="F:iText.Kernel.Geom.AffineTransform.TYPE_UNKNOWN">
            <summary>The <code>TYPE_UNKNOWN</code> is an initial type value.</summary>
        </member>
        <member name="F:iText.Kernel.Geom.AffineTransform.ZERO">
            <summary>The min value equivalent to zero.</summary>
            <remarks>The min value equivalent to zero. If absolute value less then ZERO it considered as zero.</remarks>
        </member>
        <member name="F:iText.Kernel.Geom.AffineTransform.m00">
            <summary>The values of transformation matrix</summary>
        </member>
        <member name="F:iText.Kernel.Geom.AffineTransform.type">
            <summary>The transformation <code>type</code></summary>
        </member>
        <member name="M:iText.Kernel.Geom.AffineTransform.GetTransformType">
            <summary>Method returns type of affine transformation.</summary>
            <remarks>
            Method returns type of affine transformation.
            Transform matrix is
            m00 m01 m02
            m10 m11 m12
            According analytic geometry new basis vectors are (m00, m01) and (m10, m11),
            translation vector is (m02, m12). Original basis vectors are (1, 0) and (0, 1).
            Type transformations classification:
            <ul>
            <li>
            <see cref="F:iText.Kernel.Geom.AffineTransform.TYPE_IDENTITY"/>
            - new basis equals original one and zero translation</li>
            <li>
            <see cref="F:iText.Kernel.Geom.AffineTransform.TYPE_TRANSLATION"/>
            - translation vector isn't zero</li>
            <li>
            <see cref="F:iText.Kernel.Geom.AffineTransform.TYPE_UNIFORM_SCALE"/>
            - vectors length of new basis equals</li>
            <li>
            <see cref="F:iText.Kernel.Geom.AffineTransform.TYPE_GENERAL_SCALE"/>
            - vectors length of new basis doesn't equal</li>
            <li>
            <see cref="F:iText.Kernel.Geom.AffineTransform.TYPE_FLIP"/>
            - new basis vector orientation differ from original one</li>
            <li>
            <see cref="F:iText.Kernel.Geom.AffineTransform.TYPE_QUADRANT_ROTATION"/>
            - new basis is rotated by 90, 180, 270, or 360 degrees</li>
            <li>
            <see cref="F:iText.Kernel.Geom.AffineTransform.TYPE_GENERAL_ROTATION"/>
            - new basis is rotated by arbitrary angle</li>
            <li>
            <see cref="F:iText.Kernel.Geom.AffineTransform.TYPE_GENERAL_TRANSFORM"/>
            - transformation can't be inversed</li>
            </ul>
            </remarks>
        </member>
        <member name="M:iText.Kernel.Geom.AffineTransform.Multiply(iText.Kernel.Geom.AffineTransform,iText.Kernel.Geom.AffineTransform)">
            <summary>Multiply matrix of two AffineTransform objects</summary>
            <param name="t1">- the AffineTransform object is a multiplicand</param>
            <param name="t2">- the AffineTransform object is a multiplier</param>
            <returns>an AffineTransform object that is a result of t1 multiplied by matrix t2.</returns>
        </member>
        <member name="M:iText.Kernel.Geom.AffineTransform.CreateInverse">
            <exception cref="T:iText.Kernel.Geom.NoninvertibleTransformException"/>
        </member>
        <member name="M:iText.Kernel.Geom.AffineTransform.InverseTransform(iText.Kernel.Geom.Point,iText.Kernel.Geom.Point)">
            <exception cref="T:iText.Kernel.Geom.NoninvertibleTransformException"/>
        </member>
        <member name="M:iText.Kernel.Geom.AffineTransform.InverseTransform(System.Double[],System.Int32,System.Double[],System.Int32,System.Int32)">
            <exception cref="T:iText.Kernel.Geom.NoninvertibleTransformException"/>
        </member>
        <member name="M:iText.Kernel.Geom.AffineTransform.InverseTransform(System.Single[],System.Int32,System.Single[],System.Int32,System.Int32)">
            <exception cref="T:iText.Kernel.Geom.NoninvertibleTransformException"/>
        </member>
        <member name="M:iText.Kernel.Geom.AffineTransform.Clone">
            <exception cref="!:Java.Lang.CloneNotSupportedException"/>
        </member>
        <member name="T:iText.Kernel.Geom.BezierCurve">
            <summary>Represents a Bezier curve.</summary>
        </member>
        <member name="T:iText.Kernel.Geom.IShape">
            <summary>Represents segment from a PDF path.</summary>
        </member>
        <member name="M:iText.Kernel.Geom.IShape.GetBasePoints">
            <summary>Treat base points as the points which are enough to construct a shape.</summary>
            <remarks>
            Treat base points as the points which are enough to construct a shape.
            E.g. for a bezier curve they are control points, for a line segment - the start and the end points
            of the segment.
            </remarks>
            <returns>
            Ordered
            <see cref="!:System.Collections.IList&lt;E&gt;"/>
            consisting of shape's base points.
            </returns>
        </member>
        <member name="F:iText.Kernel.Geom.BezierCurve.curveCollinearityEpsilon">
            <summary>
            If the distance between a point and a line is less than
            this constant, then we consider the point lies on the line.
            </summary>
        </member>
        <member name="F:iText.Kernel.Geom.BezierCurve.distanceToleranceSquare">
            <summary>
            In the case when neither the line ((x1, y1), (x4, y4)) passes
            through both (x2, y2) and (x3, y3) nor (x1, y1) = (x4, y4) we
            use the square of the sum of the distances mentioned below in
            compare to this field as the criterion of good approximation.
            </summary>
            <remarks>
            In the case when neither the line ((x1, y1), (x4, y4)) passes
            through both (x2, y2) and (x3, y3) nor (x1, y1) = (x4, y4) we
            use the square of the sum of the distances mentioned below in
            compare to this field as the criterion of good approximation.
            1. The distance between the line and (x2, y2)
            2. The distance between the line and (x3, y3)
            </remarks>
        </member>
        <member name="F:iText.Kernel.Geom.BezierCurve.distanceToleranceManhattan">
            <summary>
            The Manhattan distance is used in the case when either the line
            ((x1, y1), (x4, y4)) passes through both (x2, y2) and (x3, y3)
            or (x1, y1) = (x4, y4).
            </summary>
            <remarks>
            The Manhattan distance is used in the case when either the line
            ((x1, y1), (x4, y4)) passes through both (x2, y2) and (x3, y3)
            or (x1, y1) = (x4, y4). The essential observation is that when
            the curve is a uniform speed straight line from end to end, the
            control points are evenly spaced from beginning to end. Our measure
            of how far we deviate from that ideal uses distance of the middle
            controls: point 2 should be halfway between points 1 and 3; point 3
            should be halfway between points 2 and 4.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Geom.BezierCurve.#ctor(System.Collections.Generic.IList{iText.Kernel.Geom.Point})">
            <summary>Constructs new bezier curve.</summary>
            <param name="controlPoints">Curve's control points.</param>
        </member>
        <member name="M:iText.Kernel.Geom.BezierCurve.GetBasePoints">
            <summary><inheritDoc/></summary>
        </member>
        <member name="M:iText.Kernel.Geom.BezierCurve.GetPiecewiseLinearApproximation">
            <summary>
            You can adjust precision of the approximation by varying the following
            parameters:
            <see cref="F:iText.Kernel.Geom.BezierCurve.curveCollinearityEpsilon"/>
            ,
            <see cref="F:iText.Kernel.Geom.BezierCurve.distanceToleranceSquare"/>
            ,
            <see cref="F:iText.Kernel.Geom.BezierCurve.distanceToleranceManhattan"/>
            </summary>
            <returns>
            
            <see cref="!:System.Collections.IList&lt;E&gt;"/>
            containing points of piecewise linear approximation
            for this bezier curve.
            </returns>
        </member>
        <member name="T:iText.Kernel.Geom.Line">
            <summary>Represents a line.</summary>
        </member>
        <member name="M:iText.Kernel.Geom.Line.#ctor">
            <summary>Constructs a new zero-length line starting at zero.</summary>
        </member>
        <member name="M:iText.Kernel.Geom.Line.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>Constructs a new line based on the given coordinates.</summary>
        </member>
        <member name="M:iText.Kernel.Geom.Line.#ctor(iText.Kernel.Geom.Point,iText.Kernel.Geom.Point)">
            <summary>Constructs a new line based on the given coordinates.</summary>
        </member>
        <member name="T:iText.Kernel.Geom.LineSegment">
            <summary>Represents a line segment in a particular coordinate system.</summary>
            <remarks>Represents a line segment in a particular coordinate system.  This class is immutable.</remarks>
        </member>
        <member name="F:iText.Kernel.Geom.LineSegment.startPoint">
            <summary>Start vector of the segment.</summary>
        </member>
        <member name="F:iText.Kernel.Geom.LineSegment.endPoint">
            <summary>End vector of the segment.</summary>
        </member>
        <member name="M:iText.Kernel.Geom.LineSegment.#ctor(iText.Kernel.Geom.Vector,iText.Kernel.Geom.Vector)">
            <summary>Creates a new line segment.</summary>
            <param name="startPoint">the start point of a line segment.</param>
            <param name="endPoint">the end point of a line segment.</param>
        </member>
        <member name="M:iText.Kernel.Geom.LineSegment.GetStartPoint">
            <returns>the start point</returns>
        </member>
        <member name="M:iText.Kernel.Geom.LineSegment.GetEndPoint">
            <returns>the end point</returns>
        </member>
        <member name="M:iText.Kernel.Geom.LineSegment.GetLength">
            <returns>the length of this line segment</returns>
        </member>
        <member name="M:iText.Kernel.Geom.LineSegment.GetBoundingRectange">
            <summary>Computes the bounding rectangle for this line segment.</summary>
            <remarks>
            Computes the bounding rectangle for this line segment.  The rectangle has a rotation 0 degrees
            with respect to the coordinate system that the line system is in.  For example, if a line segment
            is 5 unit long and sits at a 37 degree angle from horizontal, the bounding rectangle will have
            origin of the lower left hand end point of the segment, with width = 4 and height = 3.
            </remarks>
            <returns>the bounding rectangle</returns>
        </member>
        <member name="M:iText.Kernel.Geom.LineSegment.GetBoundingRectangle">
            <summary>Computes the bounding rectangle for this line segment.</summary>
            <remarks>
            Computes the bounding rectangle for this line segment.  The rectangle has a rotation 0 degrees
            with respect to the coordinate system that the line system is in.  For example, if a line segment
            is 5 unit long and sits at a 37 degree angle from horizontal, the bounding rectangle will have
            origin of the lower left hand end point of the segment, with width = 4 and height = 3.
            </remarks>
            <returns>the bounding rectangle</returns>
        </member>
        <member name="M:iText.Kernel.Geom.LineSegment.TransformBy(iText.Kernel.Geom.Matrix)">
            <summary>Transforms the segment by the specified matrix</summary>
            <param name="m">the matrix for the transformation</param>
            <returns>the transformed segment</returns>
        </member>
        <member name="M:iText.Kernel.Geom.LineSegment.ContainsSegment(iText.Kernel.Geom.LineSegment)">
            <summary>Checks if a segment contains another segment in itself</summary>
            <param name="other">a segment to be checked</param>
            <returns>true if this segment contains other one, false otherwise</returns>
        </member>
        <member name="M:iText.Kernel.Geom.LineSegment.ContainsPoint(iText.Kernel.Geom.Vector)">
            <summary>Checks if a segment contains a given point in itself</summary>
            <param name="point">a point to be checked</param>
            <returns>true if this segment contains given point, false otherwise</returns>
        </member>
        <member name="T:iText.Kernel.Geom.Matrix">
            <summary>
            Keeps all the values of a 3 by 3 matrix and allows you to
            do some math with matrices.
            </summary>
        </member>
        <member name="F:iText.Kernel.Geom.Matrix.I11">
            <summary>the row=1, col=1 position ('a') in the matrix.</summary>
        </member>
        <member name="F:iText.Kernel.Geom.Matrix.I12">
            <summary>the row=1, col=2 position ('b') in the matrix.</summary>
        </member>
        <member name="F:iText.Kernel.Geom.Matrix.I13">
            <summary>the row=1, col=3 position (always 0 for 2-D) in the matrix.</summary>
        </member>
        <member name="F:iText.Kernel.Geom.Matrix.I21">
            <summary>the row=2, col=1 position ('c') in the matrix.</summary>
        </member>
        <member name="F:iText.Kernel.Geom.Matrix.I22">
            <summary>the row=2, col=2 position ('d') in the matrix.</summary>
        </member>
        <member name="F:iText.Kernel.Geom.Matrix.I23">
            <summary>the row=2, col=3 position (always 0 for 2-D) in the matrix.</summary>
        </member>
        <member name="F:iText.Kernel.Geom.Matrix.I31">
            <summary>the row=3, col=1 ('e', or X translation) position in the matrix.</summary>
        </member>
        <member name="F:iText.Kernel.Geom.Matrix.I32">
            <summary>the row=3, col=2 ('f', or Y translation) position in the matrix.</summary>
        </member>
        <member name="F:iText.Kernel.Geom.Matrix.I33">
            <summary>the row=3, col=3 position (always 1 for 2-D) in the matrix.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:iText.Kernel.Geom.Matrix.vals" -->
        <member name="M:iText.Kernel.Geom.Matrix.#ctor">
            <summary>constructs a new Matrix with identity.</summary>
        </member>
        <member name="M:iText.Kernel.Geom.Matrix.#ctor(System.Single,System.Single)">
            <summary>Constructs a matrix that represents translation</summary>
            <param name="tx"/>
            <param name="ty"/>
        </member>
        <member name="M:iText.Kernel.Geom.Matrix.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>Creates a Matrix with 9 specified entries</summary>
            <param name="e11">element at position (1,1)</param>
        </member>
        <member name="M:iText.Kernel.Geom.Matrix.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Creates a Matrix with 6 specified entries
            The third column will always be [0 0 1]
            (row, column)
            </summary>
            <param name="a">element at (1,1)</param>
            <param name="b">element at (1,2)</param>
            <param name="c">element at (2,1)</param>
            <param name="d">element at (2,2)</param>
            <param name="e">element at (3,1)</param>
            <param name="f">element at (3,2)</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Geom.Matrix.Get(System.Int32)" -->
        <member name="M:iText.Kernel.Geom.Matrix.Multiply(iText.Kernel.Geom.Matrix)">
            <summary>
            multiplies this matrix by 'b' and returns the result
            See http://en.wikipedia.org/wiki/Matrix_multiplication
            </summary>
            <param name="by">The matrix to multiply by</param>
            <returns>the resulting matrix</returns>
        </member>
        <member name="M:iText.Kernel.Geom.Matrix.Add(iText.Kernel.Geom.Matrix)">
            <summary>adds a matrix from this matrix and returns the results</summary>
            <param name="arg">the matrix to subtract from this matrix</param>
            <returns>a Matrix object</returns>
        </member>
        <member name="M:iText.Kernel.Geom.Matrix.Subtract(iText.Kernel.Geom.Matrix)">
            <summary>Subtracts a matrix from this matrix and returns the results</summary>
            <param name="arg">the matrix to subtract from this matrix</param>
            <returns>a Matrix object</returns>
        </member>
        <member name="M:iText.Kernel.Geom.Matrix.GetDeterminant">
            <summary>Computes the determinant of the matrix.</summary>
            <returns>the determinant of the matrix</returns>
        </member>
        <member name="M:iText.Kernel.Geom.Matrix.Equals(System.Object)">
            <summary>Checks equality of matrices.</summary>
            <param name="obj">the other Matrix that needs to be compared with this matrix.</param>
            <returns>true if both matrices are equal</returns>
            <seealso cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:iText.Kernel.Geom.Matrix.GetHashCode">
            <summary>Generates a hash code for this object.</summary>
            <returns>the hash code of this object</returns>
            <seealso cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:iText.Kernel.Geom.Matrix.ToString">
            <summary>Generates a String representation of the matrix.</summary>
            <returns>the values, delimited with tabs and newlines.</returns>
            <seealso cref="M:System.Object.ToString"/>
        </member>
        <member name="T:iText.Kernel.Geom.NoninvertibleTransformException">
            <summary>NoninvertibleTransformException</summary>
            <author>Denis M. Kishenko</author>
        </member>
        <member name="M:iText.Kernel.Geom.NoninvertibleTransformException.#ctor(System.String)">
            <summary>Creates a new NoninvertibleTransformException.</summary>
            <param name="message">the detail message.</param>
        </member>
        <member name="T:iText.Kernel.Geom.Rectangle">
            <summary>Class that represent rectangle object.</summary>
        </member>
        <member name="M:iText.Kernel.Geom.Rectangle.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>Creates new instance.</summary>
            <param name="x">the x coordinate of lower left point</param>
            <param name="y">the y coordinate of lower left point</param>
            <param name="width">the width value</param>
            <param name="height">the height value</param>
        </member>
        <member name="M:iText.Kernel.Geom.Rectangle.#ctor(System.Single,System.Single)">
            <summary>Creates new instance of rectangle with (0, 0) as the lower left point.</summary>
            <param name="width">the width value</param>
            <param name="height">the height value</param>
        </member>
        <member name="M:iText.Kernel.Geom.Rectangle.#ctor(iText.Kernel.Geom.Rectangle)">
            <summary>
            Creates the copy of given
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            </summary>
            <param name="rect">
            the copied
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            </param>
        </member>
        <member name="M:iText.Kernel.Geom.Rectangle.GetCommonRectangle(iText.Kernel.Geom.Rectangle[])">
            <summary>Calculates the common rectangle which includes all the input rectangles.</summary>
            <param name="rectangles">list of input rectangles.</param>
            <returns>common rectangle.</returns>
        </member>
        <member name="M:iText.Kernel.Geom.Rectangle.SetBbox(System.Single,System.Single,System.Single,System.Single)">
            <summary>Sets the rectangle by the coordinates, specifying its lower left and upper right points.</summary>
            <remarks>
            Sets the rectangle by the coordinates, specifying its lower left and upper right points. May be used in chain.
            <br/>
            <br/>
            Note: this method will normalize coordinates, so the rectangle will have non negative width and height,
            and its x and y coordinates specified lower left point.
            </remarks>
            <param name="llx">the X coordinate of lower left point</param>
            <param name="lly">the Y coordinate of lower left point</param>
            <param name="urx">the X coordinate of upper right point</param>
            <param name="ury">the Y coordinate of upper right point</param>
            <returns>
            this
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Geom.Rectangle.GetX">
            <summary>Gets the X coordinate of lower left point.</summary>
            <returns>the X coordinate of lower left point.</returns>
        </member>
        <member name="M:iText.Kernel.Geom.Rectangle.SetX(System.Single)">
            <summary>Sets the X coordinate of lower left point.</summary>
            <remarks>Sets the X coordinate of lower left point. May be used in chain.</remarks>
            <param name="x">the X coordinate of lower left point to be set.</param>
            <returns>
            this
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Geom.Rectangle.GetY">
            <summary>Gets the Y coordinate of lower left point.</summary>
            <returns>the Y coordinate of lower left point.</returns>
        </member>
        <member name="M:iText.Kernel.Geom.Rectangle.SetY(System.Single)">
            <summary>Sets the Y coordinate of lower left point.</summary>
            <remarks>Sets the Y coordinate of lower left point. May be used in chain.</remarks>
            <param name="y">the Y coordinate of lower left point to be set.</param>
            <returns>
            this
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Geom.Rectangle.GetWidth">
            <summary>Gets the width of rectangle.</summary>
            <returns>the width of rectangle.</returns>
        </member>
        <member name="M:iText.Kernel.Geom.Rectangle.SetWidth(System.Single)">
            <summary>Sets the width of rectangle.</summary>
            <remarks>Sets the width of rectangle. May be used in chain.</remarks>
            <param name="width">the the width of rectangle to be set.</param>
            <returns>
            this
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Geom.Rectangle.GetHeight">
            <summary>Gets the height of rectangle.</summary>
            <returns>the height of rectangle.</returns>
        </member>
        <member name="M:iText.Kernel.Geom.Rectangle.SetHeight(System.Single)">
            <summary>Sets the height of rectangle.</summary>
            <remarks>Sets the height of rectangle. May be used in chain.</remarks>
            <param name="height">the the width of rectangle to be set.</param>
            <returns>
            this
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Geom.Rectangle.IncreaseHeight(System.Single)">
            <summary>Increases the height of rectangle by the given value.</summary>
            <remarks>Increases the height of rectangle by the given value. May be used in chain.</remarks>
            <param name="extra">the value of the extra height to be added.</param>
            <returns>
            this
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Geom.Rectangle.DecreaseHeight(System.Single)">
            <summary>Decreases the height of rectangle by the given value.</summary>
            <remarks>Decreases the height of rectangle by the given value. May be used in chain.</remarks>
            <param name="extra">the value of the extra height to be subtracted.</param>
            <returns>
            this
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Geom.Rectangle.GetLeft">
            <summary>Gets the X coordinate of the left edge of the rectangle.</summary>
            <remarks>
            Gets the X coordinate of the left edge of the rectangle. Same as:
            <c>getX()</c>
            .
            </remarks>
            <returns>the X coordinate of the left edge of the rectangle.</returns>
        </member>
        <member name="M:iText.Kernel.Geom.Rectangle.GetRight">
            <summary>Gets the X coordinate of the right edge of the rectangle.</summary>
            <remarks>
            Gets the X coordinate of the right edge of the rectangle. Same as:
            <c>getX() + getWidth()</c>
            .
            </remarks>
            <returns>the X coordinate of the right edge of the rectangle.</returns>
        </member>
        <member name="M:iText.Kernel.Geom.Rectangle.GetTop">
            <summary>Gets the Y coordinate of the upper edge of the rectangle.</summary>
            <remarks>
            Gets the Y coordinate of the upper edge of the rectangle. Same as:
            <c>getY() + getHeight()</c>
            .
            </remarks>
            <returns>the Y coordinate of the upper edge of the rectangle.</returns>
        </member>
        <member name="M:iText.Kernel.Geom.Rectangle.GetBottom">
            <summary>Gets the Y coordinate of the lower edge of the rectangle.</summary>
            <remarks>
            Gets the Y coordinate of the lower edge of the rectangle. Same as:
            <c>getY()</c>
            .
            </remarks>
            <returns>the Y coordinate of the lower edge of the rectangle.</returns>
        </member>
        <member name="M:iText.Kernel.Geom.Rectangle.MoveDown(System.Single)">
            <summary>Decreases the y coordinate.</summary>
            <param name="move">the value on which the position will be changed.</param>
            <returns>
            this
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Geom.Rectangle.MoveUp(System.Single)">
            <summary>Increases the y coordinate.</summary>
            <param name="move">the value on which the position will be changed.</param>
            <returns>
            this
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Geom.Rectangle.MoveRight(System.Single)">
            <summary>Increases the x coordinate.</summary>
            <param name="move">the value on which the position will be changed.</param>
            <returns>
            this
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Geom.Rectangle.MoveLeft(System.Single)">
            <summary>Decreases the x coordinate.</summary>
            <param name="move">the value on which the position will be changed.</param>
            <returns>
            this
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Geom.Rectangle.ApplyMargins``1(System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>Change the rectangle according the specified margins.</summary>
            <param name="topIndent">the value on which the top y coordinate will change.</param>
            <param name="rightIndent">the value on which the right x coordinate will change.</param>
            <param name="bottomIndent">the value on which the bottom y coordinate will change.</param>
            <param name="leftIndent">the value on which the left x coordinate will change.</param>
            <param name="reverse">
            if
            <see langword="true"/>
            the rectangle will expand, otherwise it will shrink
            </param>
            
            <returns>this instance that is cast to type T.</returns>
        </member>
        <member name="M:iText.Kernel.Geom.Rectangle.IntersectsLine(System.Single,System.Single,System.Single,System.Single)">
            <summary>Checks if rectangle have common points with line, specified by two points.</summary>
            <param name="x1">the x coordinate of first line's point.</param>
            <param name="y1">the y coordinate of first line's point.</param>
            <param name="x2">the x coordinate of second line's point.</param>
            <param name="y2">the y coordinate of second line's point.</param>
            <returns>
            
            <see langword="true"/>
            if rectangle have common points with line and
            <see langword="false"/>
            otherwise.
            </returns>
        </member>
        <member name="M:iText.Kernel.Geom.Rectangle.ToString">
            <summary>Gets the string representation of rectangle.</summary>
            <returns>the string representation of rectangle.</returns>
        </member>
        <member name="M:iText.Kernel.Geom.Rectangle.Clone">
            <summary>Gets the copy of this rectangle.</summary>
            <returns>the copied rectangle.</returns>
        </member>
        <member name="M:iText.Kernel.Geom.Rectangle.EqualsWithEpsilon(iText.Kernel.Geom.Rectangle)">
            <summary>Compares instance of this rectangle with given deviation equals to 0.0001</summary>
            <param name="that">
            the
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            to compare with.
            </param>
            <returns>
            
            <see langword="true"/>
            if the difference between corresponding rectangle values is less than deviation and
            <see langword="false"/>
            otherwise.
            </returns>
        </member>
        <member name="M:iText.Kernel.Geom.Rectangle.EqualsWithEpsilon(iText.Kernel.Geom.Rectangle,System.Single)">
            <summary>Compares instance of this rectangle with given deviation.</summary>
            <param name="that">
            the
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            to compare with.
            </param>
            <param name="eps">the deviation value.</param>
            <returns>
            
            <see langword="true"/>
            if the difference between corresponding rectangle values is less than deviation and
            <see langword="false"/>
            otherwise.
            </returns>
        </member>
        <member name="M:iText.Kernel.Geom.PageSize.Rotate">
            <summary>Rotates PageSize clockwise.</summary>
        </member>
        <member name="T:iText.Kernel.Geom.Path">
            <summary>Paths define shapes, trajectories, and regions of all sorts.</summary>
            <remarks>
            Paths define shapes, trajectories, and regions of all sorts. They shall be used
            to draw lines, define the shapes of filled areas, and specify boundaries for clipping
            other graphics. A path shall be composed of straight and curved line segments, which
            may connect to one another or may be disconnected.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Geom.Path.GetSubpaths">
            <returns>
            A
            <see cref="!:System.Collections.IList&lt;E&gt;"/>
            of subpaths forming this path.
            </returns>
        </member>
        <member name="M:iText.Kernel.Geom.Path.AddSubpath(iText.Kernel.Geom.Subpath)">
            <summary>Adds the subpath to this path.</summary>
            <param name="subpath">The subpath to be added to this path.</param>
        </member>
        <member name="M:iText.Kernel.Geom.Path.AddSubpaths``1(System.Collections.Generic.IList{``0})">
            <summary>Adds the subpaths to this path.</summary>
            <param name="subpaths">
            
            <see cref="!:System.Collections.IList&lt;E&gt;"/>
            of subpaths to be added to this path.
            </param>
        </member>
        <member name="M:iText.Kernel.Geom.Path.GetCurrentPoint">
            <summary>The current point is the trailing endpoint of the segment most recently added to the current path.
                </summary>
            <returns>The current point.</returns>
        </member>
        <member name="M:iText.Kernel.Geom.Path.MoveTo(System.Single,System.Single)">
            <summary>Begins a new subpath by moving the current point to coordinates <CODE>(x, y)</CODE>.</summary>
        </member>
        <member name="M:iText.Kernel.Geom.Path.LineTo(System.Single,System.Single)">
            <summary>Appends a straight line segment from the current point to the point <CODE>(x, y)</CODE>.</summary>
        </member>
        <member name="M:iText.Kernel.Geom.Path.CurveTo(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>Appends a cubic Bezier curve to the current path.</summary>
            <remarks>
            Appends a cubic Bezier curve to the current path. The curve shall extend from
            the current point to the point <CODE>(x3, y3)</CODE>.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Geom.Path.CurveTo(System.Single,System.Single,System.Single,System.Single)">
            <summary>Appends a cubic Bezier curve to the current path.</summary>
            <remarks>
            Appends a cubic Bezier curve to the current path. The curve shall extend from
            the current point to the point <CODE>(x3, y3)</CODE> with the note that the current
            point represents two control points.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Geom.Path.CurveFromTo(System.Single,System.Single,System.Single,System.Single)">
            <summary>Appends a cubic Bezier curve to the current path.</summary>
            <remarks>
            Appends a cubic Bezier curve to the current path. The curve shall extend from
            the current point to the point <CODE>(x3, y3)</CODE> with the note that the (x3, y3)
            point represents two control points.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Geom.Path.Rectangle(iText.Kernel.Geom.Rectangle)">
            <summary>Appends a rectangle to the current path as a complete subpath.</summary>
        </member>
        <member name="M:iText.Kernel.Geom.Path.Rectangle(System.Single,System.Single,System.Single,System.Single)">
            <summary>Appends a rectangle to the current path as a complete subpath.</summary>
        </member>
        <member name="M:iText.Kernel.Geom.Path.CloseSubpath">
            <summary>Closes the current subpath.</summary>
        </member>
        <member name="M:iText.Kernel.Geom.Path.CloseAllSubpaths">
            <summary>Closes all subpathes contained in this path.</summary>
        </member>
        <member name="M:iText.Kernel.Geom.Path.ReplaceCloseWithLine">
            <summary>Adds additional line to each closed subpath and makes the subpath unclosed.</summary>
            <remarks>
            Adds additional line to each closed subpath and makes the subpath unclosed.
            The line connects the last and the first points of the subpaths.
            </remarks>
            <returns>Indices of modified subpaths.</returns>
        </member>
        <member name="M:iText.Kernel.Geom.Path.IsEmpty">
            <summary>Path is empty if it contains no subpaths.</summary>
        </member>
        <member name="T:iText.Kernel.Geom.Subpath">
            <summary>As subpath is a part of a path comprising a sequence of connected segments.</summary>
        </member>
        <member name="M:iText.Kernel.Geom.Subpath.#ctor">
            <summary>Creates a new SubPath instance.</summary>
        </member>
        <member name="M:iText.Kernel.Geom.Subpath.#ctor(iText.Kernel.Geom.Subpath)">
            <summary>Copy constuctor.</summary>
            <param name="subpath"/>
        </member>
        <member name="M:iText.Kernel.Geom.Subpath.#ctor(iText.Kernel.Geom.Point)">
            <summary>Constructs a new subpath starting at the given point.</summary>
        </member>
        <member name="M:iText.Kernel.Geom.Subpath.#ctor(System.Single,System.Single)">
            <summary>Constructs a new subpath starting at the given point.</summary>
        </member>
        <member name="M:iText.Kernel.Geom.Subpath.SetStartPoint(iText.Kernel.Geom.Point)">
            <summary>Sets the start point of the subpath.</summary>
            <param name="startPoint"/>
        </member>
        <member name="M:iText.Kernel.Geom.Subpath.SetStartPoint(System.Single,System.Single)">
            <summary>Sets the start point of the subpath.</summary>
            <param name="x"/>
            <param name="y"/>
        </member>
        <member name="M:iText.Kernel.Geom.Subpath.GetStartPoint">
            <returns>The point this subpath starts at.</returns>
        </member>
        <member name="M:iText.Kernel.Geom.Subpath.GetLastPoint">
            <returns>The last point of the subpath.</returns>
        </member>
        <member name="M:iText.Kernel.Geom.Subpath.AddSegment(iText.Kernel.Geom.IShape)">
            <summary>Adds a segment to the subpath.</summary>
            <remarks>
            Adds a segment to the subpath.
            Note: each new segment shall start at the end of the previous segment.
            </remarks>
            <param name="segment">new segment.</param>
        </member>
        <member name="M:iText.Kernel.Geom.Subpath.GetSegments">
            <returns>
            
            <see cref="!:System.Collections.IList&lt;E&gt;"/>
            comprising all the segments
            the subpath made on.
            </returns>
        </member>
        <member name="M:iText.Kernel.Geom.Subpath.IsEmpty">
            <summary>Checks whether subpath is empty or not.</summary>
            <returns>true if the subpath is empty, false otherwise.</returns>
        </member>
        <member name="M:iText.Kernel.Geom.Subpath.IsSinglePointOpen">
            <returns>
            <CODE>true</CODE> if this subpath contains only one point and it is not closed,
            <CODE>false</CODE> otherwise
            </returns>
        </member>
        <member name="M:iText.Kernel.Geom.Subpath.IsSinglePointClosed">
            <returns>
            <CODE>true</CODE> if this subpath contains only one point and it is closed,
            <CODE>false</CODE> otherwise
            </returns>
        </member>
        <member name="M:iText.Kernel.Geom.Subpath.IsClosed">
            <summary>Returns a <CODE>boolean</CODE> value indicating whether the subpath must be closed or not.</summary>
            <remarks>
            Returns a <CODE>boolean</CODE> value indicating whether the subpath must be closed or not.
            Ignore this value if the subpath is a rectangle because in this case it is already closed
            (of course if you paint the path using <CODE>re</CODE> operator)
            </remarks>
            <returns><CODE>boolean</CODE> value indicating whether the path must be closed or not.</returns>
        </member>
        <member name="M:iText.Kernel.Geom.Subpath.SetClosed(System.Boolean)">
            <summary>
            See
            <see cref="M:iText.Kernel.Geom.Subpath.IsClosed"/>
            </summary>
        </member>
        <member name="M:iText.Kernel.Geom.Subpath.IsDegenerate">
            <summary>Returns a <CODE>boolean</CODE> indicating whether the subpath is degenerate or not.</summary>
            <remarks>
            Returns a <CODE>boolean</CODE> indicating whether the subpath is degenerate or not.
            A degenerate subpath is the subpath consisting of a single-point closed path or of
            two or more points at the same coordinates.
            </remarks>
            <returns><CODE>boolean</CODE> value indicating whether the path is degenerate or not.</returns>
        </member>
        <member name="M:iText.Kernel.Geom.Subpath.GetPiecewiseLinearApproximation">
            <returns>
            
            <see cref="!:System.Collections.IList&lt;E&gt;"/>
            containing points of piecewise linear approximation
            for this subpath.
            </returns>
        </member>
        <member name="T:iText.Kernel.Geom.Vector">
            <summary>Represents a vector (i.e.</summary>
            <remarks>
            Represents a vector (i.e. a point in space).  This class is completely
            unrelated to the
            <see cref="!:System.Collections.ArrayList&lt;E&gt;"/>
            class in the standard JRE.
            <br/><br/>
            For many PDF related operations, the z coordinate is specified as 1
            This is to support the coordinate transformation calculations.  If it
            helps, just think of all PDF drawing operations as occurring in a single plane
            with z=1.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Geom.Vector.I1">
            <summary>index of the X coordinate</summary>
        </member>
        <member name="F:iText.Kernel.Geom.Vector.I2">
            <summary>index of the Y coordinate</summary>
        </member>
        <member name="F:iText.Kernel.Geom.Vector.I3">
            <summary>index of the Z coordinate</summary>
        </member>
        <member name="F:iText.Kernel.Geom.Vector.vals">
            <summary>the values inside the vector</summary>
        </member>
        <member name="M:iText.Kernel.Geom.Vector.#ctor(System.Single,System.Single,System.Single)">
            <summary>Creates a new Vector</summary>
            <param name="x">the X coordinate</param>
            <param name="y">the Y coordinate</param>
            <param name="z">the Z coordinate</param>
        </member>
        <member name="M:iText.Kernel.Geom.Vector.Get(System.Int32)">
            <summary>Gets the value from a coordinate of the vector</summary>
            <param name="index">the index of the value to get (I1, I2 or I3)</param>
            <returns>a coordinate value</returns>
        </member>
        <member name="M:iText.Kernel.Geom.Vector.Cross(iText.Kernel.Geom.Matrix)">
            <summary>Computes the cross product of this vector and the specified matrix</summary>
            <param name="by">the matrix to cross this vector with</param>
            <returns>the result of the cross product</returns>
        </member>
        <member name="M:iText.Kernel.Geom.Vector.Subtract(iText.Kernel.Geom.Vector)">
            <summary>Computes the difference between this vector and the specified vector</summary>
            <param name="v">the vector to subtract from this one</param>
            <returns>the results of the subtraction</returns>
        </member>
        <member name="M:iText.Kernel.Geom.Vector.Cross(iText.Kernel.Geom.Vector)">
            <summary>Computes the cross product of this vector and the specified vector</summary>
            <param name="with">the vector to cross this vector with</param>
            <returns>the cross product</returns>
        </member>
        <member name="M:iText.Kernel.Geom.Vector.Normalize">
            <summary>Normalizes the vector (i.e.</summary>
            <remarks>Normalizes the vector (i.e. returns the unit vector in the same orientation as this vector)</remarks>
            <returns>the unit vector</returns>
        </member>
        <member name="M:iText.Kernel.Geom.Vector.Multiply(System.Single)">
            <summary>Multiplies the vector by a scalar</summary>
            <param name="by">the scalar to multiply by</param>
            <returns>the result of the scalar multiplication</returns>
        </member>
        <member name="M:iText.Kernel.Geom.Vector.Dot(iText.Kernel.Geom.Vector)">
            <summary>Computes the dot product of this vector with the specified vector</summary>
            <param name="with">the vector to dot product this vector with</param>
            <returns>the dot product</returns>
        </member>
        <member name="M:iText.Kernel.Geom.Vector.Length">
            <summary>
            Computes the length of this vector
            <br />
            <b>Note:</b> If you are working with raw vectors from PDF, be careful -
            the Z axis will generally be set to 1.
            </summary>
            <remarks>
            Computes the length of this vector
            <br />
            <b>Note:</b> If you are working with raw vectors from PDF, be careful -
            the Z axis will generally be set to 1.  If you want to compute the
            length of a vector, subtract it from the origin first (this will set
            the Z axis to 0).
            <br />
            For example:
            <code>aVector.subtract(originVector).length();</code>
            </remarks>
            <returns>the length of this vector</returns>
        </member>
        <member name="M:iText.Kernel.Geom.Vector.LengthSquared">
            <summary>Computes the length squared of this vector.</summary>
            <remarks>
            Computes the length squared of this vector.
            <p/>
            The square of the length is less expensive to compute, and is often
            useful without taking the square root.
            <br/><br/>
            <b>Note:</b> See the important note under
            <see cref="M:iText.Kernel.Geom.Vector.Length"/>
            </remarks>
            <returns>the square of the length of the vector</returns>
        </member>
        <member name="M:iText.Kernel.Geom.Vector.ToString">
            <seealso cref="M:System.Object.ToString"/>
        </member>
        <member name="M:iText.Kernel.Geom.Vector.GetHashCode">
            <summary>Calculates the hashcode using the values.</summary>
        </member>
        <member name="M:iText.Kernel.Geom.Vector.Equals(System.Object)">
            <seealso cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <!-- Badly formed XML comment ignored for member "T:iText.Kernel.Log.Counter" -->
        <member name="M:iText.Kernel.Log.Counter.GetCounter(System.Type)">
            <summary>Gets a Counter instance for a specific class.</summary>
        </member>
        <member name="M:iText.Kernel.Log.Counter.OnDocumentRead(System.Int64)">
            <summary>This method gets triggered if a document is read.</summary>
            <param name="size">the length of the document that was read</param>
        </member>
        <member name="M:iText.Kernel.Log.Counter.OnDocumentWritten(System.Int64)">
            <summary>This method gets triggered if a document is written.</summary>
            <param name="size">the length of the document that was written</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:iText.Kernel.Log.CounterFactory" -->
        <member name="F:iText.Kernel.Log.CounterFactory.instance">
            <summary>The singleton instance.</summary>
        </member>
        <member name="F:iText.Kernel.Log.CounterFactory.counter">
            <summary>The current counter implementation.</summary>
        </member>
        <member name="M:iText.Kernel.Log.CounterFactory.#ctor">
            <summary>The empty constructor.</summary>
        </member>
        <member name="M:iText.Kernel.Log.CounterFactory.GetInstance">
            <summary>Returns the singleton instance of the factory.</summary>
        </member>
        <member name="M:iText.Kernel.Log.CounterFactory.GetCounter(System.Type)">
            <summary>Returns a counter factory.</summary>
        </member>
        <member name="M:iText.Kernel.Log.CounterFactory.GetCounter">
            <summary>Getter for the counter.</summary>
        </member>
        <member name="M:iText.Kernel.Log.CounterFactory.SetCounter(iText.Kernel.Log.Counter)">
            <summary>Setter for the counter.</summary>
        </member>
        <member name="T:iText.Kernel.Log.DefaultCounter">
            <summary>Default implementation of the Counter interface that essentially doesn't do anything.</summary>
        </member>
        <member name="T:iText.Kernel.Log.NoOpCounter">
            <summary>Implementation of the Counter interface that doesn't do anything.</summary>
        </member>
        <member name="T:iText.Kernel.Log.SystemOutCounter">
            <summary>
            A
            <see cref="T:iText.Kernel.Log.Counter"/>
            implementation that outputs information about read and written documents to
            <see cref="P:System.Console.Out"/>
            </summary>
        </member>
        <member name="F:iText.Kernel.Log.SystemOutCounter.name">
            <summary>
            The name of the class for which the Counter was created
            (or iText if no name is available)
            </summary>
        </member>
        <member name="T:iText.Kernel.Numbering.AlphabetNumbering">
            <summary>This is a general class for alphabet numbering.</summary>
            <remarks>
            This is a general class for alphabet numbering.
            You can specify an alphabet and convert an integer into the corresponding
            alphabet number representation.
            E.g.: if the alphabet is English letters 'a' to 'z', then
            1 is represented as "a", ..., 26 is represented as "z",
            27 is represented as "aa" and so on.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Numbering.AlphabetNumbering.ToAlphabetNumber(System.Int32,System.Char[])">
            <summary>
            Translates a positive integer (not equal to zero)
            into an alphabet number using the letters from the specified alphabet.
            </summary>
            <param name="number">the number</param>
            <param name="alphabet">the array containing all possible letters from the alphabet</param>
            <returns>a translated number representation</returns>
        </member>
        <member name="T:iText.Kernel.Numbering.ArmenianNumbering">
            <summary>This class can produce String combinations representing an armenian numeral.</summary>
            <remarks>
            This class can produce String combinations representing an armenian numeral.
            See https://en.wikipedia.org/wiki/Armenian_numerals
            </remarks>
        </member>
        <member name="M:iText.Kernel.Numbering.ArmenianNumbering.ToArmenian(System.Int32)">
            <summary>Returns an armenian numeral representation of an integer.</summary>
            <param name="number">a number greater than zero to be converted to armenian notation</param>
        </member>
        <member name="T:iText.Kernel.Numbering.EnglishAlphabetNumbering">
            <summary>
            This class is responsible for converting integer numbers to their
            English alphabet letter representations.
            </summary>
        </member>
        <member name="M:iText.Kernel.Numbering.EnglishAlphabetNumbering.ToLatinAlphabetNumberLowerCase(System.Int32)">
            <summary>Converts the given number to its English alphabet lowercase string representation.</summary>
            <remarks>
            Converts the given number to its English alphabet lowercase string representation.
            E.g. 1 will be converted to "a", 2 to "b", ..., 27 to "aa", and so on.
            </remarks>
            <param name="number">the number to be converted</param>
        </member>
        <member name="M:iText.Kernel.Numbering.EnglishAlphabetNumbering.ToLatinAlphabetNumberUpperCase(System.Int32)">
            <summary>Converts the given number to its English alphabet lowercase string representation.</summary>
            <remarks>
            Converts the given number to its English alphabet lowercase string representation.
            E.g. 1 will be converted to "A", 2 to "B", ..., 27 to "AA", and so on.
            </remarks>
            <param name="number">the number to be converted</param>
        </member>
        <member name="M:iText.Kernel.Numbering.EnglishAlphabetNumbering.ToLatinAlphabetNumber(System.Int32,System.Boolean)">
            <summary>Converts the given number to its English alphabet string representation.</summary>
            <remarks>
            Converts the given number to its English alphabet string representation.
            E.g. for <code>upperCase</code> set to false,
            1 will be converted to "a", 2 to "b", ..., 27 to "aa", and so on.
            </remarks>
            <param name="number">the number to be converted</param>
            <param name="upperCase">whether to use uppercase or lowercase alphabet</param>
        </member>
        <member name="T:iText.Kernel.Numbering.GeorgianNumbering">
            <summary>This class can produce String combinations representing a georgian numeral.</summary>
            <remarks>
            This class can produce String combinations representing a georgian numeral.
            See https://en.wikipedia.org/wiki/Georgian_numerals
            </remarks>
        </member>
        <member name="M:iText.Kernel.Numbering.GeorgianNumbering.ToGeorgian(System.Int32)">
            <summary>Returns a georgian numeral representation of an integer.</summary>
            <param name="number">a number greater than zero to be converted to georgian notation</param>
        </member>
        <member name="T:iText.Kernel.Numbering.GreekAlphabetNumbering">
            <summary>
            This class is responsible for converting integer numbers to their
            Greek alphabet letter representations.
            </summary>
            <remarks>
            This class is responsible for converting integer numbers to their
            Greek alphabet letter representations.
            We are aware of the fact that the original Greek numbering is different.
            See http://www.cogsci.indiana.edu/farg/harry/lan/grknum.htm#ancient
            but this isn't implemented yet; the main reason being the fact that we
            need a font that has the obsolete Greek characters qoppa and sampi.
            So we use standard 24 letter Greek alphabet
            </remarks>
        </member>
        <member name="M:iText.Kernel.Numbering.GreekAlphabetNumbering.ToGreekAlphabetNumberLowerCase(System.Int32)">
            <summary>Converts the given number to its Greek alphabet lowercase string representation.</summary>
            <remarks>
            Converts the given number to its Greek alphabet lowercase string representation.
            E.g. 1 will be converted to "alpha", 2 to "beta", and so on.
            </remarks>
            <param name="number">the number to be converted</param>
        </member>
        <member name="M:iText.Kernel.Numbering.GreekAlphabetNumbering.ToGreekAlphabetNumberUpperCase(System.Int32)">
            <summary>Converts the given number to its Greek alphabet lowercase string representation.</summary>
            <remarks>
            Converts the given number to its Greek alphabet lowercase string representation.
            E.g. 1 will be converted to "A", 2 to "B", and so on.
            </remarks>
            <param name="number">the number to be converted</param>
        </member>
        <member name="M:iText.Kernel.Numbering.GreekAlphabetNumbering.ToGreekAlphabetNumber(System.Int32,System.Boolean)">
            <summary>Converts the given number to its Greek alphabet string representation.</summary>
            <remarks>
            Converts the given number to its Greek alphabet string representation.
            E.g. for <code>upperCase</code> set to false,
            1 will be converted to "alpha", 2 to "beta", and so on.
            </remarks>
            <param name="number">the number to be converted</param>
            <param name="upperCase">whether to use uppercase or lowercase alphabet</param>
        </member>
        <member name="M:iText.Kernel.Numbering.GreekAlphabetNumbering.ToGreekAlphabetNumber(System.Int32,System.Boolean,System.Boolean)">
            <summary>Converts the given number to its Greek alphabet string representation.</summary>
            <remarks>
            Converts the given number to its Greek alphabet string representation.
            E.g. for <code>upperCase</code> set to false,
            1 will be converted to "alpha", 2 to "beta", and so on.
            </remarks>
            <param name="number">the number to be converted</param>
            <param name="upperCase">whether to use uppercase or lowercase alphabet</param>
            <param name="symbolFont">if <code>true</code>, then the string representation will be returned ready to write it in Symbol font
                </param>
        </member>
        <member name="M:iText.Kernel.Numbering.GreekAlphabetNumbering.GetSymbolFontChar(System.Char)">
            <summary>Converts a given greek unicode character code into the code of the corresponding char Symbol font.
                </summary>
            <param name="unicodeChar">original unicode char</param>
            <returns>the corresponding symbol code in Symbol standard font</returns>
        </member>
        <member name="T:iText.Kernel.Numbering.RomanNumbering">
            <summary>This class can produce String combinations representing a roman number.</summary>
            <remarks>
            This class can produce String combinations representing a roman number.
            The first roman numbers are: I, II, III, IV, V, VI, VII, VIII, IX, X
            See http://en.wikipedia.org/wiki/Roman_numerals
            </remarks>
        </member>
        <member name="F:iText.Kernel.Numbering.RomanNumbering.ROMAN_DIGITS">
            <summary>Array with Roman digits.</summary>
        </member>
        <member name="M:iText.Kernel.Numbering.RomanNumbering.ToRomanLowerCase(System.Int32)">
            <summary>Returns a lower case roman representation of an integer.</summary>
            <param name="number">a number to be converted to roman notation.</param>
        </member>
        <member name="M:iText.Kernel.Numbering.RomanNumbering.ToRomanUpperCase(System.Int32)">
            <summary>Returns an upper case roman representation of an integer.</summary>
            <param name="number">a number to be converted to roman notation.</param>
        </member>
        <member name="M:iText.Kernel.Numbering.RomanNumbering.ToRoman(System.Int32,System.Boolean)">
            <summary>Returns a roman representation of an integer.</summary>
            <param name="number">a number to be converted to roman notation.</param>
            <param name="upperCase">
            <code>true</code> for upper case representation,
            <code>false</code> for lower case one.
            </param>
        </member>
        <member name="M:iText.Kernel.Numbering.RomanNumbering.Convert(System.Int32)">
            <summary>Returns a roman representation of an integer.</summary>
            <param name="index">the original number</param>
            <returns>the roman number representation (lower case)</returns>
        </member>
        <member name="T:iText.Kernel.Numbering.RomanNumbering.RomanDigit">
            <summary>Helper class for Roman Digits</summary>
        </member>
        <member name="F:iText.Kernel.Numbering.RomanNumbering.RomanDigit.digit">
            <summary>part of a roman number</summary>
        </member>
        <member name="F:iText.Kernel.Numbering.RomanNumbering.RomanDigit.value">
            <summary>value of the roman digit</summary>
        </member>
        <member name="F:iText.Kernel.Numbering.RomanNumbering.RomanDigit.pre">
            <summary>can the digit be used as a prefix</summary>
        </member>
        <member name="M:iText.Kernel.Numbering.RomanNumbering.RomanDigit.#ctor(System.Char,System.Int32,System.Boolean)">
            <summary>Constructs a roman digit</summary>
            <param name="digit">the roman digit</param>
            <param name="value">the value</param>
            <param name="pre">can it be used as a prefix</param>
        </member>
        <member name="T:iText.Kernel.Pdf.Action.PdfAction">
            <summary>A wrapper for action dictionaries (ISO 32000-1 section 12.6).</summary>
            <remarks>
            A wrapper for action dictionaries (ISO 32000-1 section 12.6).
            An action dictionary defines the characteristics and behaviour of an action.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Action.PdfAction.SUBMIT_EXCLUDE">
            <summary>A possible submit value</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Action.PdfAction.SUBMIT_INCLUDE_NO_VALUE_FIELDS">
            <summary>A possible submit value</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Action.PdfAction.SUBMIT_HTML_FORMAT">
            <summary>A possible submit value</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Action.PdfAction.SUBMIT_HTML_GET">
            <summary>A possible submit value</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Action.PdfAction.SUBMIT_COORDINATES">
            <summary>A possible submit value</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Action.PdfAction.SUBMIT_XFDF">
            <summary>A possible submit value</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Action.PdfAction.SUBMIT_INCLUDE_APPEND_SAVES">
            <summary>A possible submit value</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Action.PdfAction.SUBMIT_INCLUDE_ANNOTATIONS">
            <summary>A possible submit value</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Action.PdfAction.SUBMIT_PDF">
            <summary>A possible submit value</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Action.PdfAction.SUBMIT_CANONICAL_FORMAT">
            <summary>A possible submit value</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Action.PdfAction.SUBMIT_EXCL_NON_USER_ANNOTS">
            <summary>A possible submit value</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Action.PdfAction.SUBMIT_EXCL_F_KEY">
            <summary>A possible submit value</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Action.PdfAction.SUBMIT_EMBED_FORM">
            <summary>A possible submit value</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Action.PdfAction.RESET_EXCLUDE">
            <summary>A possible submit value</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.#ctor">
            <summary>Constructs an empty action that can be further modified.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.#ctor(iText.Kernel.Pdf.PdfDictionary)">
            <summary>
            Constructs a
            <see cref="T:iText.Kernel.Pdf.Action.PdfAction"/>
            instance with a given dictionary. It can be used for handy
            property reading in reading mode or modifying in stamping mode.
            </summary>
            <param name="pdfObject">the dictionary to construct the wrapper around</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.CreateGoTo(iText.Kernel.Pdf.Navigation.PdfDestination)">
            <summary>Creates a GoTo action (section 12.6.4.2 of ISO 32000-1) via a given destination.</summary>
            <param name="destination">the desired destination of the action</param>
            <returns>created action</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.CreateGoTo(System.String)">
            <summary>
            Creates a GoTo action (section 12.6.4.2 of ISO 32000-1) via a given
            <see cref="T:iText.Kernel.Pdf.Navigation.PdfStringDestination"/>
            name.
            </summary>
            <param name="destination">
            
            <see cref="T:iText.Kernel.Pdf.Navigation.PdfStringDestination"/>
            name
            </param>
            <returns>created action</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.CreateGoToR(iText.Kernel.Pdf.Filespec.PdfFileSpec,iText.Kernel.Pdf.Navigation.PdfDestination,System.Boolean)">
            <summary>Creates a GoToR action, or remote action (section 12.6.4.3 of ISO 32000-1).</summary>
            <param name="fileSpec">the file in which the destination shall be located</param>
            <param name="destination">the destination in the remote document to jump to</param>
            <param name="newWindow">a flag specifying whether to open the destination document in a new window</param>
            <returns>created action</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.CreateGoToR(iText.Kernel.Pdf.Filespec.PdfFileSpec,iText.Kernel.Pdf.Navigation.PdfDestination)">
            <summary>Creates a GoToR action, or remote action (section 12.6.4.3 of ISO 32000-1).</summary>
            <param name="fileSpec">the file in which the destination shall be located</param>
            <param name="destination">the destination in the remote document to jump to</param>
            <returns>created action</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.CreateGoToR(System.String,System.Int32)">
            <summary>Creates a GoToR action, or remote action (section 12.6.4.3 of ISO 32000-1).</summary>
            <param name="filename">the remote destination file to jump to</param>
            <param name="pageNum">the remote destination document page to jump to</param>
            <returns>created action</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.CreateGoToR(System.String,System.Int32,System.Boolean)">
            <summary>Creates a GoToR action, or remote action (section 12.6.4.3 of ISO 32000-1).</summary>
            <param name="filename">the remote destination file to jump to</param>
            <param name="pageNum">the remote destination document page to jump to</param>
            <param name="newWindow">a flag specifying whether to open the destination document in a new window</param>
            <returns>created action</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.CreateGoToR(System.String,System.String,System.Boolean)">
            <summary>Creates a GoToR action, or remote action (section 12.6.4.3 of ISO 32000-1).</summary>
            <param name="filename">the remote destination file to jump to</param>
            <param name="destination">the string destination in the remote document to jump to</param>
            <param name="newWindow">a flag specifying whether to open the destination document in a new window</param>
            <returns>created action</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.CreateGoToR(System.String,System.String)">
            <summary>Creates a GoToR action, or remote action (section 12.6.4.3 of ISO 32000-1).</summary>
            <param name="filename">the remote destination file to jump to</param>
            <param name="destination">the string destination in the remote document to jump to</param>
            <returns>created action</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.CreateGoToE(iText.Kernel.Pdf.Navigation.PdfDestination,System.Boolean,iText.Kernel.Pdf.Action.PdfTargetDictionary)">
            <summary>Creates a GoToE action, or embedded file action (section 12.6.4.4 of ISO 32000-1).</summary>
            <param name="destination">the destination in the target to jump to</param>
            <param name="newWindow">
            if true, the destination document should be opened in a new window;
            if false, the destination document should replace the current document in the same window
            </param>
            <param name="targetDictionary">
            A target dictionary specifying path information to the target document.
            Each target dictionary specifies one element in the full path to the target and
            may have nested target dictionaries specifying additional elements
            </param>
            <returns>created action</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.CreateGoToE(iText.Kernel.Pdf.Filespec.PdfFileSpec,iText.Kernel.Pdf.Navigation.PdfDestination,System.Boolean,iText.Kernel.Pdf.Action.PdfTargetDictionary)">
            <summary>Creates a GoToE action, or embedded file action (section 12.6.4.4 of ISO 32000-1).</summary>
            <param name="fileSpec">The root document of the target relative to the root document of the source</param>
            <param name="destination">the destination in the target to jump to</param>
            <param name="newWindow">
            if true, the destination document should be opened in a new window;
            if false, the destination document should replace the current document in the same window
            </param>
            <param name="targetDictionary">
            A target dictionary specifying path information to the target document.
            Each target dictionary specifies one element in the full path to the target and
            may have nested target dictionaries specifying additional elements
            </param>
            <returns>created action</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.CreateLaunch(iText.Kernel.Pdf.Filespec.PdfFileSpec,System.Boolean)">
            <summary>Creates a Launch action (section 12.6.4.5 of ISO 32000-1).</summary>
            <param name="fileSpec">the application that shall be launched or the document that shall beopened or printed
                </param>
            <param name="newWindow">a flag specifying whether to open the destination document in a new window</param>
            <returns>created action</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.CreateLaunch(iText.Kernel.Pdf.Filespec.PdfFileSpec)">
            <summary>Creates a Launch action (section 12.6.4.5 of ISO 32000-1).</summary>
            <param name="fileSpec">the application that shall be launched or the document that shall beopened or printed
                </param>
            <returns>created action</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.CreateLaunch(iText.Kernel.Pdf.Filespec.PdfFileSpec,iText.Kernel.Pdf.Action.PdfWin,System.Boolean)">
            <summary>Creates a Launch action (section 12.6.4.5 of ISO 32000-1).</summary>
            <param name="fileSpec">the application that shall be launched or the document that shall beopened or printed
                </param>
            <param name="win">A dictionary containing Windows-specific launch parameters</param>
            <param name="newWindow">a flag specifying whether to open the destination document in a new window</param>
            <returns>created action</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.CreateThread(iText.Kernel.Pdf.Filespec.PdfFileSpec,iText.Kernel.Pdf.PdfObject,iText.Kernel.Pdf.PdfObject)">
            <summary>Creates a Thread action (section 12.6.4.6 of ISO 32000-1).</summary>
            <remarks>
            Creates a Thread action (section 12.6.4.6 of ISO 32000-1).
            A thread action jumps to a specified bead on an article thread (see 12.4.3, “Articles”),
            in either the current document or a different one. Table 205 shows the action dictionary
            entries specific to this type of action.
            </remarks>
            <param name="fileSpec">the file containing the thread. If this entry is absent, the thread is in the current file
                </param>
            <param name="destinationThread">the destination thread</param>
            <param name="bead">the bead in the destination thread</param>
            <returns>created action</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.CreateThread(iText.Kernel.Pdf.Filespec.PdfFileSpec)">
            <summary>Creates a Thread action (section 12.6.4.6 of ISO 32000-1).</summary>
            <remarks>
            Creates a Thread action (section 12.6.4.6 of ISO 32000-1).
            A thread action jumps to a specified bead on an article thread (see 12.4.3, “Articles”),
            in either the current document or a different one. Table 205 shows the action dictionary
            entries specific to this type of action.
            </remarks>
            <param name="fileSpec">the file containing the thread. If this entry is absent, the thread is in the current file
                </param>
            <returns>created action</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.CreateURI(System.String)">
            <summary>Creates a URI action (section 12.6.4.7 of ISO 32000-1).</summary>
            <param name="uri">the uniform resource identifier to resolve</param>
            <returns>created action</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.CreateURI(System.String,System.Boolean)">
            <summary>Creates a URI action (section 12.6.4.7 of ISO 32000-1).</summary>
            <param name="uri">the uniform resource identifier to resolve</param>
            <param name="isMap">a flag specifying whether to track the mouse position when the URI is resolved</param>
            <returns>created action</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.CreateSound(iText.Kernel.Pdf.PdfStream)">
            <summary>Creates a Sound action (section 12.6.4.8 of ISO 32000-1).</summary>
            <param name="sound">a sound object defining the sound that shall be played (see section 13.3 of ISO 32000-1)
                </param>
            <returns>created action</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.CreateSound(iText.Kernel.Pdf.PdfStream,System.Single,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Creates a Sound action (section 12.6.4.8 of ISO 32000-1).</summary>
            <param name="sound">a sound object defining the sound that shall be played (see section 13.3 of ISO 32000-1)
                </param>
            <param name="volume">the volume at which to play the sound, in the range -1.0 to 1.0. Default value: 1.0</param>
            <param name="synchronous">
            a flag specifying whether to play the sound synchronously or asynchronously.
            If this flag is <code>true</code>, the conforming reader retains control, allowing no further user
            interaction other than canceling the sound, until the sound has been completely played.
            Default value: <code>false</code>
            </param>
            <param name="repeat">
            a flag specifying whether to repeat the sound indefinitely
            If this entry is present, the Synchronous entry shall be ignored. Default value: <code>false</code>
            </param>
            <param name="mix">a flag specifying whether to mix this sound with any other sound already playing</param>
            <returns>created action</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.CreateMovie(iText.Kernel.Pdf.Annot.PdfAnnotation,System.String,iText.Kernel.Pdf.PdfName)">
            <summary>Creates a Movie annotation (section 12.6.4.9 of ISO 32000-1).</summary>
            <param name="annotation">a movie annotation identifying the movie that shall be played</param>
            <param name="title">the title of a movie annotation identifying the movie that shall be played</param>
            <param name="operation">
            the operation that shall be performed on the movie. Shall be one of the following:
            <see cref="F:iText.Kernel.Pdf.PdfName.Play"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.Stop"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.Pause"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.Resume"/>
            </param>
            <returns>created annotation</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.CreateHide(iText.Kernel.Pdf.Annot.PdfAnnotation,System.Boolean)">
            <summary>Creates a Hide action (section 12.6.4.10 of ISO 32000-1).</summary>
            <param name="annotation">the annotation to be hidden or shown</param>
            <param name="hidden">a flag indicating whether to hide the annotation (<code>true</code>) or show it (<code>false</code>)
                </param>
            <returns>created action</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.CreateHide(iText.Kernel.Pdf.Annot.PdfAnnotation[],System.Boolean)">
            <summary>Creates a Hide action (section 12.6.4.10 of ISO 32000-1).</summary>
            <param name="annotations">the annotations to be hidden or shown</param>
            <param name="hidden">a flag indicating whether to hide the annotation (<code>true</code>) or show it (<code>false</code>)
                </param>
            <returns>created action</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.CreateHide(System.String,System.Boolean)">
            <summary>Creates a Hide action (section 12.6.4.10 of ISO 32000-1).</summary>
            <param name="text">
            a text string giving the fully qualified field name of an interactive form field whose
            associated widget annotation or annotations are to be affected
            </param>
            <param name="hidden">a flag indicating whether to hide the annotation (<code>true</code>) or show it (<code>false</code>)
                </param>
            <returns>created action</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.CreateHide(System.String[],System.Boolean)">
            <summary>Creates a Hide action (section 12.6.4.10 of ISO 32000-1).</summary>
            <param name="text">
            a text string array giving the fully qualified field names of interactive form fields whose
            associated widget annotation or annotations are to be affected
            </param>
            <param name="hidden">a flag indicating whether to hide the annotation (<code>true</code>) or show it (<code>false</code>)
                </param>
            <returns>created action</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.CreateNamed(iText.Kernel.Pdf.PdfName)">
            <summary>Creates a Named action (section 12.6.4.11 of ISO 32000-1).</summary>
            <param name="namedAction">
            the name of the action that shall be performed. Shall be one of the following:
            <see cref="F:iText.Kernel.Pdf.PdfName.NextPage"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.PrevPage"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.FirstPage"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.LastPage"/>
            </param>
            <returns>created action</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.CreateSetOcgState(System.Collections.Generic.IList{iText.Kernel.Pdf.Action.PdfActionOcgState})">
            <summary>Creates a Set-OCG-State action (section 12.6.4.12 of ISO 32000-1).</summary>
            <param name="states">
            a list of
            <see cref="T:iText.Kernel.Pdf.Action.PdfActionOcgState"/>
            state descriptions
            </param>
            <returns>created action</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.CreateSetOcgState(System.Collections.Generic.IList{iText.Kernel.Pdf.Action.PdfActionOcgState},System.Boolean)">
            <summary>Creates a Set-OCG-State action (section 12.6.4.12 of ISO 32000-1).</summary>
            <param name="states">
            states a list of
            <see cref="T:iText.Kernel.Pdf.Action.PdfActionOcgState"/>
            state descriptions
            </param>
            <param name="preserveRb">
            If true, indicates that radio-button state relationships between optional content groups
            should be preserved when the states are applied
            </param>
            <returns>created action</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.CreateRendition(System.String,iText.Kernel.Pdf.Filespec.PdfFileSpec,System.String,iText.Kernel.Pdf.Annot.PdfAnnotation)">
            <summary>Creates a Rendition action (section 12.6.4.13 of ISO 32000-1).</summary>
            <param name="file">the name of the media clip, for use in the user interface.</param>
            <param name="fileSpec">a full file specification or form XObject that specifies the actual media data</param>
            <param name="mimeType">an ASCII string identifying the type of data</param>
            <param name="screenAnnotation">a screen annotation</param>
            <returns>created action</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.CreateJavaScript(System.String)">
            <summary>Creates a JavaScript action (section 12.6.4.16 of ISO 32000-1).</summary>
            <param name="javaScript">a text string containing the JavaScript script to be executed.</param>
            <returns>created action</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.CreateSubmitForm(System.String,System.Object[],System.Int32)">
            <summary>Creates a Submit-Form Action (section 12.7.5.2 of ISO 32000-1).</summary>
            <param name="file">a uniform resource locator, as described in 7.11.5, "URL Specifications"</param>
            <param name="names">
            an array identifying which fields to include in the submission or which to exclude,
            depending on the setting of the Include/Exclude flag in the Flags entry.
            This is an optional parameter and can be <code>null</code>
            </param>
            <param name="flags">
            a set of flags specifying various characteristics of the action (see Table 237 of ISO 32000-1).
            Default value to be passed: 0.
            </param>
            <returns>created action</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.CreateResetForm(System.Object[],System.Int32)">
            <summary>Creates a Reset-Form Action (section 12.7.5.3 of ISO 32000-1).</summary>
            <param name="names">
            an array identifying which fields to reset or which to exclude from resetting,
            depending on the setting of the Include/Exclude flag in the Flags entry (see Table 239 of ISO 32000-1).
            </param>
            <param name="flags">
            a set of flags specifying various characteristics of the action (see Table 239 of ISO 32000-1).
            Default value to be passed: 0.
            </param>
            <returns>created action</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.SetAdditionalAction(iText.Kernel.Pdf.PdfObjectWrapper{iText.Kernel.Pdf.PdfDictionary},iText.Kernel.Pdf.PdfName,iText.Kernel.Pdf.Action.PdfAction)">
            <summary>
            Adds an additional action to the provided
            <see cref="T:iText.Kernel.Pdf.PdfObjectWrapper`1"/>
            &lt;
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            &gt; wrapper.
            </summary>
            <param name="wrapper">the wrapper to add an additional action to</param>
            <param name="key">
            a
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            specifying the name of an additional action
            </param>
            <param name="action">
            the
            <see cref="T:iText.Kernel.Pdf.Action.PdfAction"/>
            to add as an additional action
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.Next(iText.Kernel.Pdf.Action.PdfAction)">
            <summary>Adds a chained action.</summary>
            <param name="nextAction">the next action or sequence of actions that shall be performed after the current action
                </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.Put(iText.Kernel.Pdf.PdfName,iText.Kernel.Pdf.PdfObject)">
            <summary>
            Inserts the value into the underlying object of this
            <see cref="T:iText.Kernel.Pdf.Action.PdfAction"/>
            and associates it with the specified key.
            If the key is already present in this
            <see cref="T:iText.Kernel.Pdf.Action.PdfAction"/>
            , this method will override the old value with the specified one.
            </summary>
            <param name="key">key to insert or to override</param>
            <param name="value">the value to associate with the specified key</param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Action.PdfAction"/>
            instance
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.Flush">
            <summary>
            To manually flush a
            <c>PdfObject</c>
            behind this wrapper, you have to ensure
            that this object is added to the document, i.e. it has an indirect reference.
            Basically this means that before flushing you need to explicitly call
            <see cref="M:iText.Kernel.Pdf.PdfObjectWrapper`1.MakeIndirect(iText.Kernel.Pdf.PdfDocument)"/>
            .
            For example: wrapperInstance.makeIndirect(document).flush();
            Note that not every wrapper require this, only those that have such warning in documentation.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfAction.IsWrappedObjectMustBeIndirect">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Action.PdfActionOcgState">
            <summary>This is a helper class for optional content states use in Set-OCG-State actions.</summary>
            <remarks>
            This is a helper class for optional content states use in Set-OCG-State actions.
            See
            <see cref="!:PdfAction.CreateSetOcgState(System.Collections.Generic.IList&lt;E&gt;)"/>
            .
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Action.PdfActionOcgState.state">
            <summary>
            Can be:
            <see cref="F:iText.Kernel.Pdf.PdfName.OFF"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.ON"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.Toggle"/>
            </summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Action.PdfActionOcgState.ocgs">
            <summary>Optional content group dictionaries</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfActionOcgState.#ctor(iText.Kernel.Pdf.PdfName,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfDictionary})">
            <summary>Constructs an optional content state object.</summary>
            <param name="state">
            a
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            describing the state. Shall be one of the following:
            <see cref="F:iText.Kernel.Pdf.PdfName.OFF"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.ON"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.Toggle"/>
            </param>
            <param name="ocgs">a list of the OCG dictionaries</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfActionOcgState.GetState">
            <summary>Gets the state the optional content groups should be switched to</summary>
            <returns>
            the state, one of the following:
            <see cref="F:iText.Kernel.Pdf.PdfName.OFF"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.ON"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.Toggle"/>
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfActionOcgState.GetOcgs">
            <summary>Gets a list of optional content groups that shall have the state changed</summary>
            <returns>the list of optional content groups</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfActionOcgState.GetObjectList">
            <summary>
            Gets a list of
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            that is describing this particular optional content group states.
            </summary>
            <returns>
            a list of
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            for construction of a
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            </returns>
        </member>
        <member name="T:iText.Kernel.Pdf.Action.PdfMediaClipData">
            <summary>This class is a wrapper of media clip data dictionary that defines the data for a media object that can be played.
                </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfMediaClipData.#ctor(iText.Kernel.Pdf.PdfDictionary)">
            <summary>
            Constructs a new
            <see cref="T:iText.Kernel.Pdf.Action.PdfMediaClipData"/>
            wrapper using an existing dictionary.
            </summary>
            <param name="pdfObject">the dictionary to construct the wrapper from</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfMediaClipData.#ctor(System.String,iText.Kernel.Pdf.Filespec.PdfFileSpec,System.String)">
            <summary>
            Constructs a new
            <see cref="T:iText.Kernel.Pdf.Action.PdfMediaClipData"/>
            wrapper around a newly created dictionary.
            </summary>
            <param name="file">the name of the file to create a media clip for</param>
            <param name="fs">a file specification that specifies the actual media data</param>
            <param name="mimeType">an ASCII string identifying the type of data</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfMediaClipData.Flush">
            <summary>
            To manually flush a
            <c>PdfObject</c>
            behind this wrapper, you have to ensure
            that this object is added to the document, i.e. it has an indirect reference.
            Basically this means that before flushing you need to explicitly call
            <see cref="M:iText.Kernel.Pdf.PdfObjectWrapper`1.MakeIndirect(iText.Kernel.Pdf.PdfDocument)"/>
            .
            For example: wrapperInstance.makeIndirect(document).flush();
            Note that not every wrapper require this, only those that have such warning in documentation.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfMediaClipData.IsWrappedObjectMustBeIndirect">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Action.PdfRendition">
            <summary>This a wrapper around a rendition dictionary.</summary>
            <remarks>This a wrapper around a rendition dictionary. See ISO 32000-1 sections 13.2.3.2, 13.2.3.3.</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfRendition.#ctor(iText.Kernel.Pdf.PdfDictionary)">
            <summary>
            Creates a new wrapper around an existing
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            </summary>
            <param name="pdfObject">a rendition object to create a wrapper for</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfRendition.#ctor(System.String,iText.Kernel.Pdf.Filespec.PdfFileSpec,System.String)">
            <summary>Creates a new wrapper around a newly created media rendition dictionary object.</summary>
            <param name="file">a text string specifying the name of the file to display</param>
            <param name="fs">a file specification that specifies the actual media data</param>
            <param name="mimeType">an ASCII string identifying the type of data</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfRendition.Flush">
            <summary>
            To manually flush a
            <c>PdfObject</c>
            behind this wrapper, you have to ensure
            that this object is added to the document, i.e. it has an indirect reference.
            Basically this means that before flushing you need to explicitly call
            <see cref="M:iText.Kernel.Pdf.PdfObjectWrapper`1.MakeIndirect(iText.Kernel.Pdf.PdfDocument)"/>
            .
            For example: wrapperInstance.makeIndirect(document).flush();
            Note that not every wrapper require this, only those that have such warning in documentation.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfRendition.IsWrappedObjectMustBeIndirect">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Action.PdfTargetDictionary">
            <summary>
            A target dictionary locates the target in relation to the source,
            in much the same way that a relative path describes the physical
            relationship between two files in a file system.
            </summary>
            <remarks>
            A target dictionary locates the target in relation to the source,
            in much the same way that a relative path describes the physical
            relationship between two files in a file system. Target dictionaries may be
            nested recursively to specify one or more intermediate targets before reaching the final one.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfTargetDictionary.#ctor(iText.Kernel.Pdf.PdfDictionary)">
            <summary>
            Creates a new
            <see cref="T:iText.Kernel.Pdf.Action.PdfTargetDictionary"/>
            object by the underlying dictionary.
            </summary>
            <param name="pdfObject">the underlying dictionary object</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfTargetDictionary.#ctor(iText.Kernel.Pdf.PdfName)">
            <summary>
            Creates a new
            <see cref="T:iText.Kernel.Pdf.Action.PdfTargetDictionary"/>
            object given its type. The type must be either
            <see cref="F:iText.Kernel.Pdf.PdfName.P"/>
            , or
            <see cref="F:iText.Kernel.Pdf.PdfName.C"/>
            . If it is
            <see cref="F:iText.Kernel.Pdf.PdfName.C"/>
            , additional entries must be specified
            according to the spec.
            </summary>
            <param name="r">the relationship between the current document and the target</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfTargetDictionary.#ctor(iText.Kernel.Pdf.PdfName,iText.Kernel.Pdf.PdfString,iText.Kernel.Pdf.PdfObject,iText.Kernel.Pdf.PdfObject,iText.Kernel.Pdf.Action.PdfTargetDictionary)">
            <summary>
            Creates a new
            <see cref="T:iText.Kernel.Pdf.Action.PdfTargetDictionary"/>
            object.
            </summary>
            <param name="r">the relationship between the current document and the target</param>
            <param name="n">the name of the file in the EmbeddedFiles name tree</param>
            <param name="p">
            if the value is an integer, it specifies the page number (zero-based) in the current
            document containing the file attachment annotation. If the value is a string,
            it specifies a named destination in the current document that provides the page
            number of the file attachment annotation
            </param>
            <param name="a">
            If the value is an integer, it specifies the index (zero-based) of the annotation in the
            Annots array of the page specified by P. If the value is a text string,
            it specifies the value of NM in the annotation dictionary
            </param>
            <param name="t">
            A target dictionary specifying additional path information to the target document.
            If this entry is absent, the current document is the target file containing the destination
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfTargetDictionary.CreateParentTarget">
            <summary>Creates a new target object pointing to the parent of the current document.</summary>
            <returns>
            created
            <see cref="T:iText.Kernel.Pdf.Action.PdfTargetDictionary"/>
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfTargetDictionary.CreateChildTarget(System.String)">
            <summary>Creates a new target object pointing to a file in the EmbeddedFiles name tree.</summary>
            <param name="embeddedFileName">the name of the file in the EmbeddedFiles name tree</param>
            <returns>created object</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfTargetDictionary.CreateChildTarget(System.String,System.String)">
            <summary>Creates a new target object pointing to a file attachment annotation.</summary>
            <param name="namedDestination">
            a named destination in the current document that
            provides the page number of the file attachment annotation
            </param>
            <param name="annotationIdentifier">
            a unique annotation identifier (
            <see cref="F:iText.Kernel.Pdf.PdfName.NM"/>
            entry) of the annotation
            </param>
            <returns>created object</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfTargetDictionary.CreateChildTarget(System.Int32,System.Int32)">
            <summary>Creates a new target object pointing to a file attachment annotation.</summary>
            <param name="pageNumber">the number of the page in the current document, one-based</param>
            <param name="annotationIndex">the index of the annotation in the Annots entry of the page, zero-based</param>
            <returns>created object</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfTargetDictionary.SetName(System.String)">
            <summary>
            Sets the name of the file in the EmbeddedFiles name tree for the child target located
            in the EmbeddedFiles.
            </summary>
            <param name="name">the name of the file</param>
            <returns>this object wrapper</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfTargetDictionary.GetName">
            <summary>
            Gets name of the file in the EmbeddedFiles name tree for the child target located
            in the EmbeddedFiles.
            </summary>
            <returns>the name of the child file for this target</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfTargetDictionary.SetPage(System.Int32)">
            <summary>
            Sets the page number in the current document containing the file attachment annotation for the
            child target associates with a file attachment annotation.
            </summary>
            <param name="pageNumber">
            the page number (one-based) in the current document containing
            the file attachment annotation
            </param>
            <returns>this object wrapper</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfTargetDictionary.SetPage(System.String)">
            <summary>
            Sets a named destination in the current document that provides the page number of the file
            attachment annotation for the child target associated with a file attachment annotation.
            </summary>
            <param name="namedDestination">
            a named destination in the current document that provides the page
            number of the file attachment annotation
            </param>
            <returns>this object wrapper</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfTargetDictionary.GetPage">
            <summary>Get the contents of the /P entry of this target object.</summary>
            <remarks>
            Get the contents of the /P entry of this target object.
            If the value is an integer, it specifies the page number (zero-based)
            in the current document containing the file attachment annotation.
            If the value is a string, it specifies a named destination in the current
            document that provides the page number of the file attachment annotation.
            </remarks>
            <returns>the /P entry of target object</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfTargetDictionary.SetAnnotation(System.Int32)">
            <summary>
            Sets the index of the annotation in Annots array of the page specified by /P entry
            for the child target associated with a file attachment annotation.
            </summary>
            <param name="annotationIndex">the index (zero-based) of the annotation in the Annots array</param>
            <returns>this object wrapper</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfTargetDictionary.SetAnnotation(System.String)">
            <summary>
            Sets the text value, which uniquely identifies an annotation (/NM entry) in an annotation dictionary
            for the child target associated with a file attachment annotation.
            </summary>
            <param name="annotationName">specifies the value of NM in the annotation dictionary of the target annotation
                </param>
            <returns>this object wrapper</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfTargetDictionary.GetAnnotation">
            <summary>Gets the object in the /A entry of the underlying object.</summary>
            <remarks>
            Gets the object in the /A entry of the underlying object. If the value is an integer,
            it specifies the index (zero-based) of the annotation in the Annots array of the page specified by P.
            If the value is a text string, it specifies the value of NM in the annotation dictionary.
            </remarks>
            <returns>the /A entry in the target object</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfTargetDictionary.SetTarget(iText.Kernel.Pdf.Action.PdfTargetDictionary)">
            <summary>Sets a target dictionary specifying additional path information to the target document.</summary>
            <remarks>
            Sets a target dictionary specifying additional path information to the target document.
            If this entry is absent, the current document is the target file containing the destination.
            </remarks>
            <param name="target">the additional path target dictionary</param>
            <returns>this object wrapper</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfTargetDictionary.GetTarget">
            <summary>Get a target dictionary specifying additional path information to the target document.</summary>
            <remarks>
            Get a target dictionary specifying additional path information to the target document.
            If the current target object is the final node in the target path, <code>null</code> is returned.
            </remarks>
            <returns>a target dictionary specifying additional path information to the target document</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfTargetDictionary.Put(iText.Kernel.Pdf.PdfName,iText.Kernel.Pdf.PdfObject)">
            <summary>
            This is a convenient method to put key-value pairs to the underlying
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            .
            </summary>
            <param name="key">
            the key, a
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            instance
            </param>
            <param name="value">the value</param>
            <returns>this object wrapper</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfTargetDictionary.IsWrappedObjectMustBeIndirect">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Action.PdfWin">
            <summary>This class is a wrapper around a Windows launch parameter dictionary.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfWin.#ctor(iText.Kernel.Pdf.PdfDictionary)">
            <summary>Creates a new wrapper around an existing Windows launch parameter dictionary.</summary>
            <param name="pdfObject">the dictionary to create a wrapper for</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfWin.#ctor(iText.Kernel.Pdf.PdfString)">
            <summary>Creates a new wrapper around a newly created Windows launch parameter dictionary.</summary>
            <param name="f">
            the file name of the application that shall be launched or the document that shall be opened or printed,
            in standard Windows pathname format. If the name string includes a backslash character (\),
            the backslash shall itself be preceded by a backslash.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfWin.#ctor(iText.Kernel.Pdf.PdfString,iText.Kernel.Pdf.PdfString,iText.Kernel.Pdf.PdfString,iText.Kernel.Pdf.PdfString)">
            <summary>Creates a new wrapper around a newly created Windows launch parameter dictionary.</summary>
            <param name="f">
            the file name of the application that shall be launched or the document that shall be opened or printed,
            in standard Windows pathname format. If the name string includes a backslash character (\),
            the backslash shall itself be preceded by a backslash
            </param>
            <param name="d">a bye string specifying the default directory in standard DOS syntax</param>
            <param name="o">
            an ASCII string specifying the operation to perform on the file. Shall be one of the following:
            "open", "print"
            </param>
            <param name="p">
            a parameter string that shall be passed to the application.
            This entry shall be omitted if a document is abound to be opened
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Action.PdfWin.IsWrappedObjectMustBeIndirect">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Annot.PdfAnnotation">
            <summary>This is a super class for the annotation dictionary wrappers.</summary>
            <remarks>
            This is a super class for the annotation dictionary wrappers. Derived classes represent
            different standard types of annotations. See ISO-320001 12.5.6, “Annotation Types.”
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Annot.PdfAnnotation.INVISIBLE">
            <summary>Annotation flag.</summary>
            <remarks>
            Annotation flag.
            See also
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetFlag(System.Int32)"/>
            and ISO-320001, table 165.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Annot.PdfAnnotation.HIDDEN">
            <summary>Annotation flag.</summary>
            <remarks>
            Annotation flag.
            See also
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetFlag(System.Int32)"/>
            and ISO-320001, table 165.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Annot.PdfAnnotation.PRINT">
            <summary>Annotation flag.</summary>
            <remarks>
            Annotation flag.
            See also
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetFlag(System.Int32)"/>
            and ISO-320001, table 165.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Annot.PdfAnnotation.NO_ZOOM">
            <summary>Annotation flag.</summary>
            <remarks>
            Annotation flag.
            See also
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetFlag(System.Int32)"/>
            and ISO-320001, table 165.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Annot.PdfAnnotation.NO_ROTATE">
            <summary>Annotation flag.</summary>
            <remarks>
            Annotation flag.
            See also
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetFlag(System.Int32)"/>
            and ISO-320001, table 165.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Annot.PdfAnnotation.NO_VIEW">
            <summary>Annotation flag.</summary>
            <remarks>
            Annotation flag.
            See also
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetFlag(System.Int32)"/>
            and ISO-320001, table 165.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Annot.PdfAnnotation.READ_ONLY">
            <summary>Annotation flag.</summary>
            <remarks>
            Annotation flag.
            See also
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetFlag(System.Int32)"/>
            and ISO-320001, table 165.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Annot.PdfAnnotation.LOCKED">
            <summary>Annotation flag.</summary>
            <remarks>
            Annotation flag.
            See also
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetFlag(System.Int32)"/>
            and ISO-320001, table 165.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Annot.PdfAnnotation.TOGGLE_NO_VIEW">
            <summary>Annotation flag.</summary>
            <remarks>
            Annotation flag.
            See also
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetFlag(System.Int32)"/>
            and ISO-320001, table 165.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Annot.PdfAnnotation.LOCKED_CONTENTS">
            <summary>Annotation flag.</summary>
            <remarks>
            Annotation flag.
            See also
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetFlag(System.Int32)"/>
            and ISO-320001, table 165.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Annot.PdfAnnotation.HIGHLIGHT_NONE">
            <summary>Widget annotation highlighting mode.</summary>
            <remarks>
            Widget annotation highlighting mode. See ISO-320001, Table 188 (H key).
            Also see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfWidgetAnnotation.SetHighlightMode(iText.Kernel.Pdf.PdfName)"/>
            .
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Annot.PdfAnnotation.HIGHLIGHT_INVERT">
            <summary>Widget annotation highlighting mode.</summary>
            <remarks>
            Widget annotation highlighting mode. See ISO-320001, Table 188 (H key).
            Also see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfWidgetAnnotation.SetHighlightMode(iText.Kernel.Pdf.PdfName)"/>
            .
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Annot.PdfAnnotation.HIGHLIGHT_OUTLINE">
            <summary>Widget annotation highlighting mode.</summary>
            <remarks>
            Widget annotation highlighting mode. See ISO-320001, Table 188 (H key).
            Also see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfWidgetAnnotation.SetHighlightMode(iText.Kernel.Pdf.PdfName)"/>
            .
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Annot.PdfAnnotation.HIGHLIGHT_PUSH">
            <summary>Widget annotation highlighting mode.</summary>
            <remarks>
            Widget annotation highlighting mode. See ISO-320001, Table 188 (H key).
            Also see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfWidgetAnnotation.SetHighlightMode(iText.Kernel.Pdf.PdfName)"/>
            .
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Annot.PdfAnnotation.HIGHLIGHT_TOGGLE">
            <summary>Widget annotation highlighting mode.</summary>
            <remarks>
            Widget annotation highlighting mode. See ISO-320001, Table 188 (H key).
            Also see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfWidgetAnnotation.SetHighlightMode(iText.Kernel.Pdf.PdfName)"/>
            .
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Annot.PdfAnnotation.STYLE_SOLID">
            <summary>Annotation border style.</summary>
            <remarks>
            Annotation border style. See ISO-320001, Table 166 (S key).
            Also see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetBorderStyle(iText.Kernel.Pdf.PdfName)"/>
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Annot.PdfAnnotation.STYLE_DASHED">
            <summary>Annotation border style.</summary>
            <remarks>
            Annotation border style. See ISO-320001, Table 166 (S key).
            Also see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetBorderStyle(iText.Kernel.Pdf.PdfName)"/>
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Annot.PdfAnnotation.STYLE_BEVELED">
            <summary>Annotation border style.</summary>
            <remarks>
            Annotation border style. See ISO-320001, Table 166 (S key).
            Also see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetBorderStyle(iText.Kernel.Pdf.PdfName)"/>
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Annot.PdfAnnotation.STYLE_INSET">
            <summary>Annotation border style.</summary>
            <remarks>
            Annotation border style. See ISO-320001, Table 166 (S key).
            Also see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetBorderStyle(iText.Kernel.Pdf.PdfName)"/>
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Annot.PdfAnnotation.STYLE_UNDERLINE">
            <summary>Annotation border style.</summary>
            <remarks>
            Annotation border style. See ISO-320001, Table 166 (S key).
            Also see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetBorderStyle(iText.Kernel.Pdf.PdfName)"/>
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Annot.PdfAnnotation.Marked">
            <summary>Annotation state.</summary>
            <remarks>
            Annotation state. See ISO-320001 12.5.6.3 "Annotation States" and Table 171 in particular.
            Also see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfTextAnnotation.SetState(iText.Kernel.Pdf.PdfString)"/>
            .
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Annot.PdfAnnotation.Unmarked">
            <summary>Annotation state.</summary>
            <remarks>
            Annotation state. See ISO-320001 12.5.6.3 "Annotation States" and Table 171 in particular.
            Also see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfTextAnnotation.SetState(iText.Kernel.Pdf.PdfString)"/>
            .
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Annot.PdfAnnotation.Accepted">
            <summary>Annotation state.</summary>
            <remarks>
            Annotation state. See ISO-320001 12.5.6.3 "Annotation States" and Table 171 in particular.
            Also see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfTextAnnotation.SetState(iText.Kernel.Pdf.PdfString)"/>
            .
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Annot.PdfAnnotation.Rejected">
            <summary>Annotation state.</summary>
            <remarks>
            Annotation state. See ISO-320001 12.5.6.3 "Annotation States" and Table 171 in particular.
            Also see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfTextAnnotation.SetState(iText.Kernel.Pdf.PdfString)"/>
            .
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Annot.PdfAnnotation.Canceled">
            <summary>Annotation state.</summary>
            <remarks>
            Annotation state. See ISO-320001 12.5.6.3 "Annotation States" and Table 171 in particular.
            Also see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfTextAnnotation.SetState(iText.Kernel.Pdf.PdfString)"/>
            .
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Annot.PdfAnnotation.Completed">
            <summary>Annotation state.</summary>
            <remarks>
            Annotation state. See ISO-320001 12.5.6.3 "Annotation States" and Table 171 in particular.
            Also see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfTextAnnotation.SetState(iText.Kernel.Pdf.PdfString)"/>
            .
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Annot.PdfAnnotation.None">
            <summary>Annotation state.</summary>
            <remarks>
            Annotation state. See ISO-320001 12.5.6.3 "Annotation States" and Table 171 in particular.
            Also see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfTextAnnotation.SetState(iText.Kernel.Pdf.PdfString)"/>
            .
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Annot.PdfAnnotation.MarkedModel">
            <summary>Annotation state model.</summary>
            <remarks>
            Annotation state model. See ISO-320001, Table 172 (StateModel key).
            Also see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfTextAnnotation.SetStateModel(iText.Kernel.Pdf.PdfString)"/>
            .
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Annot.PdfAnnotation.ReviewModel">
            <summary>Annotation state model.</summary>
            <remarks>
            Annotation state model. See ISO-320001, Table 172 (StateModel key).
            Also see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfTextAnnotation.SetStateModel(iText.Kernel.Pdf.PdfString)"/>
            .
            </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.MakeAnnotation(iText.Kernel.Pdf.PdfObject)">
            <summary>
            Factory method that creates the type specific
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            from the given
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            that represents annotation object. This method is useful for property reading in reading mode or
            modifying in stamping mode. See derived classes of this class to see possible specific annotation types
            created.
            </summary>
            <param name="pdfObject">
            a
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            that represents annotation in the document.
            </param>
            <returns>
            created
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.MakeAnnotation(iText.Kernel.Pdf.PdfObject,iText.Kernel.Pdf.Annot.PdfAnnotation)">
            <summary>
            Factory method that creates the type specific
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            from the given
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            that represents annotation object. This method is useful for property reading in reading mode or
            modifying in stamping mode.
            </summary>
            <param name="pdfObject">
            a
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            that represents annotation in the document.
            </param>
            <param name="parent">
            parent annotation of the
            <see cref="T:iText.Kernel.Pdf.Annot.PdfPopupAnnotation"/>
            to be created. This parameter is
            only needed if passed
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            represents a pop-up annotation in the document.
            </param>
            <returns>
            created
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetSubtype">
            <summary>
            Gets a
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            which value is a subtype of this annotation.
            See ISO-320001 12.5.6, “Annotation Types” for the reference to the possible types.
            </summary>
            <returns>subtype of this annotation.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetLayer(iText.Kernel.Pdf.Layer.IPdfOCG)">
            <summary>Sets the layer this annotation belongs to.</summary>
            <param name="layer">the layer this annotation belongs to</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetAction(iText.Kernel.Pdf.Action.PdfAction)">
            <summary>
            Sets a
            <see cref="T:iText.Kernel.Pdf.Action.PdfAction"/>
            to this annotation which will be performed when the annotation is activated.
            </summary>
            <param name="action">
            
            <see cref="T:iText.Kernel.Pdf.Action.PdfAction"/>
            to set to this annotation.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetAdditionalAction(iText.Kernel.Pdf.PdfName,iText.Kernel.Pdf.Action.PdfAction)">
            <summary>
            Sets an additional
            <see cref="T:iText.Kernel.Pdf.Action.PdfAction"/>
            to this annotation which will be performed in response to
            the specific trigger event defined by
            <paramref name="key"/>
            . See ISO-320001 12.6.3, "Trigger Events".
            </summary>
            <param name="key">
            a
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            that denotes a type of the additional action to set.
            </param>
            <param name="action">
            
            <see cref="T:iText.Kernel.Pdf.Action.PdfAction"/>
            to set as additional to this annotation.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetContents">
            <summary>
            Gets the text that shall be displayed for the annotation or, if this type of annotation does not display text,
            an alternate description of the annotation’s contents in human-readable form.
            </summary>
            <returns>annotation text content.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetContents(iText.Kernel.Pdf.PdfString)">
            <summary>
            Sets the text that shall be displayed for the annotation or, if this type of annotation does not display text,
            an alternate description of the annotation’s contents in human-readable form.
            </summary>
            <param name="contents">
            a
            <see cref="T:iText.Kernel.Pdf.PdfString"/>
            containing text content to be set to the annotation.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetContents(System.String)">
            <summary>
            Sets the text that shall be displayed for the annotation or, if this type of annotation does not display text,
            an alternate description of the annotation’s contents in human-readable form.
            </summary>
            <param name="contents">
            a java
            <see cref="T:System.String"/>
            containing text content to be set to the annotation.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetPageObject">
            <summary>
            Gets a
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            that represents a page of the document on which annotation is placed,
            i.e. which has this annotation in it's /Annots array.
            </summary>
            <returns>
            
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            that is a page pdf object or null if annotation is not added to the page yet.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetPage">
            <summary>
            Gets a
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            on which annotation is placed.
            </summary>
            <returns>
            
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            on which annotation is placed or null if annotation is not placed yet.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetPage(iText.Kernel.Pdf.PdfPage)">
            <summary>Method that modifies annotation page property, which defines to which page annotation belongs.</summary>
            <remarks>
            Method that modifies annotation page property, which defines to which page annotation belongs.
            Keep in mind that this doesn't actually add an annotation to the page,
            it should be done via
            <see cref="M:iText.Kernel.Pdf.PdfPage.AddAnnotation(iText.Kernel.Pdf.Annot.PdfAnnotation)"/>
            .
            Also you don't need to set this property manually, this is done automatically on addition to the page.
            </remarks>
            <param name="page">
            the
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            to which annotation will be added.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetName">
            <summary>
            Gets the annotation name, a text string uniquely identifying it among all the
            annotations on its page.
            </summary>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.PdfString"/>
            with annotation name as it's value or null if name
            is not specified.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetName(iText.Kernel.Pdf.PdfString)">
            <summary>
            Sets the annotation name, a text string uniquely identifying it among all the
            annotations on its page.
            </summary>
            <param name="name">
            a
            <see cref="T:iText.Kernel.Pdf.PdfString"/>
            to be set as annotation name.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetDate">
            <summary>The date and time when the annotation was most recently modified.</summary>
            <remarks>
            The date and time when the annotation was most recently modified.
            This is an optional property of the annotation.
            </remarks>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.PdfString"/>
            with the modification date as it's value or null if date is not specified.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetDate(iText.Kernel.Pdf.PdfString)">
            <summary>The date and time when the annotation was most recently modified.</summary>
            <param name="date">
            a
            <see cref="T:iText.Kernel.Pdf.PdfString"/>
            with date. The format should be a date string as described
            in ISO-320001 7.9.4, “Dates”.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetFlags">
            <summary>A set of flags specifying various characteristics of the annotation (see ISO-320001 12.5.3, “Annotation Flags”).
                </summary>
            <remarks>
            A set of flags specifying various characteristics of the annotation (see ISO-320001 12.5.3, “Annotation Flags”).
            For specific annotation flag constants see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetFlag(System.Int32)"/>
            .
            Default value: 0.
            </remarks>
            <returns>an integer interpreted as one-bit flags specifying various characteristics of the annotation.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetFlags(System.Int32)">
            <summary>Sets a set of flags specifying various characteristics of the annotation (see ISO-320001 12.5.3, “Annotation Flags”).
                </summary>
            <remarks>
            Sets a set of flags specifying various characteristics of the annotation (see ISO-320001 12.5.3, “Annotation Flags”).
            On the contrary from
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetFlag(System.Int32)"/>
            , this method sets a complete set of enabled and disabled flags at once.
            If not set specifically the default value is 0.
            </remarks>
            <param name="flags">an integer interpreted as set of one-bit flags specifying various characteristics of the annotation.
                </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetFlag(System.Int32)">
            <summary>Sets a flag that specifies a characteristic of the annotation to enabled state (see ISO-320001 12.5.3, “Annotation Flags”).
                </summary>
            <remarks>
            Sets a flag that specifies a characteristic of the annotation to enabled state (see ISO-320001 12.5.3, “Annotation Flags”).
            On the contrary from
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetFlags(System.Int32)"/>
            , this method sets only specified flags to enabled state,
            but doesn't disable other flags.
            Possible flags:
            <ul>
            <li>
            <see cref="F:iText.Kernel.Pdf.Annot.PdfAnnotation.INVISIBLE"/>
            - If set, do not display the annotation if it does not belong to one of the
            standard annotation types and no annotation handler is available. If clear, display such unknown annotation
            using an appearance stream specified by its appearance dictionary, if any.
            </li>
            <li>
            <see cref="F:iText.Kernel.Pdf.Annot.PdfAnnotation.HIDDEN"/>
            - If set, do not display or print the annotation or allow it to interact with
            the user, regardless of its annotation type or whether an annotation handler is available.
            </li>
            <li>
            <see cref="F:iText.Kernel.Pdf.Annot.PdfAnnotation.PRINT"/>
            - If set, print the annotation when the page is printed. If clear, never print
            the annotation, regardless of whether it is displayed on the screen.
            </li>
            <li>
            <see cref="F:iText.Kernel.Pdf.Annot.PdfAnnotation.NO_ZOOM"/>
            - If set, do not scale the annotation’s appearance to match the magnification of
            the page. The location of the annotation on the page (defined by the upper-left corner of its annotation
            rectangle) shall remain fixed, regardless of the page magnification.}
            </li>
            <li>
            <see cref="F:iText.Kernel.Pdf.Annot.PdfAnnotation.NO_ROTATE"/>
            - If set, do not rotate the annotation’s appearance to match the rotation
            of the page. The upper-left corner of the annotation rectangle shall remain in a fixed location on the page,
            regardless of the page rotation.
            </li>
            <li>
            <see cref="F:iText.Kernel.Pdf.Annot.PdfAnnotation.NO_VIEW"/>
            - If set, do not display the annotation on the screen or allow it to interact
            with the user. The annotation may be printed (depending on the setting of the Print flag) but should be considered
            hidden for purposes of on-screen display and user interaction.
            </li>
            <li>
            <see cref="F:iText.Kernel.Pdf.Annot.PdfAnnotation.READ_ONLY"/>
            -  If set, do not allow the annotation to interact with the user. The annotation
            may be displayed or printed (depending on the settings of the NoView and Print flags) but should not respond to mouse
            clicks or change its appearance in response to mouse motions.
            </li>
            <li>
            <see cref="F:iText.Kernel.Pdf.Annot.PdfAnnotation.LOCKED"/>
            -  If set, do not allow the annotation to be deleted or its properties
            (including position and size) to be modified by the user. However, this flag does not restrict changes to
            the annotation’s contents, such as the value of a form field.
            </li>
            <li>
            <see cref="F:iText.Kernel.Pdf.Annot.PdfAnnotation.TOGGLE_NO_VIEW"/>
            - If set, invert the interpretation of the NoView flag for certain events.
            </li>
            <li>
            <see cref="F:iText.Kernel.Pdf.Annot.PdfAnnotation.LOCKED_CONTENTS"/>
            - If set, do not allow the contents of the annotation to be modified
            by the user. This flag does not restrict deletion of the annotation or changes to other annotation properties,
            such as position and size.
            </li>
            </ul>
            </remarks>
            <param name="flag">- an integer interpreted as set of one-bit flags which will be enabled for this annotation.
                </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.ResetFlag(System.Int32)">
            <summary>Resets a flag that specifies a characteristic of the annotation to disabled state (see ISO-320001 12.5.3, “Annotation Flags”).
                </summary>
            <param name="flag">an integer interpreted as set of one-bit flags which will be reset to disabled state.</param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.HasFlag(System.Int32)">
            <summary>
            Checks if the certain flag that specifies a characteristic of the annotation
            is in enabled state (see ISO-320001 12.5.3, “Annotation Flags”).
            </summary>
            <remarks>
            Checks if the certain flag that specifies a characteristic of the annotation
            is in enabled state (see ISO-320001 12.5.3, “Annotation Flags”).
            This method allows only one flag to be checked at once, use constants listed in
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetFlag(System.Int32)"/>
            .
            </remarks>
            <param name="flag">
            an integer interpreted as set of one-bit flags. Only one bit must be set in this integer, otherwise
            exception is thrown.
            </param>
            <returns>true if the given flag is in enabled state.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetAppearanceDictionary">
            <summary>
            An appearance dictionary specifying how the annotation shall be presented visually on the page during its
            interactions with the user (see ISO-320001 12.5.5, “Appearance Streams”).
            </summary>
            <remarks>
            An appearance dictionary specifying how the annotation shall be presented visually on the page during its
            interactions with the user (see ISO-320001 12.5.5, “Appearance Streams”). An appearance dictionary is a dictionary
            containing one or several appearance streams or subdictionaries.
            </remarks>
            <returns>
            an appearance
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            or null if it is not specified.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetAppearanceObject(iText.Kernel.Pdf.PdfName)">
            <summary>Specific appearance object corresponding to the specific appearance type.</summary>
            <remarks>
            Specific appearance object corresponding to the specific appearance type. This object might be either an appearance
            stream or an appearance subdictionary. In the latter case, the subdictionary defines multiple appearance streams
            corresponding to different appearance states of the annotation. See ISO-320001 12.5.5, “Appearance Streams”.
            </remarks>
            <param name="appearanceType">
            a
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            specifying appearance type. Possible types are
            <see cref="F:iText.Kernel.Pdf.PdfName.N">Normal</see>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.R">Rollover</see>
            and
            <see cref="F:iText.Kernel.Pdf.PdfName.D">Down</see>
            .
            </param>
            <returns>
            null if their is no such appearance type or an appearance object which might be either
            an appearance stream or an appearance subdictionary.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetNormalAppearanceObject">
            <summary>The normal appearance is used when the annotation is not interacting with the user.</summary>
            <remarks>
            The normal appearance is used when the annotation is not interacting with the user.
            This appearance is also used for printing the annotation.
            See also
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetAppearanceObject(iText.Kernel.Pdf.PdfName)"/>
            .
            </remarks>
            <returns>an appearance object which might be either an appearance stream or an appearance subdictionary.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetRolloverAppearanceObject">
            <summary>
            The rollover appearance is used when the user moves the cursor into the annotation’s active area
            without pressing the mouse button.
            </summary>
            <remarks>
            The rollover appearance is used when the user moves the cursor into the annotation’s active area
            without pressing the mouse button. If not specified normal appearance is used.
            See also
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetAppearanceObject(iText.Kernel.Pdf.PdfName)"/>
            .
            </remarks>
            <returns>
            null if rollover appearance is not specified or an appearance object which might be either
            an appearance stream or an appearance subdictionary.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetDownAppearanceObject">
            <summary>The down appearance is used when the mouse button is pressed or held down within the annotation’s active area.
                </summary>
            <remarks>
            The down appearance is used when the mouse button is pressed or held down within the annotation’s active area.
            If not specified normal appearance is used.
            See also
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetAppearanceObject(iText.Kernel.Pdf.PdfName)"/>
            .
            </remarks>
            <returns>
            null if down appearance is not specified or an appearance object which might be either
            an appearance stream or an appearance subdictionary.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetAppearance(iText.Kernel.Pdf.PdfName,iText.Kernel.Pdf.PdfDictionary)">
            <summary>Sets a specific type of the appearance.</summary>
            <remarks>
            Sets a specific type of the appearance. See
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetAppearanceObject(iText.Kernel.Pdf.PdfName)"/>
            and
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetAppearanceDictionary"/>
            for more info.
            </remarks>
            <param name="appearanceType">
            a
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            specifying appearance type. Possible types are
            <see cref="F:iText.Kernel.Pdf.PdfName.N">Normal</see>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.R">Rollover</see>
            and
            <see cref="F:iText.Kernel.Pdf.PdfName.D">Down</see>
            .
            </param>
            <param name="appearance">an appearance object which might be either an appearance stream or an appearance subdictionary.
                </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetNormalAppearance(iText.Kernel.Pdf.PdfDictionary)">
            <summary>Sets normal appearance.</summary>
            <remarks>
            Sets normal appearance. See
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetNormalAppearanceObject"/>
            and
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetAppearanceDictionary"/>
            for more info.
            </remarks>
            <param name="appearance">an appearance object which might be either an appearance stream or an appearance subdictionary.
                </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetRolloverAppearance(iText.Kernel.Pdf.PdfDictionary)">
            <summary>Sets rollover appearance.</summary>
            <remarks>
            Sets rollover appearance. See
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetRolloverAppearanceObject"/>
            and
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetAppearanceDictionary"/>
            for more info.
            </remarks>
            <param name="appearance">an appearance object which might be either an appearance stream or an appearance subdictionary.
                </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetDownAppearance(iText.Kernel.Pdf.PdfDictionary)">
            <summary>Sets down appearance.</summary>
            <remarks>
            Sets down appearance. See
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetDownAppearanceObject"/>
            and
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetAppearanceDictionary"/>
            for more info.
            </remarks>
            <param name="appearance">an appearance object which might be either an appearance stream or an appearance subdictionary.
                </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetAppearance(iText.Kernel.Pdf.PdfName,iText.Kernel.Pdf.Annot.PdfAnnotationAppearance)">
            <summary>
            Sets a specific type of the appearance using
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotationAppearance"/>
            wrapper.
            This method is used to set only an appearance subdictionary. See
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetAppearanceObject(iText.Kernel.Pdf.PdfName)"/>
            and
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetAppearanceDictionary"/>
            for more info.
            </summary>
            <param name="appearanceType">
            a
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            specifying appearance type. Possible types are
            <see cref="F:iText.Kernel.Pdf.PdfName.N">Normal</see>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.R">Rollover</see>
            and
            <see cref="F:iText.Kernel.Pdf.PdfName.D">Down</see>
            .
            </param>
            <param name="appearance">
            an appearance subdictionary wrapped in
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotationAppearance"/>
            .
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetNormalAppearance(iText.Kernel.Pdf.Annot.PdfAnnotationAppearance)">
            <summary>
            Sets normal appearance using
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotationAppearance"/>
            wrapper. This method is used to set only
            appearance subdictionary. See
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetNormalAppearanceObject"/>
            and
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetAppearanceDictionary"/>
            for more info.
            </summary>
            <param name="appearance">
            an appearance subdictionary wrapped in
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotationAppearance"/>
            .
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetRolloverAppearance(iText.Kernel.Pdf.Annot.PdfAnnotationAppearance)">
            <summary>
            Sets rollover appearance using
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotationAppearance"/>
            wrapper. This method is used to set only
            appearance subdictionary. See
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetRolloverAppearanceObject"/>
            and
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetAppearanceDictionary"/>
            for more info.
            </summary>
            <param name="appearance">
            an appearance subdictionary wrapped in
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotationAppearance"/>
            .
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetDownAppearance(iText.Kernel.Pdf.Annot.PdfAnnotationAppearance)">
            <summary>
            Sets down appearance using
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotationAppearance"/>
            wrapper. This method is used to set only
            appearance subdictionary. See
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetDownAppearanceObject"/>
            and
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetAppearanceDictionary"/>
            for more info.
            </summary>
            <param name="appearance">
            an appearance subdictionary wrapped in
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotationAppearance"/>
            .
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetAppearanceState">
            <summary>
            The annotation’s appearance state, which selects the applicable appearance stream
            from an appearance subdictionary if there is such.
            </summary>
            <remarks>
            The annotation’s appearance state, which selects the applicable appearance stream
            from an appearance subdictionary if there is such. See
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetAppearanceObject(iText.Kernel.Pdf.PdfName)"/>
            for more info.
            </remarks>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            which defines selected appearance state.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetAppearanceState(iText.Kernel.Pdf.PdfName)">
            <summary>
            Sets the annotation’s appearance state, which selects the applicable appearance stream
            from an appearance subdictionary.
            </summary>
            <remarks>
            Sets the annotation’s appearance state, which selects the applicable appearance stream
            from an appearance subdictionary. See
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetAppearanceObject(iText.Kernel.Pdf.PdfName)"/>
            for more info.
            </remarks>
            <param name="as">
            a
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            which defines appearance state to be selected.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            instance.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetBorder" -->
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetBorder(iText.Kernel.Pdf.PdfArray)">
            <summary>Sets the characteristics of the annotation’s border.</summary>
            <param name="border">
            an
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            specifying the characteristics of the annotation’s border.
            See
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetBorder"/>
            for more detailes.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetColorObject">
            <summary>
            An array of numbers in the range 0.0 to 1.0, representing a colour used for the following purposes:
            <ul>
            <li>The background of the annotation’s icon when closed</li>
            <li>The title bar of the annotation’s pop-up window</li>
            <li>The border of a link annotation</li>
            </ul>
            The number of array elements determines the colour space in which the colour shall be defined:
            <ul>
            <li>0 - No colour; transparent</li>
            <li>1 - DeviceGray</li>
            <li>3 - DeviceRGB</li>
            <li>4 - DeviceCMYK</li>
            </ul>
            </summary>
            <returns>An array of numbers in the range 0.0 to 1.0, representing an annotation colour.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetColor(iText.Kernel.Pdf.PdfArray)">
            <summary>Sets an annotation color.</summary>
            <remarks>
            Sets an annotation color. For more details on annotation color purposes and the format
            of the passing
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetColorObject"/>
            .
            </remarks>
            <param name="color">an array of numbers in the range 0.0 to 1.0, specifying color.</param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetColor(System.Single[])">
            <summary>Sets an annotation color.</summary>
            <remarks>
            Sets an annotation color. For more details on annotation color purposes and the format
            of the passing array see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetColorObject"/>
            .
            </remarks>
            <param name="color">an array of numbers in the range 0.0 to 1.0, specifying color.</param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetColor(iText.Kernel.Colors.Color)">
            <summary>Sets an annotation color.</summary>
            <remarks>
            Sets an annotation color. For more details on annotation color purposes
            see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetColorObject"/>
            .
            </remarks>
            <param name="color">
            
            <see cref="T:iText.Kernel.Colors.Color"/>
            object of the either
            <see cref="T:iText.Kernel.Colors.DeviceGray"/>
            ,
            <see cref="T:iText.Kernel.Colors.DeviceRgb"/>
            or
            <see cref="T:iText.Kernel.Colors.DeviceCmyk"/>
            type.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetStructParentIndex">
            <summary>
            The integer key of the annotation’s entry in the structural parent tree
            (see ISO-320001 14.7.4.4, “Finding Structure Elements from Content Items”).
            </summary>
            <returns>integer key in structural parent tree or -1 if annotation is not tagged.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetStructParentIndex(System.Int32)">
            <summary>
            Sets he integer key of the annotation’s entry in the structural parent tree
            (see ISO-320001 14.7.4.4, “Finding Structure Elements from Content Items”).
            </summary>
            <remarks>
            Sets he integer key of the annotation’s entry in the structural parent tree
            (see ISO-320001 14.7.4.4, “Finding Structure Elements from Content Items”).
            Note: Normally, there is no need to take care of this manually, struct parent index is set automatically
            if annotation is added to the tagged document's page.
            </remarks>
            <param name="structParentIndex">
            integer which is to be the key of the annotation's entry
            in structural parent tree.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetOpen">
            <summary>A flag specifying whether the annotation shall initially be displayed open.</summary>
            <remarks>
            A flag specifying whether the annotation shall initially be displayed open.
            This flag has affect to not all kinds of annotations.
            </remarks>
            <returns>true if annotation is initially open, false - if closed.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetOpen(System.Boolean)">
            <summary>Sets a flag specifying whether the annotation shall initially be displayed open.</summary>
            <remarks>
            Sets a flag specifying whether the annotation shall initially be displayed open.
            This flag has affect to not all kinds of annotations.
            </remarks>
            <param name="open">true if annotation shall initially be open, false - if closed.</param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            instance.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetQuadPoints" -->
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetQuadPoints(iText.Kernel.Pdf.PdfArray)" -->
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetBorderStyle(iText.Kernel.Pdf.PdfDictionary)">
            <summary>
            Sets border style dictionary that has more settings than the array specified for the Border entry (
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetBorder"/>
            ).
            See ISO-320001, Table 166 and
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetBorderStyle"/>
            for more info.
            </summary>
            <param name="borderStyle">
            a border style dictionary specifying the line width and dash pattern that shall be used
            in drawing the annotation’s border.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetBorderStyle(iText.Kernel.Pdf.PdfName)">
            <summary>Setter for the annotation's preset border style.</summary>
            <remarks>
            Setter for the annotation's preset border style. Possible values are
            <ul>
            <li>
            <see cref="F:iText.Kernel.Pdf.Annot.PdfAnnotation.STYLE_SOLID"/>
            - A solid rectangle surrounding the annotation.</li>
            <li>
            <see cref="F:iText.Kernel.Pdf.Annot.PdfAnnotation.STYLE_DASHED"/>
            - A dashed rectangle surrounding the annotation.</li>
            <li>
            <see cref="F:iText.Kernel.Pdf.Annot.PdfAnnotation.STYLE_BEVELED"/>
            - A simulated embossed rectangle that appears to be raised above the surface of the page.</li>
            <li>
            <see cref="F:iText.Kernel.Pdf.Annot.PdfAnnotation.STYLE_INSET"/>
            - A simulated engraved rectangle that appears to be recessed below the surface of the page.</li>
            <li>
            <see cref="F:iText.Kernel.Pdf.Annot.PdfAnnotation.STYLE_UNDERLINE"/>
            - A single line along the bottom of the annotation rectangle.</li>
            </ul>
            See also ISO-320001, Table 166.
            </remarks>
            <param name="style">The new value for the annotation's border style.</param>
            <returns>The annotation which this method was called on.</returns>
            <seealso cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetBorderStyle"/>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetDashPattern(iText.Kernel.Pdf.PdfArray)">
            <summary>Setter for the annotation's preset dashed border style.</summary>
            <remarks>
            Setter for the annotation's preset dashed border style. This property has affect only if
            <see cref="F:iText.Kernel.Pdf.Annot.PdfAnnotation.STYLE_DASHED"/>
            style was used for the annotation border style (see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetBorderStyle(iText.Kernel.Pdf.PdfName)"/>
            .
            See ISO-320001 8.4.3.6, “Line Dash Pattern” for the format in which dash pattern shall be specified.
            </remarks>
            <param name="dashPattern">
            a dash array defining a pattern of dashes and gaps that
            shall be used in drawing a dashed border.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetBorderStyle">
            <summary>The dictionaries for some annotation types (such as free text and polygon annotations) can include the BS entry.
                </summary>
            <remarks>
            The dictionaries for some annotation types (such as free text and polygon annotations) can include the BS entry.
            That entry specifies a border style dictionary that has more settings than the array specified for the Border
            entry (see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetBorder"/>
            ). If an annotation dictionary includes the BS entry, then the Border
            entry is ignored. If annotation includes AP (see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetAppearanceDictionary"/>
            ) it takes
            precedence over the BS entry. For more info on BS entry see ISO-320001, Table 166.
            </remarks>
            <returns>
            
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            which is a border style dictionary or null if it is not specified.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetTitle(iText.Kernel.Pdf.PdfString)">
            <summary>Sets annotation title.</summary>
            <remarks>Sets annotation title. This property affects not all annotation types.</remarks>
            <param name="title">
            a
            <see cref="T:iText.Kernel.Pdf.PdfString"/>
            which value is to be annotation title.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetTitle">
            <summary>Annotation title.</summary>
            <remarks>
            Annotation title. For example for markup annotations, the title is the text label that shall be displayed in the
            title bar of the annotation’s pop-up window when open and active. For movie annotation Movie actions
            (ISO-320001 12.6.4.9, “Movie Actions”) may use this title to reference the movie annotation.
            </remarks>
            <returns>
            
            <see cref="T:iText.Kernel.Pdf.PdfString"/>
            which value is an annotation title or null if it isn't specifed.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetAppearanceCharacteristics(iText.Kernel.Pdf.PdfDictionary)">
            <summary>
            Sets an appearance characteristics dictionary containing additional information for constructing the
            annotation’s appearance stream.
            </summary>
            <remarks>
            Sets an appearance characteristics dictionary containing additional information for constructing the
            annotation’s appearance stream. See ISO-320001, Table 189.
            This property affects
            <see cref="T:iText.Kernel.Pdf.Annot.PdfWidgetAnnotation"/>
            and
            <see cref="T:iText.Kernel.Pdf.Annot.PdfScreenAnnotation"/>
            .
            </remarks>
            <param name="characteristics">
            the
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            with additional information for appearance stream.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetAppearanceCharacteristics">
            <summary>
            An appearance characteristics dictionary containing additional information for constructing the
            annotation’s appearance stream.
            </summary>
            <remarks>
            An appearance characteristics dictionary containing additional information for constructing the
            annotation’s appearance stream. See ISO-320001, Table 189.
            This property affects
            <see cref="T:iText.Kernel.Pdf.Annot.PdfWidgetAnnotation"/>
            and
            <see cref="T:iText.Kernel.Pdf.Annot.PdfScreenAnnotation"/>
            .
            </remarks>
            <returns>an appearance characteristics dictionary or null if it isn't specified.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetAction">
            <summary>
            An
            <see cref="T:iText.Kernel.Pdf.Action.PdfAction"/>
            to perform, such as launching an application, playing a sound,
            changing an annotation’s appearance state etc, when the annotation is activated.
            </summary>
            <returns>
            
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            which defines the characteristics and behaviour of an action.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetAdditionalAction">
            <summary>An additional actions dictionary that extends the set of events that can trigger the execution of an action.
                </summary>
            <remarks>
            An additional actions dictionary that extends the set of events that can trigger the execution of an action.
            See ISO-320001 12.6.3 Trigger Events.
            </remarks>
            <returns>
            an additional actions
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            .
            </returns>
            <seealso cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetAction"/>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetRectangle(iText.Kernel.Pdf.PdfArray)">
            <summary>The annotation rectangle, defining the location of the annotation on the page in default user space units.
                </summary>
            <param name="array">
            a
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            which specifies a rectangle by two diagonally opposite corners.
            Typically, the array is of form [llx lly urx ury].
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetRectangle">
            <summary>The annotation rectangle, defining the location of the annotation on the page in default user space units.
                </summary>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            which specifies a rectangle by two diagonally opposite corners.
            Typically, the array is of form [llx lly urx ury].
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.Put(iText.Kernel.Pdf.PdfName,iText.Kernel.Pdf.PdfObject)">
            <summary>
            Inserts the value into into the underlying
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            of this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            and associates it
            with the specified key. If the key is already present in this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            , this method will override
            the old value with the specified one.
            </summary>
            <param name="key">key to insert or to override</param>
            <param name="value">the value to associate with the specified key</param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.Remove(iText.Kernel.Pdf.PdfName)">
            <summary>
            Removes the specified key from the underlying
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            of this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            .
            </summary>
            <param name="key">key to be removed</param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfAnnotation.Flush">
            <summary>
            To manually flush a
            <c>PdfObject</c>
            behind this wrapper, you have to ensure
            that this object is added to the document, i.e. it has an indirect reference.
            Basically this means that before flushing you need to explicitly call
            <see cref="M:iText.Kernel.Pdf.PdfObjectWrapper`1.MakeIndirect(iText.Kernel.Pdf.PdfDocument)"/>
            .
            For example: wrapperInstance.makeIndirect(document).flush();
            Note that not every wrapper require this, only those that have such warning in documentation.
            </summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation">
            <summary>
            This is a super class for the annotations which are defined as markup annotations
            because they are used primarily to mark up PDF documents.
            </summary>
            <remarks>
            This is a super class for the annotations which are defined as markup annotations
            because they are used primarily to mark up PDF documents. These annotations have
            text that appears as part of the annotation and may be displayed in other ways
            by a conforming reader, such as in a Comments pane.
            See also ISO-320001 12.5.6.2 "Markup Annotations".
            </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.GetText">
            <summary>
            The text label that will be displayed in the title bar of the annotation's pop-up window
            when open and active.
            </summary>
            <remarks>
            The text label that will be displayed in the title bar of the annotation's pop-up window
            when open and active. This entry shall identify the user who added the annotation.
            </remarks>
            <returns>
            
            <see cref="T:iText.Kernel.Pdf.PdfString"/>
            which value is an annotation text label content
            or null if text is not specified.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.SetText(iText.Kernel.Pdf.PdfString)">
            <summary>
            Sets the text label that will be displayed in the title bar of the annotation's pop-up window
            when open and active.
            </summary>
            <remarks>
            Sets the text label that will be displayed in the title bar of the annotation's pop-up window
            when open and active. This entry shall identify the user who added the annotation.
            </remarks>
            <param name="text">
            
            <see cref="T:iText.Kernel.Pdf.PdfString"/>
            which value is an annotation text label content.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.GetOpacity">
            <summary>The constant opacity value that will be used in painting the annotation.</summary>
            <remarks>
            The constant opacity value that will be used in painting the annotation.
            This value is applied to all visible elements of the annotation in its closed state
            (including its background and border) but not to the pop-up window that appears when
            the annotation is opened. Default value: 1.0.
            </remarks>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.PdfNumber"/>
            which value is in range between 0 and 1, which specifies the
            level of opacity. This method returns null if opacity is not specified; in this case default
            value is used, which is 1.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.SetOpacity(iText.Kernel.Pdf.PdfNumber)">
            <summary>Sets the constant opacity value that will be used in painting the annotation.</summary>
            <param name="ca">
            a
            <see cref="T:iText.Kernel.Pdf.PdfNumber"/>
            which value is in range between 0 and 1, which specifies the
            level of opacity.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation"/>
            instance.
            </returns>
            <seealso cref="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.GetOpacity"/>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.GetRichText">
            <summary>
            A rich text string (see ISO-320001 12.7.3.4, “Rich Text Strings”) that
            shall be displayed in the pop-up window when the annotation is opened.
            </summary>
            <returns>
            text string or text stream that specifies rich text or null if
            rich text is not specified.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.SetRichText(iText.Kernel.Pdf.PdfObject)">
            <summary>
            Sets a rich text string (see ISO-320001 12.7.3.4, “Rich Text Strings”) that
            shall be displayed in the pop-up window when the annotation is opened.
            </summary>
            <param name="richText">text string or text stream that specifies rich text.</param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.GetCreationDate">
            <summary>The date and time when the annotation was created.</summary>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.PdfString"/>
            which value should be in the date format specified in (ISO-320001 7.9.4, “Dates”).
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.SetCreationDate(iText.Kernel.Pdf.PdfString)">
            <summary>Sets the date and time when the annotation was created.</summary>
            <param name="creationDate">
            
            <see cref="T:iText.Kernel.Pdf.PdfString"/>
            which value should be in the date format
            specified in (ISO-320001 7.9.4, “Dates”).
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.GetInReplyToObject">
            <summary>
            An annotation object that this annotation is “in reply to.”
            Both annotations shall be on the same page of the document.
            </summary>
            <remarks>
            An annotation object that this annotation is “in reply to.”
            Both annotations shall be on the same page of the document.
            The relationship between the two annotations shall be specified by the RT entry
            (see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.GetReplyType"/>
            ).
            </remarks>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            that represents an annotation that this annotation is “in reply to.”
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.GetInReplyTo">
            <summary>
            An annotation that this annotation is “in reply to.”
            Both annotations shall be on the same page of the document.
            </summary>
            <remarks>
            An annotation that this annotation is “in reply to.”
            Both annotations shall be on the same page of the document.
            The relationship between the two annotations shall be specified by the RT entry
            (see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.GetReplyType"/>
            ).
            </remarks>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            that this annotation is “in reply to.”
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.SetInReplyTo(iText.Kernel.Pdf.Annot.PdfAnnotation)">
            <summary>
            Sets an annotation that this annotation is “in reply to.”
            Both annotations shall be on the same page of the document.
            </summary>
            <remarks>
            Sets an annotation that this annotation is “in reply to.”
            Both annotations shall be on the same page of the document.
            The relationship between the two annotations shall be specified by the RT entry
            (see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.GetReplyType"/>
            ).
            </remarks>
            <param name="inReplyTo">
            a
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            that this annotation is “in reply to.”
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.SetPopup(iText.Kernel.Pdf.Annot.PdfPopupAnnotation)">
            <summary>Sets a pop-up annotation for entering or editing the text associated with this annotation.</summary>
            <remarks>
            Sets a pop-up annotation for entering or editing the text associated with this annotation.
            Pop-up annotation defines an associated with this annotation pop-up window that may contain text.
            The Contents (see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetContents(iText.Kernel.Pdf.PdfString)"/>
            ) entry of the annotation that has
            an associated popup specifies the text that shall be displayed when the pop-up window is opened.
            </remarks>
            <param name="popup">
            an
            <see cref="T:iText.Kernel.Pdf.Annot.PdfPopupAnnotation"/>
            that will be associated with this annotation.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.GetPopupObject">
            <summary>An associated pop-up annotation object.</summary>
            <remarks>
            An associated pop-up annotation object. See
            <see cref="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.GetPopup"/>
            for more info.
            </remarks>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            that represents an associated pop-up annotation,
            or null if popup annotation is not specified.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.GetPopup">
            <summary>An associated pop-up annotation for entering or editing the text associated with this annotation.
                </summary>
            <remarks>
            An associated pop-up annotation for entering or editing the text associated with this annotation.
            Pop-up annotation defines an associated with this annotation pop-up window that may contain text.
            The Contents (see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetContents"/>
            ) entry of the annotation that has
            an associated popup specifies the text that shall be displayed when the pop-up window is opened.
            </remarks>
            <returns>
            an
            <see cref="T:iText.Kernel.Pdf.Annot.PdfPopupAnnotation"/>
            that is associated with this annotation, or null if there is none.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.GetSubject">
            <summary>Text representing a short description of the subject being addressed by the annotation.</summary>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.PdfString"/>
            which value is a annotation subject.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.SetSubject(iText.Kernel.Pdf.PdfString)">
            <summary>Sets the text representing a short description of the subject being addressed by the annotation.</summary>
            <param name="subject">
            a
            <see cref="T:iText.Kernel.Pdf.PdfString"/>
            which value is a annotation subject.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.GetReplyType">
            <summary>
            A name specifying the relationship (the “reply type”) between this annotation and one specified by IRT entry
            (see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.GetInReplyTo"/>
            ). Valid values are:
            <ul>
            <li>
            <see cref="F:iText.Kernel.Pdf.PdfName.R"/>
            - The annotation shall be considered a reply to the annotation specified by IRT.
            Conforming readers shall not display replies to an annotation individually but together in the form of
            threaded comments.</li>
            <li>
            <see cref="F:iText.Kernel.Pdf.PdfName.Group"/>
            - The annotation shall be grouped with the annotation specified by IRT.</li>
            </ul>
            </summary>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            specifying relationship with the specified by the IRT entry; or null if reply
            type is not specified, in this case the default value is
            <see cref="F:iText.Kernel.Pdf.PdfName.R"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.SetReplyType(iText.Kernel.Pdf.PdfName)">
            <summary>
            Sets the relationship (the “reply type”) between this annotation and one specified by IRT entry
            (see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.SetInReplyTo(iText.Kernel.Pdf.Annot.PdfAnnotation)"/>
            ). For valid values see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.GetInReplyTo"/>
            .
            </summary>
            <param name="replyType">
            a
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            specifying relationship with the specified by the IRT entry.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.GetIntent">
            <summary>A name describing the intent of the markup annotation.</summary>
            <remarks>
            A name describing the intent of the markup annotation.
            See
            <see cref="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.SetIntent(iText.Kernel.Pdf.PdfName)"/>
            for more info.
            </remarks>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            describing the intent of the markup annotation, or null if not specified.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.SetIntent(iText.Kernel.Pdf.PdfName)">
            <summary>Sets a name describing the intent of the markup annotation.</summary>
            <remarks>
            Sets a name describing the intent of the markup annotation.
            Intents allow conforming readers to distinguish between different uses and behaviors
            of a single markup annotation type. If this entry is not present or its value is the same as the annotation type,
            the annotation shall have no explicit intent and should behave in a generic manner in a conforming reader.
            <p>
            See ISO-320001, free text annotations (Table 174), line annotations (Table 175), polygon annotations (Table 178),
            and polyline annotations (Table 178) for the specific intent values for those types.
            </p>
            </remarks>
            <param name="intent">
            a
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            describing the intent of the markup annotation.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.GetExternalData">
            <summary>An external data dictionary specifying data that shall be associated with the annotation.</summary>
            <remarks>
            An external data dictionary specifying data that shall be associated with the annotation.
            This dictionary contains the following entries:
            <ul>
            <li>
            <see cref="F:iText.Kernel.Pdf.PdfName.Type"/>
            - (optional) If present, shall be
            <see cref="F:iText.Kernel.Pdf.PdfName.ExData"/>
            .</li>
            <li>
            <see cref="F:iText.Kernel.Pdf.PdfName.Subtype"/>
            - (required) a name specifying the type of data that the markup annotation
            shall be associated with. The only defined value is
            <see cref="F:iText.Kernel.Pdf.PdfName.Markup3D"/>
            . Table 298 (ISO-320001)
            lists the values that correspond to a subtype of Markup3D (See also
            <see cref="T:iText.Kernel.Pdf.Annot.Pdf3DAnnotation"/>
            ).</li>
            </ul>
            </remarks>
            <returns>
            An external data
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            , or null if not specified.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.SetExternalData(iText.Kernel.Pdf.PdfName)">
            <summary>Sets an external data dictionary specifying data that shall be associated with the annotation.</summary>
            <remarks>
            Sets an external data dictionary specifying data that shall be associated with the annotation.
            This dictionary should contain the following entries:
            <ul>
            <li>
            <see cref="F:iText.Kernel.Pdf.PdfName.Type"/>
            - (optional) If present, shall be
            <see cref="F:iText.Kernel.Pdf.PdfName.ExData"/>
            .</li>
            <li>
            <see cref="F:iText.Kernel.Pdf.PdfName.Subtype"/>
            - (required) a name specifying the type of data that the markup annotation
            shall be associated with. The only defined value is
            <see cref="F:iText.Kernel.Pdf.PdfName.Markup3D"/>
            . Table 298 (ISO-320001)
            lists the values that correspond to a subtype of Markup3D (See also
            <see cref="T:iText.Kernel.Pdf.Annot.Pdf3DAnnotation"/>
            ).</li>
            </ul>
            </remarks>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.SetRectangleDifferences(iText.Kernel.Pdf.PdfArray)">
            <summary>
            A set of four numbers describing the numerical differences between two rectangles:
            the Rect entry of the annotation and another rectangle within that one, which
            meaning depends on the type of the annotation:
            <ul>
            <li> for
            <see cref="T:iText.Kernel.Pdf.Annot.PdfFreeTextAnnotation"/>
            the inner rectangle is where the annotation's text should be displayed;</li>
            <li>
            for
            <see cref="T:iText.Kernel.Pdf.Annot.PdfSquareAnnotation"/>
            and
            <see cref="T:iText.Kernel.Pdf.Annot.PdfCircleAnnotation"/>
            the inner rectangle is the actual boundaries
            of the underlying square or circle;
            </li>
            <li> for
            <see cref="T:iText.Kernel.Pdf.Annot.PdfCaretAnnotation"/>
            the inner rectangle is the actual boundaries of the underlying caret.</li>
            </ul>
            </summary>
            <param name="rect">
            a
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            with four numbers which correspond to the differences in default user space between
            the left, top, right, and bottom coordinates of Rect and those of the inner rectangle, respectively.
            Each value shall be greater than or equal to 0. The sum of the top and bottom differences shall be
            less than the height of Rect, and the sum of the left and right differences shall be less than
            the width of Rect.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.GetRectangleDifferences">
            <summary>
            A set of four numbers describing the numerical differences between two rectangles:
            the Rect entry of the annotation and another rectangle within that one, which
            meaning depends on the type of the annotation (see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.SetRectangleDifferences(iText.Kernel.Pdf.PdfArray)"/>
            ).
            </summary>
            <returns>
            null if not specified, otherwise a
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            with four numbers which correspond to the
            differences in default user space between the left, top, right, and bottom coordinates of Rect and those
            of the inner rectangle, respectively.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.SetBorderEffect(iText.Kernel.Pdf.PdfDictionary)">
            <summary>
            Some annotations types (
            <see cref="T:iText.Kernel.Pdf.Annot.PdfSquareAnnotation"/>
            ,
            <see cref="T:iText.Kernel.Pdf.Annot.PdfCircleAnnotation"/>
            ,
            <see cref="T:iText.Kernel.Pdf.Annot.PdfPolyGeomAnnotation"/>
            and
            <see cref="T:iText.Kernel.Pdf.Annot.PdfFreeTextAnnotation"/>
            ) may have a
            <see cref="F:iText.Kernel.Pdf.PdfName.BE"/>
            entry, which is a border effect dictionary that specifies
            an effect that shall be applied to the border of the annotations.
            </summary>
            <param name="borderEffect">
            a
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            which contents shall be specified in accordance to ISO-320001, Table 167.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.GetBorderEffect">
            <summary>A border effect dictionary that specifies an effect that shall be applied to the border of the annotations.
                </summary>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            , which is a border effect dictionary (see ISO-320001, Table 167).
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.GetInteriorColor">
            <summary>The interior color which is used to fill areas specific for different types of annotation.</summary>
            <remarks>
            The interior color which is used to fill areas specific for different types of annotation. For
            <see cref="T:iText.Kernel.Pdf.Annot.PdfLineAnnotation"/>
            and polyline annotation (
            <see cref="T:iText.Kernel.Pdf.Annot.PdfPolyGeomAnnotation"/>
            - the annotation's line endings, for
            <see cref="T:iText.Kernel.Pdf.Annot.PdfSquareAnnotation"/>
            and
            <see cref="T:iText.Kernel.Pdf.Annot.PdfCircleAnnotation"/>
            - the annotation's rectangle or ellipse, for
            <see cref="T:iText.Kernel.Pdf.Annot.PdfRedactAnnotation"/>
            - the redacted
            region after the affected content has been removed.
            </remarks>
            <returns>
            
            <see cref="T:iText.Kernel.Colors.Color"/>
            of either
            <see cref="T:iText.Kernel.Colors.DeviceGray"/>
            ,
            <see cref="T:iText.Kernel.Colors.DeviceRgb"/>
            or
            <see cref="T:iText.Kernel.Colors.DeviceCmyk"/>
            type which defines
            interior color of the annotation, or null if interior color is not specified.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.SetInteriorColor(iText.Kernel.Pdf.PdfArray)">
            <summary>
            An array of numbers in the range 0.0 to 1.0 specifying the interior color which is used to fill areas specific
            for different types of annotation.
            </summary>
            <remarks>
            An array of numbers in the range 0.0 to 1.0 specifying the interior color which is used to fill areas specific
            for different types of annotation. For
            <see cref="T:iText.Kernel.Pdf.Annot.PdfLineAnnotation"/>
            and polyline annotation (
            <see cref="T:iText.Kernel.Pdf.Annot.PdfPolyGeomAnnotation"/>
            -
            the annotation's line endings, for
            <see cref="T:iText.Kernel.Pdf.Annot.PdfSquareAnnotation"/>
            and
            <see cref="T:iText.Kernel.Pdf.Annot.PdfCircleAnnotation"/>
            - the annotation's
            rectangle or ellipse, for
            <see cref="T:iText.Kernel.Pdf.Annot.PdfRedactAnnotation"/>
            - the redacted region after the affected content has been removed.
            </remarks>
            <param name="interiorColor">
            a
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            of numbers in the range 0.0 to 1.0. The number of array elements determines
            the colour space in which the colour is defined: 0 - No colour, transparent; 1 - DeviceGray,
            3 - DeviceRGB, 4 - DeviceCMYK. For the
            <see cref="T:iText.Kernel.Pdf.Annot.PdfRedactAnnotation"/>
            number of elements shall be
            equal to 3 (which defines DeviceRGB colour space).
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.SetInteriorColor(System.Single[])">
            <summary>
            An array of numbers in the range 0.0 to 1.0 specifying the interior color which is used to fill areas specific
            for different types of annotation.
            </summary>
            <remarks>
            An array of numbers in the range 0.0 to 1.0 specifying the interior color which is used to fill areas specific
            for different types of annotation. See
            <see cref="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.SetInteriorColor(iText.Kernel.Pdf.PdfArray)"/>
            for more info.
            </remarks>
            <param name="interiorColor">an array of floats in the range 0.0 to 1.0.</param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.GetIconName">
            <summary>The name of an icon that is used in displaying the annotation.</summary>
            <remarks>
            The name of an icon that is used in displaying the annotation. Possible values are different for different
            annotation types. See
            <see cref="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.SetIconName(iText.Kernel.Pdf.PdfName)"/>
            .
            </remarks>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            that specifies the icon for displaying annotation, or null if icon name is not specified.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.SetIconName(iText.Kernel.Pdf.PdfName)">
            <summary>The name of an icon that is used in displaying the annotation.</summary>
            <param name="name">
            a
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            that specifies the icon for displaying annotation. Possible values are different
            for different annotation types:
            <ul>
            <li>
            <see cref="T:iText.Kernel.Pdf.Annot.PdfTextAnnotation"/>
            - Comment, Key, Note, Help, NewParagraph, Paragraph, Insert;</li>
            <li>
            <see cref="T:iText.Kernel.Pdf.Annot.PdfStampAnnotation"/>
            - Approved, Experimental, NotApproved, AsIs, Expired, NotForPublicRelease,
            Confidential, Final, Sold, Departmental, ForComment, TopSecret, Draft, ForPublicRelease.</li>
            <li>
            <see cref="T:iText.Kernel.Pdf.Annot.PdfFileAttachmentAnnotation"/>
            - GraphPushPin, PaperclipTag. Additional names may be supported as well.</li>
            <li>
            <see cref="T:iText.Kernel.Pdf.Annot.PdfSoundAnnotation"/>
            - Speaker and Mic. Additional names may be supported as well.</li>
            </ul>
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.SetDefaultAppearance(iText.Kernel.Pdf.PdfString)">
            <summary>The default appearance string that shall be used in formatting the text.</summary>
            <remarks>The default appearance string that shall be used in formatting the text. See ISO-32001 12.7.3.3, “Variable Text”.
                </remarks>
            <param name="appearanceString">
            a
            <see cref="T:iText.Kernel.Pdf.PdfString"/>
            that specifies the default appearance.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.GetDefaultAppearance">
            <summary>The default appearance string that shall be used in formatting the text.</summary>
            <remarks>The default appearance string that shall be used in formatting the text. See ISO-32001 12.7.3.3, “Variable Text”.
                </remarks>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.PdfString"/>
            that specifies the default appearance, or null if default appereance is not specified.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.GetJustification">
            <summary>
            A code specifying the form of quadding (justification) that is used in displaying the annotation's text:
            0 - Left-justified, 1 - Centered, 2 - Right-justified.
            </summary>
            <remarks>
            A code specifying the form of quadding (justification) that is used in displaying the annotation's text:
            0 - Left-justified, 1 - Centered, 2 - Right-justified. Default value: 0 (left-justified).
            </remarks>
            <returns>a code specifying the form of quadding (justification), returns the default value if not explicitly specified.
                </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.SetJustification(System.Int32)">
            <summary>
            A code specifying the form of quadding (justification) that is used in displaying the annotation's text:
            0 - Left-justified, 1 - Centered, 2 - Right-justified.
            </summary>
            <remarks>
            A code specifying the form of quadding (justification) that is used in displaying the annotation's text:
            0 - Left-justified, 1 - Centered, 2 - Right-justified. Default value: 0 (left-justified).
            </remarks>
            <param name="justification">a code specifying the form of quadding (justification).</param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="F:iText.Kernel.Pdf.Annot.PdfFreeTextAnnotation.LEFT_JUSTIFIED">
            <summary>Text justification options.</summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Annot.PdfLineAnnotation">
            <summary>The purpose of a line annotation is to display a single straight line on the page.</summary>
            <remarks>
            The purpose of a line annotation is to display a single straight line on the page.
            When opened, it displays a pop-up window containing the text of the associated note.
            See also ISO-320001 12.5.6.7 "Line Annotations".
            </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfLineAnnotation.#ctor(iText.Kernel.Geom.Rectangle,System.Single[])">
            <summary>
            Creates a
            <see cref="T:iText.Kernel.Pdf.Annot.PdfLineAnnotation"/>
            instance.
            </summary>
            <param name="rect">
            the annotation rectangle, defining the location of the annotation on the page
            in default user space units. See
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetRectangle(iText.Kernel.Pdf.PdfArray)"/>
            .
            </param>
            <param name="line">
            an array of four numbers, [x1 y1 x2 y2], specifying the starting and ending coordinates
            of the line in default user space. See also
            <see cref="M:iText.Kernel.Pdf.Annot.PdfLineAnnotation.GetLine"/>
            .
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfLineAnnotation.#ctor(iText.Kernel.Pdf.PdfDictionary)">
            <summary>
            Creates a
            <see cref="T:iText.Kernel.Pdf.Annot.PdfLineAnnotation"/>
            instance from the given
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            that represents annotation object. This method is useful for property reading in reading mode or
            modifying in stamping mode.
            </summary>
            <param name="pdfDictionary">
            a
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            that represents existing annotation in the document.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfLineAnnotation.GetSubtype">
            <summary><inheritDoc/></summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfLineAnnotation.GetLine">
            <summary>
            An array of four numbers, [x1 y1 x2 y2], specifying the starting and ending coordinates of the line
            in default user space.
            </summary>
            <remarks>
            An array of four numbers, [x1 y1 x2 y2], specifying the starting and ending coordinates of the line
            in default user space. If the
            <see cref="F:iText.Kernel.Pdf.PdfName.LL"/>
            (see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfLineAnnotation.GetLeaderLine"/>
            ) entry is present, this value represents
            the endpoints of the leader lines rather than the endpoints of the line itself.
            </remarks>
            <returns>An array of four numbers specifying the starting and ending coordinates of the line in default user space.
                </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfLineAnnotation.GetLineEndingStyles">
            <summary>An array of two names specifying the line ending styles that is used in drawing the line.</summary>
            <remarks>
            An array of two names specifying the line ending styles that is used in drawing the line.
            The first and second elements of the array shall specify the line ending styles for the endpoints defined,
            respectively, by the first and second pairs of coordinates, (x1, y1) and (x2, y2), in the
            <see cref="F:iText.Kernel.Pdf.PdfName.L"/>
            array
            (see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfLineAnnotation.GetLine"/>
            . For possible values see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfLineAnnotation.SetLineEndingStyles(iText.Kernel.Pdf.PdfArray)"/>
            .
            </remarks>
            <returns>
            An array of two names specifying the line ending styles that is used in drawing the line; or null if line
            endings style is not explicitly defined, default value is [/None /None].
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfLineAnnotation.SetLineEndingStyles(iText.Kernel.Pdf.PdfArray)">
            <summary>Sets the line ending styles that are used in drawing the line.</summary>
            <remarks>
            Sets the line ending styles that are used in drawing the line.
            The first and second elements of the array shall specify the line ending styles for the endpoints defined,
            respectively, by the first and second pairs of coordinates, (x1, y1) and (x2, y2), in the
            <see cref="F:iText.Kernel.Pdf.PdfName.L"/>
            array
            (see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfLineAnnotation.GetLine"/>
            . Possible values for styles are:
            <ul>
            <li>
            <see cref="F:iText.Kernel.Pdf.PdfName.Square"/>
            - A square filled with the annotation's interior color, if any; </li>
            <li>
            <see cref="F:iText.Kernel.Pdf.PdfName.Circle"/>
            - A circle filled with the annotation's interior color, if any; </li>
            <li>
            <see cref="F:iText.Kernel.Pdf.PdfName.Diamond"/>
            - A diamond shape filled with the annotation's interior color, if any; </li>
            <li>
            <see cref="F:iText.Kernel.Pdf.PdfName.OpenArrow"/>
            - Two short lines meeting in an acute angle to form an open arrowhead; </li>
            <li>
            <see cref="F:iText.Kernel.Pdf.PdfName.ClosedArrow"/>
            - Two short lines meeting in an acute angle as in the
            <see cref="F:iText.Kernel.Pdf.PdfName.OpenArrow"/>
            style and
            connected by a third line to form a triangular closed arrowhead filled with the annotation's interior color, if any; </li>
            <li>
            <see cref="F:iText.Kernel.Pdf.PdfName.None"/>
            - No line ending; </li>
            <li>
            <see cref="F:iText.Kernel.Pdf.PdfName.Butt"/>
            - A short line at the endpoint perpendicular to the line itself; </li>
            <li>
            <see cref="F:iText.Kernel.Pdf.PdfName.ROpenArrow"/>
            - Two short lines in the reverse direction from
            <see cref="F:iText.Kernel.Pdf.PdfName.OpenArrow"/>
            ; </li>
            <li>
            <see cref="F:iText.Kernel.Pdf.PdfName.RClosedArrow"/>
            - A triangular closed arrowhead in the reverse direction from
            <see cref="F:iText.Kernel.Pdf.PdfName.ClosedArrow"/>
            ; </li>
            <li>
            <see cref="F:iText.Kernel.Pdf.PdfName.Slash"/>
            - A short line at the endpoint approximately 30 degrees clockwise from perpendicular to the line itself; </li>
            </ul>
            see also ISO-320001, Table 176 "Line ending styles".
            </remarks>
            <param name="lineEndingStyles">An array of two names specifying the line ending styles that is used in drawing the line.
                </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfLineAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfLineAnnotation.GetLeaderLine">
            <summary>
            The length of leader lines in default user space that extend from each endpoint of the line perpendicular
            to the line itself.
            </summary>
            <remarks>
            The length of leader lines in default user space that extend from each endpoint of the line perpendicular
            to the line itself. A positive value means that the leader lines appear in the direction that is clockwise
            when traversing the line from its starting point to its ending point (as specified by
            <see cref="F:iText.Kernel.Pdf.PdfName.L"/>
            (see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfLineAnnotation.GetLine"/>
            );
            a negative value indicates the opposite direction.
            </remarks>
            <returns>a float specifying the length of leader lines in default user space.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfLineAnnotation.SetLeaderLine(System.Single)">
            <summary>
            Sets the length of leader lines in default user space that extend from each endpoint of the line perpendicular
            to the line itself.
            </summary>
            <remarks>
            Sets the length of leader lines in default user space that extend from each endpoint of the line perpendicular
            to the line itself. A positive value means that the leader lines appear in the direction that is clockwise
            when traversing the line from its starting point to its ending point (as specified by
            <see cref="F:iText.Kernel.Pdf.PdfName.L"/>
            (see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfLineAnnotation.GetLine"/>
            );
            a negative value indicates the opposite direction.
            </remarks>
            <param name="leaderLine">a float specifying the length of leader lines in default user space.</param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfLineAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfLineAnnotation.GetLeaderLineLength">
            <summary>
            The length of leader lines in default user space that extend from each endpoint of the line perpendicular
            to the line itself.
            </summary>
            <remarks>
            The length of leader lines in default user space that extend from each endpoint of the line perpendicular
            to the line itself. A positive value means that the leader lines appear in the direction that is clockwise
            when traversing the line from its starting point to its ending point (as specified by
            <see cref="F:iText.Kernel.Pdf.PdfName.L"/>
            (see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfLineAnnotation.GetLine"/>
            );
            a negative value indicates the opposite direction.
            </remarks>
            <returns>a float specifying the length of leader lines in default user space.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfLineAnnotation.SetLeaderLineLength(System.Single)">
            <summary>
            Sets the length of leader lines in default user space that extend from each endpoint of the line perpendicular
            to the line itself.
            </summary>
            <remarks>
            Sets the length of leader lines in default user space that extend from each endpoint of the line perpendicular
            to the line itself. A positive value means that the leader lines appear in the direction that is clockwise
            when traversing the line from its starting point to its ending point (as specified by
            <see cref="F:iText.Kernel.Pdf.PdfName.L"/>
            (see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfLineAnnotation.GetLine"/>
            );
            a negative value indicates the opposite direction.
            </remarks>
            <param name="leaderLineLength">a float specifying the length of leader lines in default user space.</param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfLineAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfLineAnnotation.GetLeaderLineExtension">
            <summary>
            A non-negative number that represents the length of leader line extensions that extend from the line proper
            180 degrees from the leader lines.
            </summary>
            <returns>
            a non-negative float that represents the length of leader line extensions; or if the leader line extension
            is not explicitly set, returns the default value, which is 0.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfLineAnnotation.SetLeaderLineExtension(System.Single)">
            <summary>Sets the length of leader line extensions that extend from the line proper 180 degrees from the leader lines.
                </summary>
            <remarks>
            Sets the length of leader line extensions that extend from the line proper 180 degrees from the leader lines.
            <b>This value shall not be set unless
            <see cref="F:iText.Kernel.Pdf.PdfName.LL"/>
            (see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfLineAnnotation.SetLeaderLine(System.Single)"/>
            ) is set.</b>
            </remarks>
            <param name="leaderLineExtension">a non-negative float that represents the length of leader line extensions.
                </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfLineAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfLineAnnotation.GetLeaderLineOffset">
            <summary>
            A non-negative number that represents the length of the leader line offset, which is the amount of empty space
            between the endpoints of the annotation and the beginning of the leader lines.
            </summary>
            <returns>
            a non-negative number that represents the length of the leader line offset,
            or null if leader line offset is not set.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfLineAnnotation.SetLeaderLineOffset(System.Single)">
            <summary>
            Sets the length of the leader line offset, which is the amount of empty space between the endpoints of the
            annotation and the beginning of the leader lines.
            </summary>
            <param name="leaderLineOffset">a non-negative number that represents the length of the leader line offset.
                </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfLineAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfLineAnnotation.GetContentsAsCaption">
            <summary>
            If true, the text specified by the
            <see cref="F:iText.Kernel.Pdf.PdfName.Contents"/>
            or
            <see cref="F:iText.Kernel.Pdf.PdfName.RC"/>
            entries
            (see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetContents"/>
            and
            <see cref="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.GetRichText"/>
            )
            is replicated as a caption in the appearance of the line.
            </summary>
            <returns>
            true, if the annotation text is replicated as a caption, false otherwise. If this property is
            not set, default value is used which is <i>false</i>.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfLineAnnotation.SetContentsAsCaption(System.Boolean)">
            <summary>
            If set to true, the text specified by the
            <see cref="F:iText.Kernel.Pdf.PdfName.Contents"/>
            or
            <see cref="F:iText.Kernel.Pdf.PdfName.RC"/>
            entries
            (see
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.GetContents"/>
            and
            <see cref="M:iText.Kernel.Pdf.Annot.PdfMarkupAnnotation.GetRichText"/>
            )
            will be replicated as a caption in the appearance of the line.
            </summary>
            <param name="contentsAsCaption">true, if the annotation text should be replicated as a caption, false otherwise.
                </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfLineAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfLineAnnotation.GetCaptionPosition">
            <summary>A name describing the annotation's caption positioning.</summary>
            <remarks>
            A name describing the annotation's caption positioning. Valid values are
            <see cref="F:iText.Kernel.Pdf.PdfName.Inline"/>
            , meaning the caption
            is centered inside the line, and
            <see cref="F:iText.Kernel.Pdf.PdfName.Top"/>
            , meaning the caption is on top of the line.
            </remarks>
            <returns>
            a name describing the annotation's caption positioning, or null if the caption positioning is not
            explicitly defined (in this case the default value is used, which is
            <see cref="F:iText.Kernel.Pdf.PdfName.Inline"/>
            ).
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfLineAnnotation.SetCaptionPosition(iText.Kernel.Pdf.PdfName)">
            <summary>Sets annotation's caption positioning.</summary>
            <remarks>
            Sets annotation's caption positioning. Valid values are
            <see cref="F:iText.Kernel.Pdf.PdfName.Inline"/>
            , meaning the caption
            is centered inside the line, and
            <see cref="F:iText.Kernel.Pdf.PdfName.Top"/>
            , meaning the caption is on top of the line.
            </remarks>
            <param name="captionPosition">a name describing the annotation's caption positioning.</param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfLineAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfLineAnnotation.GetMeasure">
            <summary>A measure dictionary (see ISO-320001, Table 261) that specifies the scale and units that apply to the line annotation.
                </summary>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            that represents a measure dictionary.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfLineAnnotation.SetMeasure(iText.Kernel.Pdf.PdfDictionary)">
            <summary>Sets a measure dictionary that specifies the scale and units that apply to the line annotation.</summary>
            <param name="measure">
            a
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            that represents a measure dictionary, see ISO-320001, Table 261 for valid
            contents specification.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfLineAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfLineAnnotation.GetCaptionOffset">
            <summary>An array of two numbers that specifies the offset of the caption text from its normal position.</summary>
            <remarks>
            An array of two numbers that specifies the offset of the caption text from its normal position.
            The first value is the horizontal offset along the annotation line from its midpoint, with a positive value
            indicating offset to the right and a negative value indicating offset to the left. The second value is the vertical
            offset perpendicular to the annotation line, with a positive value indicating a shift up and a negative value indicating
            a shift down.
            </remarks>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            of two numbers that specifies the offset of the caption text from its normal position,
            or null if caption offset is not explicitly specified (in this case a default value is used, which is [0, 0]).
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfLineAnnotation.SetCaptionOffset(iText.Kernel.Pdf.PdfArray)">
            <summary>Sets the offset of the caption text from its normal position.</summary>
            <param name="captionOffset">
            a
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            of two numbers that specifies the offset of the caption text from its
            normal position. The first value defines the horizontal offset along the annotation line from
            its midpoint, with a positive value indicating offset to the right and a negative value indicating
            offset to the left. The second value defines the vertical offset perpendicular to the annotation line,
            with a positive value indicating a shift up and a negative value indicating a shift down.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfLineAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfLineAnnotation.SetCaptionOffset(System.Single[])">
            <summary>Sets the offset of the caption text from its normal position.</summary>
            <param name="captionOffset">
            an array of two floats that specifies the offset of the caption text from its
            normal position. The first value defines the horizontal offset along the annotation line from
            its midpoint, with a positive value indicating offset to the right and a negative value indicating
            offset to the left. The second value defines the vertical offset perpendicular to the annotation line,
            with a positive value indicating a shift up and a negative value indicating a shift down.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfLineAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="F:iText.Kernel.Pdf.Annot.PdfLinkAnnotation.None">
            <summary>Highlight modes.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Annot.PdfPolyGeomAnnotation.Polygon">
            <summary>Subtypes</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfSoundAnnotation.#ctor(iText.Kernel.Pdf.PdfDocument,iText.Kernel.Geom.Rectangle,System.IO.Stream,System.Single,iText.Kernel.Pdf.PdfName,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="F:iText.Kernel.Pdf.Annot.PdfTextMarkupAnnotation.MarkupHighlight">
            <summary>Subtypes</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Pdf.Annot.PdfTextMarkupAnnotation.CreateHighLight(iText.Kernel.Geom.Rectangle,System.Single[])" -->
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Pdf.Annot.PdfTextMarkupAnnotation.CreateUnderline(iText.Kernel.Geom.Rectangle,System.Single[])" -->
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Pdf.Annot.PdfTextMarkupAnnotation.CreateStrikeout(iText.Kernel.Geom.Rectangle,System.Single[])" -->
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Pdf.Annot.PdfTextMarkupAnnotation.CreateSquiggly(iText.Kernel.Geom.Rectangle,System.Single[])" -->
        <member name="T:iText.Kernel.Pdf.Annot.PdfTrapNetworkAnnotation">
            <summary>
            A
            <see cref="T:iText.Kernel.Pdf.Annot.PdfTrapNetworkAnnotation"/>
            may be used to define the trapping characteristics for a page
            of a PDF document. Trapping is the process of adding marks to a page along colour boundaries
            to avoid unwanted visual artifacts resulting from misregistration of colorants when the page is printed.
            See ISO-320001 14.11.6 "Trapping Support" and 14.11.6.2 "Trap Network Annotations" in particular.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfTrapNetworkAnnotation.#ctor(iText.Kernel.Geom.Rectangle,iText.Kernel.Pdf.Xobject.PdfFormXObject)">
            <summary>
            Creates a
            <see cref="T:iText.Kernel.Pdf.Annot.PdfTrapNetworkAnnotation"/>
            instance. Note that there shall be at most one trap network annotation
            per page, which shall be the last element in the page’s Annots array.
            </summary>
            <param name="rect">
            the annotation rectangle, defining the location of the annotation on the page
            in default user space units. See
            <see cref="M:iText.Kernel.Pdf.Annot.PdfAnnotation.SetRectangle(iText.Kernel.Pdf.PdfArray)"/>
            .
            </param>
            <param name="appearanceStream">
            the form XObject defining a trap network which body contains the graphics objects needed
            to paint the traps making up the trap network. Process colour model shall be defined for the
            appearance stream (see
            <see cref="M:iText.Kernel.Pdf.Xobject.PdfFormXObject.SetProcessColorModel(iText.Kernel.Pdf.PdfName)"/>
            .
            See also ISO-320001 Table 367 "Additional entries specific to a trap network appearance stream".
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfTrapNetworkAnnotation.#ctor(iText.Kernel.Pdf.PdfDictionary)">
            <summary>
            Creates a
            <see cref="T:iText.Kernel.Pdf.Annot.PdfLineAnnotation"/>
            instance from the given
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            that represents annotation object. This method is useful for property reading in reading mode or
            modifying in stamping mode.
            </summary>
            <param name="pdfObject">
            a
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            that represents existing annotation in the document.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfTrapNetworkAnnotation.GetSubtype">
            <summary><inheritDoc/></summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Pdf.Annot.PdfTrapNetworkAnnotation.SetLastModified(iText.Kernel.Pdf.PdfDate)" -->
        <member name="M:iText.Kernel.Pdf.Annot.PdfTrapNetworkAnnotation.GetLastModified">
            <summary>The date and time when the trap network was most recently modified.</summary>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.PdfString"/>
            with date. The format should be a date string as described
            in ISO-320001 7.9.4, “Dates”. See also
            <see cref="M:iText.Kernel.Pdf.PdfDate.Decode(System.String)"/>
            .
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Pdf.Annot.PdfTrapNetworkAnnotation.SetVersion(iText.Kernel.Pdf.PdfArray)" -->
        <member name="M:iText.Kernel.Pdf.Annot.PdfTrapNetworkAnnotation.GetVersion">
            <summary>
            An unordered array of all objects present in the page description at the time the trap networks were generated
            and that, if changed, could affect the appearance of the page.
            </summary>
            <returns>
            an unordered
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            of all objects present in the page description at the time the trap networks
            were generated.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Pdf.Annot.PdfTrapNetworkAnnotation.SetAnnotStates(iText.Kernel.Pdf.PdfArray)" -->
        <member name="M:iText.Kernel.Pdf.Annot.PdfTrapNetworkAnnotation.GetAnnotStates">
            <summary>An array of name objects representing the appearance states for annotations associated with the page.
                </summary>
            <remarks>
            An array of name objects representing the appearance states for annotations associated with the page.
            See also
            <see cref="M:iText.Kernel.Pdf.Annot.PdfTrapNetworkAnnotation.SetAnnotStates(iText.Kernel.Pdf.PdfArray)"/>
            .
            </remarks>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            of name objects representing the appearance states for annotations associated with the page,
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfTrapNetworkAnnotation.SetFauxedFonts(iText.Kernel.Pdf.PdfArray)">
            <summary>
            An array of font dictionaries representing fonts that were fauxed (replaced by substitute fonts) during the
            generation of trap networks for the page.
            </summary>
            <param name="fauxedFonts">
            a
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            of
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            each of which represent font in the document.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfTrapNetworkAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfTrapNetworkAnnotation.SetFauxedFonts(System.Collections.Generic.IList{iText.Kernel.Font.PdfFont})">
            <summary>
            A list of font dictionaries representing fonts that were fauxed (replaced by substitute fonts) during the
            generation of trap networks for the page.
            </summary>
            <param name="fauxedFonts">
            a
            <see cref="!:System.Collections.IList&lt;E&gt;"/>
            of
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            objects.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Annot.PdfTrapNetworkAnnotation"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfTrapNetworkAnnotation.GetFauxedFonts">
            <summary>
            An array of font dictionaries representing fonts that were fauxed (replaced by substitute fonts) during the
            generation of trap networks for the page.
            </summary>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            of
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            each of which represent font in the document.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfWidgetAnnotation.SetHighlightMode(iText.Kernel.Pdf.PdfName)">
            <summary>Setter for the annotation's highlighting mode.</summary>
            <remarks>
            Setter for the annotation's highlighting mode. Possible values are
            <ul>
            <li>
            <see cref="F:iText.Kernel.Pdf.Annot.PdfAnnotation.HIGHLIGHT_NONE"/>
            - No highlighting.</li>
            <li>
            <see cref="F:iText.Kernel.Pdf.Annot.PdfAnnotation.HIGHLIGHT_INVERT"/>
            - Invert the contents of the annotation rectangle.</li>
            <li>
            <see cref="F:iText.Kernel.Pdf.Annot.PdfAnnotation.HIGHLIGHT_OUTLINE"/>
            - Invert the annotation's border.</li>
            <li>
            <see cref="F:iText.Kernel.Pdf.Annot.PdfAnnotation.HIGHLIGHT_PUSH"/>
            - Display the annotation?s down appearance, if any.</li>
            <li>
            <see cref="F:iText.Kernel.Pdf.Annot.PdfAnnotation.HIGHLIGHT_TOGGLE"/>
            - Same as P.</li>
            </ul>
            </remarks>
            <param name="mode">The new value for the annotation's highlighting mode.</param>
            <returns>The widget annotation which this method was called on.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfWidgetAnnotation.GetHighlightMode">
            <summary>Getter for the annotation's highlighting mode.</summary>
            <returns>Current value of the annotation's highlighting mode.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfWidgetAnnotation.ReleaseFormFieldFromWidgetAnnotation">
            <summary>This method removes all widget annotation entries from the form field  the given annotation merged with.
                </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Annot.PdfWidgetAnnotation.SetVisibility(System.Int32)">
            <summary>
            Set the visibility flags of the Widget annotation
            Options are: HIDDEN, HIDDEN_BUT_PRINTABLE, VISIBLE, VISIBLE_BUT_DOES_NOT_PRINT
            </summary>
            <param name="visibility">visibility option</param>
            <returns>the edited widget annotation</returns>
        </member>
        <member name="T:iText.Kernel.Pdf.ByteBufferOutputStream">
            <summary>Acts like a <CODE>StringBuffer</CODE> but works with <CODE>byte</CODE> arrays.
            	</summary>
            <remarks>
            Acts like a <CODE>StringBuffer</CODE> but works with <CODE>byte</CODE> arrays.
            Floating point is converted to a format suitable to the PDF.
            </remarks>
            <author>Paulo Soares</author>
        </member>
        <member name="F:iText.Kernel.Pdf.ByteBufferOutputStream.count">
            <summary>The count of bytes in the buffer.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.ByteBufferOutputStream.buf">
            <summary>The buffer where the bytes are stored.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.ByteBufferOutputStream.HIGH_PRECISION">
            <summary>If <CODE>true</CODE> always output floating point numbers with 6 decimal digits.
            	</summary>
            <remarks>
            If <CODE>true</CODE> always output floating point numbers with 6 decimal digits.
            If <CODE>false</CODE> uses the faster, although less precise, representation.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.ByteBufferOutputStream.#ctor">
            <summary>Creates new ByteBufferOutputStream with capacity 128</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.ByteBufferOutputStream.#ctor(System.Int32)">
            <summary>Creates a byte buffer with a certain capacity.</summary>
            <param name="size">the initial capacity</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Pdf.ByteBufferOutputStream.SetCacheSize(System.Int32)" -->
        <member name="M:iText.Kernel.Pdf.ByteBufferOutputStream.FillCache(System.Int32)">
            <summary>You can fill the cache in advance if you want to.</summary>
            <param name="decimals"/>
        </member>
        <member name="M:iText.Kernel.Pdf.ByteBufferOutputStream.Append_i(System.Int32)">
            <summary>Appends an <CODE>int</CODE>.</summary>
            <remarks>Appends an <CODE>int</CODE>. The size of the array will grow by one.</remarks>
            <param name="b">the int to be appended</param>
            <returns>a reference to this <CODE>ByteBufferOutputStream</CODE> object</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.ByteBufferOutputStream.Append(System.Byte[],System.Int32,System.Int32)">
            <summary>Appends the subarray of the <CODE>byte</CODE> array.</summary>
            <remarks>
            Appends the subarray of the <CODE>byte</CODE> array. The buffer will grow by
            <CODE>len</CODE> bytes.
            </remarks>
            <param name="b">the array to be appended</param>
            <param name="off">the offset to the start of the array</param>
            <param name="len">the length of bytes to append</param>
            <returns>a reference to this <CODE>ByteBufferOutputStream</CODE> object</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.ByteBufferOutputStream.Append(System.Byte[])">
            <summary>Appends an array of bytes.</summary>
            <param name="b">the array to be appended</param>
            <returns>a reference to this <CODE>ByteBufferOutputStream</CODE> object</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.ByteBufferOutputStream.Append(System.String)">
            <summary>Appends a <CODE>String</CODE> to the buffer.</summary>
            <remarks>
            Appends a <CODE>String</CODE> to the buffer. The <CODE>String</CODE> is
            converted according to the encoding ISO-8859-1.
            </remarks>
            <param name="str">the <CODE>String</CODE> to be appended</param>
            <returns>a reference to this <CODE>ByteBufferOutputStream</CODE> object</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.ByteBufferOutputStream.Append(System.Char)">
            <summary>Appends a <CODE>char</CODE> to the buffer.</summary>
            <remarks>
            Appends a <CODE>char</CODE> to the buffer. The <CODE>char</CODE> is
            converted according to the encoding ISO-8859-1.
            </remarks>
            <param name="c">the <CODE>char</CODE> to be appended</param>
            <returns>a reference to this <CODE>ByteBufferOutputStream</CODE> object</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.ByteBufferOutputStream.Append(iText.Kernel.Pdf.ByteBufferOutputStream)">
            <summary>Appends another <CODE>ByteBufferOutputStream</CODE> to this buffer.</summary>
            <param name="buf">the <CODE>ByteBufferOutputStream</CODE> to be appended</param>
            <returns>a reference to this <CODE>ByteBufferOutputStream</CODE> object</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.ByteBufferOutputStream.Append(System.Int32)">
            <summary>Appends the string representation of an <CODE>int</CODE>.</summary>
            <param name="i">the <CODE>int</CODE> to be appended</param>
            <returns>a reference to this <CODE>ByteBufferOutputStream</CODE> object</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.ByteBufferOutputStream.Append(System.Int64)">
            <summary>Appends the string representation of a <CODE>long</CODE>.</summary>
            <param name="i">the <CODE>long</CODE> to be appended</param>
            <returns>a reference to this <CODE>ByteBufferOutputStream</CODE> object</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.ByteBufferOutputStream.Append(System.Single)">
            <summary>
            Appends a string representation of a <CODE>float</CODE> according
            to the Pdf conventions.
            </summary>
            <param name="i">the <CODE>float</CODE> to be appended</param>
            <returns>a reference to this <CODE>ByteBufferOutputStream</CODE> object</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.ByteBufferOutputStream.Append(System.Double)">
            <summary>
            Appends a string representation of a <CODE>double</CODE> according
            to the Pdf conventions.
            </summary>
            <param name="d">the <CODE>double</CODE> to be appended</param>
            <returns>a reference to this <CODE>ByteBufferOutputStream</CODE> object</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.ByteBufferOutputStream.FormatDouble(System.Double)">
            <summary>Outputs a <CODE>double</CODE> into a format suitable for the PDF.</summary>
            <param name="d">a double</param>
            <returns>the <CODE>String</CODE> representation of the <CODE>double</CODE></returns>
        </member>
        <member name="M:iText.Kernel.Pdf.ByteBufferOutputStream.FormatDouble(System.Double,iText.Kernel.Pdf.ByteBufferOutputStream)">
            <summary>Outputs a <CODE>double</CODE> into a format suitable for the PDF.</summary>
            <param name="d">a double</param>
            <param name="buf">a ByteBufferOutputStream</param>
            <returns>
            the <CODE>String</CODE> representation of the <CODE>double</CODE> if
            <CODE>buf</CODE> is <CODE>null</CODE>. If <CODE>buf</CODE> is <B>not</B> <CODE>null</CODE>,
            then the double is appended directly to the buffer and this methods returns <CODE>null</CODE>.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.ByteBufferOutputStream.Reset">
            <summary>Sets the size to zero.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.ByteBufferOutputStream.ToByteArray">
            <summary>Creates a newly allocated byte array.</summary>
            <remarks>
            Creates a newly allocated byte array. Its size is the current
            size of this output stream and the valid contents of the buffer
            have been copied into it.
            </remarks>
            <returns>the current contents of this output stream, as a byte array.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.ByteBufferOutputStream.Size">
            <summary>Returns the current size of the buffer.</summary>
            <returns>the value of the <code>count</code> field, which is the number of valid bytes in this byte buffer.
            	</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.ByteBufferOutputStream.ToString">
            <summary>
            Converts the buffer's contents into a string, translating bytes into
            characters according to the platform's default character encoding.
            </summary>
            <returns>String translated from the buffer's contents.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.ByteBufferOutputStream.ToString(System.String)">
            <summary>
            Converts the buffer's contents into a string, translating bytes into
            characters according to the specified character encoding.
            </summary>
            <param name="enc">a character-encoding name.</param>
            <returns>String translated from the buffer's contents.</returns>
            <exception cref="T:System.ArgumentException">If the named encoding is not supported.
            	</exception>
        </member>
        <member name="M:iText.Kernel.Pdf.ByteBufferOutputStream.WriteTo(System.IO.Stream)">
            <summary>
            Writes the complete contents of this byte buffer output to
            the specified output stream argument, as if by calling the output
            stream's write method using <code>out.write(buf, 0, count)</code>.
            </summary>
            <param name="out">the output stream to which to write the data.</param>
            <exception>
            java.io.IOException
            if an I/O error occurs.
            </exception>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.ByteBufferOutputStream.Write(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.ByteBufferOutputStream.ConvertToBytes(System.Int32)">
            <summary>Converts an double (multiplied by 100 and cast to an int) into an array of bytes.
            	</summary>
            <param name="i">the int</param>
            <returns>a byte array</returns>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.CanvasArtifact">
            <summary>
            A subclass of
            <see cref="T:iText.Kernel.Pdf.Canvas.CanvasTag"/>
            for Artifacts.
            In Tagged PDF, an object can be marked as an Artifact in order to signify
            that it is more part of the document structure than of the document content.
            Examples are page headers, layout features, etc. Screen readers can choose to
            ignore Artifacts.
            </summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.CanvasTag">
            <summary>This class represents a single tag on a single piece of marked content.</summary>
            <remarks>
            This class represents a single tag on a single piece of marked content.
            <p>
            In Tagged PDF, a tag is the basic structure unit for marking content. The tag
            structure and hierarchy is largely comparable to HTML. As in HTML, every tag
            type has a name, defined here in the <code>role</code> attribute. The tagging
            mechanism in Tagged PDF is extensible, so PDF creators can choose to create
            custom tags.</p>
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.CanvasTag.role">
            <summary>The type of the tag.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.CanvasTag.properties">
            <summary>The properties of the tag.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.CanvasTag.#ctor(iText.Kernel.Pdf.PdfName)">
            <summary>Creates a tag that is referenced to the document's tag structure (i.e.</summary>
            <remarks>
            Creates a tag that is referenced to the document's tag structure (i.e.
            logical structure).
            </remarks>
            <param name="role">the type of tag</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.CanvasTag.#ctor(iText.Kernel.Pdf.PdfName,System.Int32)">
            <summary>Creates a tag that is referenced to the document's tag structure (i.e.</summary>
            <remarks>
            Creates a tag that is referenced to the document's tag structure (i.e.
            logical structure).
            </remarks>
            <param name="role">the type of tag</param>
            <param name="mcid">marked content id which serves as a reference to the document's logical structure</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.CanvasTag.#ctor(iText.Kernel.Pdf.Tagging.PdfMcr)">
            <summary>Creates a tag that is referenced to the document's tag structure (i.e.</summary>
            <remarks>
            Creates a tag that is referenced to the document's tag structure (i.e.
            logical structure).
            </remarks>
            <param name="mcr">
            the
            <see cref="T:iText.Kernel.Pdf.Tagging.PdfMcr">Marked Content Reference</see>
            wrapper object
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.CanvasTag.GetRole">
            <summary>Get the role of the tag.</summary>
            <returns>the role of the tag as a PdfName</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.CanvasTag.GetMcid">
            <summary>Get the marked content id of the tag.</summary>
            <returns>marked content id</returns>
            <exception cref="T:System.InvalidOperationException">if there is no MCID</exception>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.CanvasTag.HasMcid">
            <summary>Determine if an MCID is available</summary>
            <returns>true if the MCID is available, false otherwise</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.CanvasTag.SetProperties(iText.Kernel.Pdf.PdfDictionary)">
            <summary>
            Adds a dictionary of properties to the
            <see cref="T:iText.Kernel.Pdf.Canvas.CanvasTag">tag</see>
            's properties.
            </summary>
            <param name="properties">a dictionary</param>
            <returns>
            current
            <see cref="T:iText.Kernel.Pdf.Canvas.CanvasTag"/>
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.CanvasTag.AddProperty(iText.Kernel.Pdf.PdfName,iText.Kernel.Pdf.PdfObject)">
            <summary>
            Adds a single property to the
            <see cref="T:iText.Kernel.Pdf.Canvas.CanvasTag">tag</see>
            's properties.
            </summary>
            <param name="name">a key</param>
            <param name="value">the value for the key</param>
            <returns>
            current
            <see cref="T:iText.Kernel.Pdf.Canvas.CanvasTag"/>
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.CanvasTag.RemoveProperty(iText.Kernel.Pdf.PdfName)">
            <summary>
            Removes a single property from the
            <see cref="T:iText.Kernel.Pdf.Canvas.CanvasTag">tag</see>
            's properties.
            </summary>
            <param name="name">the key of the key-value pair to be removed</param>
            <returns>
            current
            <see cref="T:iText.Kernel.Pdf.Canvas.CanvasTag"/>
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.CanvasTag.GetProperty(iText.Kernel.Pdf.PdfName)">
            <summary>
            Gets a property from the
            <see cref="T:iText.Kernel.Pdf.Canvas.CanvasTag">tag</see>
            's properties dictionary.
            </summary>
            <param name="name">the key of the key-value pair to be retrieved</param>
            <returns>the value corresponding to the key</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.CanvasTag.GetProperties">
            <summary>Get the properties of the tag.</summary>
            <returns>properties of the tag</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.CanvasArtifact.#ctor">
            <summary>
            Creates a CanvasArtifact object, which is a
            <see cref="T:iText.Kernel.Pdf.Canvas.CanvasTag"/>
            with a role
            of
            <see cref="F:iText.Kernel.Pdf.PdfName.Artifact">Artifact</see>
            .
            </summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.CanvasGraphicsState">
            <summary>This class is designed for internal usage.</summary>
            <remarks>
            This class is designed for internal usage. <br />
            Use <code>PdfExtGState</code> class and <code>PdfCanvas#setExtGState()</code> method for setting extended graphics properties.
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "F:iText.Kernel.Pdf.Canvas.CanvasGraphicsState.ctm" -->
        <!-- Badly formed XML comment ignored for member "F:iText.Kernel.Pdf.Canvas.CanvasGraphicsState.dashPattern" -->
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Pdf.Canvas.CanvasGraphicsState.#ctor" -->
        <member name="M:iText.Kernel.Pdf.Canvas.CanvasGraphicsState.#ctor(iText.Kernel.Pdf.Canvas.CanvasGraphicsState)">
            <summary>Copy constructor.</summary>
            <param name="source">the Graphics State to copy from</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.CanvasGraphicsState.UpdateFromExtGState(iText.Kernel.Pdf.PdfDictionary)">
            <summary>Updates this object with the values from a dictionary.</summary>
            <param name="extGState">the dictionary containing source parameters</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.CanvasGraphicsState.GetCtm">
            <returns>current transformation matrix.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.CanvasGraphicsState.UpdateCtm(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>Updates current transformation matrix.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.CanvasGraphicsState.UpdateCtm(iText.Kernel.Geom.Matrix)">
            <summary>Updates current transformation matrix.</summary>
            <param name="newCtm">new current transformation matrix.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.CanvasGraphicsState.UpdateFromExtGState(iText.Kernel.Pdf.Extgstate.PdfExtGState)">
            <summary>Updates current graphic state with values from extended graphic state dictionary.</summary>
            <param name="extGState">the wrapper around the extended graphic state dictionary</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.CanvasGraphicsState.UpdateFromExtGState(iText.Kernel.Pdf.Extgstate.PdfExtGState,iText.Kernel.Pdf.PdfDocument)">
            <summary>Updates current graphic state with values from extended graphic state dictionary.</summary>
            <param name="extGState">the wrapper around the extended graphic state dictionary</param>
            <param name="pdfDocument">the document to retrieve fonts from. Needed when the newly created fonts are used
                </param>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Draw.DashedLine">
            <summary>
            Implementation of
            <see cref="T:iText.Kernel.Pdf.Canvas.Draw.ILineDrawer"/>
            which draws a dashed horizontal line over
            the middle of the specified rectangle.
            </summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Draw.ILineDrawer">
            <summary>
            The
            <see cref="T:iText.Kernel.Pdf.Canvas.Draw.ILineDrawer"/>
            defines a drawing operation on a
            <see cref="T:iText.Kernel.Pdf.Canvas.PdfCanvas"/>
            <p/>
            This interface allows to customize the 'empty' space in a
            <c>com.itextpdf.layout.element.TabStop</c>
            through a Strategy design
            pattern
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Draw.ILineDrawer.Draw(iText.Kernel.Pdf.Canvas.PdfCanvas,iText.Kernel.Geom.Rectangle)">
            <summary>
            Performs configurable drawing operations related to specific region
            coordinates on a canvas.
            </summary>
            <param name="canvas">the canvas to draw on</param>
            <param name="drawArea">
            the rectangle in relation to which to fulfill drawing
            instructions
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Draw.ILineDrawer.GetLineWidth">
            <summary>Gets the width of the line</summary>
            <returns>width of the line</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Draw.ILineDrawer.SetLineWidth(System.Single)">
            <summary>Sets line width in points</summary>
            <param name="lineWidth">new line width</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Draw.ILineDrawer.GetColor">
            <summary>Gets the color of the line</summary>
            <returns>color of the line</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Draw.ILineDrawer.SetColor(iText.Kernel.Colors.Color)">
            <summary>Sets line color</summary>
            <param name="color">new line color</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Draw.DashedLine.#ctor(System.Single)">
            <summary>
            Creates an instance of
            <see cref="T:iText.Kernel.Pdf.Canvas.Draw.DashedLine"/>
            with the specified line width.
            </summary>
            <param name="lineWidth"/>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Draw.DashedLine.GetLineWidth">
            <summary>Gets line width in points</summary>
            <returns>line thickness</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Draw.DashedLine.SetLineWidth(System.Single)">
            <summary>Sets line width in points</summary>
            <param name="lineWidth">new line width</param>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Draw.DottedLine">
            <summary>
            Implementation of
            <see cref="T:iText.Kernel.Pdf.Canvas.Draw.ILineDrawer"/>
            which draws a dotted horizontal line along
            the bottom edge of the specified rectangle.
            </summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Draw.DottedLine.gap">
            <summary>the gap between the dots.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Draw.DottedLine.#ctor">
            <summary>Constructs a dotted horizontal line which will be drawn along the bottom edge of the specified rectangle.
                </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Draw.DottedLine.#ctor(System.Single,System.Single)">
            <summary>Constructs a dotted horizontal line which will be drawn along the bottom edge of the specified rectangle.
                </summary>
            <param name="lineWidth">the width of the line</param>
            <param name="gap">the gap between the center of the dots of the dotted line.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Draw.DottedLine.#ctor(System.Single)">
            <summary>Constructs a dotted horizontal line which will be drawn along the bottom edge of the specified rectangle.
                </summary>
            <param name="lineWidth">the width of the line</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Draw.DottedLine.GetGap">
            <summary>Getter for the gap between the center of the dots of the dotted line.</summary>
            <returns>the gap between the center of the dots</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Draw.DottedLine.SetGap(System.Single)">
            <summary>Setter for the gap between the center of the dots of the dotted line.</summary>
            <param name="gap">the gap between the center of the dots</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Draw.DottedLine.GetLineWidth">
            <summary>Gets line width in points</summary>
            <returns>line thickness</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Draw.DottedLine.SetLineWidth(System.Single)">
            <summary>Sets line width in points</summary>
            <param name="lineWidth">new line width</param>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Draw.SolidLine">
            <summary>
            Implementation of
            <see cref="T:iText.Kernel.Pdf.Canvas.Draw.ILineDrawer"/>
            which draws a solid horizontal line along
            the bottom edge of the specified rectangle.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Draw.SolidLine.#ctor">
            <summary>Constructs an instance of solid line drawer</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Draw.SolidLine.#ctor(System.Single)">
            <summary>Constructs an instance of solid line drawer with the specified line thickness</summary>
            <param name="lineWidth">line width</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Draw.SolidLine.GetLineWidth">
            <summary>Gets line width in points</summary>
            <returns>line thickness</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Draw.SolidLine.SetLineWidth(System.Single)">
            <summary>Sets line width in points</summary>
            <param name="lineWidth">new line width</param>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.ClipperLib.ClipperBridge">
            <summary>
            This class contains variety of methods allowing to convert iText
            abstractions into the abstractions of the Clipper library and vise versa.
            </summary>
            <remarks>
            This class contains variety of methods allowing to convert iText
            abstractions into the abstractions of the Clipper library and vise versa.
            <p>
            For example:
            <ul>
            <li>
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.ClipperLib.PolyTree"/>
            to
            <see cref="T:iText.Kernel.Geom.Path"/>
            </li>
            <li>
            <see cref="T:iText.Kernel.Geom.Point"/>
            to
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.ClipperLib.IntPoint"/>
            </li>
            <li>
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.ClipperLib.IntPoint"/>
            to
            <see cref="T:iText.Kernel.Geom.Point"/>
            </li>
            </ul>
            </p>
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Parser.ClipperLib.ClipperBridge.floatMultiplier">
            <summary>
            Since the clipper library uses integer coordinates, we should convert
            our floating point numbers into fixed point numbers by multiplying by
            this coefficient.
            </summary>
            <remarks>
            Since the clipper library uses integer coordinates, we should convert
            our floating point numbers into fixed point numbers by multiplying by
            this coefficient. Vary it to adjust the preciseness of the calculations.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.ClipperLib.ClipperBridge.ConvertToPath(iText.Kernel.Pdf.Canvas.Parser.ClipperLib.PolyTree)">
            <summary>
            Converts Clipper library
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.ClipperLib.PolyTree"/>
            abstraction into iText
            <see cref="T:iText.Kernel.Geom.Path"/>
            object.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Pdf.Canvas.Parser.ClipperLib.ClipperBridge.AddPath(iText.Kernel.Pdf.Canvas.Parser.ClipperLib.Clipper,iText.Kernel.Geom.Path,iText.Kernel.Pdf.Canvas.Parser.ClipperLib.PolyType)" -->
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Pdf.Canvas.Parser.ClipperLib.ClipperBridge.AddPath(iText.Kernel.Pdf.Canvas.Parser.ClipperLib.ClipperOffset,iText.Kernel.Geom.Path,iText.Kernel.Pdf.Canvas.Parser.ClipperLib.JoinType,iText.Kernel.Pdf.Canvas.Parser.ClipperLib.EndType)" -->
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.ClipperLib.ClipperBridge.ConvertToFloatPoints(System.Collections.Generic.IList{iText.Kernel.Pdf.Canvas.Parser.ClipperLib.IntPoint})">
            <summary>
            Converts list of
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.ClipperLib.IntPoint"/>
            objects into list of
            <see cref="T:iText.Kernel.Geom.Point"/>
            objects.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.ClipperLib.ClipperBridge.ConvertToLongPoints(System.Collections.Generic.IList{iText.Kernel.Geom.Point})">
            <summary>
            Converts list of
            <see cref="T:iText.Kernel.Geom.Point"/>
            objects into list of
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.ClipperLib.IntPoint"/>
            objects.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.ClipperLib.ClipperBridge.GetJoinType(System.Int32)">
            <summary>
            Converts iText line join style constant into the corresponding constant
            of the Clipper library.
            </summary>
            <param name="lineJoinStyle">
            iText line join style constant. See
            <see cref="T:iText.Kernel.Pdf.Canvas.PdfCanvasConstants"/>
            </param>
            <returns>Clipper line join style constant.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.ClipperLib.ClipperBridge.GetEndType(System.Int32)">
            <summary>
            Converts iText line cap style constant into the corresponding constant
            of the Clipper library.
            </summary>
            <param name="lineCapStyle">
            iText line cap style constant. See
            <see cref="T:iText.Kernel.Pdf.Canvas.PdfCanvasConstants"/>
            </param>
            <returns>Clipper line cap (end type) style constant.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.ClipperLib.ClipperBridge.GetFillType(System.Int32)">
            <summary>
            Converts iText filling rule constant into the corresponding constant
            of the Clipper library .
            </summary>
            <param name="fillingRule">
            Either
            <see cref="F:iText.Kernel.Pdf.Canvas.PdfCanvasConstants.FillingRule.NONZERO_WINDING"/>
            or
            <see cref="F:iText.Kernel.Pdf.Canvas.PdfCanvasConstants.FillingRule.EVEN_ODD"/>
            .
            </param>
            <returns>Clipper fill type constant.</returns>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.Data.IEventData">
            <summary>
            Marker interface for the set of classes used to combine
            parameters required for different types of events.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.ClippingPathInfo.#ctor(iText.Kernel.Geom.Path,iText.Kernel.Geom.Matrix)">
            <param name="path">The path to be rendered.</param>
            <param name="ctm">The path to be rendered.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.ClippingPathInfo.GetClippingPath">
            <returns>
            The
            <see cref="T:iText.Kernel.Geom.Path"/>
            which represents current clipping path.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.ClippingPathInfo.GetCtm">
            <returns>Current transformation matrix.</returns>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.Data.ImageRenderInfo">
            <summary>Represents image data from a PDF</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Parser.Data.ImageRenderInfo.ctm">
            <summary>The coordinate transformation matrix that was in effect when the image was rendered</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Parser.Data.ImageRenderInfo.colorSpaceDictionary">
            <summary>the color space dictionary from resources which are associated with the image</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Parser.Data.ImageRenderInfo.isInline">
            <summary>defines if the encountered image was inline</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.ImageRenderInfo.#ctor(iText.Kernel.Geom.Matrix,iText.Kernel.Pdf.PdfStream,iText.Kernel.Pdf.PdfDictionary,System.Boolean)">
            <summary>Create an ImageRenderInfo</summary>
            <param name="ctm">the coordinate transformation matrix at the time the image is rendered</param>
            <param name="stream">image stream object</param>
            <param name="colorSpaceDictionary">the color space dictionary from resources which are associated with the image
                </param>
            <param name="isInline">defines if the encountered image was inline</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.ImageRenderInfo.GetImage">
            <summary>Gets an image wrapped in ImageXObject.</summary>
            <remarks>
            Gets an image wrapped in ImageXObject.
            You can:
            <ul>
            <li>get image bytes with
            <see cref="M:iText.Kernel.Pdf.Xobject.PdfImageXObject.GetImageBytes(System.Boolean)"/>
            , these image bytes
            represent native image, i.e you can write these bytes to disk and get just an usual image;</li>
            <li>obtain PdfStream object which contains image dictionary with
            <see cref="M:iText.Kernel.Pdf.PdfObjectWrapper`1.GetPdfObject"/>
            method;</li>
            <li>convert image to
            <see cref="!:Java.Awt.Image.BufferedImage"/>
            with
            <see cref="!:iText.Kernel.Pdf.Xobject.PdfImageXObject.GetBufferedImage()"/>
            ;</li>
            </ul>
            </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.ImageRenderInfo.GetStartPoint">
            <returns>a vector in User space representing the start point of the image</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.ImageRenderInfo.GetImageCtm">
            <returns>The coordinate transformation matrix which was active when this image was rendered. Coordinates are in User space.
                </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.ImageRenderInfo.GetArea">
            <returns>the size of the image, in User space units</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.ImageRenderInfo.IsInline">
            <returns>true if image was inlined in original stream.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.ImageRenderInfo.GetColorSpaceDictionary">
            <returns>the color space dictionary from resources which are associated with the image</returns>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.Data.PathRenderInfo">
            <summary>Contains information relating to painting current path.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Parser.Data.PathRenderInfo.NO_OP">
            <summary>End the path object without filling or stroking it.</summary>
            <remarks>
            End the path object without filling or stroking it. This operator shall be a path-painting no-op,
            used primarily for the side effect of changing the current clipping path
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Parser.Data.PathRenderInfo.STROKE">
            <summary>Value specifying stroke operation to perform on the current path.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Parser.Data.PathRenderInfo.FILL">
            <summary>Value specifying fill operation to perform on the current path.</summary>
            <remarks>
            Value specifying fill operation to perform on the current path. When the fill operation
            is performed it should use either nonzero winding or even-odd rule.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.PathRenderInfo.#ctor(iText.Kernel.Geom.Path,System.Int32,System.Int32,System.Boolean,System.Int32,iText.Kernel.Pdf.Canvas.CanvasGraphicsState)">
            <param name="path">The path to be rendered.</param>
            <param name="operation">
            One of the possible combinations of
            <see cref="F:iText.Kernel.Pdf.Canvas.Parser.Data.PathRenderInfo.STROKE"/>
            and
            <see cref="F:iText.Kernel.Pdf.Canvas.Parser.Data.PathRenderInfo.FILL"/>
            values or
            <see cref="F:iText.Kernel.Pdf.Canvas.Parser.Data.PathRenderInfo.NO_OP"/>
            </param>
            <param name="rule">
            Either
            <see cref="F:iText.Kernel.Pdf.Canvas.PdfCanvasConstants.FillingRule.NONZERO_WINDING"/>
            or
            <see cref="F:iText.Kernel.Pdf.Canvas.PdfCanvasConstants.FillingRule.EVEN_ODD"/>
            .
            </param>
            <param name="isClip">True indicates that current path modifies the clipping path, false - if not.</param>
            <param name="clipRule">
            Either
            <see cref="F:iText.Kernel.Pdf.Canvas.PdfCanvasConstants.FillingRule.NONZERO_WINDING"/>
            or
            <see cref="F:iText.Kernel.Pdf.Canvas.PdfCanvasConstants.FillingRule.EVEN_ODD"/>
            .
            </param>
            <param name="gs">The graphics state.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Pdf.Canvas.Parser.Data.PathRenderInfo.#ctor(iText.Kernel.Geom.Path,System.Int32,iText.Kernel.Pdf.Canvas.CanvasGraphicsState)" -->
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.PathRenderInfo.GetPath">
            <returns>
            The
            <see cref="T:iText.Kernel.Geom.Path"/>
            to be rendered.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.PathRenderInfo.GetOperation">
            <returns>
            <CODE>int</CODE> value which is either
            <see cref="F:iText.Kernel.Pdf.Canvas.Parser.Data.PathRenderInfo.NO_OP"/>
            or one of possible
            combinations of
            <see cref="F:iText.Kernel.Pdf.Canvas.Parser.Data.PathRenderInfo.STROKE"/>
            and
            <see cref="F:iText.Kernel.Pdf.Canvas.Parser.Data.PathRenderInfo.FILL"/>
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.PathRenderInfo.GetRule">
            <returns>
            Either
            <see cref="F:iText.Kernel.Pdf.Canvas.PdfCanvasConstants.FillingRule.NONZERO_WINDING"/>
            or
            <see cref="F:iText.Kernel.Pdf.Canvas.PdfCanvasConstants.FillingRule.EVEN_ODD"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.PathRenderInfo.IsPathModifiesClippingPath">
            <returns>true indicates that current path modifies the clipping path, false - if not.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.PathRenderInfo.GetClippingRule">
            <returns>
            Either
            <see cref="F:iText.Kernel.Pdf.Canvas.PdfCanvasConstants.FillingRule.NONZERO_WINDING"/>
            or
            <see cref="F:iText.Kernel.Pdf.Canvas.PdfCanvasConstants.FillingRule.EVEN_ODD"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.PathRenderInfo.GetCtm">
            <returns>Current transformation matrix.</returns>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo">
            <summary>
            Provides information and calculations needed by render listeners
            to display/evaluate text render operations.
            </summary>
            <remarks>
            Provides information and calculations needed by render listeners
            to display/evaluate text render operations.
            <br/><br/>
            This is passed between the
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor"/>
            and
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.Listener.IEventListener"/>
            objects as text rendering operations are
            discovered
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.canvasTagHierarchy">
            <summary>Hierarchy of nested canvas tags for the text from the most inner (nearest to text) tag to the most outer.
                </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.#ctor(iText.Kernel.Pdf.PdfString,iText.Kernel.Pdf.Canvas.CanvasGraphicsState,iText.Kernel.Geom.Matrix,System.Collections.Generic.Stack{iText.Kernel.Pdf.Canvas.CanvasTag})">
            <summary>Creates a new TextRenderInfo object</summary>
            <param name="str">the PDF string that should be displayed</param>
            <param name="gs">the graphics state (note: at this time, this is not immutable, so don't cache it)</param>
            <param name="textMatrix">the text matrix at the time of the render operation</param>
            <param name="canvasTagHierarchy">the marked content tags sequence, if available</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.#ctor(iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo,iText.Kernel.Pdf.PdfString,System.Single)">
            <summary>Used for creating sub-TextRenderInfos for each individual character</summary>
            <param name="parent">the parent TextRenderInfo</param>
            <param name="string">the content of a TextRenderInfo</param>
            <param name="horizontalOffset">the unscaled horizontal offset of the character that this TextRenderInfo represents
                </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.GetText">
            <returns>the text to render</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.GetPdfString">
            <returns>original PDF string</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.HasMcid(System.Int32)">
            <summary>
            Checks if the text belongs to a marked content sequence
            with a given mcid.
            </summary>
            <param name="mcid">a marked content id</param>
            <returns>true if the text is marked with this id</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.HasMcid(System.Int32,System.Boolean)">
            <summary>
            Checks if the text belongs to a marked content sequence
            with a given mcid.
            </summary>
            <param name="mcid">a marked content id</param>
            <param name="checkTheTopmostLevelOnly">indicates whether to check the topmost level of marked content stack only
                </param>
            <returns>true if the text is marked with this id</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.GetMcid">
            <returns>the marked content associated with the TextRenderInfo instance.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.GetBaseline">
            <summary>Gets the baseline for the text (i.e.</summary>
            <remarks>
            Gets the baseline for the text (i.e. the line that the text 'sits' on)
            This value includes the Rise of the draw operation - see
            <see cref="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.GetRise"/>
            for the amount added by Rise
            </remarks>
            <returns>the baseline line segment</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.GetAscentLine">
            <summary>Gets the ascentline for the text (i.e.</summary>
            <remarks>
            Gets the ascentline for the text (i.e. the line that represents the topmost extent that a string of the current font could have)
            This value includes the Rise of the draw operation - see
            <see cref="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.GetRise"/>
            for the amount added by Rise
            </remarks>
            <returns>the ascentline line segment</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.GetDescentLine">
            <summary>Gets the descentline for the text (i.e.</summary>
            <remarks>
            Gets the descentline for the text (i.e. the line that represents the bottom most extent that a string of the current font could have).
            This value includes the Rise of the draw operation - see
            <see cref="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.GetRise"/>
            for the amount added by Rise
            </remarks>
            <returns>the descentline line segment</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.GetFont">
            <summary>Getter for the font</summary>
            <returns>the font</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.GetRise">
            <summary>The rise represents how far above the nominal baseline the text should be rendered.</summary>
            <remarks>
            The rise represents how far above the nominal baseline the text should be rendered.  The
            <see cref="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.GetBaseline"/>
            ,
            <see cref="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.GetAscentLine"/>
            and
            <see cref="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.GetDescentLine"/>
            methods already include Rise.
            This method is exposed to allow listeners to determine if an explicit rise was involved in the computation of the baseline (this might be useful, for example, for identifying superscript rendering)
            </remarks>
            <returns>The Rise for the text draw operation, in user space units (Ts value, scaled to user space)</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.GetCharacterRenderInfos">
            <summary>Provides detail useful if a listener needs access to the position of each individual glyph in the text render operation
                </summary>
            <returns>
            A list of
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo"/>
            objects that represent each glyph used in the draw operation. The next effect is if there was a separate Tj opertion for each character in the rendered string
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.GetSingleSpaceWidth">
            <returns>The width, in user space units, of a single space character in the current font</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.GetTextRenderMode">
            <returns>
            the text render mode that should be used for the text.  From the
            PDF specification, this means:
            <ul>
            <li>0 = Fill text</li>
            <li>1 = Stroke text</li>
            <li>2 = Fill, then stroke text</li>
            <li>3 = Invisible</li>
            <li>4 = Fill text and add to path for clipping</li>
            <li>5 = Stroke text and add to path for clipping</li>
            <li>6 = Fill, then stroke text and add to path for clipping</li>
            <li>7 = Add text to padd for clipping</li>
            </ul>
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.GetFillColor">
            <returns>the current fill color.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.GetStrokeColor">
            <returns>the current stroke color.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.GetActualText">
            <summary>Gets /ActualText tag entry value if this text chunk is marked content.</summary>
            <returns>/ActualText value or <code>null</code> if none found</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.GetExpansionText">
            <summary>Gets /E tag (expansion text) entry value if this text chunk is marked content.</summary>
            <returns>/E value or <code>null</code> if none found</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.IsReversedChars">
            <summary>
            Determines if the text represented by this
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo"/>
            instance is written in a text showing operator
            wrapped by /ReversedChars marked content sequence
            </summary>
            <returns><code>true</code> if this text block lies within /ReversedChars block, <code>false</code> otherwise
                </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.GetCanvasTagHierarchy">
            <summary>Gets hierarchy of the canvas tags that wraps given text.</summary>
            <returns>list of the wrapping canvas tags. The first tag is the innermost (nearest to the text).</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.GetUnscaledWidth">
            <returns>the unscaled (i.e. in Text space) width of the text</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.ConvertWidthFromTextSpaceToUserSpace(System.Single)">
            <param name="width">the width, in text space</param>
            <returns>the width in user space</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.ConvertHeightFromTextSpaceToUserSpace(System.Single)">
            <param name="height">the height, in text space</param>
            <returns>the height in user space</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.GetUnscaledFontSpaceWidth">
            <summary>Calculates the width of a space character.</summary>
            <remarks>
            Calculates the width of a space character.  If the font does not define
            a width for a standard space character \u0020, we also attempt to use
            the width of \u00A0 (a non-breaking space in many fonts)
            </remarks>
            <returns>the width of a single space character in text space units</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.GetStringWidth(System.String)">
            <summary>Gets the width of a String in text space units</summary>
            <param name="string">the string that needs measuring</param>
            <returns>the width of a String in text space units</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.GetPdfStringWidth(iText.Kernel.Pdf.PdfString,System.Boolean)">
            <summary>Gets the width of a PDF string in text space units</summary>
            <param name="string">the string that needs measuring</param>
            <returns>the width of a String in text space units</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.GetWidthAndWordSpacing(iText.Kernel.Pdf.PdfString)">
            <summary>Calculates width and word spacing of a single character PDF string.</summary>
            <remarks>
            Calculates width and word spacing of a single character PDF string.
            IMPORTANT: Shall ONLY be used for a single character pdf strings.
            </remarks>
            <param name="string">a character to calculate width.</param>
            <returns>array of 2 items: first item is a character width, second item is a calculated word spacing.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.GetCharCode(System.String)">
            <summary>Converts a single character string to char code.</summary>
            <param name="string">single character string to convert to.</param>
            <returns>char code.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo.SplitString(iText.Kernel.Pdf.PdfString)">
            <summary>Split PDF string into array of single character PDF strings.</summary>
            <param name="string">PDF string to be splitted.</param>
            <returns>splitted PDF string.</returns>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.EventType">
            <summary>Specifies different types of events where a callback should be notified.</summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.Filter.IEventFilter">
            <summary>This is an interface which helps to filter events.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Filter.IEventFilter.Accept(iText.Kernel.Pdf.Canvas.Parser.Data.IEventData,iText.Kernel.Pdf.Canvas.Parser.EventType)">
            <summary>
            This method checks an event and decides whether it should be processed further (corresponds to
            <see langword="true"/>
            return value), or filtered out (corresponds to
            <see langword="false"/>
            return value).
            </summary>
            <param name="data">event data</param>
            <param name="type">event type</param>
            <returns>true to process event further, false to filter event out</returns>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.Filter.TextRegionEventFilter">
            <summary>
            This
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.Filter.IEventFilter"/>
            implementation only accepts text render events within the specified
            rectangular region.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Filter.TextRegionEventFilter.#ctor(iText.Kernel.Geom.Rectangle)">
            <summary>Constructs a filter instance.</summary>
            <param name="filterRect">the rectangle to filter text against</param>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.IContentOperator">
            <summary>Root interface for a series of handlers for content stream operators.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.IContentOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary>Called when a content operator should be processed.</summary>
            <param name="processor">The processor that is dealing with the PDF content stream.</param>
            <param name="operator">The literal PDF syntax of the operator.</param>
            <param name="operands">The operands that come with the operator.</param>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.IXObjectDoHandler">
            <author>Kevin Day</author>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.Listener.CharacterRenderInfo">
            <summary>This class represents a single character and its bounding box</summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.Listener.LocationTextExtractionStrategy.TextChunk">
            <summary>Represents a chunk of text, it's orientation, and location relative to the orientation vector</summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.Listener.ITextExtractionStrategy">
            <summary>
            This is a special interface for
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.Filter.IEventFilter"/>
            that returns text as result of its work.
            </summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.Listener.IEventListener">
            <summary>
            A callback interface that receives notifications from the
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor"/>
            as various events occur (see
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.EventType"/>
            ).
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.IEventListener.EventOccurred(iText.Kernel.Pdf.Canvas.Parser.Data.IEventData,iText.Kernel.Pdf.Canvas.Parser.EventType)">
            <summary>Called when some event occurs during parsing a content stream.</summary>
            <param name="data">Combines the data required for processing corresponding event type.</param>
            <param name="type">Event type.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.IEventListener.GetSupportedEvents">
            <summary>Provides the set of event types this listener supports.</summary>
            <remarks>
            Provides the set of event types this listener supports.
            Returns null if all possible event types are supported.
            </remarks>
            <returns>
            Set of event types supported by this listener or
            null if all possible event types are supported.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.ITextExtractionStrategy.GetResultantText">
            <summary>Returns the text that has been processed so far.</summary>
            <returns>
            
            <see cref="T:System.String"/>
            instance with the current resultant text
            </returns>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Parser.Listener.LocationTextExtractionStrategy.DUMP_STATE">
            <summary>set to true for debugging</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Parser.Listener.LocationTextExtractionStrategy.locationalResult">
            <summary>a summary of all found text</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.LocationTextExtractionStrategy.#ctor">
            <summary>Creates a new text extraction renderer.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.LocationTextExtractionStrategy.#ctor(iText.Kernel.Pdf.Canvas.Parser.Listener.LocationTextExtractionStrategy.ITextChunkLocationStrategy)">
            <summary>
            Creates a new text extraction renderer, with a custom strategy for
            creating new TextChunkLocation objects based on the input of the
            TextRenderInfo.
            </summary>
            <param name="strat">the custom strategy</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.LocationTextExtractionStrategy.SetUseActualText(System.Boolean)">
            <summary>
            Changes the behavior of text extraction so that if the parameter is set to
            <see langword="true"/>
            ,
            /ActualText marked content property will be used instead of raw decoded bytes.
            Beware: the logic is not stable yet.
            </summary>
            <param name="useActualText">true to use /ActualText, false otherwise</param>
            <returns>this object</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.LocationTextExtractionStrategy.SetRightToLeftRunDirection(System.Boolean)">
            <summary>Sets if text flows from left to right or from right to left.</summary>
            <remarks>
            Sets if text flows from left to right or from right to left.
            Call this method with <code>true</code> argument for extracting Arabic, Hebrew or other
            text with right-to-left writing direction.
            </remarks>
            <param name="rightToLeftRunDirection">value specifying whether the direction should be right to left</param>
            <returns>this object</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.LocationTextExtractionStrategy.IsUseActualText">
            <summary>
            Gets the value of the property which determines if /ActualText will be used when extracting
            the text
            </summary>
            <returns>true if /ActualText value is used, false otherwise</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.LocationTextExtractionStrategy.IsChunkAtWordBoundary(iText.Kernel.Pdf.Canvas.Parser.Listener.LocationTextExtractionStrategy.TextChunk,iText.Kernel.Pdf.Canvas.Parser.Listener.LocationTextExtractionStrategy.TextChunk)">
            <summary>Determines if a space character should be inserted between a previous chunk and the current chunk.
                </summary>
            <remarks>
            Determines if a space character should be inserted between a previous chunk and the current chunk.
            This method is exposed as a callback so subclasses can fine time the algorithm for determining whether a space should be inserted or not.
            By default, this method will insert a space if the there is a gap of more than half the font space character width between the end of the
            previous chunk and the beginning of the current chunk.  It will also indicate that a space is needed if the starting point of the new chunk
            appears *before* the end of the previous chunk (i.e. overlapping text).
            </remarks>
            <param name="chunk">the new chunk being evaluated</param>
            <param name="previousChunk">the chunk that appeared immediately before the current chunk</param>
            <returns>true if the two chunks represent different words (i.e. should have a space between them).  False otherwise.
                </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.LocationTextExtractionStrategy.StartsWithSpace(System.String)">
            <summary>Checks if the string starts with a space character, false if the string is empty or starts with a non-space character.
                </summary>
            <param name="str">the string to be checked</param>
            <returns>true if the string starts with a space character, false if the string is empty or starts with a non-space character
                </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.LocationTextExtractionStrategy.EndsWithSpace(System.String)">
            <summary>Checks if the string ends with a space character, false if the string is empty or ends with a non-space character
                </summary>
            <param name="str">the string to be checked</param>
            <returns>true if the string ends with a space character, false if the string is empty or ends with a non-space character
                </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.LocationTextExtractionStrategy.DumpState">
            <summary>Used for debugging only</summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.Listener.LocationTextExtractionStrategy.TextChunk">
            <summary>Represents a chunk of text, it's orientation, and location relative to the orientation vector</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Parser.Listener.LocationTextExtractionStrategy.TextChunk.text">
            <summary>the text of the chunk</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.LocationTextExtractionStrategy.TextChunk.GetText">
            <returns>the text captured by this chunk</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.LocationTextExtractionStrategy.TextChunk.CompareTo(iText.Kernel.Pdf.Canvas.Parser.Listener.LocationTextExtractionStrategy.TextChunk)">
            <summary>Compares based on orientation, perpendicular distance, then parallel distance</summary>
            <seealso cref="!:System.IComparable&lt;T&gt;.CompareTo(System.Object)"/>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Parser.Listener.LocationTextExtractionStrategy.TextChunkLocationDefaultImp.startLocation">
            <summary>the starting location of the chunk</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Parser.Listener.LocationTextExtractionStrategy.TextChunkLocationDefaultImp.endLocation">
            <summary>the ending location of the chunk</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Parser.Listener.LocationTextExtractionStrategy.TextChunkLocationDefaultImp.orientationVector">
            <summary>unit vector in the orientation of the chunk</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Parser.Listener.LocationTextExtractionStrategy.TextChunkLocationDefaultImp.orientationMagnitude">
            <summary>the orientation as a scalar for quick sorting</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Parser.Listener.LocationTextExtractionStrategy.TextChunkLocationDefaultImp.distPerpendicular">
            <summary>perpendicular distance to the orientation unit vector (i.e.</summary>
            <remarks>
            perpendicular distance to the orientation unit vector (i.e. the Y position in an unrotated coordinate system)
            we round to the nearest integer to handle the fuzziness of comparing floats
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Parser.Listener.LocationTextExtractionStrategy.TextChunkLocationDefaultImp.distParallelStart">
            <summary>distance of the start of the chunk parallel to the orientation unit vector (i.e.</summary>
            <remarks>distance of the start of the chunk parallel to the orientation unit vector (i.e. the X position in an unrotated coordinate system)
                </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Parser.Listener.LocationTextExtractionStrategy.TextChunkLocationDefaultImp.distParallelEnd">
            <summary>distance of the end of the chunk parallel to the orientation unit vector (i.e.</summary>
            <remarks>distance of the end of the chunk parallel to the orientation unit vector (i.e. the X position in an unrotated coordinate system)
                </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Parser.Listener.LocationTextExtractionStrategy.TextChunkLocationDefaultImp.charSpaceWidth">
            <summary>the width of a single space character in the font of the chunk</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.LocationTextExtractionStrategy.TextChunkLocationDefaultImp.GetStartLocation">
            <returns>the start location of the text</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.LocationTextExtractionStrategy.TextChunkLocationDefaultImp.GetEndLocation">
            <returns>the end location of the text</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.LocationTextExtractionStrategy.TextChunkLocationDefaultImp.GetCharSpaceWidth">
            <returns>the width of a single space character as rendered by this chunk</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.LocationTextExtractionStrategy.TextChunkLocationDefaultImp.SameLine(iText.Kernel.Pdf.Canvas.Parser.Listener.LocationTextExtractionStrategy.ITextChunkLocation)">
            <param name="as">the location to compare to</param>
            <returns>true is this location is on the the same line as the other</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.LocationTextExtractionStrategy.TextChunkLocationDefaultImp.DistanceFromEndOf(iText.Kernel.Pdf.Canvas.Parser.Listener.LocationTextExtractionStrategy.ITextChunkLocation)">
            <summary>
            Computes the distance between the end of 'other' and the beginning of this chunk
            in the direction of this chunk's orientation vector.
            </summary>
            <remarks>
            Computes the distance between the end of 'other' and the beginning of this chunk
            in the direction of this chunk's orientation vector.  Note that it's a bad idea
            to call this for chunks that aren't on the same line and orientation, but we don't
            explicitly check for that condition for performance reasons.
            </remarks>
            <param name="other"/>
            <returns>the number of spaces between the end of 'other' and the beginning of this chunk</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Pdf.Canvas.Parser.Listener.CharacterRenderInfo.MapString(System.Collections.Generic.IList{iText.Kernel.Pdf.Canvas.Parser.Listener.CharacterRenderInfo})" -->
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.Listener.DefaultPdfTextLocation">
            <summary>This class acts as a default implementation of IPdfTextLocation</summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.Listener.IPdfTextLocation">
            <summary>
            Instances of this interface represent a piece of text,
            somewhere on a page in a pdf document.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.IPdfTextLocation.GetRectangle">
            <returns>
            the visual
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            in which the text is located
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.IPdfTextLocation.GetText">
            <returns>the text</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.IPdfTextLocation.GetPageNumber">
            <summary>Get the page number of the page on which the text is located</summary>
            <returns>the page number, or 0 if no page number was set</returns>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.Listener.FilteredEventListener">
            <summary>An event listener which filters events on the fly before passing them on to the delegate.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.FilteredEventListener.#ctor">
            <summary>
            Constructs a
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.Listener.FilteredEventListener"/>
            empty instance.
            Use
            <see cref="!:AttachEventListener&lt;T&gt;(IEventListener, iText.Kernel.Pdf.Canvas.Parser.Filter.IEventFilter[])"/>
            to add an event listener along with its filters.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.FilteredEventListener.#ctor(iText.Kernel.Pdf.Canvas.Parser.Listener.IEventListener,iText.Kernel.Pdf.Canvas.Parser.Filter.IEventFilter[])">
            <summary>
            Constructs a
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.Listener.FilteredEventListener"/>
            instance with one delegate.
            Use
            <see cref="!:AttachEventListener&lt;T&gt;(IEventListener, iText.Kernel.Pdf.Canvas.Parser.Filter.IEventFilter[])"/>
            to add more
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.Listener.IEventListener"/>
            delegates
            along with their filters.
            </summary>
            <param name="delegate_">a delegate that fill be called when all the corresponding filters for an event pass
                </param>
            <param name="filterSet">filters attached to the delegate that will be tested before passing an event on to the delegate
                </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.FilteredEventListener.AttachEventListener``1(``0,iText.Kernel.Pdf.Canvas.Parser.Filter.IEventFilter[])">
            <summary>
            Attaches another
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.Listener.IEventListener"/>
            delegate with its filters.
            When all the filters attached to the delegate for an event accept the event, the event will be passed on to
            the delegate.
            You can attach multiple delegates to this
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.Listener.FilteredEventListener"/>
            instance. The content stream will
            be parsed just once, so it is better for performance than creating multiple
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.Listener.FilteredEventListener"/>
            instances and parsing the content stream multiple times. This is useful, for instance, when you want
            to extract content from multiple regions of a page.
            </summary>
            <param name="delegate_">a delegate that fill be called when all the corresponding filters for an event pass
                </param>
            <param name="filterSet">filters attached to the delegate that will be tested before passing an event on to the delegate
                </param>
            <returns>delegate that has been passed to the method, used for convenient call chaining</returns>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.Listener.FilteredTextEventListener">
            <summary>A text event listener which filters events on the fly before passing them on to the delegate.</summary>
            <remarks>
            A text event listener which filters events on the fly before passing them on to the delegate.
            The only difference from
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.Listener.FilteredEventListener"/>
            is that this class conveniently implements
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.Listener.ITextExtractionStrategy"/>
            and can therefore used as a strategy on its own, apart from the inherited
            function of filtering event appropriately to its delegates.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.FilteredTextEventListener.#ctor(iText.Kernel.Pdf.Canvas.Parser.Listener.ITextExtractionStrategy,iText.Kernel.Pdf.Canvas.Parser.Filter.IEventFilter[])">
            <summary>
            Constructs a
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.Listener.FilteredTextEventListener"/>
            instance with a
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.Listener.ITextExtractionStrategy"/>
            delegate.
            </summary>
            <param name="delegate_">a delegate that fill be called when all the corresponding filters for an event pass
                </param>
            <param name="filterSet">filters attached to the delegate that will be tested before passing an event on to the delegate
                </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.FilteredTextEventListener.GetResultantText">
            <summary>
            As an resultant text we use the concatenation of all the resultant text of all the delegates that implement
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.Listener.ITextExtractionStrategy"/>
            .
            </summary>
            <returns>the resulting concatenation of the text extracted from the delegates</returns>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.Listener.GlyphEventListener">
            <summary>
            This class expands each
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo"/>
            for
            <see cref="F:iText.Kernel.Pdf.Canvas.Parser.EventType.RENDER_TEXT"/>
            event types into
            multiple
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo"/>
            instances for each glyph occurred.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.GlyphEventListener.#ctor(iText.Kernel.Pdf.Canvas.Parser.Listener.IEventListener)">
            <summary>
            Constructs a
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.Listener.GlyphEventListener"/>
            instance by a delegate to which the expanded text events for each
            glyph occurred will be passed on.
            </summary>
            <param name="delegate_">delegate to pass the expanded glyph render events to.</param>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.Listener.GlyphTextEventListener">
            <summary>
            This class expands each
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo"/>
            for
            <see cref="F:iText.Kernel.Pdf.Canvas.Parser.EventType.RENDER_TEXT"/>
            event types into
            multiple
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo"/>
            instances for each glyph occurred.
            The only difference from
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.Listener.GlyphEventListener"/>
            is that this class conveniently implements
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.Listener.ITextExtractionStrategy"/>
            and can therefore used as a strategy on its own.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.GlyphTextEventListener.#ctor(iText.Kernel.Pdf.Canvas.Parser.Listener.ITextExtractionStrategy)">
            <summary>
            Constructs a
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.Listener.GlyphEventListener"/>
            instance by a
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.Listener.ITextExtractionStrategy"/>
            delegate to which
            the expanded text events for each glyph occurred will be passed on.
            </summary>
            <param name="delegate_">delegate to pass the expanded glyph render events to.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.GlyphTextEventListener.GetResultantText">
            <summary>
            As an resultant text we use the the resultant text of the delegate that implement
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.Listener.ITextExtractionStrategy"/>
            and was passed to this class.
            </summary>
            <returns>the resulting text extracted from the delegate</returns>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.Listener.ILocationExtractionStrategy">
            <summary>
            This is a special interface for
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.Filter.IEventFilter"/>
            that returns a collection of rectangles as result of its work.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.ILocationExtractionStrategy.GetResultantLocations">
            <summary>
            Returns the
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            s that have been processed so far.
            </summary>
            <returns>
            
            <see cref="!:System.Collections.ICollection&lt;E&gt;"/>
            &lt;
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.Listener.IPdfTextLocation"/>
            &gt; instance with the current resultant IPdfTextLocations
            </returns>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.Listener.RegexBasedLocationExtractionStrategy">
            <summary>This class is designed to search for the occurrences of a regular expression and return the resultant rectangles.
                </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.RegexBasedLocationExtractionStrategy.ToCRI(iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo)">
            <summary>
            Convert
            <c>TextRenderInfo</c>
            to
            <c>CharacterRenderInfo</c>
            This method is public and not final so that custom implementations can choose to override it.
            Other implementations of
            <c>CharacterRenderInfo</c>
            may choose to store different properties than
            merely the
            <c>Rectangle</c>
            describing the bounding box. E.g. a custom implementation might choose to
            store
            <c>Color</c>
            information as well, to better match the content surrounding the redaction
            <c>Rectangle</c>
            .
            </summary>
            <param name="tri"/>
            <returns/>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.RegexBasedLocationExtractionStrategy.ToRectangles(System.Collections.Generic.IList{iText.Kernel.Pdf.Canvas.Parser.Listener.CharacterRenderInfo})">
            <summary>
            Converts
            <c>CharacterRenderInfo</c>
            objects to
            <c>Rectangles</c>
            This method is protected and not final so that custom implementations can choose to override it.
            E.g. other implementations may choose to add padding/margin to the Rectangles.
            This method also offers a convenient access point to the mapping of
            <c>CharacterRenderInfo</c>
            to
            <c>Rectangle</c>
            .
            This mapping enables (custom implementations) to match color of text in redacted Rectangles,
            or match color of background, by the mere virtue of offering access to the
            <c>CharacterRenderInfo</c>
            objects
            that generated the
            <c>Rectangle</c>
            .
            </summary>
            <param name="cris"/>
            <returns/>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Parser.Listener.SimpleTextExtractionStrategy.result">
            <summary>used to store the resulting String.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.SimpleTextExtractionStrategy.GetResultantText">
            <summary>Returns the result so far.</summary>
            <returns>a String with the resulting text.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.SimpleTextExtractionStrategy.AppendTextChunk(System.String)">
            <summary>Used to actually append text to the text results.</summary>
            <remarks>
            Used to actually append text to the text results.  Subclasses can use this to insert
            text that wouldn't normally be included in text parsing (e.g. result of OCR performed against
            image content)
            </remarks>
            <param name="text">the text to append to the text results accumulated so far</param>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.Listener.TextMarginFinder">
            <summary>This class allows you to find the rectangle which contains all the text in the given content stream.
                </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Listener.TextMarginFinder.GetTextRectangle">
            <summary>
            Returns the common text rectangle, containing all the text found in the stream so far, ot
            <see langword="null"/>
            , if no
            text has been found yet.
            </summary>
            <returns>common text rectangle</returns>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.ParserGraphicsState">
            <summary>
            Internal class which is essentially a
            <see cref="T:iText.Kernel.Pdf.Canvas.CanvasGraphicsState"/>
            which supports tracking of
            clipping path state and changes.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Pdf.Canvas.Parser.ParserGraphicsState.#ctor" -->
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.ParserGraphicsState.#ctor(iText.Kernel.Pdf.Canvas.Parser.ParserGraphicsState)">
            <summary>Copy constructor.</summary>
            <param name="source">the Graphics State to copy from</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.ParserGraphicsState.SetClippingPath(iText.Kernel.Geom.Path)">
            <summary>Sets the current clipping path to the specified path.</summary>
            <remarks>
            Sets the current clipping path to the specified path.
            <br/>
            <strong>Note:</strong>This method doesn't modify existing clipping path,
            it simply replaces it with the new one instead.
            </remarks>
            <param name="clippingPath">New clipping path.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.ParserGraphicsState.Clip(iText.Kernel.Geom.Path,System.Int32)">
            <summary>Intersects the current clipping path with the given path.</summary>
            <remarks>
            Intersects the current clipping path with the given path.
            <br/>
            <strong>Note:</strong> Coordinates of the given path should be in
            the transformed user space.
            </remarks>
            <param name="path">The path to be intersected with the current clipping path.</param>
            <param name="fillingRule">
            The filling rule which should be applied to the given path.
            It should be either
            <see cref="F:iText.Kernel.Pdf.Canvas.PdfCanvasConstants.FillingRule.EVEN_ODD"/>
            or
            <see cref="F:iText.Kernel.Pdf.Canvas.PdfCanvasConstants.FillingRule.NONZERO_WINDING"/>
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.ParserGraphicsState.GetClippingPath">
            <summary>Getter for the current clipping path.</summary>
            <remarks>
            Getter for the current clipping path.
            <br/>
            <strong>Note:</strong> The returned clipping path is in the transformed user space, so
            if you want to get it in default user space, apply transformation matrix (
            <see cref="M:iText.Kernel.Pdf.Canvas.CanvasGraphicsState.GetCtm"/>
            ).
            </remarks>
            <returns>The current clipping path.</returns>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor">
            <summary>Processor for a PDF content stream.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.eventListener">
            <summary>Listener that will be notified of render events</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.supportedEvents">
            <summary>
            Cache supported events in case the user's
            <see cref="M:iText.Kernel.Pdf.Canvas.Parser.Listener.IEventListener.GetSupportedEvents"/>
            method is not very efficient
            </summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.isClip">
            <summary>
            Indicates whether the current clipping path should be modified by
            intersecting it with the current path.
            </summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.clippingRule">
            <summary>
            Specifies the filling rule which should be applied while calculating
            new clipping path.
            </summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.operators">
            <summary>A map with all supported operators (PDF syntax).</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.resourcesStack">
            <summary>Resources for the content stream.</summary>
            <remarks>
            Resources for the content stream.
            Current resources are always at the top of the stack.
            Stack is needed in case if some "inner" content stream with it's own resources
            is encountered (like Form XObject).
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.gsStack">
            <summary>Stack keeping track of the graphics state.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.xobjectDoHandlers">
            <summary>A map with all supported XObject handlers</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.cachedFonts">
            <summary>The font cache</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.markedContentStack">
            <summary>A stack containing marked content info.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.#ctor(iText.Kernel.Pdf.Canvas.Parser.Listener.IEventListener)">
            <summary>
            Creates a new PDF Content Stream Processor that will send its output to the
            designated render listener.
            </summary>
            <param name="eventListener">
            the
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.Listener.IEventListener"/>
            that will receive rendering notifications
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.#ctor(iText.Kernel.Pdf.Canvas.Parser.Listener.IEventListener,System.Collections.Generic.IDictionary{System.String,iText.Kernel.Pdf.Canvas.Parser.IContentOperator})">
            <summary>
            Creates a new PDF Content Stream Processor that will send its output to the
            designated render listener.
            </summary>
            <remarks>
            Creates a new PDF Content Stream Processor that will send its output to the
            designated render listener.
            Also allows registration of custom IContentOperators that can influence
            how (and whether or not) the PDF instructions will be parsed.
            </remarks>
            <param name="eventListener">
            the
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.Listener.IEventListener"/>
            that will receive rendering notifications
            </param>
            <param name="additionalContentOperators">
            an optional map of custom
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.IContentOperator"/>
            s for rendering instructions
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.RegisterXObjectDoHandler(iText.Kernel.Pdf.PdfName,iText.Kernel.Pdf.Canvas.Parser.IXObjectDoHandler)">
            <summary>Registers a Do handler that will be called when Do for the provided XObject subtype is encountered during content processing.
                </summary>
            <remarks>
            Registers a Do handler that will be called when Do for the provided XObject subtype is encountered during content processing.
            <br />
            If you register a handler, it is a very good idea to pass the call on to the existing registered handler (returned by this call), otherwise you
            may inadvertently change the internal behavior of the processor.
            </remarks>
            <param name="xobjectSubType">the XObject subtype this handler will process, or PdfName.DEFAULT for a catch-all handler
                </param>
            <param name="handler">the handler that will receive notification when the Do operator for the specified subtype is encountered
                </param>
            <returns>the existing registered handler, if any</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.RegisterContentOperator(System.String,iText.Kernel.Pdf.Canvas.Parser.IContentOperator)">
            <summary>Registers a content operator that will be called when the specified operator string is encountered during content processing.
                </summary>
            <remarks>
            Registers a content operator that will be called when the specified operator string is encountered during content processing.
            <br />
            If you register an operator, it is a very good idea to pass the call on to the existing registered operator (returned by this call), otherwise you
            may inadvertently change the internal behavior of the processor.
            </remarks>
            <param name="operatorString">the operator id, or DEFAULT_OPERATOR for a catch-all operator</param>
            <param name="operator">the operator that will receive notification when the operator is encountered</param>
            <returns>the existing registered operator, if any</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.GetRegisteredOperatorStrings">
            <summary>
            Gets the
            <see cref="!:System.Collections.ICollection&lt;E&gt;"/>
            containing all the registered operators strings.
            </summary>
            <returns>
            
            <see cref="!:System.Collections.ICollection&lt;E&gt;"/>
            containing all the registered operators strings.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.Reset">
            <summary>Resets the graphics state stack, matrices and resources.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.GetGraphicsState">
            <summary>
            Gets the current
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.ParserGraphicsState"/>
            </summary>
            <returns>
            the current
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.ParserGraphicsState"/>
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.ProcessContent(System.Byte[],iText.Kernel.Pdf.PdfResources)">
            <summary>Processes PDF syntax.</summary>
            <remarks>
            Processes PDF syntax.
            <b>Note:</b> If you re-use a given
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor"/>
            , you must call
            <see cref="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.Reset"/>
            </remarks>
            <param name="contentBytes">the bytes of a content stream</param>
            <param name="resources">the resources of the content stream. Must not be null.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.ProcessPageContent(iText.Kernel.Pdf.PdfPage)">
            <summary>Processes PDF syntax.</summary>
            <remarks>
            Processes PDF syntax.
            <br/>
            <strong>Note:</strong> If you re-use a given
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor"/>
            , you must call
            <see cref="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.Reset"/>
            </remarks>
            <param name="page">the page to process</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.GetEventListener">
            <summary>
            Accessor method for the
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.Listener.IEventListener"/>
            object maintained in this class.
            Necessary for implementing custom ContentOperator implementations.
            </summary>
            <returns>the renderListener</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.PopulateOperators">
            <summary>Loads all the supported graphics and text state operators in a map.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.PaintPath(System.Int32,System.Int32)">
            <summary>Displays the current path.</summary>
            <param name="operation">
            One of the possible combinations of
            <see cref="F:iText.Kernel.Pdf.Canvas.Parser.Data.PathRenderInfo.STROKE"/>
            and
            <see cref="F:iText.Kernel.Pdf.Canvas.Parser.Data.PathRenderInfo.FILL"/>
            values or
            <see cref="F:iText.Kernel.Pdf.Canvas.Parser.Data.PathRenderInfo.NO_OP"/>
            </param>
            <param name="rule">
            Either
            <see cref="F:iText.Kernel.Pdf.Canvas.PdfCanvasConstants.FillingRule.NONZERO_WINDING"/>
            or
            <see cref="F:iText.Kernel.Pdf.Canvas.PdfCanvasConstants.FillingRule.EVEN_ODD"/>
            In case it isn't applicable pass any <CODE>byte</CODE> value.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.InvokeOperator(iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary>Invokes an operator.</summary>
            <param name="operator">the PDF Syntax of the operator</param>
            <param name="operands">a list with operands</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.GetFont(iText.Kernel.Pdf.PdfDictionary)">
            <summary>Gets the font pointed to by the indirect reference.</summary>
            <remarks>Gets the font pointed to by the indirect reference. The font may have been cached.</remarks>
            <param name="fontDict"/>
            <returns>the font</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.BeginMarkedContent(iText.Kernel.Pdf.PdfName,iText.Kernel.Pdf.PdfDictionary)">
            <summary>Add to the marked content stack</summary>
            <param name="tag">the tag of the marked content</param>
            <param name="dict">the PdfDictionary associated with the marked content</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.EndMarkedContent">
            <summary>Remove the latest marked content from the stack.</summary>
            <remarks>Remove the latest marked content from the stack.  Keeps track of the BMC, BDC and EMC operators.</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.BeginText">
            <summary>Used to trigger beginTextBlock on the renderListener</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.EndText">
            <summary>Used to trigger endTextBlock on the renderListener</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.EventOccurred(iText.Kernel.Pdf.Canvas.Parser.Data.IEventData,iText.Kernel.Pdf.Canvas.Parser.EventType)">
            <summary>This is a proxy to pass only those events to the event listener which are supported by it.</summary>
            <param name="data">event data</param>
            <param name="type">event type</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.DisplayPdfString(iText.Kernel.Pdf.PdfString)">
            <summary>Displays text.</summary>
            <param name="string">the text to display</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.DisplayXObject(iText.Kernel.Pdf.PdfName)">
            <summary>Displays an XObject using the registered handler for this XObject's subtype</summary>
            <param name="xobjectName">the name of the XObject to retrieve from the resource dictionary</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.ApplyTextAdjust(System.Single)">
            <summary>Adjusts the text matrix for the specified adjustment value (see TJ operator in the PDF spec for information)
                </summary>
            <param name="tj">the text adjustment</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.GetColor(iText.Kernel.Pdf.Colorspace.PdfColorSpace,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject},iText.Kernel.Pdf.PdfResources)">
            <summary>Gets a color based on a list of operands and Color space.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.GetColor(System.Int32,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary>Gets a color based on a list of operands.</summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.IgnoreOperator">
            <summary>A handler that implements operator (unregistered).</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.IgnoreOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.ShowTextArrayOperator">
            <summary>A handler that implements operator (TJ).</summary>
            <remarks>A handler that implements operator (TJ). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.ShowTextArrayOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.MoveNextLineAndShowTextWithSpacingOperator">
            <summary>A handler that implements operator (").</summary>
            <remarks>A handler that implements operator ("). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.MoveNextLineAndShowTextWithSpacingOperator.#ctor(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetTextWordSpacingOperator,iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetTextCharacterSpacingOperator,iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.MoveNextLineAndShowTextOperator)">
            <summary>Create new instance of this handler.</summary>
            <param name="setTextWordSpacing">the handler for Tw operator</param>
            <param name="setTextCharacterSpacing">the handler for Tc operator</param>
            <param name="moveNextLineAndShowText">the handler for ' operator</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.MoveNextLineAndShowTextWithSpacingOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.MoveNextLineAndShowTextOperator">
            <summary>A handler that implements operator (').</summary>
            <remarks>A handler that implements operator ('). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.MoveNextLineAndShowTextOperator.#ctor(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.TextMoveNextLineOperator,iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.ShowTextOperator)">
            <summary>Creates the new instance of this handler</summary>
            <param name="textMoveNextLine">the handler for T* operator</param>
            <param name="showText">the handler for Tj operator</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.MoveNextLineAndShowTextOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.ShowTextOperator">
            <summary>A handler that implements operator (Tj).</summary>
            <remarks>A handler that implements operator (Tj). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.ShowTextOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.TextMoveNextLineOperator">
            <summary>A handler that implements operator (T*).</summary>
            <remarks>A handler that implements operator (T*). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.TextMoveNextLineOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.TextSetTextMatrixOperator">
            <summary>A handler that implements operator (Tm).</summary>
            <remarks>A handler that implements operator (Tm). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.TextSetTextMatrixOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.TextMoveStartNextLineWithLeadingOperator">
            <summary>A handler that implements operator (TD).</summary>
            <remarks>A handler that implements operator (TD). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.TextMoveStartNextLineWithLeadingOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.TextMoveStartNextLineOperator">
            <summary>A handler that implements operator (Td).</summary>
            <remarks>A handler that implements operator (Td). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.TextMoveStartNextLineOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetTextFontOperator">
            <summary>A handler that implements operator (Tf).</summary>
            <remarks>A handler that implements operator (Tf). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetTextFontOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetTextRenderModeOperator">
            <summary>A handler that implements operator (Tr).</summary>
            <remarks>A handler that implements operator (Tr). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetTextRenderModeOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetTextRiseOperator">
            <summary>A handler that implements operator (Ts).</summary>
            <remarks>A handler that implements operator (Ts). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetTextRiseOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetTextLeadingOperator">
            <summary>A handler that implements operator (TL).</summary>
            <remarks>A handler that implements operator (TL). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetTextLeadingOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetTextHorizontalScalingOperator">
            <summary>A handler that implements operator (Tz).</summary>
            <remarks>A handler that implements operator (Tz). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetTextHorizontalScalingOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetTextCharacterSpacingOperator">
            <summary>A handler that implements operator (Tc).</summary>
            <remarks>A handler that implements operator (Tc). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetTextCharacterSpacingOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetTextWordSpacingOperator">
            <summary>A handler that implements operator (Tw).</summary>
            <remarks>A handler that implements operator (Tw). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetTextWordSpacingOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.ProcessGraphicsStateResourceOperator">
            <summary>A handler that implements operator (gs).</summary>
            <remarks>A handler that implements operator (gs). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.ProcessGraphicsStateResourceOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.PushGraphicsStateOperator">
            <summary>A handler that implements operator (q).</summary>
            <remarks>A handler that implements operator (q). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.PushGraphicsStateOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.ModifyCurrentTransformationMatrixOperator">
            <summary>A handler that implements operator (cm).</summary>
            <remarks>A handler that implements operator (cm). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.ModifyCurrentTransformationMatrixOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.PopGraphicsStateOperator">
            <summary>A handler that implements operator (Q).</summary>
            <remarks>A handler that implements operator (Q). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.PopGraphicsStateOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetGrayFillOperator">
            <summary>A handler that implements operator (g).</summary>
            <remarks>A handler that implements operator (g). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetGrayFillOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetGrayStrokeOperator">
            <summary>A handler that implements operator (G).</summary>
            <remarks>A handler that implements operator (G). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetGrayStrokeOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetRGBFillOperator">
            <summary>A handler that implements operator (rg).</summary>
            <remarks>A handler that implements operator (rg). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetRGBFillOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetRGBStrokeOperator">
            <summary>A handler that implements operator (RG).</summary>
            <remarks>A handler that implements operator (RG). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetRGBStrokeOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetCMYKFillOperator">
            <summary>A handler that implements operator (k).</summary>
            <remarks>A handler that implements operator (k). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetCMYKFillOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetCMYKStrokeOperator">
            <summary>A handler that implements operator (K).</summary>
            <remarks>A handler that implements operator (K). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetCMYKStrokeOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetColorSpaceFillOperator">
            <summary>A handler that implements operator (CS).</summary>
            <remarks>A handler that implements operator (CS). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetColorSpaceFillOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetColorSpaceStrokeOperator">
            <summary>A handler that implements operator (cs).</summary>
            <remarks>A handler that implements operator (cs). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetColorSpaceStrokeOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetColorFillOperator">
            <summary>A handler that implements operator (sc / scn).</summary>
            <remarks>A handler that implements operator (sc / scn). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetColorFillOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetColorStrokeOperator">
            <summary>A handler that implements operator (SC / SCN).</summary>
            <remarks>A handler that implements operator (SC / SCN). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetColorStrokeOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.BeginTextOperator">
            <summary>A handler that implements operator (BT).</summary>
            <remarks>A handler that implements operator (BT). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.BeginTextOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.EndTextOperator">
            <summary>A handler that implements operator (ET).</summary>
            <remarks>A handler that implements operator (ET). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.EndTextOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.BeginMarkedContentOperator">
            <summary>A handler that implements operator (BMC).</summary>
            <remarks>A handler that implements operator (BMC). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.BeginMarkedContentOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.BeginMarkedContentDictionaryOperator">
            <summary>A handler that implements operator (BDC).</summary>
            <remarks>A handler that implements operator (BDC). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.BeginMarkedContentDictionaryOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.EndMarkedContentOperator">
            <summary>A handler that implements operator (EMC).</summary>
            <remarks>A handler that implements operator (EMC). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.EndMarkedContentOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.DoOperator">
            <summary>A handler that implements operator (Do).</summary>
            <remarks>A handler that implements operator (Do). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.DoOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.EndImageOperator">
            <summary>A handler that implements operator (EI).</summary>
            <remarks>
            A handler that implements operator (EI). For more information see Table 51 ISO-32000-1
            BI and ID operators are parsed along with this operator.
            This not a usual operator, it will have a single operand, which will be a PdfStream object which
            encapsulates inline image dictionary and bytes
            </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.EndImageOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetLineWidthOperator">
            <summary>A handler that implements operator (w).</summary>
            <remarks>A handler that implements operator (w). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetLineWidthOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetLineCapOperator">
            <summary>A handler that implements operator (J).</summary>
            <remarks>A handler that implements operator (J). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetLineCapOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetLineJoinOperator">
            <summary>A handler that implements operator (j).</summary>
            <remarks>A handler that implements operator (j). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetLineJoinOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetMiterLimitOperator">
            <summary>A handler that implements operator (M).</summary>
            <remarks>A handler that implements operator (M). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetMiterLimitOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetLineDashPatternOperator">
            <summary>A handler that implements operator (d).</summary>
            <remarks>A handler that implements operator (d). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.SetLineDashPatternOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.FormXObjectDoHandler">
            <summary>An XObject subtype handler for FORM</summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.ImageXObjectDoHandler">
            <summary>An XObject subtype handler for IMAGE</summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.IgnoreXObjectDoHandler">
            <summary>An XObject subtype handler that does nothing</summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.MoveToOperator">
            <summary>A handler that implements operator (m).</summary>
            <remarks>A handler that implements operator (m). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.MoveToOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.LineToOperator">
            <summary>A handler that implements operator (l).</summary>
            <remarks>A handler that implements operator (l). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.LineToOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.CurveOperator">
            <summary>A handler that implements operator (c).</summary>
            <remarks>A handler that implements operator (c). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.CurveOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.CurveFirstPointDuplicatedOperator">
            <summary>A handler that implements operator (v).</summary>
            <remarks>A handler that implements operator (v). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.CurveFirstPointDuplicatedOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.CurveFourhPointDuplicatedOperator">
            <summary>A handler that implements operator (y).</summary>
            <remarks>A handler that implements operator (y). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.CurveFourhPointDuplicatedOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.CloseSubpathOperator">
            <summary>A handler that implements operator (h).</summary>
            <remarks>A handler that implements operator (h). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.CloseSubpathOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.RectangleOperator">
            <summary>A handler that implements operator (re).</summary>
            <remarks>A handler that implements operator (re). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.RectangleOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.PaintPathOperator">
            <summary>A handler that implements operator (S, s, f, F, f*, B, B*, b, b*).</summary>
            <remarks>A handler that implements operator (S, s, f, F, f*, B, B*, b, b*). For more information see Table 51 ISO-32000-1
                </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.PaintPathOperator.#ctor(System.Int32,System.Int32,System.Boolean)">
            <summary>Constructs PainPath object.</summary>
            <param name="operation">
            One of the possible combinations of
            <see cref="F:iText.Kernel.Pdf.Canvas.Parser.Data.PathRenderInfo.STROKE"/>
            and
            <see cref="F:iText.Kernel.Pdf.Canvas.Parser.Data.PathRenderInfo.FILL"/>
            values or
            <see cref="F:iText.Kernel.Pdf.Canvas.Parser.Data.PathRenderInfo.NO_OP"/>
            </param>
            <param name="rule">
            Either
            <see cref="F:iText.Kernel.Pdf.Canvas.PdfCanvasConstants.FillingRule.NONZERO_WINDING"/>
            or
            <see cref="F:iText.Kernel.Pdf.Canvas.PdfCanvasConstants.FillingRule.EVEN_ODD"/>
            In case it isn't applicable pass any value.
            </param>
            <param name="close">Indicates whether the path should be closed or not.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.PaintPathOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.ClipPathOperator">
            <summary>A handler that implements operator (W, W*).</summary>
            <remarks>A handler that implements operator (W, W*). For more information see Table 51 ISO-32000-1</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor.ClipPathOperator.Invoke(iText.Kernel.Pdf.Canvas.Parser.PdfCanvasProcessor,iText.Kernel.Pdf.PdfLiteral,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.PdfDocumentContentParser">
            <summary>
            A utility class that makes it cleaner to process content from pages of a
            <see cref="T:iText.Kernel.Pdf.PdfDocument"/>
            through a specified RenderListener.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfDocumentContentParser.ProcessContent``1(System.Int32,``0,System.Collections.Generic.IDictionary{System.String,iText.Kernel.Pdf.Canvas.Parser.IContentOperator})">
            <summary>Processes content from the specified page number using the specified listener.</summary>
            <remarks>
            Processes content from the specified page number using the specified listener.
            Also allows registration of custom IContentOperators that can influence
            how (and whether or not) the PDF instructions will be parsed.
            </remarks>
            
            <param name="pageNumber">the page number to process</param>
            <param name="renderListener">the listener that will receive render callbacks</param>
            <param name="additionalContentOperators">an optional map of custom ContentOperators for rendering instructions
                </param>
            <returns>the provided renderListener</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfDocumentContentParser.ProcessContent``1(System.Int32,``0)">
            <summary>Processes content from the specified page number using the specified listener</summary>
            
            <param name="pageNumber">the page number to process</param>
            <param name="renderListener">the listener that will receive render callbacks</param>
            <returns>the provided renderListener</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfTextExtractor.GetTextFromPage(iText.Kernel.Pdf.PdfPage,iText.Kernel.Pdf.Canvas.Parser.Listener.ITextExtractionStrategy,System.Collections.Generic.IDictionary{System.String,iText.Kernel.Pdf.Canvas.Parser.IContentOperator})">
            <summary>Extract text from a specified page using an extraction strategy.</summary>
            <remarks>
            Extract text from a specified page using an extraction strategy.
            Also allows registration of custom IContentOperators that can influence
            how (and whether or not) the PDF instructions will be parsed.
            </remarks>
            <param name="page">the page for the text to be extracted from</param>
            <param name="strategy">the strategy to use for extracting text</param>
            <param name="additionalContentOperators">
            an optional map of custom
            <see cref="T:iText.Kernel.Pdf.Canvas.Parser.IContentOperator"/>
            s for rendering instructions
            </param>
            <returns>the extracted text</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfTextExtractor.GetTextFromPage(iText.Kernel.Pdf.PdfPage,iText.Kernel.Pdf.Canvas.Parser.Listener.ITextExtractionStrategy)">
            <summary>Extract text from a specified page using an extraction strategy.</summary>
            <param name="page">the page for the text to be extracted from</param>
            <param name="strategy">the strategy to use for extracting text</param>
            <returns>the extracted text</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.PdfTextExtractor.GetTextFromPage(iText.Kernel.Pdf.PdfPage)">
            <summary>Extract text from a specified page using the default strategy.</summary>
            <remarks>
            Extract text from a specified page using the default strategy.
            Node: the default strategy is subject to change. If using a specific strategy
            is important, please use
            <see cref="M:iText.Kernel.Pdf.Canvas.Parser.PdfTextExtractor.GetTextFromPage(iText.Kernel.Pdf.PdfPage,iText.Kernel.Pdf.Canvas.Parser.Listener.ITextExtractionStrategy)"/>
            .
            </remarks>
            <param name="page">the page for the text to be extracted from</param>
            <returns>the extracted text</returns>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.Util.InlineImageParsingUtils">
            <summary>Utility methods to help with processing of inline images</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Parser.Util.InlineImageParsingUtils.inlineImageEntryAbbreviationMap">
            <summary>
            Map between key abbreviations allowed in dictionary of inline images and their
            equivalent image dictionary keys
            </summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Parser.Util.InlineImageParsingUtils.inlineImageColorSpaceAbbreviationMap">
            <summary>Map between value abbreviations allowed in dictionary of inline images for COLORSPACE</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Parser.Util.InlineImageParsingUtils.inlineImageFilterAbbreviationMap">
            <summary>Map between value abbreviations allowed in dictionary of inline images for FILTER</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Util.InlineImageParsingUtils.Parse(iText.Kernel.Pdf.Canvas.Parser.Util.PdfCanvasParser,iText.Kernel.Pdf.PdfDictionary)">
            <summary>Parses an inline image from the provided content parser.</summary>
            <remarks>
            Parses an inline image from the provided content parser.  The parser must be positioned immediately following the BI operator in the content stream.
            The parser will be left with current position immediately following the EI operator that terminates the inline image
            </remarks>
            <param name="ps">the content parser to use for reading the image.</param>
            <param name="colorSpaceDic">a color space dictionary</param>
            <returns>the parsed image</returns>
            <exception cref="T:System.IO.IOException">if anything goes wring with the parsing</exception>
            <exception cref="T:iText.Kernel.Pdf.Canvas.Parser.Util.InlineImageParsingUtils.InlineImageParseException">if parsing of the inline image failed due to issues specific to inline image processing
                </exception>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Util.InlineImageParsingUtils.ParseDictionary(iText.Kernel.Pdf.Canvas.Parser.Util.PdfCanvasParser)">
            <summary>Parses the next inline image dictionary from the parser.</summary>
            <remarks>
            Parses the next inline image dictionary from the parser.  The parser must be positioned immediately following the BI operator.
            The parser will be left with position immediately following the whitespace character that follows the ID operator that ends the inline image dictionary.
            </remarks>
            <param name="ps">the parser to extract the embedded image information from</param>
            <returns>the dictionary for the inline image, with any abbreviations converted to regular image dictionary keys and values
                </returns>
            <exception cref="T:System.IO.IOException">if the parse fails</exception>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Util.InlineImageParsingUtils.GetAlternateValue(iText.Kernel.Pdf.PdfName,iText.Kernel.Pdf.PdfObject)">
            <summary>Transforms value abbreviations into their corresponding real value</summary>
            <param name="key">the key that the value is for</param>
            <param name="value">the value that might be an abbreviation</param>
            <returns>if value is an allowed abbreviation for the key, the expanded value for that abbreviation.  Otherwise, value is returned without modification
                </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Util.InlineImageParsingUtils.GetComponentsPerPixel(iText.Kernel.Pdf.PdfName,iText.Kernel.Pdf.PdfDictionary)">
            <param name="colorSpaceName">the name of the color space. If null, a bi-tonal (black and white) color space is assumed.
                </param>
            <returns>the components per pixel for the specified color space</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Util.InlineImageParsingUtils.ComputeBytesPerRow(iText.Kernel.Pdf.PdfDictionary,iText.Kernel.Pdf.PdfDictionary)">
            <summary>Computes the number of unfiltered bytes that each row of the image will contain.</summary>
            <remarks>
            Computes the number of unfiltered bytes that each row of the image will contain.
            If the number of bytes results in a partial terminating byte, this number is rounded up
            per the PDF specification
            </remarks>
            <param name="imageDictionary">the dictionary of the inline image</param>
            <returns>the number of bytes per row of the image</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Util.InlineImageParsingUtils.ParseUnfilteredSamples(iText.Kernel.Pdf.PdfDictionary,iText.Kernel.Pdf.PdfDictionary,iText.Kernel.Pdf.Canvas.Parser.Util.PdfCanvasParser)">
            <summary>Parses the samples of the image from the underlying content parser, ignoring all filters.</summary>
            <remarks>
            Parses the samples of the image from the underlying content parser, ignoring all filters.
            The parser must be positioned immediately after the ID operator that ends the inline image's dictionary.
            The parser will be left positioned immediately following the EI operator.
            This is primarily useful if no filters have been applied.
            </remarks>
            <param name="imageDictionary">the dictionary of the inline image</param>
            <param name="ps">the content parser</param>
            <returns>the samples of the image</returns>
            <exception cref="T:System.IO.IOException">if anything bad happens during parsing</exception>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Util.InlineImageParsingUtils.ParseSamples(iText.Kernel.Pdf.PdfDictionary,iText.Kernel.Pdf.PdfDictionary,iText.Kernel.Pdf.Canvas.Parser.Util.PdfCanvasParser)">
            <summary>
            Parses the samples of the image from the underlying content parser, accounting for filters
            The parser must be positioned immediately after the ID operator that ends the inline image's dictionary.
            </summary>
            <remarks>
            Parses the samples of the image from the underlying content parser, accounting for filters
            The parser must be positioned immediately after the ID operator that ends the inline image's dictionary.
            The parser will be left positioned immediately following the EI operator.
            <b>Note:</b>This implementation does not actually apply the filters at this time
            </remarks>
            <param name="imageDictionary">the dictionary of the inline image</param>
            <param name="ps">the content parser</param>
            <returns>the samples of the image</returns>
            <exception cref="T:System.IO.IOException">if anything bad happens during parsing</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Pdf.Canvas.Parser.Util.InlineImageParsingUtils.InlineImageStreamBytesAreComplete(System.Byte[],iText.Kernel.Pdf.PdfDictionary)" -->
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.Util.InlineImageParsingUtils.InlineImageParseException">
            <summary>
            Simple class in case users need to differentiate an exception from processing
            inline images vs other exceptions
            </summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Parser.Util.PdfCanvasParser">
            <summary>Parses the page or form XObject content.</summary>
            <author>Paulo Soares</author>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Parser.Util.PdfCanvasParser.tokeniser">
            <summary>Holds value of property tokeniser.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Util.PdfCanvasParser.#ctor(iText.IO.Source.PdfTokenizer)">
            <summary>Creates a new instance of PdfContentParser</summary>
            <param name="tokeniser">the tokeniser with the content</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Util.PdfCanvasParser.#ctor(iText.IO.Source.PdfTokenizer,iText.Kernel.Pdf.PdfResources)">
            <summary>Creates a new instance of PdfContentParser</summary>
            <param name="tokeniser">the tokeniser with the content</param>
            <param name="currentResources">
            current resources of the content stream.
            It is optional parameter, which is used for performance improvements of specific cases of
            inline images parsing.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Util.PdfCanvasParser.Parse(System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary>Parses a single command from the content.</summary>
            <remarks>
            Parses a single command from the content. Each command is output as an array of arguments
            having the command itself as the last element. The returned array will be empty if the
            end of content was reached.
            <br/>
            A specific behaviour occurs when inline image is encountered (BI command):
            in that case, parser would continue parsing until it meets EI - end of the inline image;
            as a result in this case it will return an array with inline image dictionary and image bytes
            encapsulated in PdfStream object as first element and EI command as second element.
            </remarks>
            <param name="ls">
            an <CODE>ArrayList</CODE> to use. It will be cleared before using. If it's
            <CODE>null</CODE> will create a new <CODE>ArrayList</CODE>
            </param>
            <returns>the same <CODE>ArrayList</CODE> given as argument or a new one</returns>
            <exception cref="T:System.IO.IOException">on error</exception>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Util.PdfCanvasParser.GetTokeniser">
            <summary>Gets the tokeniser.</summary>
            <returns>the tokeniser.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Util.PdfCanvasParser.SetTokeniser(iText.IO.Source.PdfTokenizer)">
            <summary>Sets the tokeniser.</summary>
            <param name="tokeniser">the tokeniser</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Util.PdfCanvasParser.ReadDictionary">
            <summary>Reads a dictionary.</summary>
            <remarks>Reads a dictionary. The tokeniser must be positioned past the "&lt;&lt;" token.</remarks>
            <returns>the dictionary</returns>
            <exception cref="T:System.IO.IOException">on error</exception>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Util.PdfCanvasParser.ReadArray">
            <summary>Reads an array.</summary>
            <remarks>Reads an array. The tokeniser must be positioned past the "[" token.</remarks>
            <returns>an array</returns>
            <exception cref="T:System.IO.IOException">on error</exception>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Util.PdfCanvasParser.ReadObject">
            <summary>Reads a pdf object.</summary>
            <returns>the pdf object</returns>
            <exception cref="T:System.IO.IOException">on error</exception>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Parser.Util.PdfCanvasParser.NextValidToken">
            <summary>Reads the next token skipping over the comments.</summary>
            <returns><CODE>true</CODE> if a token was read, <CODE>false</CODE> if the end of content was reached</returns>
            <exception cref="T:System.IO.IOException">on error</exception>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.PdfCanvasConstants">
            <summary>A container for constants defined in the PDF specification (ISO 32000-1).</summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.PdfCanvasConstants.TextRenderingMode">
            <summary>
            The text rendering mode determines whether showing text causes glyph
            outlines to be stroked, filled, used as a clipping boundary, or some
            combination of the three.
            </summary>
            <remarks>
            The text rendering mode determines whether showing text causes glyph
            outlines to be stroked, filled, used as a clipping boundary, or some
            combination of the three. Stroking, filling, and clipping have the same
            effects for a text object as they do for a path object, although they are
            specified in an entirely different way.
            If the text rendering mode calls for filling, the current nonstroking
            color in the graphics state is used; if it calls for stroking, the
            current stroking color is used.
            All documentation for this class is taken from ISO 32000-1, section 9.3.6
            "Text Rendering Mode".
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.PdfCanvasConstants.TextRenderingMode.FILL">
            <summary>Fill text</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.PdfCanvasConstants.TextRenderingMode.STROKE">
            <summary>Stroke text, providing the outline of the glyphs</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.PdfCanvasConstants.TextRenderingMode.FILL_STROKE">
            <summary>Fill and stroke text</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.PdfCanvasConstants.TextRenderingMode.INVISIBLE">
            <summary>Neither fill nor stroke, i.e.</summary>
            <remarks>Neither fill nor stroke, i.e. render invisibly</remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.PdfCanvasConstants.TextRenderingMode.FILL_CLIP">
            <summary>Fill text and add to path for clipping</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.PdfCanvasConstants.TextRenderingMode.STROKE_CLIP">
            <summary>Stroke text and add to path for clipping</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.PdfCanvasConstants.TextRenderingMode.FILL_STROKE_CLIP">
            <summary>Fill, then stroke text and add to path for clipping</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.PdfCanvasConstants.TextRenderingMode.CLIP">
            <summary>Add text to path for clipping</summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.PdfCanvasConstants.LineCapStyle">
            <summary>
            The line cap style specifies the shape to be used at the ends of open
            subpaths (and dashes, if any) when they are stroked.
            </summary>
            <remarks>
            The line cap style specifies the shape to be used at the ends of open
            subpaths (and dashes, if any) when they are stroked.
            All documentation for this class is taken from ISO 32000-1, section
            8.4.3.3 "Line Cap Style".
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.PdfCanvasConstants.LineCapStyle.BUTT">
            <summary>The stroke is squared of at the endpoint of the path.</summary>
            <remarks>
            The stroke is squared of at the endpoint of the path. There is no
            projection beyond the end of the path.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.PdfCanvasConstants.LineCapStyle.ROUND">
            <summary>
            A semicircular arc with a diameter equal to the line width is drawn
            around the endpoint and filled in.
            </summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.PdfCanvasConstants.LineCapStyle.PROJECTING_SQUARE">
            <summary>
            The stroke continues beyond the endpoint of the path for a distance
            equal to half the line width and is squared off.
            </summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.PdfCanvasConstants.LineJoinStyle">
            <summary>
            The line join style specifies the shape to be used at the corners of
            paths that are stroked.
            </summary>
            <remarks>
            The line join style specifies the shape to be used at the corners of
            paths that are stroked. Join styles are significant only at points where
            consecutive segments of a path connect at an angle; segments that meet or
            intersect fortuitously receive no special treatment.
            All documentation for this class is taken from ISO 32000-1, section
            8.4.3.4 "Line Join Style".
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.PdfCanvasConstants.LineJoinStyle.MITER">
            <summary>
            The outer edges of the strokes for the two segments are extended
            until they meet at an angle, as in a picture frame.
            </summary>
            <remarks>
            The outer edges of the strokes for the two segments are extended
            until they meet at an angle, as in a picture frame. If the segments
            meet at too sharp an angle, a bevel join is used instead.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.PdfCanvasConstants.LineJoinStyle.ROUND">
            <summary>
            An arc of a circle with a diameter equal to the line width is drawn
            around the point where the two segments meet, connecting the outer
            edges of the strokes for the two segments.
            </summary>
            <remarks>
            An arc of a circle with a diameter equal to the line width is drawn
            around the point where the two segments meet, connecting the outer
            edges of the strokes for the two segments. This pieslice-shaped
            figure is filled in, producing a rounded corner.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.PdfCanvasConstants.LineJoinStyle.BEVEL">
            <summary>
            The two segments are finished with butt caps (@see LineCapStyle#BUTT)
            and the resulting notch beyond the ends of the segments is filled
            with a triangle.
            </summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.PdfPatternCanvas">
            <summary>A PdfCanvas instance with an inherent tiling pattern.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfPatternCanvas.#ctor(iText.Kernel.Pdf.PdfStream,iText.Kernel.Pdf.PdfResources,iText.Kernel.Pdf.PdfDocument)">
            <summary>Creates PdfPatternCanvas from content stream of page, form XObject, pattern etc.</summary>
            <param name="contentStream">@see PdfStream.</param>
            <param name="resources">the resources, a specialized dictionary that can be used by PDF instructions in the content stream
                </param>
            <param name="document">the document that the resulting content stream will be written to</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.PdfPatternCanvas.#ctor(iText.Kernel.Pdf.Colorspace.PdfPattern.Tiling,iText.Kernel.Pdf.PdfDocument)">
            <summary>Creates PdfPatternCanvas for a document from a provided Tiling pattern</summary>
            <param name="pattern">@see PdfPattern.Tiling. The Tiling pattern must be colored</param>
            <param name="document">the document that the resulting content stream will be written to</param>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Wmf.InputMeta">
            <summary>Helper class to read nt, short, words, etc.</summary>
            <remarks>Helper class to read nt, short, words, etc. from an InputStream.</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.InputMeta.#ctor(System.IO.Stream)">
            <summary>Creates an InputMeta object.</summary>
            <param name="in">InputStream containing the WMF data</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.InputMeta.ReadWord">
            <summary>Read the next word from the InputStream.</summary>
            <returns>the next word or 0 if the end of the stream has been reached</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.InputMeta.ReadShort">
            <summary>Read the next short from the InputStream.</summary>
            <returns>the next short value</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.InputMeta.ReadInt">
            <summary>Read the next int from the InputStream.</summary>
            <returns>the next int</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.InputMeta.ReadByte">
            <summary>Read the next byte from the InputStream.</summary>
            <returns>the next byte</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.InputMeta.Skip(System.Int32)">
            <summary>Skips "len" amount of bytes from the InputStream.</summary>
            <remarks>Skips "len" amount of bytes from the InputStream. If len is &lt; 0, nothing is skipped.</remarks>
            <param name="len">amount of bytes needed to skip</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.InputMeta.GetLength">
            <summary>Get the amount of bytes read and/or skipped from the InputStream.</summary>
            <returns>number of bytes read</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.InputMeta.ReadColor">
            <summary>
            Read the next
            <see cref="T:iText.Kernel.Colors.Color"/>
            from the InputStream. This reads 4 bytes.
            </summary>
            <returns>the next Color</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Wmf.MetaBrush">
            <summary>
            A Brush bject that holds information about the style, the hatch and the color of
            the brush.
            </summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Wmf.MetaObject">
            <summary>A meta object.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaObject.#ctor">
            <summary>Creates a new MetaObject.</summary>
            <remarks>Creates a new MetaObject. This constructor doesn't set the type.</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaObject.#ctor(System.Int32)">
            <summary>Creates a MetaObject with a type.</summary>
            <param name="type">the type of meta object</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaObject.GetObjectType">
            <summary>Get the type of this MetaObject.</summary>
            <returns>type of MetaObject</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaBrush.#ctor">
            <summary>Creates a MetaBrush object.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaBrush.Init(iText.Kernel.Pdf.Canvas.Wmf.InputMeta)">
            <summary>Initializes this MetaBrush object.</summary>
            <param name="in">the InputMeta</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaBrush.GetStyle">
            <summary>Get the style of the MetaBrush.</summary>
            <returns>style of the brush</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaBrush.GetHatch">
            <summary>Get the hatch pattern of the MetaBrush</summary>
            <returns>hatch of the brush</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaBrush.GetColor">
            <summary>Get the color of the MetaBrush.</summary>
            <returns>color of the brush</returns>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Wmf.MetaDo">
            <summary>A class to process WMF files.</summary>
            <remarks>
            A class to process WMF files. Used internally by
            <see cref="T:iText.Kernel.Pdf.Canvas.Wmf.WmfImageHelper"/>
            .
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Wmf.MetaDo.cb">
            <summary>PdfCanvas of the MetaDo object.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Wmf.MetaDo.in">
            <summary>The InputMeta instance containing the data.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaDo.#ctor(System.IO.Stream,iText.Kernel.Pdf.Canvas.PdfCanvas)">
            <summary>Creates a MetaDo instance.</summary>
            <param name="in">inputstream containing the data</param>
            <param name="cb">PdfCanvas</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaDo.ReadAll">
            <summary>Reads and processes all the data of the InputMeta.</summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaDo.OutputText(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
            <summary>Output Text at a certain x and y coordinate.</summary>
            <remarks>Output Text at a certain x and y coordinate. Clipped or opaque text isn't supported as of yet.</remarks>
            <param name="x">x-coordinate</param>
            <param name="y">y-coordinate</param>
            <param name="flag">flag indicating clipped or opaque</param>
            <param name="x1">x1-coordinate of the rectangle if clipped or opaque</param>
            <param name="y1">y1-coordinate of the rectangle if clipped or opaque</param>
            <param name="x2">x2-coordinate of the rectangle if clipped or opaque</param>
            <param name="y2">y1-coordinate of the rectangle if clipped or opaque</param>
            <param name="text">text to output</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaDo.IsNullStrokeFill(System.Boolean)">
            <summary>Return true if the pen style is null and if it isn't a brush.</summary>
            <param name="isRectangle">
            value to decide how to change the state. If true state.setLineJoinRectangle(cb) is called,
            if false state.setLineJoinPolygon(cb) is called.
            </param>
            <returns>true if the pen style is null and if it isn't a brush</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaDo.StrokeAndFill">
            <summary>Stroke and fill the MetaPen and MetaBrush paths.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaDo.WrapBMP(iText.IO.Image.ImageData)">
            <summary>Wrap a BMP image in an WMF.</summary>
            <param name="image">the BMP image to be wrapped</param>
            <returns>the wrapped BMP</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaDo.WriteWord(System.IO.Stream,System.Int32)">
            <summary>Writes the specified value to the specified outputstream as a word.</summary>
            <param name="os">outputstream to write the word to</param>
            <param name="v">value to be written</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaDo.WriteDWord(System.IO.Stream,System.Int32)">
            <summary>Writes the specified value to the specified outputstream as a dword.</summary>
            <param name="os">outputstream to write the dword to</param>
            <param name="v">value to be written</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Wmf.MetaFont">
            <summary>A Meta Font.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaFont.#ctor">
            <summary>Creates a MetaFont instance.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaFont.Init(iText.Kernel.Pdf.Canvas.Wmf.InputMeta)">
            <summary>Initializes the MetaFont instance.</summary>
            <param name="in">InputMeta containing the WMF data</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaFont.GetFont">
            <summary>Returns the Font.</summary>
            <returns>the font</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaFont.GetEncoding">
            <summary>Returns the encoding used in the MetaFont.</summary>
            <returns>the font encoding</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaFont.GetAngle">
            <summary>Returns the angle of the MetaFont.</summary>
            <returns>the angle</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaFont.IsUnderline">
            <summary>Returns a boolean value indicating if the font is underlined or not.</summary>
            <returns>true if the font is underlined</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaFont.IsStrikeout">
            <summary>Returns a boolean value indicating if a font has a strikeout.</summary>
            <returns>true if the font set strikeout</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaFont.GetFontSize(iText.Kernel.Pdf.Canvas.Wmf.MetaState)">
            <summary>Returns the font size.</summary>
            <param name="state">the MetaState</param>
            <returns>font size</returns>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Wmf.MetaPen">
            <summary>A Pen object of the WMF format.</summary>
            <remarks>A Pen object of the WMF format. Holds the color, style and width information of the pen.</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaPen.#ctor">
            <summary>Creates a MetaPen object.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaPen.Init(iText.Kernel.Pdf.Canvas.Wmf.InputMeta)">
            <summary>Initializes a MetaPen object.</summary>
            <param name="in">the InputMeta object that holds the inputstream of the WMF image</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaPen.GetStyle">
            <summary>Get the style of the MetaPen.</summary>
            <returns>style of the pen</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaPen.GetPenWidth">
            <summary>Get the width of the MetaPen.</summary>
            <returns>width of the pen</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaPen.GetColor">
            <summary>Get the color of the MetaPen.</summary>
            <returns>color of the pen</returns>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Wmf.MetaState">
            <summary>Class to keep the state.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Wmf.MetaState.savedStates">
            <summary>Stack of saved states.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Wmf.MetaState.MetaObjects">
            <summary>List of MetaObjects.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Wmf.MetaState.currentPoint">
            <summary>Current Point.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Wmf.MetaState.currentPen">
            <summary>Current Pen.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Wmf.MetaState.currentBrush">
            <summary>Current Brush.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Wmf.MetaState.currentFont">
            <summary>Current Font.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Wmf.MetaState.currentBackgroundColor">
            <summary>The current background color.</summary>
            <remarks>The current background color. Default value is DeviceRgb#WHITE.</remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Wmf.MetaState.currentTextColor">
            <summary>Current text color.</summary>
            <remarks>Current text color. Default value is DeviceRgb#BLACK.</remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Wmf.MetaState.backgroundMode">
            <summary>The current background mode.</summary>
            <remarks>The current background mode. Default value is OPAQUE.</remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Wmf.MetaState.polyFillMode">
            <summary>Current polygon fill mode.</summary>
            <remarks>Current polygon fill mode. Default value is ALTERNATE.</remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Wmf.MetaState.lineJoin">
            <summary>Curent line join.</summary>
            <remarks>Curent line join. Default value is 1.</remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Wmf.MetaState.textAlign">
            <summary>Current text alignment.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Wmf.MetaState.offsetWx">
            <summary>Current offset for Wx.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Wmf.MetaState.offsetWy">
            <summary>Current offset for Wy.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Wmf.MetaState.extentWx">
            <summary>Current extent for Wx.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Wmf.MetaState.extentWy">
            <summary>Current extent for Wy.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Wmf.MetaState.scalingX">
            <summary>Current x value for scaling.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Wmf.MetaState.scalingY">
            <summary>Current y value for scaling.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.#ctor">
            <summary>Creates new MetaState</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.#ctor(iText.Kernel.Pdf.Canvas.Wmf.MetaState)">
            <summary>Clones a new MetaState from the specified MetaState.</summary>
            <param name="state">the state to clone</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.SetMetaState(iText.Kernel.Pdf.Canvas.Wmf.MetaState)">
            <summary>Sets every field of this MetaState to the values of the fields of the specified MetaState.</summary>
            <param name="state">state to copy</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.AddMetaObject(iText.Kernel.Pdf.Canvas.Wmf.MetaObject)">
            <summary>Add a MetaObject to the State.</summary>
            <param name="object">MetaObject to be added</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.SelectMetaObject(System.Int32,iText.Kernel.Pdf.Canvas.PdfCanvas)">
            <summary>Select the MetaObject at the specified index and prepare the PdfCanvas.</summary>
            <param name="index">position of the MetaObject</param>
            <param name="cb">PdfCanvas to prepare</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.DeleteMetaObject(System.Int32)">
            <summary>Deletes the MetaObject at the specified index.</summary>
            <param name="index">index of the MetaObject to delete</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.SaveState(iText.Kernel.Pdf.Canvas.PdfCanvas)">
            <summary>Saves the state of this MetaState object.</summary>
            <param name="cb">PdfCanvas object on which saveState() will be called</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.RestoreState(System.Int32,iText.Kernel.Pdf.Canvas.PdfCanvas)">
            <summary>Restores the state to the next state on the saved states stack.</summary>
            <param name="index">index of the state to be restored</param>
            <param name="cb">PdfCanvas object on which restoreState() will be called</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.Cleanup(iText.Kernel.Pdf.Canvas.PdfCanvas)">
            <summary>Restres the state of the specified PdfCanvas object for as many times as there are saved states on the stack.
                </summary>
            <param name="cb">PdfCanvas object</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.TransformX(System.Int32)">
            <summary>Transform the specified value.</summary>
            <param name="x">the value to transform</param>
            <returns>the transformed value</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.TransformY(System.Int32)">
            <summary>Transform the specified value.</summary>
            <param name="y">the value to transform</param>
            <returns>transformed value</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.SetScalingX(System.Single)">
            <summary>Sets the x value for scaling.</summary>
            <param name="scalingX">x value for scaling</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.SetScalingY(System.Single)">
            <summary>Sets the y value for scaling.</summary>
            <param name="scalingY">y value for scaling</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.SetOffsetWx(System.Int32)">
            <summary>Sets the Wx offset value.</summary>
            <param name="offsetWx">Wx offset value</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.SetOffsetWy(System.Int32)">
            <summary>Sets the Wy offset value.</summary>
            <param name="offsetWy">Wy offset value</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.SetExtentWx(System.Int32)">
            <summary>Sets the Wx extent value.</summary>
            <param name="extentWx">Wx extent value</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.SetExtentWy(System.Int32)">
            <summary>Sets the Wy extent value.</summary>
            <param name="extentWy">Wy extent value</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.TransformAngle(System.Single)">
            <summary>Transforms the specified angle.</summary>
            <remarks>
            Transforms the specified angle. If scalingY is less than 0, the angle is multiplied by -1. If scalingX is less
            than 0, the angle is subtracted from Math.PI.
            </remarks>
            <param name="angle">the angle to transform</param>
            <returns>the transformed angle</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.SetCurrentPoint(iText.Kernel.Geom.Point)">
            <summary>Sets the current Point to the specified Point.</summary>
            <param name="p">Point to set</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.GetCurrentPoint">
            <summary>Returns the current Point.</summary>
            <returns>current Point</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.GetCurrentBrush">
            <summary>Returns the current MetaBrush object.</summary>
            <returns>current MetaBrush</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.GetCurrentPen">
            <summary>Returns the current MetaPen object.</summary>
            <returns>current MetaPen</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.GetCurrentFont">
            <summary>Returns the current MetaFont object.</summary>
            <returns>current MetaFont</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.GetCurrentBackgroundColor">
            <summary>Getter for property currentBackgroundColor.</summary>
            <returns>Value of property currentBackgroundColor.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.SetCurrentBackgroundColor(iText.Kernel.Colors.Color)">
            <summary>Setter for property currentBackgroundColor.</summary>
            <param name="currentBackgroundColor">New value of property currentBackgroundColor.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.GetCurrentTextColor">
            <summary>Getter for property currentTextColor.</summary>
            <returns>Value of property currentTextColor.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.SetCurrentTextColor(iText.Kernel.Colors.Color)">
            <summary>Setter for property currentTextColor.</summary>
            <param name="currentTextColor">New value of property currentTextColor.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.GetBackgroundMode">
            <summary>Getter for property backgroundMode.</summary>
            <returns>Value of property backgroundMode.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.SetBackgroundMode(System.Int32)">
            <summary>Setter for property backgroundMode.</summary>
            <param name="backgroundMode">New value of property backgroundMode.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.GetTextAlign">
            <summary>Getter for property textAlign.</summary>
            <returns>Value of property textAlign.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.SetTextAlign(System.Int32)">
            <summary>Setter for property textAlign.</summary>
            <param name="textAlign">New value of property textAlign.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.GetPolyFillMode">
            <summary>Getter for property polyFillMode.</summary>
            <returns>Value of property polyFillMode.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.SetPolyFillMode(System.Int32)">
            <summary>Setter for property polyFillMode.</summary>
            <param name="polyFillMode">New value of property polyFillMode.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.SetLineJoinRectangle(iText.Kernel.Pdf.Canvas.PdfCanvas)">
            <summary>
            Sets the line join style to
            <see cref="F:iText.Kernel.Pdf.Canvas.PdfCanvasConstants.LineJoinStyle.MITER"/>
            if lineJoin isn't 0.
            </summary>
            <param name="cb">PdfCanvas to set the line join style</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.SetLineJoinPolygon(iText.Kernel.Pdf.Canvas.PdfCanvas)">
            <summary>
            Sets the line join style to
            <see cref="F:iText.Kernel.Pdf.Canvas.PdfCanvasConstants.LineJoinStyle.ROUND"/>
            if lineJoin is 0.
            </summary>
            <param name="cb">PdfCanvas to set the line join style</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.MetaState.GetLineNeutral">
            <summary>Returns true if lineJoin is 0.</summary>
            <returns>true if lineJoin is 0</returns>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Wmf.WmfImageData">
            <summary>Image implementation for WMF, Windows Metafile.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.WmfImageData.#ctor(System.String)">
            <summary>Creates a WmfImage from a file.</summary>
            <param name="fileName">pah to the file</param>
            <exception cref="T:System.UriFormatException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.WmfImageData.#ctor(System.Uri)">
            <summary>Creates a WmfImage from a URL.</summary>
            <param name="url">URL to the file</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.WmfImageData.#ctor(System.Byte[])">
            <summary>Creates a WmfImage from a byte[].</summary>
            <param name="bytes">the image bytes</param>
        </member>
        <member name="T:iText.Kernel.Pdf.Canvas.Wmf.WmfImageHelper">
            <summary>Helper class for the WmfImage implementation.</summary>
            <remarks>
            Helper class for the WmfImage implementation. Assists in the creation of a
            <see cref="T:iText.Kernel.Pdf.Xobject.PdfFormXObject"/>
            .
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Canvas.Wmf.WmfImageHelper.wmfFontCorrection">
            <summary>Scales the WMF font size.</summary>
            <remarks>Scales the WMF font size. The default value is 0.86.</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.WmfImageHelper.#ctor(iText.IO.Image.ImageData)">
            <summary>Creates a helper instance.</summary>
            <param name="wmf">
            the
            <see cref="T:iText.Kernel.Pdf.Canvas.Wmf.WmfImageData"/>
            object
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.WmfImageHelper.ProcessParameters">
            <summary>This method checks if the image is a valid WMF and processes some parameters.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Canvas.Wmf.WmfImageHelper.CreatePdfForm(iText.Kernel.Pdf.PdfDocument)">
            <summary>Create a PdfXObject based on the WMF image.</summary>
            <remarks>
            Create a PdfXObject based on the WMF image. The PdfXObject will have the dimensions of the
            WMF image.
            </remarks>
            <param name="document">PdfDocument to add the PdfXObject to</param>
            <returns>PdfXObject based on the WMF image</returns>
        </member>
        <member name="F:iText.Kernel.Pdf.Collection.PdfCollection.DETAILS">
            <summary>A type of initial view</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Collection.PdfCollection.TILE">
            <summary>A type of initial view</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Collection.PdfCollection.HIDDEN">
            <summary>A type of initial view</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Collection.PdfCollection.#ctor">
            <summary>Constructs a PDF Collection.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Collection.PdfCollection.SetSchema(iText.Kernel.Pdf.Collection.PdfCollectionSchema)">
            <summary>Sets the Collection schema dictionary.</summary>
            <param name="schema">an overview of the collection fields</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Collection.PdfCollection.SetInitialDocument(System.String)">
            <summary>
            Identifies the document that will be initially presented
            in the user interface.
            </summary>
            <param name="documentName">a string that identifies an entry in the EmbeddedFiles name tree</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Collection.PdfCollection.SetView(System.Int32)">
            <summary>Sets the initial view.</summary>
            <param name="viewType"/>
        </member>
        <member name="M:iText.Kernel.Pdf.Collection.PdfCollection.SetSort(iText.Kernel.Pdf.Collection.PdfCollectionSort)">
            <summary>Sets the Collection sort dictionary.</summary>
            <param name="sort"/>
        </member>
        <member name="F:iText.Kernel.Pdf.Collection.PdfCollectionField.TEXT">
            <summary>A possible type of collection field.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Collection.PdfCollectionField.DATE">
            <summary>A possible type of collection field.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Collection.PdfCollectionField.NUMBER">
            <summary>A possible type of collection field.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Collection.PdfCollectionField.FILENAME">
            <summary>A possible type of collection field.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Collection.PdfCollectionField.DESC">
            <summary>A possible type of collection field.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Collection.PdfCollectionField.MODDATE">
            <summary>A possible type of collection field.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Collection.PdfCollectionField.CREATIONDATE">
            <summary>A possible type of collection field.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Collection.PdfCollectionField.SIZE">
            <summary>A possible type of collection field.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Collection.PdfCollectionField.#ctor(System.String,System.Int32)">
            <summary>Creates a PdfCollectionField.</summary>
            <param name="name">the field name</param>
            <param name="subType">the field subtype</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Collection.PdfCollectionField.SetOrder(System.Int32)">
            <summary>The relative order of the field name.</summary>
            <remarks>The relative order of the field name. Fields are sorted in ascending order.</remarks>
            <param name="order">a number indicating the order of the field</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Collection.PdfCollectionField.SetVisibility(System.Boolean)">
            <summary>Sets the initial visibility of the field.</summary>
            <param name="visible"/>
        </member>
        <member name="M:iText.Kernel.Pdf.Collection.PdfCollectionField.SetEditable(System.Boolean)">
            <summary>Indication if the field value should be editable in the viewer.</summary>
            <param name="editable"/>
        </member>
        <member name="M:iText.Kernel.Pdf.Collection.PdfCollectionItem.AddItem(System.String,System.String)">
            <summary>Sets the value of the collection item.</summary>
            <param name="key"/>
            <param name="value"/>
        </member>
        <member name="M:iText.Kernel.Pdf.Collection.PdfCollectionItem.AddItem(System.String,iText.Kernel.Pdf.PdfDate)">
            <summary>Sets the value of the collection item.</summary>
            <param name="d"/>
        </member>
        <member name="M:iText.Kernel.Pdf.Collection.PdfCollectionItem.AddItem(System.String,iText.Kernel.Pdf.PdfNumber)">
            <summary>Sets the value of the collection item.</summary>
            <param name="n"/>
        </member>
        <member name="M:iText.Kernel.Pdf.Collection.PdfCollectionItem.SetPrefix(System.String,System.String)">
            <summary>Adds a prefix for the Collection item.</summary>
            <remarks>
            Adds a prefix for the Collection item.
            You can only use this method after you have set the value of the item.
            </remarks>
            <param name="key"/>
            <param name="prefix"/>
        </member>
        <member name="M:iText.Kernel.Pdf.Collection.PdfCollectionSchema.#ctor">
            <summary>Creates a Collection Schema dictionary.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Collection.PdfCollectionSchema.AddField(System.String,iText.Kernel.Pdf.Collection.PdfCollectionField)">
            <summary>Adds a Collection field to the Schema.</summary>
            <param name="name">the name of the collection field</param>
            <param name="field">a Collection Field</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Collection.PdfCollectionSort.#ctor(System.String)">
            <summary>Constructs a PDF Collection Sort Dictionary.</summary>
            <param name="key">the key of the field that will be used to sort entries</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Collection.PdfCollectionSort.#ctor(System.String[])">
            <summary>Constructs a PDF Collection Sort Dictionary.</summary>
            <param name="keys">the keys of the fields that will be used to sort entries</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Collection.PdfCollectionSort.SetSortOrder(System.Boolean)">
            <summary>Defines the sort order of the field (ascending or descending).</summary>
            <param name="ascending">true is the default, use false for descending order</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Collection.PdfCollectionSort.SetSortOrder(System.Boolean[])">
            <summary>Defines the sort order of the field (ascending or descending).</summary>
            <param name="ascending">an array with every element corresponding with a name of a field.</param>
        </member>
        <member name="T:iText.Kernel.Pdf.Colorspace.PdfColorSpace">
            <summary>Represents the most common properties of color spaces.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfCieBasedCs.Flush">
            <summary>
            To manually flush a
            <c>PdfObject</c>
            behind this wrapper, you have to ensure
            that this object is added to the document, i.e. it has an indirect reference.
            Basically this means that before flushing you need to explicitly call
            <see cref="M:iText.Kernel.Pdf.PdfObjectWrapper`1.MakeIndirect(iText.Kernel.Pdf.PdfDocument)"/>
            .
            For example: wrapperInstance.makeIndirect(document).flush();
            Note that not every wrapper require this, only those that have such warning in documentation.
            </summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Colorspace.PdfPattern">
            <summary>
            Dictionary wrapper that represent special type of color space, that uses pattern objects
            as the equivalent of colour values instead of the numeric component values used with other spaces.
            </summary>
            <remarks>
            Dictionary wrapper that represent special type of color space, that uses pattern objects
            as the equivalent of colour values instead of the numeric component values used with other spaces.
            A pattern object shall be a dictionary or a stream, depending on the type of pattern.
            For mor information see paragraph 8.7 in ISO-32000-1.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfPattern.GetPatternInstance(iText.Kernel.Pdf.PdfDictionary)">
            <summary>
            Creates the instance wrapper of correct type from the
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            </summary>
            <param name="pdfObject">
            the
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            that represent Pattern
            </param>
            <returns>new wrapper instance.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfPattern.GetMatrix">
            <summary>
            Gets a transformation matrix that maps the pattern’s internal coordinate system
            to the default coordinate system of the pattern’s parent content stream.
            </summary>
            <remarks>
            Gets a transformation matrix that maps the pattern’s internal coordinate system
            to the default coordinate system of the pattern’s parent content stream.
            The concatenation of the pattern matrix with that of the parent content stream
            establishes the pattern coordinate space, within which all graphics objects in the pattern shall be interpreted.
            </remarks>
            <returns>pattern matrix</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfPattern.SetMatrix(iText.Kernel.Pdf.PdfArray)">
            <summary>
            Sets a transformation matrix that maps the pattern’s internal coordinate system
            to the default coordinate system of the pattern’s parent content stream.
            </summary>
            <remarks>
            Sets a transformation matrix that maps the pattern’s internal coordinate system
            to the default coordinate system of the pattern’s parent content stream.
            The concatenation of the pattern matrix with that of the parent content stream
            establishes the pattern coordinate space, within which all graphics objects in the pattern shall be interpreted.
            </remarks>
            <param name="matrix">pattern matrix to set</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfPattern.Flush">
            <summary>
            To manually flush a
            <c>PdfObject</c>
            behind this wrapper, you have to ensure
            that this object is added to the document, i.e. it has an indirect reference.
            Basically this means that before flushing you need to explicitly call
            <see cref="M:iText.Kernel.Pdf.PdfObjectWrapper`1.MakeIndirect(iText.Kernel.Pdf.PdfDocument)"/>
            .
            For example: wrapperInstance.makeIndirect(document).flush();
            Note that not every wrapper require this, only those that have such warning in documentation.
            </summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Colorspace.PdfPattern.Tiling">
            <summary>Wrapper that represents tiling pattern of color space.</summary>
            <remarks>
            Wrapper that represents tiling pattern of color space. This pattern consists of a small graphical figure (cells).
            Painting with the pattern replicates the cell at fixed horizontal and vertical intervals to fill an area.
            The pattern cell can include graphical elements such as filled areas, text, and sampled images.
            Its shape need not be rectangular, and the spacing of tiles can differ from the dimensions of the cell itself.
            The appearance of the pattern cell shall be defined by a content stream
            containing the painting operators needed to paint one instance of the cell
            </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfPattern.Tiling.#ctor(iText.Kernel.Pdf.PdfStream)">
            <summary>
            Creates new instance from the
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            object.
            This stream should have PatternType equals to 1.
            </summary>
            <param name="pdfObject">
            the
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            that represents Tiling Pattern.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfPattern.Tiling.IsColored">
            <summary>Checks if this pattern have colored paint type.</summary>
            <returns>
            
            <see langword="true"/>
            if this pattern's paint type is
            <see cref="F:iText.Kernel.Pdf.Colorspace.PdfPattern.Tiling.PaintType.COLORED"/>
            and
            <see langword="false"/>
            otherwise.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfPattern.Tiling.SetColored(System.Boolean)">
            <summary>Sets the paint type.</summary>
            <param name="colored">
            if
            <see langword="true"/>
            then the paint type will be set as
            <see cref="F:iText.Kernel.Pdf.Colorspace.PdfPattern.Tiling.PaintType.COLORED"/>
            ,
            and
            <see cref="F:iText.Kernel.Pdf.Colorspace.PdfPattern.Tiling.PaintType.UNCOLORED"/>
            otherwise.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfPattern.Tiling.GetTilingType">
            <summary>Gets the tiling type.</summary>
            <returns>
            int value of
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfPattern.Tiling.TilingType"/>
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfPattern.Tiling.SetTilingType(System.Int32)">
            <summary>Sets the tiling type.</summary>
            <param name="tilingType">
            int value of
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfPattern.Tiling.TilingType"/>
            to set.
            </param>
            <exception cref="T:System.ArgumentException">in case of wrong value.</exception>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfPattern.Tiling.GetBBox">
            <summary>Gets the pattern cell's bounding box.</summary>
            <remarks>Gets the pattern cell's bounding box. These boundaries shall be used to clip the pattern cell.</remarks>
            <returns>pattern cell's bounding box.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfPattern.Tiling.SetBBox(iText.Kernel.Geom.Rectangle)">
            <summary>Sets the pattern cell's bounding box.</summary>
            <remarks>Sets the pattern cell's bounding box. These boundaries shall be used to clip the pattern cell.</remarks>
            <param name="bbox">pattern cell's bounding box to set.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfPattern.Tiling.Flush">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Colorspace.PdfPattern.Tiling.PaintType">
            <summary>A code that determines how the colour of the pattern cell shall be specified</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Colorspace.PdfPattern.Tiling.PaintType.COLORED">
            <summary>The pattern’s content stream shall specify the colours used to paint the pattern cell.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Colorspace.PdfPattern.Tiling.PaintType.UNCOLORED">
            <summary>The pattern’s content stream shall not specify any colour information.</summary>
            <remarks>
            The pattern’s content stream shall not specify any colour information.
            Instead, the entire cell is painted with a separately specified colour each time the pattern is used.
            </remarks>
        </member>
        <member name="T:iText.Kernel.Pdf.Colorspace.PdfPattern.Tiling.TilingType">
            <summary>A code that controls adjustments to the spacing of tiles relative to the device pixel grid</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Colorspace.PdfPattern.Tiling.TilingType.CONSTANT_SPACING">
            <summary>Pattern cells shall be spaced consistently—that is, by a multiple of a device pixel.</summary>
            <remarks>
            Pattern cells shall be spaced consistently—that is, by a multiple of a device pixel.
            To achieve this, the conforming reader may need to distort the pattern cell slightly.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Colorspace.PdfPattern.Tiling.TilingType.NO_DISTORTION">
            <summary>
            The pattern cell shall not be distorted,
            but the spacing between pattern cells may vary by as much as 1 device pixel.
            </summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Colorspace.PdfPattern.Tiling.TilingType.CONSTANT_SPACING_AND_FASTER_TILING">
            <summary>
            Pattern cells shall be spaced consistently as in tiling type 1,
            but with additional distortion permitted to enable a more efficient implementation.
            </summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Colorspace.PdfShading">
            <summary>The abstract PdfShading class that represents the Shading Dictionary PDF object.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.MakeShading(iText.Kernel.Pdf.PdfDictionary)">
            <summary>
            Creates the
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfShading"/>
            object from the existing
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            with corresponding type.
            </summary>
            <param name="shadingDictionary">
            
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            from which the
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfShading"/>
            object will be created.
            </param>
            <returns>
            Created
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfShading"/>
            object.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.GetShadingType">
            <summary>Gets the shading type.</summary>
            <returns>
            int value of
            <see cref="F:iText.Kernel.Pdf.PdfName.ShadingType"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.GetColorSpace">
            <summary>Gets the color space in which colour values shall be expressed.</summary>
            <returns>
            
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            Color space
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.GetFunction">
            <summary>
            Gets the function PdfObject that represents color transitions
            across the shading geometry.
            </summary>
            <returns>
            
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            Function
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.SetFunction(iText.Kernel.Pdf.Function.PdfFunction)">
            <summary>
            Sets the function that represents color transitions
            across the shading geometry as one object.
            </summary>
            <param name="function">
            The
            <see cref="T:iText.Kernel.Pdf.Function.PdfFunction"/>
            to set.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.SetFunction(iText.Kernel.Pdf.Function.PdfFunction[])">
            <summary>
            Sets the function object that represents color transitions
            across the shading geometry as an array of functions.
            </summary>
            <param name="functions">
            The array of
            <see cref="T:iText.Kernel.Pdf.Function.PdfFunction"/>
            to be set.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.Flush">
            <summary>
            To manually flush a
            <c>PdfObject</c>
            behind this wrapper, you have to ensure
            that this object is added to the document, i.e. it has an indirect reference.
            Basically this means that before flushing you need to explicitly call
            <see cref="M:iText.Kernel.Pdf.PdfObjectWrapper`1.MakeIndirect(iText.Kernel.Pdf.PdfDocument)"/>
            .
            For example: wrapperInstance.makeIndirect(document).flush();
            Note that not every wrapper require this, only those that have such warning in documentation.
            </summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Colorspace.PdfShading.ShadingType">
            <summary>constants of shading type (see ISO-320001 Table 78)</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Colorspace.PdfShading.ShadingType.FUNCTION_BASED">
            <summary>The int value of function-based shading type</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Colorspace.PdfShading.ShadingType.AXIAL">
            <summary>The int value of axial shading type</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Colorspace.PdfShading.ShadingType.RADIAL">
            <summary>The int value of radial shading type</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Colorspace.PdfShading.ShadingType.FREE_FORM_GOURAUD_SHADED_TRIANGLE_MESH">
            <summary>The int value of free-form Gouraud-shaded triangle mesh shading type</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Colorspace.PdfShading.ShadingType.LATTICE_FORM_GOURAUD_SHADED_TRIANGLE_MESH">
            <summary>The int value of lattice-form Gouraud-shaded triangle mesh shading type</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Colorspace.PdfShading.ShadingType.COONS_PATCH_MESH">
            <summary>The int value of coons patch meshes shading type</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Colorspace.PdfShading.ShadingType.TENSOR_PRODUCT_PATCH_MESH">
            <summary>The int value of tensor-product patch meshes shading type</summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Colorspace.PdfShading.FunctionBased">
            <summary>
            The class that extends
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfShading"/>
            class and is in charge of Shading Dictionary with function-based type,
            that defines color at every point in the domain by a specified mathematical function.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.FunctionBased.#ctor(iText.Kernel.Pdf.PdfDictionary)">
            <summary>
            Creates the new instance of the class from the existing
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            object.
            </summary>
            <param name="pdfDictionary">
            
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            from which the instance is created.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.FunctionBased.#ctor(iText.Kernel.Pdf.Colorspace.PdfColorSpace,iText.Kernel.Pdf.Function.PdfFunction)">
            <summary>Creates the new instance of the class.</summary>
            <param name="colorSpace">
            the
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfColorSpace"/>
            object in which colour values shall be expressed.
            </param>
            <param name="function">
            the
            <see cref="T:iText.Kernel.Pdf.Function.PdfFunction"/>
            , that is used to calculate color transitions.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.FunctionBased.#ctor(iText.Kernel.Pdf.PdfObject,iText.Kernel.Pdf.Function.PdfFunction)">
            <summary>Creates the new instance of the class.</summary>
            <param name="colorSpace">
            the
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            , that represents color space in which colour values shall be expressed.
            </param>
            <param name="function">
            the
            <see cref="T:iText.Kernel.Pdf.Function.PdfFunction"/>
            , that is used to calculate color transitions.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.FunctionBased.GetDomain">
            <summary>
            Gets the
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            domain rectangle object that establishes an internal coordinate space
            for the shading that is independent of the target coordinate space in which it shall be painted.
            </summary>
            <returns>
            
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            domain rectangle.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.FunctionBased.SetDomain(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Sets the
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            domain rectangle object that establishes an internal coordinate space
            for the shading that is independent of the target coordinate space in which it shall be painted.
            </summary>
            <param name="xmin">the Xmin coordinate of rectangle.</param>
            <param name="xmax">the Xmax coordinate of rectangle.</param>
            <param name="ymin">the Ymin coordinate of rectangle.</param>
            <param name="ymax">the Ymax coordinate of rectangle.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.FunctionBased.SetDomain(iText.Kernel.Pdf.PdfArray)">
            <summary>
            Sets the
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            domain rectangle object that establishes an internal coordinate space
            for the shading that is independent of the target coordinate space in which it shall be painted.
            </summary>
            <param name="domain">
            the
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            domain rectangle object to be set.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.FunctionBased.GetMatrix">
            <summary>
            Gets the array of floats that represents the transformation matrix that maps the domain rectangle
            into a corresponding figure in the target coordinate space.
            </summary>
            <returns>
            the
            <c>float[]</c>
            of transformation matrix (identical matrix by default).
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.FunctionBased.SetMatrix(System.Single[])">
            <summary>
            Sets the array of floats that represents the transformation matrix that maps the domain rectangle
            into a corresponding figure in the target coordinate space.
            </summary>
            <param name="matrix">
            the
            <c>float[]</c>
            of transformation matrix to be set.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.FunctionBased.SetMatrix(iText.Kernel.Pdf.PdfArray)">
            <summary>
            Sets the array of floats that represents the transformation matrix that maps the domain rectangle
            into a corresponding figure in the target coordinate space.
            </summary>
            <param name="matrix">
            the
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            transformation matrix object to be set.
            </param>
        </member>
        <member name="T:iText.Kernel.Pdf.Colorspace.PdfShading.Axial">
            <summary>
            The class that extends
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfShading"/>
            class and is in charge of Shading Dictionary with axial type,
            that define a colour blend that varies along a linear axis between two endpoints
            and extends indefinitely perpendicular to that axis.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.Axial.#ctor(iText.Kernel.Pdf.PdfDictionary)">
            <summary>
            Creates the new instance of the class from the existing
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            object.
            </summary>
            <param name="pdfDictionary">
            
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            from which the instance is created.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.Axial.#ctor(iText.Kernel.Pdf.Colorspace.PdfColorSpace,System.Single,System.Single,System.Single[],System.Single,System.Single,System.Single[])">
            <summary>Creates the new instance of the class.</summary>
            <param name="cs">
            the
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfColorSpace"/>
            object in which colour values shall be expressed.
            The special Pattern space isn't excepted.
            </param>
            <param name="x0">the start coordinate of X axis expressed in the shading's target coordinate space.</param>
            <param name="y0">the start coordinate of Y axis expressed in the shading's target coordinate space.</param>
            <param name="color0">
            the
            <c>float[]</c>
            that represents the color in the start point.
            </param>
            <param name="x1">the end coordinate of X axis expressed in the shading's target coordinate space.</param>
            <param name="y1">the end coordinate of Y axis expressed in the shading's target coordinate space.</param>
            <param name="color1">
            the
            <c>float[]</c>
            that represents the color in the end point.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.Axial.#ctor(iText.Kernel.Pdf.Colorspace.PdfColorSpace,System.Single,System.Single,System.Single[],System.Single,System.Single,System.Single[],System.Boolean[])">
            <summary>Creates the new instance of the class.</summary>
            <param name="cs">
            the
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfColorSpace"/>
            object in which colour values shall be expressed.
            The special Pattern space isn't excepted.
            </param>
            <param name="x0">the start coordinate of X axis expressed in the shading's target coordinate space.</param>
            <param name="y0">the start coordinate of Y axis expressed in the shading's target coordinate space.</param>
            <param name="color0">
            the
            <c>float[]</c>
            that represents the color in the start point.
            </param>
            <param name="x1">the end coordinate of X axis expressed in the shading's target coordinate space.</param>
            <param name="y1">the end coordinate of Y axis expressed in the shading's target coordinate space.</param>
            <param name="color1">
            the
            <c>float[]</c>
            that represents the color in the end point.
            </param>
            <param name="extend">
            the array of two booleans that specified whether to extend the shading
            beyond the starting and ending points of the axis, respectively.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.Axial.#ctor(iText.Kernel.Pdf.Colorspace.PdfColorSpace,iText.Kernel.Pdf.PdfArray,iText.Kernel.Pdf.Function.PdfFunction)">
            <summary>Creates the new instance of the class.</summary>
            <param name="cs">
            the
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfColorSpace"/>
            object in which colour values shall be expressed.
            The special Pattern space isn't excepted.
            </param>
            <param name="coords">
            the
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            of four number four numbers [x0 y0 x1 y1] that specified the starting
            and the endings coordinates of thew axis, expressed in the shading's target coordinate space.
            </param>
            <param name="function">
            the
            <see cref="T:iText.Kernel.Pdf.Function.PdfFunction"/>
            object, that is used to calculate color transitions.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.Axial.GetCoords">
            <summary>
            Gets the Coords object - a
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            of four numbers [x0 y0 x1 y1] that specified the starting
            and the endings coordinates of thew axis, expressed in the shading's target coordinate space.
            </summary>
            <returns>
            the
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            Coords object.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.Axial.SetCoords(System.Single,System.Single,System.Single,System.Single)">
            <summary>Sets the Choords object with the four params expressed in the shading's target coordinate space.</summary>
            <param name="x0">the start coordinate of X axis to be set.</param>
            <param name="y0">the start coordinate of Y axis to be set.</param>
            <param name="x1">the end coordinate of X axis to be set.</param>
            <param name="y1">the end coordinate of Y axis to be set.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.Axial.SetCoords(iText.Kernel.Pdf.PdfArray)">
            <summary>
            Sets the Choords object with the
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            of four numbers [x0 y0 x1 y1],
            that specified the starting and the endings coordinates of thew axis,
            expressed in the shading's target coordinate space.
            </summary>
            <param name="coords">
            the Chords
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            to be set.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.Axial.GetDomain">
            <summary>
            Gets the array of two
            <c>float</c>
            [t0, t1] that represent the limiting values of a parametric
            variable t, that becomes an input of color function(s).
            </summary>
            <returns>
            
            <c>float[]</c>
            of Domain object ([0.0 1.0] by default)
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.Axial.SetDomain(System.Single,System.Single)">
            <summary>
            Sets the Domain with the array of two
            <c>float</c>
            [t0, t1] that represent the limiting values
            of a parametric variable t, that becomes an input of color function(s).
            </summary>
            <param name="t0">first limit of variable t</param>
            <param name="t1">second limit of variable t</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.Axial.GetExtend">
            <summary>
            Gets the array of two
            <c>boolean</c>
            that specified whether to extend the shading
            beyond the starting and ending points of the axis, respectively.
            </summary>
            <returns>
            
            <c>boolean[]</c>
            of Extended object ([false false] by default)
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.Axial.SetExtend(System.Boolean,System.Boolean)">
            <summary>
            Sets the Extend object with the two
            <c>boolean</c>
            value.
            </summary>
            <param name="extendStart">if true will extend shading beyond the starting point of Coords</param>
            <param name="extendEnd">if true will extend shading beyond the ending point of Coords</param>
        </member>
        <member name="T:iText.Kernel.Pdf.Colorspace.PdfShading.Radial">
            <summary>
            The class that extends
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfShading"/>
            class and is in charge of Shading Dictionary with radial type,
            that define a colour blend that varies between two circles.
            This type of shading shall not be used with an Indexed colour space
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.Radial.#ctor(iText.Kernel.Pdf.PdfDictionary)">
            <summary>
            Creates the new instance of the class from the existing
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            object.
            </summary>
            <param name="pdfDictionary">
            -
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            from which the instance is created.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.Radial.#ctor(iText.Kernel.Pdf.Colorspace.PdfColorSpace,System.Single,System.Single,System.Single,System.Single[],System.Single,System.Single,System.Single,System.Single[])">
            <summary>Creates the new instance of the class.</summary>
            <param name="cs">
            the
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfColorSpace"/>
            object in which colour values shall be expressed.
            The Indexed color space isn't excepted.
            </param>
            <param name="x0">the X coordinate of starting circle's centre, expressed in in the shading’s target coordinate space.
                </param>
            <param name="y0">the Y coordinate of starting circle's centre, expressed in in the shading’s target coordinate space.
                </param>
            <param name="r0">
            the radius of starting circle's centre, should be greater or equal to 0.
            If 0 then starting circle is treated as point.
            If both radii are 0, nothing shall be painted.
            </param>
            <param name="color0">
            the
            <c>float[]</c>
            that represents the color in the start circle.
            </param>
            <param name="x1">the X coordinate of ending circle's centre, expressed in in the shading’s target coordinate space.
                </param>
            <param name="y1">the Y coordinate of ending circle's centre, expressed in in the shading’s target coordinate space.
                </param>
            <param name="r1">
            the radius of ending circle's centre, should be greater or equal to 0.
            If 0 then ending circle is treated as point.
            If both radii are 0, nothing shall be painted.
            </param>
            <param name="color1">
            the
            <c>float[]</c>
            that represents the color in the end circle.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.Radial.#ctor(iText.Kernel.Pdf.Colorspace.PdfColorSpace,System.Single,System.Single,System.Single,System.Single[],System.Single,System.Single,System.Single,System.Single[],System.Boolean[])">
            <summary>Creates the new instance of the class.</summary>
            <param name="cs">
            the
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfColorSpace"/>
            object in which colour values shall be expressed.
            The Indexed color space isn't excepted.
            </param>
            <param name="x0">the X coordinate of starting circle's centre, expressed in in the shading’s target coordinate space.
                </param>
            <param name="y0">the Y coordinate of starting circle's centre, expressed in in the shading’s target coordinate space.
                </param>
            <param name="r0">
            the radius of starting circle's centre, should be greater or equal to 0.
            If 0 then starting circle is treated as point.
            If both radii are 0, nothing shall be painted.
            </param>
            <param name="color0">
            the
            <c>float[]</c>
            that represents the color in the start circle.
            </param>
            <param name="x1">the X coordinate of ending circle's centre, expressed in in the shading’s target coordinate space.
                </param>
            <param name="y1">the Y coordinate of ending circle's centre, expressed in in the shading’s target coordinate space.
                </param>
            <param name="r1">
            the radius of ending circle's centre, should be greater or equal to 0.
            If 0 then ending circle is treated as point.
            If both radii are 0, nothing shall be painted.
            </param>
            <param name="color1">
            the
            <c>float[]</c>
            that represents the color in the end circle.
            </param>
            <param name="extend">
            the array of two
            <c>boolean</c>
            that specified whether to extend the shading
            beyond the starting and ending points of the axis, respectively.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.Radial.#ctor(iText.Kernel.Pdf.Colorspace.PdfColorSpace,iText.Kernel.Pdf.PdfArray,iText.Kernel.Pdf.Function.PdfFunction)">
            <summary>Creates the new instance of the class.</summary>
            <param name="cs">
            the
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfColorSpace"/>
            object in which colour values shall be expressed.
            The Indexed color space isn't excepted.
            </param>
            <param name="coords">
            the
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            of of six numbers [x0 y0 r0 x1 y1 r1],
            specifying the centres and radii of the starting and ending circles,
            expressed in the shading’s target coordinate space.
            The radii r0 and r1 shall both be greater than or equal to 0.
            If one radius is 0, the corresponding circle shall be treated as a point;
            if both are 0, nothing shall be painted.
            </param>
            <param name="function">
            the
            <see cref="T:iText.Kernel.Pdf.Function.PdfFunction"/>
            object, that is used to calculate color transitions.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.Radial.GetCoords">
            <summary>
            Gets the coords
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            object - an array of six numbers [x0 y0 r0 x1 y1 r1],
            specifying the centres and radii of the starting and ending circles,
            expressed in the shading’s target coordinate space.
            The radii r0 and r1 shall both be greater than or equal to 0.
            If one radius is 0, the corresponding circle shall be treated as a point;
            if both are 0, nothing shall be painted.
            </summary>
            <returns>
            the
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            coords object.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.Radial.SetCoords(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>Sets the coords object.</summary>
            <param name="x0">the X coordinate of starting circle's centre, expressed in in the shading’s target coordinate space.
                </param>
            <param name="y0">the Y coordinate of starting circle's centre, expressed in in the shading’s target coordinate space.
                </param>
            <param name="r0">
            the radius of starting circle's centre, should be greater or equal to 0.
            If 0 then starting circle is treated as point.
            If both radii are 0, nothing shall be painted.
            </param>
            <param name="x1">the X coordinate of ending circle's centre, expressed in in the shading’s target coordinate space.
                </param>
            <param name="y1">the Y coordinate of ending circle's centre, expressed in in the shading’s target coordinate space.
                </param>
            <param name="r1">
            the radius of ending circle's centre, should be greater or equal to 0.
            If 0 then ending circle is treated as point.
            If both radii are 0, nothing shall be painted.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.Radial.SetCoords(iText.Kernel.Pdf.PdfArray)">
            <summary>
            Sets the coords
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            object - an array of six numbers [x0 y0 r0 x1 y1 r1],
            specifying the centres and radii of the starting and ending circles,
            expressed in the shading’s target coordinate space.
            The radii r0 and r1 shall both be greater than or equal to 0.
            If one radius is 0, the corresponding circle shall be treated as a point;
            if both are 0, nothing shall be painted.
            </summary>
            <param name="coords">
            -
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            choords object to be set.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.Radial.GetDomain">
            <summary>
            Gets the array of two
            <c>float</c>
            [t0, t1] that represent the limiting values of a parametric
            variable t, that becomes an input of color function(s).
            </summary>
            <returns>
            
            <c>float[]</c>
            of Domain object ([0.0 1.0] by default)
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.Radial.SetDomain(System.Single,System.Single)">
            <summary>
            Sets the Domain with the array of two
            <c>float</c>
            [t0, t1] that represent the limiting values
            of a parametric variable t, that becomes an input of color function(s).
            </summary>
            <param name="t0">first limit of variable t</param>
            <param name="t1">second limit of variable t</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.Radial.GetExtend">
            <summary>
            Gets the array of two
            <c>boolean</c>
            that specified whether to extend the shading
            beyond the starting and ending circles of the axis, respectively.
            </summary>
            <returns>
            
            <c>boolean[]</c>
            of Extended object ([false false] by default)
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.Radial.SetExtend(System.Boolean,System.Boolean)">
            <summary>
            Sets the Extend object with the two
            <c>boolean</c>
            value.
            </summary>
            <param name="extendStart">if true will extend shading beyond the starting circle of Coords.</param>
            <param name="extendEnd">if true will extend shading beyond the ending circle of Coords.</param>
        </member>
        <member name="T:iText.Kernel.Pdf.Colorspace.PdfShading.FreeFormGouraudShadedTriangleMesh">
            <summary>
            The class that extends
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfShading"/>
            class and is in charge of Shading Dictionary with
            free-form Gouraud-shaded triangle mesh type.
            The area to be shaded is defined by a path composed entirely of triangles.
            The colour at each vertex of the triangles is specified,
            and a technique known as Gouraud interpolation is used to colour the interiors.
            The object shall be represented as stream containing a sequence of vertex data.
            Each vertex is specified by the following values, in the order shown:
            f x y c1 ... cn where:
            f -  the vertex's edge flag, that determines the vertex is connected to other vertices of the triangle mesh.
            For full description, see ISO-320001 Paragraph 8.7.4.5.5
            x, y - vertex's horizontal and vertical coordinates, expressed in the shading's target coordinate space.
            c1...cn - vertex's colour components.
            If the shading dictionary includes a Function entry, only a single parametric value, t,
            shall be specified for each vertex in place of the colour components c1...cn.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.FreeFormGouraudShadedTriangleMesh.#ctor(iText.Kernel.Pdf.PdfStream)">
            <summary>
            Creates the new instance of the class from the existing
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            object.
            </summary>
            <param name="pdfStream">
            
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            from which the instance is created.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.FreeFormGouraudShadedTriangleMesh.#ctor(iText.Kernel.Pdf.Colorspace.PdfColorSpace,System.Int32,System.Int32,System.Int32,System.Single[])">
            <summary>Creates the new instance of the class.</summary>
            <param name="cs">
            the
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfColorSpace"/>
            object in which colour values shall be expressed.
            The special Pattern space isn't excepted.
            </param>
            <param name="bitsPerCoordinate">
            the number of bits used to represent each vertex coordinate.
            The value shall be 1, 2, 4, 8, 12, 16, 24, or 32.
            </param>
            <param name="bitsPerComponent">
            the number of bits used to represent each colour component.
            The value shall be 1, 2, 4, 8, 12, or 16.
            </param>
            <param name="bitsPerFlag">
            the number of bits used to represent the edge flag for each vertex.
            The value of BitsPerFlag shall be 2, 4, or 8,
            but only the least significant 2 bits in each flag value shall be used.
            The value for the edge flag shall be 0, 1, or 2.
            </param>
            <param name="decode">
            the
            <c>int[]</c>
            of numbers specifying how to map vertex coordinates and colour components
            into the appropriate ranges of values. The ranges shall be specified as follows:
            [x_min x_max y_min y_max c1_min c1_max … cn_min cn_max].
            Only one pair of color values shall be specified if a Function entry is present.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.FreeFormGouraudShadedTriangleMesh.#ctor(iText.Kernel.Pdf.Colorspace.PdfColorSpace,System.Int32,System.Int32,System.Int32,iText.Kernel.Pdf.PdfArray)">
            <summary>Creates the new instance of the class.</summary>
            <param name="cs">
            the
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfColorSpace"/>
            object in which colour values shall be expressed.
            The special Pattern space isn't excepted.
            </param>
            <param name="bitsPerCoordinate">
            the number of bits used to represent each vertex coordinate.
            The value shall be 1, 2, 4, 8, 12, 16, 24, or 32.
            </param>
            <param name="bitsPerComponent">
            the number of bits used to represent each colour component.
            The value shall be 1, 2, 4, 8, 12, or 16.
            </param>
            <param name="bitsPerFlag">
            the number of bits used to represent the edge flag for each vertex.
            The value of BitsPerFlag shall be 2, 4, or 8,
            but only the least significant 2 bits in each flag value shall be used.
            The value for the edge flag shall be 0, 1, or 2.
            </param>
            <param name="decode">
            the
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            of numbers specifying how to map vertex coordinates and colour components
            into the appropriate ranges of values. The ranges shall be specified as follows:
            [x_min x_max y_min y_max c1_min c1_max … cn_min cn_max].
            Only one pair of color values shall be specified if a Function entry is present.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.FreeFormGouraudShadedTriangleMesh.GetBitsPerCoordinate">
            <summary>Gets the number of bits used to represent each vertex coordinate.</summary>
            <returns>the number of bits. Can be 1, 2, 4, 8, 12, 16, 24, or 32.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.FreeFormGouraudShadedTriangleMesh.SetBitsPerCoordinate(System.Int32)">
            <summary>Sets the number of bits used to represent each vertex coordinate.</summary>
            <param name="bitsPerCoordinate">the number of bits to be set. Shall be 1, 2, 4, 8, 12, 16, 24, or 32.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.FreeFormGouraudShadedTriangleMesh.GetBitsPerComponent">
            <summary>Gets the number of bits used to represent each colour component.</summary>
            <returns>the number of bits. Can be 1, 2, 4, 8, 12, or 16.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.FreeFormGouraudShadedTriangleMesh.SetBitsPerComponent(System.Int32)">
            <summary>Sets the number of bits used to represent each colour component.</summary>
            <param name="bitsPerComponent">the number of bits to be set. Shall be 1, 2, 4, 8, 12, or 16.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.FreeFormGouraudShadedTriangleMesh.GetBitsPerFlag">
            <summary>Gets the number of bits used to represent the edge flag for each vertex.</summary>
            <remarks>
            Gets the number of bits used to represent the edge flag for each vertex.
            But only the least significant 2 bits in each flag value shall be used.
            The valid flag values are 0, 1 or 2.
            </remarks>
            <returns>the number of bits. Can be 2, 4 or 8.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.FreeFormGouraudShadedTriangleMesh.SetBitsPerFlag(System.Int32)">
            <summary>Sets the number of bits used to represent the edge flag for each vertex.</summary>
            <remarks>
            Sets the number of bits used to represent the edge flag for each vertex.
            But only the least significant 2 bits in each flag value shall be used.
            The valid flag values are 0, 1 or 2.
            </remarks>
            <param name="bitsPerFlag">the number of bits to be set. Shall be 2, 4 or 8.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.FreeFormGouraudShadedTriangleMesh.GetDecode">
            <summary>
            Gets the
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            of numbers specifying how to map vertex coordinates and colour components
            into the appropriate ranges of values. The ranges shall be specified as follows:
            [x_min x_max y_min y_max c1_min c1_max … cn_min cn_max].
            Only one pair of color values shall be specified if a Function entry is present.
            </summary>
            <returns>
            the
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            Decode object.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.FreeFormGouraudShadedTriangleMesh.SetDecode(System.Single[])">
            <summary>
            Sets the
            <c>float[]</c>
            of numbers specifying how to map vertex coordinates and colour components
            into the appropriate ranges of values. The ranges shall be specified as follows:
            [x_min x_max y_min y_max c1_min c1_max … cn_min cn_max].
            Only one pair of color values shall be specified if a Function entry is present.
            </summary>
            <param name="decode">
            the
            <c>float[]</c>
            of Decode object to set.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.FreeFormGouraudShadedTriangleMesh.SetDecode(iText.Kernel.Pdf.PdfArray)">
            <summary>
            Sets the
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            of numbers specifying how to map vertex coordinates and colour components
            into the appropriate ranges of values. The ranges shall be specified as follows:
            [x_min x_max y_min y_max c1_min c1_max … cn_min cn_max].
            Only one pair of color values shall be specified if a Function entry is present.
            </summary>
            <param name="decode">
            the
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            Decode object to set.
            </param>
        </member>
        <member name="T:iText.Kernel.Pdf.Colorspace.PdfShading.LatticeFormGouraudShadedTriangleMesh">
            <summary>
            The class that extends
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfShading"/>
            class and is in charge of Shading Dictionary with
            lattice-form Gouraud-shaded triangle mesh type.
            This type is similar to
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfShading.FreeFormGouraudShadedTriangleMesh"/>
            but instead of using free-form geometry,
            the vertices are arranged in a pseudorectangular lattice,
            which is topologically equivalent to a rectangular grid.
            The vertices are organized into rows, which need not be geometrically linear.
            The verticals data in stream is similar to
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfShading.FreeFormGouraudShadedTriangleMesh"/>
            ,
            except there is no edge flag.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.LatticeFormGouraudShadedTriangleMesh.#ctor(iText.Kernel.Pdf.PdfStream)">
            <summary>
            Creates the new instance of the class from the existing
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            object.
            </summary>
            <param name="pdfStream">
            
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            from which the instance is created.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.LatticeFormGouraudShadedTriangleMesh.#ctor(iText.Kernel.Pdf.Colorspace.PdfColorSpace,System.Int32,System.Int32,System.Int32,System.Single[])">
            <summary>Creates the new instance of the class.</summary>
            <param name="cs">
            the
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfColorSpace"/>
            object in which colour values shall be expressed.
            The special Pattern space isn't excepted.
            </param>
            <param name="bitsPerCoordinate">
            the number of bits used to represent each vertex coordinate.
            The value shall be 1, 2, 4, 8, 12, 16, 24, or 32.
            </param>
            <param name="bitsPerComponent">
            the number of bits used to represent each colour component.
            The value shall be 1, 2, 4, 8, 12, or 16.
            </param>
            <param name="verticesPerRow">
            the number of vertices in each row of the lattice (shall be &gt; 1).
            The number of rows need not be specified.
            </param>
            <param name="decode">
            the
            <c>int[]</c>
            of numbers specifying how to map vertex coordinates and colour components
            into the appropriate ranges of values. The ranges shall be specified as follows:
            [x_min x_max y_min y_max c1_min c1_max … cn_min cn_max].
            Only one pair of color values shall be specified if a Function entry is present.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.LatticeFormGouraudShadedTriangleMesh.#ctor(iText.Kernel.Pdf.Colorspace.PdfColorSpace,System.Int32,System.Int32,System.Int32,iText.Kernel.Pdf.PdfArray)">
            <summary>Creates the new instance of the class.</summary>
            <param name="cs">
            the
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfColorSpace"/>
            object in which colour values shall be expressed.
            The special Pattern space isn't excepted.
            </param>
            <param name="bitsPerCoordinate">
            the number of bits used to represent each vertex coordinate.
            The value shall be 1, 2, 4, 8, 12, 16, 24, or 32.
            </param>
            <param name="bitsPerComponent">
            the number of bits used to represent each colour component.
            The value shall be 1, 2, 4, 8, 12, or 16.
            </param>
            <param name="verticesPerRow">
            the number of vertices in each row of the lattice (shall be &gt; 1).
            The number of rows need not be specified.
            </param>
            <param name="decode">
            the
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            of numbers specifying how to map vertex coordinates and colour components
            into the appropriate ranges of values. The ranges shall be specified as follows:
            [x_min x_max y_min y_max c1_min c1_max … cn_min cn_max].
            Only one pair of color values shall be specified if a Function entry is present.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.LatticeFormGouraudShadedTriangleMesh.GetBitsPerCoordinate">
            <summary>Gets the number of bits used to represent each vertex coordinate.</summary>
            <returns>the number of bits. Can be 1, 2, 4, 8, 12, 16, 24, or 32.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.LatticeFormGouraudShadedTriangleMesh.SetBitsPerCoordinate(System.Int32)">
            <summary>Sets the number of bits used to represent each vertex coordinate.</summary>
            <param name="bitsPerCoordinate">the number of bits to be set. Shall be 1, 2, 4, 8, 12, 16, 24, or 32.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.LatticeFormGouraudShadedTriangleMesh.GetBitsPerComponent">
            <summary>Gets the number of bits used to represent each colour component.</summary>
            <returns>the number of bits. Can be 1, 2, 4, 8, 12, or 16.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.LatticeFormGouraudShadedTriangleMesh.SetBitsPerComponent(System.Int32)">
            <summary>Sets the number of bits used to represent each colour component.</summary>
            <param name="bitsPerComponent">the number of bits to be set. Shall be 1, 2, 4, 8, 12, or 16.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.LatticeFormGouraudShadedTriangleMesh.GetVerticesPerRow">
            <summary>Gets the number of vertices in each row of the lattice.</summary>
            <returns>the number of vertices. Can only be greater than 1.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.LatticeFormGouraudShadedTriangleMesh.SetVerticesPerRow(System.Int32)">
            <summary>Sets the number of vertices in each row of the lattice.</summary>
            <remarks>
            Sets the number of vertices in each row of the lattice.
            The number of rows need not be specified.
            </remarks>
            <param name="verticesPerRow">the number of vertices to be set. Shall be greater than 1.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.LatticeFormGouraudShadedTriangleMesh.GetDecode">
            <summary>
            Gets the
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            of numbers specifying how to map vertex coordinates and colour components
            into the appropriate ranges of values. The ranges shall be specified as follows:
            [x_min x_max y_min y_max c1_min c1_max … cn_min cn_max].
            Only one pair of color values shall be specified if a Function entry is present.
            </summary>
            <returns>
            the
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            Decode object.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.LatticeFormGouraudShadedTriangleMesh.SetDecode(System.Single[])">
            <summary>
            Sets the
            <c>float[]</c>
            of numbers specifying how to map vertex coordinates and colour components
            into the appropriate ranges of values. The ranges shall be specified as follows:
            [x_min x_max y_min y_max c1_min c1_max … cn_min cn_max].
            Only one pair of color values shall be specified if a Function entry is present.
            </summary>
            <param name="decode">
            the
            <c>float[]</c>
            of Decode object to set.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.LatticeFormGouraudShadedTriangleMesh.SetDecode(iText.Kernel.Pdf.PdfArray)">
            <summary>
            Sets the
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            of numbers specifying how to map vertex coordinates and colour components
            into the appropriate ranges of values. The ranges shall be specified as follows:
            [x_min x_max y_min y_max c1_min c1_max … cn_min cn_max].
            Only one pair of color values shall be specified if a Function entry is present.
            </summary>
            <param name="decode">
            the
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            Decode object to set.
            </param>
        </member>
        <member name="T:iText.Kernel.Pdf.Colorspace.PdfShading.CoonsPatchMesh">
            <summary>
            The class that extends
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfShading"/>
            class and is in charge of Shading Dictionary with
            Coons Patch mesh type.
            This type of shading is constructed from one or more colour patches, each bounded by four cubic Bézier curves.
            Degenerate Bézier curves are allowed and are useful for certain graphical effects.
            At least one complete patch shall be specified.
            The shape of patch is defined by 12 control points.
            Colours are specified for each corner of the unit square,
            and bilinear interpolation is used to fill in colours over the entire unit square.
            Coordinates are mapped from the unit square into a four-sided patch whose sides are not necessarily linear.
            The mapping is continuous: the corners of the unit square map to corners of the patch
            and the sides of the unit square map to sides of the patch.
            For the format of data stream, that defines patches (see ISO-320001 Table 85).
            If the shading dictionary contains a Function entry, the colour data for each corner of a patch
            shall be specified by a single parametric value t rather than by n separate colour components c1...cn.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.CoonsPatchMesh.#ctor(iText.Kernel.Pdf.PdfStream)">
            <summary>
            Creates the new instance of the class from the existing
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            object.
            </summary>
            <param name="pdfStream">
            
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            from which the instance is created.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.CoonsPatchMesh.#ctor(iText.Kernel.Pdf.Colorspace.PdfColorSpace,System.Int32,System.Int32,System.Int32,System.Single[])">
            <summary>Creates the new instance of the class.</summary>
            <param name="cs">
            the
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfColorSpace"/>
            object in which colour values shall be expressed.
            The special Pattern space isn't excepted.
            </param>
            <param name="bitsPerCoordinate">
            the number of bits used to represent each vertex coordinate.
            The value shall be 1, 2, 4, 8, 12, 16, 24, or 32.
            </param>
            <param name="bitsPerComponent">
            the number of bits used to represent each colour component.
            The value shall be 1, 2, 4, 8, 12, or 16.
            </param>
            <param name="bitsPerFlag">
            the number of bits used to represent the edge flag for each vertex.
            The value of BitsPerFlag shall be 2, 4, or 8,
            but only the least significant 2 bits in each flag value shall be used.
            The value for the edge flag shall be 0, 1, 2 or 3.
            </param>
            <param name="decode">
            the
            <c>int[]</c>
            of numbers specifying how to map vertex coordinates and colour components
            into the appropriate ranges of values. The ranges shall be specified as follows:
            [x_min x_max y_min y_max c1_min c1_max … cn_min cn_max].
            Only one pair of color values shall be specified if a Function entry is present.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.CoonsPatchMesh.#ctor(iText.Kernel.Pdf.Colorspace.PdfColorSpace,System.Int32,System.Int32,System.Int32,iText.Kernel.Pdf.PdfArray)">
            <summary>Creates the new instance of the class.</summary>
            <param name="cs">
            the
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfColorSpace"/>
            object in which colour values shall be expressed.
            The special Pattern space isn't excepted.
            </param>
            <param name="bitsPerCoordinate">
            the number of bits used to represent each vertex coordinate.
            The value shall be 1, 2, 4, 8, 12, 16, 24, or 32.
            </param>
            <param name="bitsPerComponent">
            the number of bits used to represent each colour component.
            The value shall be 1, 2, 4, 8, 12, or 16.
            </param>
            <param name="bitsPerFlag">
            the number of bits used to represent the edge flag for each vertex.
            The value of BitsPerFlag shall be 2, 4, or 8,
            but only the least significant 2 bits in each flag value shall be used.
            The value for the edge flag shall be 0, 1, 2 or 3.
            </param>
            <param name="decode">
            the
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            of numbers specifying how to map vertex coordinates and colour components
            into the appropriate ranges of values. The ranges shall be specified as follows:
            [x_min x_max y_min y_max c1_min c1_max … cn_min cn_max].
            Only one pair of color values shall be specified if a Function entry is present.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.CoonsPatchMesh.GetBitsPerCoordinate">
            <summary>Gets the number of bits used to represent each vertex coordinate.</summary>
            <returns>the number of bits. Can be 1, 2, 4, 8, 12, 16, 24, or 32.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.CoonsPatchMesh.SetBitsPerCoordinate(System.Int32)">
            <summary>Sets the number of bits used to represent each vertex coordinate.</summary>
            <param name="bitsPerCoordinate">the number of bits to be set. Shall be 1, 2, 4, 8, 12, 16, 24, or 32.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.CoonsPatchMesh.GetBitsPerComponent">
            <summary>Gets the number of bits used to represent each colour component.</summary>
            <returns>the number of bits. Can be 1, 2, 4, 8, 12, or 16.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.CoonsPatchMesh.SetBitsPerComponent(System.Int32)">
            <summary>Sets the number of bits used to represent each colour component.</summary>
            <param name="bitsPerComponent">the number of bits to be set. Shall be 1, 2, 4, 8, 12, or 16.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.CoonsPatchMesh.GetBitsPerFlag">
            <summary>Gets the number of bits used to represent the edge flag for each vertex.</summary>
            <remarks>
            Gets the number of bits used to represent the edge flag for each vertex.
            But only the least significant 2 bits in each flag value shall be used.
            The valid flag values are 0, 1, 2 or 3.
            </remarks>
            <returns>the number of bits. Can be 2, 4 or 8.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.CoonsPatchMesh.SetBitsPerFlag(System.Int32)">
            <summary>Sets the number of bits used to represent the edge flag for each vertex.</summary>
            <remarks>
            Sets the number of bits used to represent the edge flag for each vertex.
            But only the least significant 2 bits in each flag value shall be used.
            The valid flag values are 0, 1, 2 or 3.
            </remarks>
            <param name="bitsPerFlag">the number of bits to be set. Shall be 2, 4 or 8.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.CoonsPatchMesh.GetDecode">
            <summary>
            Gets the
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            of numbers specifying how to map vertex coordinates and colour components
            into the appropriate ranges of values. The ranges shall be specified as follows:
            [x_min x_max y_min y_max c1_min c1_max … cn_min cn_max].
            Only one pair of color values shall be specified if a Function entry is present.
            </summary>
            <returns>
            the
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            Decode object.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.CoonsPatchMesh.SetDecode(System.Single[])">
            <summary>
            Sets the
            <c>float[]</c>
            of numbers specifying how to map vertex coordinates and colour components
            into the appropriate ranges of values. The ranges shall be specified as follows:
            [x_min x_max y_min y_max c1_min c1_max … cn_min cn_max].
            Only one pair of color values shall be specified if a Function entry is present.
            </summary>
            <param name="decode">
            the
            <c>float[]</c>
            of Decode object to set.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.CoonsPatchMesh.SetDecode(iText.Kernel.Pdf.PdfArray)">
            <summary>
            Sets the
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            of numbers specifying how to map vertex coordinates and colour components
            into the appropriate ranges of values. The ranges shall be specified as follows:
            [x_min x_max y_min y_max c1_min c1_max … cn_min cn_max].
            Only one pair of color values shall be specified if a Function entry is present.
            </summary>
            <param name="decode">
            the
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            Decode object to set.
            </param>
        </member>
        <member name="T:iText.Kernel.Pdf.Colorspace.PdfShading.TensorProductPatchMesh">
            <summary>
            The class that extends
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfShading"/>
            class and is in charge of Shading Dictionary with
            Tensor-Product Patch mesh type.
            This type of shading is identical to
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfShading.CoonsPatchMesh"/>
            , except that it's based on a
            bicubic tensor-product patch defined by 16 control points.
            For the format of data stream, that defines patches, see ISO-320001 Table 86.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.TensorProductPatchMesh.#ctor(iText.Kernel.Pdf.PdfStream)">
            <summary>
            Creates the new instance of the class from the existing
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            object.
            </summary>
            <param name="pdfStream">
            
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            from which the instance is created.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.TensorProductPatchMesh.#ctor(iText.Kernel.Pdf.Colorspace.PdfColorSpace,System.Int32,System.Int32,System.Int32,System.Single[])">
            <summary>Creates the new instance of the class.</summary>
            <param name="cs">
            the
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfColorSpace"/>
            object in which colour values shall be expressed.
            The special Pattern space isn't excepted.
            </param>
            <param name="bitsPerCoordinate">
            the number of bits used to represent each vertex coordinate.
            The value shall be 1, 2, 4, 8, 12, 16, 24, or 32.
            </param>
            <param name="bitsPerComponent">
            the number of bits used to represent each colour component.
            The value shall be 1, 2, 4, 8, 12, or 16.
            </param>
            <param name="bitsPerFlag">
            the number of bits used to represent the edge flag for each vertex.
            The value of BitsPerFlag shall be 2, 4, or 8,
            but only the least significant 2 bits in each flag value shall be used.
            The value for the edge flag shall be 0, 1, 2 or 3.
            </param>
            <param name="decode">
            the
            <c>int[]</c>
            of numbers specifying how to map vertex coordinates and colour components
            into the appropriate ranges of values. The ranges shall be specified as follows:
            [x_min x_max y_min y_max c1_min c1_max … cn_min cn_max].
            Only one pair of color values shall be specified if a Function entry is present.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.TensorProductPatchMesh.#ctor(iText.Kernel.Pdf.Colorspace.PdfColorSpace,System.Int32,System.Int32,System.Int32,iText.Kernel.Pdf.PdfArray)">
            <summary>Creates the new instance of the class.</summary>
            <param name="cs">
            the
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfColorSpace"/>
            object in which colour values shall be expressed.
            The special Pattern space isn't excepted.
            </param>
            <param name="bitsPerCoordinate">
            the number of bits used to represent each vertex coordinate.
            The value shall be 1, 2, 4, 8, 12, 16, 24, or 32.
            </param>
            <param name="bitsPerComponent">
            the number of bits used to represent each colour component.
            The value shall be 1, 2, 4, 8, 12, or 16.
            </param>
            <param name="bitsPerFlag">
            the number of bits used to represent the edge flag for each vertex.
            The value of BitsPerFlag shall be 2, 4, or 8,
            but only the least significant 2 bits in each flag value shall be used.
            The value for the edge flag shall be 0, 1, 2 or 3.
            </param>
            <param name="decode">
            the
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            of numbers specifying how to map vertex coordinates and colour components
            into the appropriate ranges of values. The ranges shall be specified as follows:
            [x_min x_max y_min y_max c1_min c1_max … cn_min cn_max].
            Only one pair of color values shall be specified if a Function entry is present.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.TensorProductPatchMesh.GetBitsPerCoordinate">
            <summary>Gets the number of bits used to represent each vertex coordinate.</summary>
            <returns>the number of bits. Can be 1, 2, 4, 8, 12, 16, 24, or 32.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.TensorProductPatchMesh.SetBitsPerCoordinate(System.Int32)">
            <summary>Sets the number of bits used to represent each vertex coordinate.</summary>
            <param name="bitsPerCoordinate">the number of bits to be set. Shall be 1, 2, 4, 8, 12, 16, 24, or 32.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.TensorProductPatchMesh.GetBitsPerComponent">
            <summary>Gets the number of bits used to represent each colour component.</summary>
            <returns>the number of bits. Can be 1, 2, 4, 8, 12, or 16.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.TensorProductPatchMesh.SetBitsPerComponent(System.Int32)">
            <summary>Sets the number of bits used to represent each colour component.</summary>
            <param name="bitsPerComponent">the number of bits to be set. Shall be 1, 2, 4, 8, 12, or 16.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.TensorProductPatchMesh.GetBitsPerFlag">
            <summary>Gets the number of bits used to represent the edge flag for each vertex.</summary>
            <remarks>
            Gets the number of bits used to represent the edge flag for each vertex.
            But only the least significant 2 bits in each flag value shall be used.
            The valid flag values are 0, 1, 2 or 3.
            </remarks>
            <returns>the number of bits. Can be 2, 4 or 8.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.TensorProductPatchMesh.SetBitsPerFlag(System.Int32)">
            <summary>Sets the number of bits used to represent the edge flag for each vertex.</summary>
            <remarks>
            Sets the number of bits used to represent the edge flag for each vertex.
            But only the least significant 2 bits in each flag value shall be used.
            The valid flag values are 0, 1, 2 or 3.
            </remarks>
            <param name="bitsPerFlag">the number of bits to be set. Shall be 2, 4 or 8.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.TensorProductPatchMesh.GetDecode">
            <summary>
            Gets the
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            of numbers specifying how to map vertex coordinates and colour components
            into the appropriate ranges of values. The ranges shall be specified as follows:
            [x_min x_max y_min y_max c1_min c1_max … cn_min cn_max].
            Only one pair of color values shall be specified if a Function entry is present.
            </summary>
            <returns>
            the
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            Decode object.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.TensorProductPatchMesh.SetDecode(System.Single[])">
            <summary>
            Sets the
            <c>float[]</c>
            of numbers specifying how to map vertex coordinates and colour components
            into the appropriate ranges of values. The ranges shall be specified as follows:
            [x_min x_max y_min y_max c1_min c1_max … cn_min cn_max].
            Only one pair of color values shall be specified if a Function entry is present.
            </summary>
            <param name="decode">
            the
            <c>float[]</c>
            of Decode object to set.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfShading.TensorProductPatchMesh.SetDecode(iText.Kernel.Pdf.PdfArray)">
            <summary>
            Sets the
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            of numbers specifying how to map vertex coordinates and colour components
            into the appropriate ranges of values. The ranges shall be specified as follows:
            [x_min x_max y_min y_max c1_min c1_max … cn_min cn_max].
            Only one pair of color values shall be specified if a Function entry is present.
            </summary>
            <param name="decode">
            the
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            Decode object to set.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfSpecialCs.Flush">
            <summary>
            To manually flush a
            <c>PdfObject</c>
            behind this wrapper, you have to ensure
            that this object is added to the document, i.e. it has an indirect reference.
            Basically this means that before flushing you need to explicitly call
            <see cref="M:iText.Kernel.Pdf.PdfObjectWrapper`1.MakeIndirect(iText.Kernel.Pdf.PdfDocument)"/>
            .
            For example: wrapperInstance.makeIndirect(document).flush();
            Note that not every wrapper require this, only those that have such warning in documentation.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Colorspace.PdfSpecialCs.UncoloredTilingPattern.Flush">
            <summary>
            To manually flush a
            <c>PdfObject</c>
            behind this wrapper, you have to ensure
            that this object is added to the document, i.e. it has an indirect reference.
            Basically this means that before flushing you need to explicitly call
            <see cref="M:iText.Kernel.Pdf.PdfObjectWrapper`1.MakeIndirect(iText.Kernel.Pdf.PdfDocument)"/>
            .
            For example: wrapperInstance.makeIndirect(document).flush();
            Note that not every wrapper require this, only those that have such warning in documentation.
            </summary>
        </member>
        <member name="T:iText.Kernel.Pdf.CompressionConstants">
            <summary>
            Compression constants for <see cref="T:iText.Kernel.Pdf.PdfStream"/>. 
            </summary>
        </member>
        <member name="F:iText.Kernel.Pdf.CompressionConstants.UNDEFINED_COMPRESSION">
            <summary>A possible compression level.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.CompressionConstants.DEFAULT_COMPRESSION">
            <summary>A possible compression level.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.CompressionConstants.NO_COMPRESSION">
            <summary>A possible compression level.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.CompressionConstants.BEST_SPEED">
            <summary>A possible compression level.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.CompressionConstants.BEST_COMPRESSION">
            <summary>A possible compression level.</summary>
        </member>
        <member name="T:iText.Kernel.Pdf.EncryptionConstants">
            <summary>
            Encryption constants for
            <see cref="M:iText.Kernel.Pdf.WriterProperties.SetStandardEncryption(System.Byte[],System.Byte[],System.Int32,System.Int32)"/>
            .
            </summary>
        </member>
        <member name="F:iText.Kernel.Pdf.EncryptionConstants.STANDARD_ENCRYPTION_40">
            <summary>Type of encryption.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.EncryptionConstants.STANDARD_ENCRYPTION_128">
            <summary>Type of encryption.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.EncryptionConstants.ENCRYPTION_AES_128">
            <summary>Type of encryption.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.EncryptionConstants.ENCRYPTION_AES_256">
            <summary>Type of encryption.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.EncryptionConstants.ENCRYPTION_MASK">
            <summary>Mask to separate the encryption type from the encryption mode.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.EncryptionConstants.DO_NOT_ENCRYPT_METADATA">
            <summary>Add this to the mode to keep the metadata in clear text.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.EncryptionConstants.EMBEDDED_FILES_ONLY">
            <summary>Add this to the mode to keep encrypt only the embedded files.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.EncryptionConstants.ALLOW_PRINTING">
            <summary>The operation permitted when the document is opened with the user password.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.EncryptionConstants.ALLOW_MODIFY_CONTENTS">
            <summary>The operation permitted when the document is opened with the user password.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.EncryptionConstants.ALLOW_COPY">
            <summary>The operation permitted when the document is opened with the user password.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.EncryptionConstants.ALLOW_MODIFY_ANNOTATIONS">
            <summary>The operation permitted when the document is opened with the user password.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.EncryptionConstants.ALLOW_FILL_IN">
            <summary>The operation permitted when the document is opened with the user password.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.EncryptionConstants.ALLOW_SCREENREADERS">
            <summary>The operation permitted when the document is opened with the user password.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.EncryptionConstants.ALLOW_ASSEMBLY">
            <summary>The operation permitted when the document is opened with the user password.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.EncryptionConstants.ALLOW_DEGRADED_PRINTING">
            <summary>The operation permitted when the document is opened with the user password.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.EncryptionProperties.userPassword">
            <summary>StandardEncryption properties</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.EncryptionProperties.publicCertificates">
            <summary>PublicKeyEncryption properties</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.EncryptionProperties.SetStandardEncryption(System.Byte[],System.Byte[],System.Int32,System.Int32)">
            <summary>Sets the encryption options for the document.</summary>
            <remarks>
            Sets the encryption options for the document. The userPassword and the
            ownerPassword can be null or have zero length. In this case the ownerPassword
            is replaced by a random string. The open permissions for the document can be
            ALLOW_PRINTING, ALLOW_MODIFY_CONTENTS, ALLOW_COPY, ALLOW_MODIFY_ANNOTATIONS,
            ALLOW_FILL_IN, ALLOW_SCREENREADERS, ALLOW_ASSEMBLY and ALLOW_DEGRADED_PRINTING.
            The permissions can be combined by ORing them.
            See
            <see cref="T:iText.Kernel.Pdf.EncryptionConstants"/>
            .
            </remarks>
            <param name="userPassword">the user password. Can be null or empty</param>
            <param name="ownerPassword">the owner password. Can be null or empty</param>
            <param name="permissions">the user permissions</param>
            <param name="encryptionAlgorithm">
            the type of encryption. It can be one of STANDARD_ENCRYPTION_40, STANDARD_ENCRYPTION_128,
            ENCRYPTION_AES128 or ENCRYPTION_AES256
            Optionally DO_NOT_ENCRYPT_METADATA can be ored to output the metadata in cleartext
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.EncryptionProperties.SetPublicKeyEncryption(Org.BouncyCastle.X509.X509Certificate[],System.Int32[],System.Int32)">
            <summary>Sets the certificate encryption options for the document.</summary>
            <remarks>
            Sets the certificate encryption options for the document. An array of one or more public certificates
            must be provided together with an array of the same size for the permissions for each certificate.
            The open permissions for the document can be
            AllowPrinting, AllowModifyContents, AllowCopy, AllowModifyAnnotations,
            AllowFillIn, AllowScreenReaders, AllowAssembly and AllowDegradedPrinting.
            The permissions can be combined by ORing them.
            Optionally DO_NOT_ENCRYPT_METADATA can be ORed to output the metadata in cleartext
            See
            <see cref="T:iText.Kernel.Pdf.EncryptionConstants"/>
            .
            </remarks>
            <param name="certs">the public certificates to be used for the encryption</param>
            <param name="permissions">the user permissions for each of the certificates</param>
            <param name="encryptionAlgorithm">
            the type of encryption. It can be one of STANDARD_ENCRYPTION_40, STANDARD_ENCRYPTION_128,
            ENCRYPTION_AES128 or ENCRYPTION_AES256.
            </param>
        </member>
        <member name="T:iText.Kernel.Pdf.Extgstate.PdfExtGState">
            <summary>Graphics state parameter dictionary wrapper.</summary>
            <remarks>
            Graphics state parameter dictionary wrapper.
            See ISO-320001, 8.4.5 Graphics State Parameter Dictionaries.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Extgstate.PdfExtGState.BM_NORMAL">
            <summary>Standard separable blend mode.</summary>
            <remarks>Standard separable blend mode. See ISO-320001, table 136</remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Extgstate.PdfExtGState.BM_MULTIPLY">
            <summary>Standard separable blend mode.</summary>
            <remarks>Standard separable blend mode. See ISO-320001, table 136</remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Extgstate.PdfExtGState.BM_SCREEN">
            <summary>Standard separable blend mode.</summary>
            <remarks>Standard separable blend mode. See ISO-320001, table 136</remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Extgstate.PdfExtGState.BM_OVERLAY">
            <summary>Standard separable blend mode.</summary>
            <remarks>Standard separable blend mode. See ISO-320001, table 136</remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Extgstate.PdfExtGState.BM_DARKEN">
            <summary>Standard separable blend mode.</summary>
            <remarks>Standard separable blend mode. See ISO-320001, table 136</remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Extgstate.PdfExtGState.BM_LIGHTEN">
            <summary>Standard separable blend mode.</summary>
            <remarks>Standard separable blend mode. See ISO-320001, table 136</remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Extgstate.PdfExtGState.BM_COLOR_DODGE">
            <summary>Standard separable blend mode.</summary>
            <remarks>Standard separable blend mode. See ISO-320001, table 136</remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Extgstate.PdfExtGState.BM_COLOR_BURN">
            <summary>Standard separable blend mode.</summary>
            <remarks>Standard separable blend mode. See ISO-320001, table 136</remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Extgstate.PdfExtGState.BM_HARD_LIGHT">
            <summary>Standard separable blend mode.</summary>
            <remarks>Standard separable blend mode. See ISO-320001, table 136</remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Extgstate.PdfExtGState.BM_SOFT_LIGHT">
            <summary>Standard separable blend mode.</summary>
            <remarks>Standard separable blend mode. See ISO-320001, table 136</remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Extgstate.PdfExtGState.BM_DIFFERENCE">
            <summary>Standard separable blend mode.</summary>
            <remarks>Standard separable blend mode. See ISO-320001, table 136</remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Extgstate.PdfExtGState.BM_EXCLUSION">
            <summary>Standard separable blend mode.</summary>
            <remarks>Standard separable blend mode. See ISO-320001, table 136</remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Extgstate.PdfExtGState.BM_HUE">
            <summary>Standard nonseparable blend mode.</summary>
            <remarks>Standard nonseparable blend mode. See ISO-320001, table 137</remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Extgstate.PdfExtGState.BM_SATURATION">
            <summary>Standard nonseparable blend mode.</summary>
            <remarks>Standard nonseparable blend mode. See ISO-320001, table 137</remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Extgstate.PdfExtGState.BM_COLOR">
            <summary>Standard nonseparable blend mode.</summary>
            <remarks>Standard nonseparable blend mode. See ISO-320001, table 137</remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Extgstate.PdfExtGState.BM_LUMINOSITY">
            <summary>Standard nonseparable blend mode.</summary>
            <remarks>Standard nonseparable blend mode. See ISO-320001, table 137</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.#ctor(iText.Kernel.Pdf.PdfDictionary)">
            <summary>
            Create instance of graphics state parameter dictionary wrapper
            by existed
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            object
            </summary>
            <param name="pdfObject">instance of graphics state parameter dictionary</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.#ctor">
            <summary>Create default instance of graphics state parameter dictionary</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.GetLineWidth">
            <summary>
            Gets line width value,
            <c>LW</c>
            key.
            </summary>
            <returns>
            a
            <c>float</c>
            value if exist, otherwise
            <see langword="null"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.SetLineWidth(System.Single)">
            <summary>
            Sets line width value,
            <c>LW</c>
            key.
            </summary>
            <param name="lineWidth">
            a
            <c>float</c>
            value.
            </param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.GetLineCapStyle">
            <summary>
            Gets line gap style value,
            <c>LC</c>
            key.
            </summary>
            <returns>0 - butt cap, 1 - round cap, 2 - projecting square cap.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.SetLineCapStryle(System.Int32)">
            <summary>
            Sets line gap style value,
            <c>LC</c>
            key.
            </summary>
            <param name="lineCapStyle">0 - butt cap, 1 - round cap, 2 - projecting square cap.</param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.SetLineCapStyle(System.Int32)">
            <summary>
            Sets line gap style value,
            <c>LC</c>
            key.
            </summary>
            <param name="lineCapStyle">0 - butt cap, 1 - round cap, 2 - projecting square cap.</param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.GetLineJoinStyle">
            <summary>
            Gets line join style value,
            <c>LJ</c>
            key.
            </summary>
            <returns>0 - miter join (see also miter limit), 1 - round join, 2 - bevel join.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.SetLineJoinStyle(System.Int32)">
            <summary>
            Sets line join style value,
            <c>LJ</c>
            key.
            </summary>
            <param name="lineJoinStyle">0 - miter join (see also miter limit), 1 - round join, 2 - bevel join.</param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.GetMiterLimit">
            <summary>
            Gets miter limit value,
            <c>ML key</c>
            . See also line join style.
            </summary>
            <returns>
            a
            <c>float</c>
            value if exist, otherwise
            <see langword="null"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.SetMiterLimit(System.Single)">
            <summary>
            Sets miter limit value,
            <c>ML key</c>
            . See also line join style.
            </summary>
            <param name="miterLimit">
            a
            <c>float</c>
            value.
            </param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.GetDashPattern">
            <summary>
            Gets line dash pattern value,
            <c>D</c>
            key.
            </summary>
            <returns>
            a
            <c>PdfArray</c>
            , that represents line dash pattern.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.SetDashPattern(iText.Kernel.Pdf.PdfArray)">
            <summary>
            Sets line dash pattern value,
            <c>D</c>
            key.
            </summary>
            <param name="dashPattern">
            a
            <c>PdfArray</c>
            , that represents line dash pattern.
            </param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.GetRenderingIntent">
            <summary>
            Gets rendering intent value,
            <c>RI</c>
            key.
            Valid values are:
            <c>AbsoluteColorimetric</c>
            ,
            <c>RelativeColorimetric</c>
            ,
            <c>Saturation</c>
            ,
            <c>Perceptual</c>
            .
            </summary>
            <returns>
            a
            <c>PdfName</c>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.SetRenderingIntent(iText.Kernel.Pdf.PdfName)">
            <summary>
            Sets rendering intent value,
            <c>RI</c>
            key.
            </summary>
            <param name="renderingIntent">
            a
            <c>PdfName</c>
            instance, Valid values are:
            <c>AbsoluteColorimetric</c>
            ,
            <c>RelativeColorimetric</c>
            ,
            <c>Saturation</c>
            ,
            <c>Perceptual</c>
            .
            </param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.GetStrokeOverprintFlag">
            <summary>
            Get overprint flag value for <b>stroking</b> operations,
            <c>OP</c>
            key.
            </summary>
            <returns>
            a
            <c>boolean</c>
            value if exist, otherwise
            <see langword="null"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.SetStrokeOverPrintFlag(System.Boolean)">
            <summary>
            Set overprint flag value for <b>stroking</b> operations,
            <c>OP</c>
            key.
            </summary>
            <param name="strokeOverPrintFlag">
            
            <see langword="true"/>
            , for applying overprint for <b>stroking</b> operations.
            </param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.GetFillOverprintFlag">
            <summary>
            Get overprint flag value for <b>non-stroking</b> operations,
            <c>op</c>
            key.
            </summary>
            <returns>
            a
            <c>boolean</c>
            value if exist, otherwise
            <see langword="null"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.SetFillOverPrintFlag(System.Boolean)">
            <summary>
            Set overprint flag value for <b>non-stroking</b> operations,
            <c>op</c>
            key.
            </summary>
            <param name="fillOverprintFlag">
            
            <see langword="true"/>
            , for applying overprint for <b>non-stroking</b> operations.
            </param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.GetOverprintMode">
            <summary>
            Get overprint control mode,
            <c>OPM</c>
            key.
            </summary>
            <returns>
            an
            <c>int</c>
            value if exist, otherwise
            <see langword="null"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.SetOverprintMode(System.Int32)">
            <summary>
            Set overprint control mode,
            <c>OPM</c>
            key.
            </summary>
            <param name="overprintMode">
            an
            <c>int</c>
            value, see ISO-320001, 8.6.7 Overprint Control.
            </param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.GetFont">
            <summary>
            Gets font and size,
            <c>Font</c>
            key.
            </summary>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            of the form
            <c>[font size]</c>
            , where
            <c>font</c>
            shall be an indirect reference to a font dictionary and
            <c>size</c>
            shall be a number expressed in text space units.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.SetFont(iText.Kernel.Pdf.PdfArray)">
            <summary>
            Sets font and size,
            <c>Font</c>
            key.
            NOTE: If you want add the font object which has just been created, make sure to register the font with
            <see cref="M:iText.Kernel.Pdf.PdfDocument.AddFont(iText.Kernel.Font.PdfFont)"/>
            method first.
            </summary>
            <param name="font">
            a
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            of the form
            <c>[font size]</c>
            , where
            <paramref name="font"/>
            shall be an indirect reference to a font dictionary and
            <c>size</c>
            shall be a number expressed in text space units.
            </param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.GetBlackGenerationFunction">
            <summary>
            Gets the black-generation function value,
            <c>BG</c>
            .
            </summary>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            , should be
            <see cref="T:iText.Kernel.Pdf.Function.PdfFunction"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.SetBlackGenerationFunction(iText.Kernel.Pdf.PdfObject)">
            <summary>
            Sets the black-generation function value,
            <c>BG</c>
            .
            </summary>
            <param name="blackGenerationFunction">
            a
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            , shall be
            <see cref="T:iText.Kernel.Pdf.Function.PdfFunction"/>
            .
            </param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.GetBlackGenerationFunction2">
            <summary>
            Gets the black-generation function value or
            <c>Default</c>
            ,
            <c>BG2</c>
            key.
            </summary>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            value, should be either
            <see cref="T:iText.Kernel.Pdf.Function.PdfFunction"/>
            or
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.SetBlackGenerationFunction2(iText.Kernel.Pdf.PdfObject)">
            <summary>
            Sets the black-generation function value or
            <c>Default</c>
            ,
            <c>BG2</c>
            key.
            Note, if both
            <c>BG</c>
            and
            <c>BG2</c>
            are present in the same graphics state parameter dictionary,
            <c>BG2</c>
            takes precedence.
            </summary>
            <param name="blackGenerationFunction2">
            a
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            value, shall be either
            <see cref="T:iText.Kernel.Pdf.Function.PdfFunction"/>
            or
            <c>Default</c>
            .
            </param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.GetUndercolorRemovalFunction">
            <summary>
            Gets the undercolor-removal function,
            <c>UCR</c>
            key.
            </summary>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            , should be
            <see cref="T:iText.Kernel.Pdf.Function.PdfFunction"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.SetUndercolorRemovalFunction(iText.Kernel.Pdf.PdfObject)">
            <summary>
            Sets the undercolor-removal function,
            <c>UCR</c>
            key.
            </summary>
            <param name="undercolorRemovalFunction">
            a
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            , shall be
            <see cref="T:iText.Kernel.Pdf.Function.PdfFunction"/>
            .
            </param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.GetUndercolorRemovalFunction2">
            <summary>
            Gets the undercolor-removal function value or
            <c>Default</c>
            ,
            <c>UCR2</c>
            key.
            </summary>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            value, should be either
            <see cref="T:iText.Kernel.Pdf.Function.PdfFunction"/>
            or
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.SetUndercolorRemovalFunction2(iText.Kernel.Pdf.PdfObject)">
            <summary>
            Sets the undercolor-removal function value or
            <c>Default</c>
            ,
            <c>UCR2</c>
            key.
            Note, if both
            <c>UCR</c>
            and
            <c>UCR2</c>
            are present in the same graphics state parameter dictionary,
            <c>UCR2</c>
            takes precedence.
            </summary>
            <param name="undercolorRemovalFunction2">
            a
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            value, shall be either
            <see cref="T:iText.Kernel.Pdf.Function.PdfFunction"/>
            or
            <c>Default</c>
            .
            </param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.GetTransferFunction">
            <summary>
            Gets the transfer function value,
            <c>TR</c>
            key.
            </summary>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            , should be either
            <see cref="T:iText.Kernel.Pdf.Function.PdfFunction"/>
            ,
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            or
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.SetTransferFunction(iText.Kernel.Pdf.PdfObject)">
            <summary>
            Sets the transfer function value,
            <c>TR</c>
            key.
            </summary>
            <param name="transferFunction">
            a
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            , shall be either
            <see cref="T:iText.Kernel.Pdf.Function.PdfFunction"/>
            ,
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            or
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            .
            </param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.GetTransferFunction2">
            <summary>
            Gets the transfer function value or
            <c>Default</c>
            ,
            <c>TR2</c>
            key.
            </summary>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            , should be either
            <see cref="T:iText.Kernel.Pdf.Function.PdfFunction"/>
            ,
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            or
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.SetTransferFunction2(iText.Kernel.Pdf.PdfObject)">
            <summary>
            Sets the transfer function value or
            <c>Default</c>
            ,
            <c>TR2</c>
            key.
            Note, if both
            <c>TR</c>
            and
            <c>TR2</c>
            are present in the same graphics state parameter dictionary,
            <c>TR2</c>
            takes precedence.
            </summary>
            <param name="transferFunction2">
            a
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            , shall be either
            <see cref="T:iText.Kernel.Pdf.Function.PdfFunction"/>
            ,
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            ,
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            or
            <c>Default</c>
            .
            </param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.GetHalftone">
            <summary>
            Gets the halftone dictionary, stream or
            <c>Default</c>
            ,
            <c>HT</c>
            key.
            </summary>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            , should be either
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            ,
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            or
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.SetHalftone(iText.Kernel.Pdf.PdfObject)">
            <summary>
            Sets the halftone or
            <c>Default</c>
            ,
            <c>HT</c>
            key.
            </summary>
            <param name="halftone">
            a
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            , shall be either
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            ,
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            or
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            .
            </param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.GetHTP">
            <summary>
            Gets
            <c>HTP</c>
            key.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.SetHTP(iText.Kernel.Pdf.PdfObject)">
            <summary>
            Sets
            <c>HTP</c>
            key.
            </summary>
            <param name="htp">
            a
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            .
            </param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.GetFlatnessTolerance">
            <summary>
            Gets the flatness tolerance value,
            <c>FL</c>
            key.
            </summary>
            <returns>
            a
            <c>float</c>
            value if exist, otherwise
            <see langword="null"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.SetFlatnessTolerance(System.Single)">
            <summary>
            Sets the flatness tolerance value,
            <c>FL</c>
            key.
            </summary>
            <param name="flatnessTolerance">
            a
            <c>float</c>
            value.
            </param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.GetSmothnessTolerance">
            <summary>
            Gets the smoothness tolerance value,
            <c>SM</c>
            key.
            </summary>
            <returns>
            a
            <c>float</c>
            value if exist, otherwise
            <see langword="null"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.SetSmoothnessTolerance(System.Single)">
            <summary>
            Sets the smoothness tolerance value,
            <c>SM</c>
            key.
            </summary>
            <param name="smoothnessTolerance">
            a
            <c>float</c>
            value.
            </param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.GetAutomaticStrokeAdjustmentFlag">
            <summary>
            Gets value of an automatic stroke adjustment flag,
            <c>SA</c>
            key.
            </summary>
            <returns>
            a
            <c>boolean</c>
            value if exist, otherwise
            <see langword="null"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.SetAutomaticStrokeAdjustmentFlag(System.Boolean)">
            <summary>
            Sets value of an automatic stroke adjustment flag,
            <c>SA</c>
            key.
            </summary>
            <param name="strokeAdjustment">
            a
            <c>boolean</c>
            value.
            </param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.GetBlendMode">
            <summary>
            Gets the current blend mode for the transparent imaging model,
            <c>BM</c>
            key.
            </summary>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            , should be either
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            or
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.SetBlendMode(iText.Kernel.Pdf.PdfObject)">
            <summary>
            Sets the current blend mode for the transparent imaging model,
            <c>BM</c>
            key.
            </summary>
            <param name="blendMode">
            a
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            , shall be either
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            or
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            .
            </param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.GetSoftMask">
            <summary>
            Gets the current soft mask,
            <c>SMask</c>
            key.
            </summary>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            , should be either
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            or
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.SetSoftMask(iText.Kernel.Pdf.PdfObject)">
            <summary>
            Sets the current soft mask,
            <c>SMask</c>
            key.
            </summary>
            <param name="sMask">
            a
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            , shall be either
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            or
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            .
            </param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.GetStrokeOpacity">
            <summary>
            Gets the current alpha constant, specifying the constant shape or constant opacity value
            for <b>stroking</b> operations in the transparent imaging model,
            <c>CA</c>
            key.
            </summary>
            <returns>
            a
            <c>float</c>
            value if exist, otherwise
            <see langword="null"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.SetStrokeOpacity(System.Single)">
            <summary>
            Sets the current alpha constant, specifying the constant shape or constant opacity value
            for <b>stroking</b> operations in the transparent imaging model,
            <c>CA</c>
            key.
            </summary>
            <param name="strokingAlphaConstant">
            a
            <c>float</c>
            value.
            </param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.GetFillOpacity">
            <summary>
            Gets the current alpha constant, specifying the constant shape or constant opacity value
            for <b>non-stroking</b> operations in the transparent imaging model,
            <c>ca</c>
            key.
            </summary>
            <returns>
            a
            <c>float</c>
            value if exist, otherwise
            <see langword="null"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.SetFillOpacity(System.Single)">
            <summary>
            Sets the current alpha constant, specifying the constant shape or constant opacity value
            for <b>non-stroking</b> operations in the transparent imaging model,
            <c>ca</c>
            key.
            </summary>
            <param name="fillingAlphaConstant">
            a
            <c>float</c>
            value.
            </param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.GetAlphaSourceFlag">
            <summary>
            Gets the alpha source flag (“alpha is shape”), specifying whether the current soft mask and alpha constant
            shall be interpreted as shape values (
            <see langword="true"/>
            ) or opacity values (
            <see langword="false"/>
            ),
            <c>AIS</c>
            key.
            </summary>
            <returns>
            a
            <c>boolean</c>
            value if exist, otherwise
            <see langword="null"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.SetAlphaSourceFlag(System.Boolean)">
            <summary>
            Sets the alpha source flag (“alpha is shape”), specifying whether the current soft mask and alpha constant
            shall be interpreted as shape values (
            <see langword="true"/>
            ) or opacity values (
            <see langword="false"/>
            ),
            <c>AIS</c>
            key.
            </summary>
            <param name="alphaSourceFlag">
            if
            <see langword="true"/>
            - alpha as shape values, if
            <see langword="false"/>
            — as opacity values.
            </param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.GetTextKnockoutFlag">
            <summary>
            Gets the text knockout flag, which determine the behaviour of overlapping glyphs
            within a text object in the transparent imaging model,
            <c>TK</c>
            key.
            </summary>
            <returns>
            a
            <c>boolean</c>
            value if exist, otherwise
            <see langword="null"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.SetTextKnockoutFlag(System.Boolean)">
            <summary>
            Sets the text knockout flag, which determine the behaviour of overlapping glyphs
            within a text object in the transparent imaging model,
            <c>TK</c>
            key.
            </summary>
            <param name="textKnockoutFlag">
            
            <see langword="true"/>
            if enabled.
            </param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.Put(iText.Kernel.Pdf.PdfName,iText.Kernel.Pdf.PdfObject)">
            <summary>Puts the value into Graphics state parameter dictionary and associates it with the specified key.
                </summary>
            <remarks>
            Puts the value into Graphics state parameter dictionary and associates it with the specified key.
            If the key is already present, it will override the old value with the specified one.
            </remarks>
            <param name="key">key to insert or to override</param>
            <param name="value">the value to associate with the specified key</param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.Flush">
            <summary>
            To manually flush a
            <c>PdfObject</c>
            behind this wrapper, you have to ensure
            that this object is added to the document, i.e. it has an indirect reference.
            Basically this means that before flushing you need to explicitly call
            <see cref="M:iText.Kernel.Pdf.PdfObjectWrapper`1.MakeIndirect(iText.Kernel.Pdf.PdfDocument)"/>
            .
            For example: wrapperInstance.makeIndirect(document).flush();
            Note that not every wrapper require this, only those that have such warning in documentation.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Extgstate.PdfExtGState.IsWrappedObjectMustBeIndirect">
            <summary><inheritDoc/></summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Filespec.PdfFileSpec.CreateEmbeddedFileSpec(iText.Kernel.Pdf.PdfDocument,System.Byte[],System.String,System.String,iText.Kernel.Pdf.PdfName,iText.Kernel.Pdf.PdfDictionary,iText.Kernel.Pdf.PdfName,System.Boolean)">
            <summary>Embed a file to a PdfDocument.</summary>
            <param name="doc">PdfDocument to add the file to</param>
            <param name="fileStore">byte[] containing the file</param>
            <param name="description">file description</param>
            <param name="fileDisplay">actual file name stored in the pdf</param>
            <param name="mimeType">mime-type of the file</param>
            <param name="fileParameter">Pdfdictionary containing fil parameters</param>
            <param name="afRelationshipValue">AFRelationship key value, @see AFRelationshipValue. If <CODE>null</CODE>, @see AFRelationshipValue.Unspecified will be added.
                </param>
            <param name="isUnicodeFileName"/>
            <returns>PdfFileSpec containing the file specification of the file as Pdfobject</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Filespec.PdfFileSpec.CreateEmbeddedFileSpec(iText.Kernel.Pdf.PdfDocument,System.String,System.String,System.String,iText.Kernel.Pdf.PdfName,iText.Kernel.Pdf.PdfName,System.Boolean)">
            <param name="doc"/>
            <param name="filePath"/>
            <param name="description"/>
            <param name="fileDisplay"/>
            <param name="mimeType"/>
            <param name="afRelationshipValue"/>
            <param name="isUnicodeFileName"/>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.Filespec.PdfFileSpec.CreateEmbeddedFileSpec(iText.Kernel.Pdf.PdfDocument,System.IO.Stream,System.String,System.String,iText.Kernel.Pdf.PdfName,iText.Kernel.Pdf.PdfName,System.Boolean)">
            <param name="doc"/>
            <param name="is"/>
            <param name="description"/>
            <param name="fileDisplay"/>
            <param name="mimeType"/>
            <param name="afRelationshipValue"/>
            <param name="isUnicodeFileName"/>
        </member>
        <member name="M:iText.Kernel.Pdf.Filespec.PdfFileSpec.CreateEmbeddedFileSpec(iText.Kernel.Pdf.PdfDocument,iText.Kernel.Pdf.PdfStream,System.String,System.String,iText.Kernel.Pdf.PdfName,iText.Kernel.Pdf.PdfName,System.Boolean)">
            <param name="doc"/>
            <param name="stream"/>
            <param name="description"/>
            <param name="fileDisplay"/>
            <param name="mimeType"/>
            <param name="afRelationshipValue"/>
            <param name="isUnicodeFileName"/>
        </member>
        <member name="T:iText.Kernel.Pdf.Filters.ASCII85DecodeFilter">
            <summary>Handles ASCII85Decode filter</summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Filters.IFilterHandler">
            <summary>
            The main interface for creating a new
            <c>FilterHandler</c>
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Filters.IFilterHandler.Decode(System.Byte[],iText.Kernel.Pdf.PdfName,iText.Kernel.Pdf.PdfObject,iText.Kernel.Pdf.PdfDictionary)">
            <summary>Decode the byte[] using the provided filterName.</summary>
            <param name="b">the bytes that need to be decoded</param>
            <param name="filterName">PdfName of the filter</param>
            <param name="decodeParams">decode parameters</param>
            <param name="streamDictionary">the dictionary of the stream. Can contain additional information needed to decode the byte[].
                </param>
            <returns>decoded byte array</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Filters.ASCII85DecodeFilter.ASCII85Decode(System.Byte[])">
            <summary>Decodes the input bytes according to ASCII85.</summary>
            <param name="in">the byte[] to be decoded</param>
            <returns>the decoded byte[]</returns>
        </member>
        <member name="T:iText.Kernel.Pdf.Filters.ASCIIHexDecodeFilter">
            <summary>Handles ASCIIHexDecode filter</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Filters.ASCIIHexDecodeFilter.ASCIIHexDecode(System.Byte[])">
            <summary>Decodes a byte[] according to ASCII Hex encoding.</summary>
            <param name="in">byte[] to be decoded</param>
            <returns>decoded byte[]</returns>
        </member>
        <member name="T:iText.Kernel.Pdf.Filters.CCITTFaxDecodeFilter">
            <summary>Handles CCITTFaxDecode filter</summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Filters.DoNothingFilter">
            <summary>A filter that doesn't modify the stream at all</summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Filters.FilterHandlers">
            <summary>Encapsulates filter behavior for PDF streams.</summary>
            <remarks>
            Encapsulates filter behavior for PDF streams.  Classes generally interace with this
            using the static getDefaultFilterHandlers() method, then obtain the desired
            <see cref="T:iText.Kernel.Pdf.Filters.IFilterHandler"/>
            via a lookup.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Filters.FilterHandlers.defaults">
            <summary>
            The default
            <see cref="T:iText.Kernel.Pdf.Filters.IFilterHandler"/>
            s used by iText
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Filters.FilterHandlers.GetDefaultFilterHandlers">
            <returns>
            the default
            <see cref="T:iText.Kernel.Pdf.Filters.IFilterHandler"/>
            s used by iText
            </returns>
        </member>
        <member name="T:iText.Kernel.Pdf.Filters.FlateDecodeFilter">
            <summary>Handles FlateDecode filter.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Filters.FlateDecodeFilter.FlateDecode(System.Byte[],System.Boolean)">
            <summary>A helper to flateDecode.</summary>
            <param name="in">the input data</param>
            <param name="strict">
            
            <see langword="true"/>
            to read a correct stream.
            <see langword="false"/>
            to try to read a corrupted stream.
            </param>
            <returns>the decoded data</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Filters.FlateDecodeFilter.DecodePredictor(System.Byte[],iText.Kernel.Pdf.PdfObject)">
            <param name="in">Input byte array.</param>
            <param name="decodeParams">PdfDictionary of decodeParams.</param>
            <returns>a byte array</returns>
        </member>
        <member name="T:iText.Kernel.Pdf.Filters.LZWDecodeFilter">
            <summary>Handles LZWDECODE filter</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Filters.LZWDecodeFilter.LZWDecode(System.Byte[])">
            <summary>Decodes a byte[] according to the LZW encoding.</summary>
            <param name="in">byte[] to be decoded</param>
            <returns>decoded byte[]</returns>
        </member>
        <member name="T:iText.Kernel.Pdf.Filters.LZWDecoder">
            <summary>A class for performing LZW decoding.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Filters.LZWDecoder.#ctor">
            <summary>Creates an LZWDecoder instance.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Filters.LZWDecoder.Decode(System.Byte[],System.IO.Stream)">
            <summary>Method to decode LZW compressed data.</summary>
            <param name="data">The compressed data.</param>
            <param name="uncompData">Array to return the uncompressed data in.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Filters.LZWDecoder.InitializeStringTable">
            <summary>Initialize the string table.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Filters.LZWDecoder.WriteString(System.Byte[])">
            <summary>Write out the string just uncompressed.</summary>
            <param name="string">content to write to the uncompressed data</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Filters.LZWDecoder.AddStringToTable(System.Byte[],System.Byte)">
            <summary>Add a new string to the string table.</summary>
            <param name="oldString">stored string</param>
            <param name="newString">string to be appended to the stored string</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Filters.LZWDecoder.AddStringToTable(System.Byte[])">
            <summary>Add a new string to the string table.</summary>
            <param name="string">byte[] to store in the string table</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Filters.LZWDecoder.ComposeString(System.Byte[],System.Byte)">
            <summary>Append <code>newString</code> to the end of <code>oldString</code>.</summary>
            <param name="oldString">string be appended to</param>
            <param name="newString">string that is to be appended to oldString</param>
            <returns>combined string</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Filters.LZWDecoder.GetNextCode">
            <summary>Attempt to get the next code.</summary>
            <remarks>
            Attempt to get the next code. Exceptions are caught to make
            this robust to cases wherein the EndOfInformation code has been
            omitted from a strip. Examples of such cases have been observed
            in practice.
            </remarks>
            <returns>next code</returns>
        </member>
        <member name="T:iText.Kernel.Pdf.Filters.RunLengthDecodeFilter">
            <summary>Handles RunLengthDecode filter.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Function.PdfFunction.Flush">
            <summary>
            To manually flush a
            <c>PdfObject</c>
            behind this wrapper, you have to ensure
            that this object is added to the document, i.e. it has an indirect reference.
            Basically this means that before flushing you need to explicitly call
            <see cref="M:iText.Kernel.Pdf.PdfObjectWrapper`1.MakeIndirect(iText.Kernel.Pdf.PdfDocument)"/>
            .
            For example: wrapperInstance.makeIndirect(document).flush();
            Note that not every wrapper require this, only those that have such warning in documentation.
            </summary>
        </member>
        <member name="T:iText.Kernel.Pdf.IPdfPageExtraCopier">
            <summary>
            This interface defines logic which can be used to perform a custom copying
            operation of a
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            .
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.IPdfPageExtraCopier.Copy(iText.Kernel.Pdf.PdfPage,iText.Kernel.Pdf.PdfPage)">
            <summary>Copies a page.</summary>
            <remarks>
            Copies a page.
            The new page must already be created before calling this, either in a new
            <see cref="T:iText.Kernel.Pdf.PdfDocument"/>
            or in the same
            <see cref="T:iText.Kernel.Pdf.PdfDocument"/>
            as the old page.
            </remarks>
            <param name="fromPage">the source page</param>
            <param name="toPage">the target page in a target document</param>
        </member>
        <member name="T:iText.Kernel.Pdf.IsoKey">
            <summary>Type of object to conform.</summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Layer.IPdfOCG">
            <summary>The interface generalizing the layer types (PdfLayer, PdfLayerMembership).</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.IPdfOCG.GetPdfObject">
            <summary>Gets the object representing the layer.</summary>
            <returns>the object representing the layer</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.IPdfOCG.GetIndirectReference">
            <summary>Gets the <CODE>PdfIndirectReference</CODE> that represents this layer.</summary>
            <returns>the <CODE>PdfIndirectReference</CODE> that represents this layer</returns>
        </member>
        <member name="T:iText.Kernel.Pdf.Layer.PdfLayer">
            <summary>
            An optional content group is a dictionary representing a collection of graphics
            that can be made visible or invisible dynamically by users of viewer applications.
            </summary>
            <remarks>
            An optional content group is a dictionary representing a collection of graphics
            that can be made visible or invisible dynamically by users of viewer applications.
            In iText they are referenced as layers.
            <br/><br/>
            To be able to be wrapped with this
            <see cref="T:iText.Kernel.Pdf.PdfObjectWrapper`1"/>
            the
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            must be indirect.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Layer.PdfLayer.title">
            <summary>Used for titling group of objects but not actually grouping them.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayer.#ctor(iText.Kernel.Pdf.PdfDictionary)">
            <summary>Creates a new layer by existing dictionary, which must be an indirect object.</summary>
            <param name="layerDictionary">the layer dictionary, must have an indirect reference.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayer.#ctor(System.String,iText.Kernel.Pdf.PdfDocument)">
            <summary>Creates a new layer by its name and document.</summary>
            <param name="name">the layer name</param>
            <param name="document">the PdfDocument which the layer belongs to</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayer.CreateTitle(System.String,iText.Kernel.Pdf.PdfDocument)">
            <summary>Creates a title layer.</summary>
            <remarks>
            Creates a title layer. A title layer is not really a layer but a collection of layers
            under the same title heading.
            </remarks>
            <param name="title">the title text</param>
            <param name="document">the <CODE>PdfDocument</CODE></param>
            <returns>the title layer</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayer.AddOCGRadioGroup(iText.Kernel.Pdf.PdfDocument,System.Collections.Generic.IList{iText.Kernel.Pdf.Layer.PdfLayer})">
            <summary>
            Use this method to set a collection of optional content groups
            whose states are intended to follow a "radio button" paradigm.
            </summary>
            <remarks>
            Use this method to set a collection of optional content groups
            whose states are intended to follow a "radio button" paradigm.
            That is, the state of at most one optional content group
            in the array should be ON at a time: if one group is turned
            ON, all others must be turned OFF.
            </remarks>
            <param name="document">the <CODE>PdfDocument</CODE></param>
            <param name="group">the radio group</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayer.AddChild(iText.Kernel.Pdf.Layer.PdfLayer)">
            <summary>Adds a child layer.</summary>
            <remarks>Adds a child layer. Nested layers can only have one parent.</remarks>
            <param name="childLayer">the child layer</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayer.GetParent">
            <summary>Gets the parent of this layer, be it a title layer, or a usual one.</summary>
            <returns>the parent of the layer, or null if it has no parent</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayer.SetName(System.String)">
            <summary>Sets the name of the layer to be displayed in the Layers panel.</summary>
            <param name="name">the name of the layer.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayer.IsOn">
            <summary>Gets the initial visibility of the layer when the document is opened.</summary>
            <returns>the initial visibility of the layer</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayer.SetOn(System.Boolean)">
            <summary>Sets the initial visibility of the layer when the document is opened.</summary>
            <param name="on">the initial visibility of the layer</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayer.IsLocked">
            <summary>Gets whether the layer is currently locked or not.</summary>
            <remarks>
            Gets whether the layer is currently locked or not. If the layer is locked,
            it will not be possible to change its state (on/off) in a viewer.
            </remarks>
            <returns>true of the layer is currently locked, false otherwise.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayer.SetLocked(System.Boolean)">
            <summary>Use this method to lock an optional content group.</summary>
            <remarks>
            Use this method to lock an optional content group.
            The state of a locked group cannot be changed through the user interface
            of a viewer application. Producers can use this entry to prevent the visibility
            of content that depends on these groups from being changed by users.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayer.IsOnPanel">
            <summary>Gets the layer visibility in Acrobat's layer panel</summary>
            <returns>the layer visibility in Acrobat's layer panel</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayer.SetOnPanel(System.Boolean)">
            <summary>Sets the visibility of the layer in Acrobat's layer panel.</summary>
            <remarks>
            Sets the visibility of the layer in Acrobat's layer panel. If <CODE>false</CODE>
            the layer cannot be directly manipulated by the user. Note that any children layers will
            also be absent from the panel.
            </remarks>
            <param name="onPanel">the visibility of the layer in Acrobat's layer panel</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayer.GetIntents">
            <summary>Gets a collection of current intents specified for this layer.</summary>
            <remarks>
            Gets a collection of current intents specified for this layer.
            The default value is PdfName.View, so it will be the only element of the
            resultant colletion if no intents are currently specified.
            </remarks>
            <returns>the collection of intents.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayer.SetIntents(System.Collections.Generic.IList{iText.Kernel.Pdf.PdfName})">
            <summary>Sets the intents of the layer.</summary>
            <param name="intents">the list of intents.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayer.SetCreatorInfo(System.String,System.String)">
            <summary>
            Used by the creating application to store application-specific
            data associated with this optional content group.
            </summary>
            <param name="creator">a text string specifying the application that created the group</param>
            <param name="subtype">
            a string defining the type of content controlled by the group. Suggested
            values include but are not limited to <B>Artwork</B>, for graphic-design or publishing
            applications, and <B>Technical</B>, for technical designs such as building plans or
            schematics
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayer.SetLanguage(System.String,System.Boolean)">
            <summary>
            Specifies the language of the content controlled by this
            optional content group
            </summary>
            <param name="lang">
            a language string which specifies a language and possibly a locale
            (for example, <B>es-MX</B> represents Mexican Spanish)
            </param>
            <param name="preferred">
            used by viewer applications when there is a partial match but no exact
            match between the system language and the language strings in all usage dictionaries
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayer.SetExport(System.Boolean)">
            <summary>
            Specifies the recommended state for content in this
            group when the document (or part of it) is saved by a viewer application to a format
            that does not support optional content (for example, an earlier version of
            PDF or a raster image format).
            </summary>
            <param name="export">the export state</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayer.SetZoom(System.Single,System.Single)">
            <summary>
            Specifies a range of magnifications at which the content
            in this optional content group is best viewed.
            </summary>
            <param name="min">
            the minimum recommended magnification factors at which the group
            should be ON. A negative value will set the default to 0
            </param>
            <param name="max">
            the maximum recommended magnification factor at which the group
            should be ON. A negative value will set the largest possible magnification supported by the
            viewer application
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayer.SetPrint(System.String,System.Boolean)">
            <summary>
            Specifies that the content in this group is intended for
            use in printing
            </summary>
            <param name="subtype">
            a name specifying the kind of content controlled by the group;
            for example, <B>Trapping</B>, <B>PrintersMarks</B> and <B>Watermark</B>
            </param>
            <param name="printState">
            indicates that the group should be
            set to that state when the document is printed from a viewer application
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayer.SetView(System.Boolean)">
            <summary>
            Indicates that the group should be set to that state when the
            document is opened in a viewer application.
            </summary>
            <param name="view">the view state</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayer.SetUser(System.String,System.String[])">
            <summary>
            Specifies one or more users for whom this optional content group
            is primarily intended.
            </summary>
            <param name="type">a name that can be Ind (individual), Ttl (title), or Org (organization).</param>
            <param name="names">
            one or more text strings representing
            the name(s) of the individual, position or organization
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayer.SetPageElement(System.String)">
            <summary>Indicates that the group contains a pagination artifact.</summary>
            <param name="pe">
            one of the following names: "HF" (Header Footer),
            "FG" (Foreground), "BG" (Background), or "L" (Logo).
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayer.GetIndirectReference">
            <summary>
            Gets the indirect reference to the current layer object,
            making it indirect first if necessary.
            </summary>
            <returns>the indirect reference to the object representing the layer</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayer.GetTitle">
            <summary>Gets the title of the layer if it is a title layer, or null if it is a usual layer.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayer.GetChildren">
            <summary>Gets the list of the current child layers of the layer.</summary>
            <remarks>
            Gets the list of the current child layers of the layer.
            BE CAREFUL! Do not try to add a child layer using the resultant child list,
            use #addChild method instead.
            </remarks>
            <returns>the list of the current child layers, null if the layer has no children.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayer.CreateTitleSilent(System.String,iText.Kernel.Pdf.PdfDocument)">
            <summary>Creates a title layer without registering it in PdfOCProperties.</summary>
            <param name="title">the title of the layer</param>
            <param name="document">the document this title layer belongs to</param>
            <returns>the created layer</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayer.GetUsage">
            <summary>Gets the /Usage dictionary, creating a new one if necessary.</summary>
            <returns>the /Usage dictionary</returns>
        </member>
        <member name="T:iText.Kernel.Pdf.Layer.PdfLayerMembership">
            <summary>
            Content typically belongs to a single optional content group,
            and is visible when the group is <B>ON</B> and invisible when it is <B>OFF</B>.
            </summary>
            <remarks>
            Content typically belongs to a single optional content group,
            and is visible when the group is <B>ON</B> and invisible when it is <B>OFF</B>. To express more
            complex visibility policies, content should not declare itself to belong to an optional
            content group directly, but rather to an optional content membership dictionary
            represented by this class.
            <br/><br/>
            To be able to be wrapped with this
            <see cref="T:iText.Kernel.Pdf.PdfObjectWrapper`1"/>
            the
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            must be indirect.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayerMembership.#ctor(iText.Kernel.Pdf.PdfDocument)">
            <summary>Creates a new, empty membership layer.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayerMembership.#ctor(iText.Kernel.Pdf.PdfDictionary)">
            <summary>Creates a new PdfLayerMembership instance by its PdfDictionary, which must be an indirect object.
                </summary>
            <param name="membershipDictionary">the membership dictionary, must have an indirect reference.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayerMembership.GetLayers">
            <summary>Gets the collection of the layers this layer membership operates with.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayerMembership.AddLayer(iText.Kernel.Pdf.Layer.PdfLayer)">
            <summary>Adds a new layer to the current layer membership.</summary>
            <param name="layer">the layer to be added</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayerMembership.SetVisibilityPolicy(iText.Kernel.Pdf.PdfName)">
            <summary>
            Sets the visibility policy for content belonging to this
            membership dictionary.
            </summary>
            <remarks>
            Sets the visibility policy for content belonging to this
            membership dictionary. Possible values are AllOn, AnyOn, AnyOff and AllOff.
            AllOn - Visible only if all of the entries are <B>ON</B>.
            AnyOn - Visible if any of the entries are <B>ON</B>.
            AnyOff - Visible if any of the entries are <B>OFF</B>.
            AllOff - Visible only if all of the entries are <B>OFF</B>.
            The default value is AnyOn.
            </remarks>
            <param name="visibilityPolicy">the visibility policy</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayerMembership.GetVisibilityPolicy">
            <summary>
            Gets the visibility policy for content belonging to this
            optional content membership dictionary.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayerMembership.SetVisibilityExpression(iText.Kernel.Pdf.Layer.PdfVisibilityExpression)">
            <summary>
            Sets the visibility expression for content belonging to this
            membership dictionary.
            </summary>
            <param name="visibilityExpression">
            A (nested) array of which the first value is /And, /Or, or /Not
            followed by a series of indirect references to OCGs or other visibility
            expressions.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfLayerMembership.GetVisibilityExpression">
            <summary>
            Gets the visibility expression for content belonging to this
            optional content membership dictionary.
            </summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Layer.PdfOCProperties">
            <summary>
            This class represents /OCProperties entry if pdf catalog and manages
            the layers of the pdf document.
            </summary>
            <remarks>
            This class represents /OCProperties entry if pdf catalog and manages
            the layers of the pdf document.
            <br/><br/>
            To be able to be wrapped with this
            <see cref="T:iText.Kernel.Pdf.PdfObjectWrapper`1"/>
            the
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            must be indirect.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfOCProperties.#ctor(iText.Kernel.Pdf.PdfDocument)">
            <summary>Creates a new PdfOCProperties instance.</summary>
            <param name="document">the document the optional content belongs to</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfOCProperties.#ctor(iText.Kernel.Pdf.PdfDictionary)">
            <summary>
            Creates a new PdfOCProperties instance by the dictionary it represents,
            the dictionary must be an indirect object.
            </summary>
            <param name="ocPropertiesDict">the dictionary of optional content properties, must have an indirect reference.
                </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfOCProperties.AddOCGRadioGroup(System.Collections.Generic.IList{iText.Kernel.Pdf.Layer.PdfLayer})">
            <summary>
            Use this method to set a collection of optional content groups
            whose states are intended to follow a "radio button" paradigm.
            </summary>
            <remarks>
            Use this method to set a collection of optional content groups
            whose states are intended to follow a "radio button" paradigm.
            That is, the state of at most one optional content group
            in the array should be ON at a time: if one group is turned
            ON, all others must be turned OFF.
            </remarks>
            <param name="group">the radio group</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfOCProperties.FillDictionary">
            <summary>Fills the underlying PdfDictionary object with the current layers and their settings.</summary>
            <remarks>
            Fills the underlying PdfDictionary object with the current layers and their settings.
            Note that it completely regenerates the dictionary, so your direct changes to the dictionary
            will not take any affect.
            </remarks>
            <returns>the resultant dictionary</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfOCProperties.GetLayers">
            <summary>Gets the list of all the layers currently registered in the OCProperties.</summary>
            <remarks>
            Gets the list of all the layers currently registered in the OCProperties.
            Note that this is just a new list and modifications to it will not affect anything.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfOCProperties.RegisterLayer(iText.Kernel.Pdf.Layer.PdfLayer)">
            <summary>This method registers a new layer in the OCProperties.</summary>
            <param name="layer">the new layer</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfOCProperties.GetOCGOrder(iText.Kernel.Pdf.PdfArray,iText.Kernel.Pdf.Layer.PdfLayer)">
            <summary>
            Gets the order of the layers in which they will be displayed in the layer view panel,
            including nesting.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfOCProperties.AddASEvent(iText.Kernel.Pdf.PdfName,iText.Kernel.Pdf.PdfName)">
            <summary>Populates the /AS entry in the /D dictionary.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfOCProperties.ReadLayersFromDictionary">
            <summary>Reads the layers from the document to be able to modify them in the future.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfOCProperties.ReadOrderFromDictionary(iText.Kernel.Pdf.Layer.PdfLayer,iText.Kernel.Pdf.PdfArray,System.Collections.Generic.IDictionary{iText.Kernel.Pdf.PdfIndirectReference,iText.Kernel.Pdf.Layer.PdfLayer})">
            <summary>Reads the /Order in the /D entry and initialized the parent-child hierarchy.</summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Layer.PdfVisibilityExpression">
            <summary>
            An array specifying a visibility expression, used to compute visibility
            of content based on a set of optional content groups.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfVisibilityExpression.#ctor(iText.Kernel.Pdf.PdfArray)">
            <summary>Constructs a new PdfVisibilityExpression instance by its raw PdfArray.</summary>
            <param name="visibilityExpressionArray">the array representing the visibility expression</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfVisibilityExpression.#ctor(iText.Kernel.Pdf.PdfName)">
            <summary>Creates a visibility expression.</summary>
            <param name="operator">should be either PdfName#And, PdfName#Or, or PdfName#Not</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfVisibilityExpression.AddOperand(iText.Kernel.Pdf.Layer.PdfLayer)">
            <summary>Adds a new operand to the current visibility expression.</summary>
            <param name="layer">the layer operand to be added.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Layer.PdfVisibilityExpression.AddOperand(iText.Kernel.Pdf.Layer.PdfVisibilityExpression)">
            <summary>Adds a new opeand to the current visibility expression.</summary>
            <param name="expression">the PdfVisibilityExpression instance operand to be added</param>
        </member>
        <member name="T:iText.Kernel.Pdf.PdfAConformanceLevel">
            <summary>Enumeration of all the PDF/A conformance levels.</summary>
        </member>
        <member name="T:iText.Kernel.Pdf.PdfArray">
            <summary>A representation of an array as described in the PDF specification.</summary>
            <remarks>
            A representation of an array as described in the PDF specification. A PdfArray can contain any
            subclass of
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            .
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfObject.FLUSHED">
            <summary>Indicates if the object has been flushed.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfObject.FREE">
            <summary>Indicates that the indirect reference of the object could be reused or have to be marked as free.
                </summary>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfObject.READING">
            <summary>Indicates that definition of the indirect reference of the object still not found (e.g.</summary>
            <remarks>Indicates that definition of the indirect reference of the object still not found (e.g. keys in XRefStm).
                </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfObject.MODIFIED">
            <summary>Indicates that object changed (is used in append mode).</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfObject.ORIGINAL_OBJECT_STREAM">
            <summary>Indicates that the indirect reference of the object represents ObjectStream from original document.
                </summary>
            <remarks>
            Indicates that the indirect reference of the object represents ObjectStream from original document.
            When PdfReader read ObjectStream reference marked as OriginalObjectStream
            to avoid further reusing.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfObject.MUST_BE_FLUSHED">
            <summary>For internal usage only.</summary>
            <remarks>
            For internal usage only. Marks objects that shall be written to the output document.
            Option is needed to build the correct PDF objects tree when closing the document.
            As a result it avoids writing unused (removed) objects.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfObject.MUST_BE_INDIRECT">
            <summary>Indicates that the object shall be indirect when it is written to the document.</summary>
            <remarks>
            Indicates that the object shall be indirect when it is written to the document.
            It is used to postpone the creation of indirect reference for the objects that shall be indirect,
            so it is possible to create such objects without PdfDocument instance.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfObject.FORBID_RELEASE">
            <summary>Indicates that the object is highly sensitive and we do not want to release it even if release() is called.
                </summary>
            <remarks>
            Indicates that the object is highly sensitive and we do not want to release it even if release() is called.
            This flag can be set in stamping mode in object wrapper constructors and is automatically set when setModified
            flag is set (we do not want to release changed objects).
            The flag is set automatically for some wrappers that need document even in reader mode (FormFields etc).
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfObject.READ_ONLY">
            <summary>
            Indicates that we do not want this object to be ever written into the resultant document
            (because of multiple objects read from the same reference inconsistency).
            </summary>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfObject.UNENCRYPTED">
            <summary>Indicates that this object is not encrypted in the encrypted document.</summary>
            <remarks>
            Indicates that this object is not encrypted in the encrypted document.
            E.g. digital signature dictionary /Contents entry shall not be encrypted.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfObject.indirectReference">
            <summary>If object is flushed the indirect reference is kept here.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfObject.state">
            <summary>Indicate same special states of PdfIndirectObject or PdfObject like @see Free, @see Reading, @see Modified.
                </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfObject.GetObjectType">
            <summary>Gets object type.</summary>
            <returns>object type.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfObject.Flush">
            <summary>Flushes the object to the document.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfObject.Flush(System.Boolean)">
            <summary>Flushes the object to the document.</summary>
            <param name="canBeInObjStm">indicates whether object can be placed into object stream.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfObject.GetIndirectReference">
            <summary>Gets the indirect reference associated with the object.</summary>
            <remarks>
            Gets the indirect reference associated with the object.
            The indirect reference is used when flushing object to the document.
            </remarks>
            <returns>indirect reference.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfObject.IsIndirect">
            <summary>Checks if object is indirect.</summary>
            <remarks>
            Checks if object is indirect.
            <br />
            Note:
            Return value
            <see langword="true"/>
            doesn't necessarily mean that indirect reference of this object
            is not null at the moment. Object could be marked as indirect and
            be transformed to indirect on flushing.
            <br />
            E.g. all PdfStreams are transformed to indirect objects when they are written, but they don't always
            have indirect references at any given moment.
            </remarks>
            <returns>
            returns
            <see langword="true"/>
            if object is indirect or is to be indirect in the resultant document.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfObject.MakeIndirect(iText.Kernel.Pdf.PdfDocument,iText.Kernel.Pdf.PdfIndirectReference)">
            <summary>Marks object to be saved as indirect.</summary>
            <param name="document">a document the indirect reference will belong to.</param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfObject.MakeIndirect(iText.Kernel.Pdf.PdfDocument)">
            <summary>Marks object to be saved as indirect.</summary>
            <param name="document">a document the indirect reference will belong to.</param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfObject.IsFlushed">
            <summary>Indicates is the object has been flushed or not.</summary>
            <returns>true if object has been flushed, otherwise false.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfObject.IsModified">
            <summary>Indicates is the object has been set as modified or not.</summary>
            <remarks>Indicates is the object has been set as modified or not. Useful for incremental updates (e.g. appendMode).
                </remarks>
            <returns>true is object has been set as modified, otherwise false.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfObject.Clone">
            <summary>Creates clone of the object which belongs to the same document as original object.</summary>
            <remarks>
            Creates clone of the object which belongs to the same document as original object.
            New object shall not be used in other documents.
            </remarks>
            <returns>cloned object.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfObject.CopyTo(iText.Kernel.Pdf.PdfDocument)">
            <summary>Copies object to a specified document.</summary>
            <remarks>
            Copies object to a specified document.
            <br/><br/>
            NOTE: Works only for objects that are read from document opened in reading mode, otherwise an exception is thrown.
            </remarks>
            <param name="document">document to copy object to.</param>
            <returns>copied object.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfObject.CopyTo(iText.Kernel.Pdf.PdfDocument,System.Boolean)">
            <summary>Copies object to a specified document.</summary>
            <remarks>
            Copies object to a specified document.
            <br/><br/>
            NOTE: Works only for objects that are read from document opened in reading mode, otherwise an exception is thrown.
            </remarks>
            <param name="document">document to copy object to.</param>
            <param name="allowDuplicating">
            indicates if to allow copy objects which already have been copied.
            If object is associated with any indirect reference and allowDuplicating is false then already existing reference will be returned instead of copying object.
            If allowDuplicating is true then object will be copied and new indirect reference will be assigned.
            </param>
            <returns>copied object.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfObject.SetModified">
            <summary>Sets the 'modified' flag to the indirect object, the flag denotes that the object was modified since the document opening.
                </summary>
            <remarks>
            Sets the 'modified' flag to the indirect object, the flag denotes that the object was modified since the document opening.
            <p>
            This flag is meaningful only if the
            <see cref="T:iText.Kernel.Pdf.PdfDocument"/>
            is opened in append mode
            (see
            <see cref="M:iText.Kernel.Pdf.StampingProperties.UseAppendMode"/>
            ).
            </p>
            <p>
            In append mode the whole document is preserved as is, and only changes to the document are
            appended to the end of the document file. Because of this, only modified objects need to be flushed and are
            allowed to be flushed (i.e. to be written).
            </p>
            </remarks>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfObject.IsNull">
            <summary>
            Checks if this <CODE>PdfObject</CODE> is of the type
            <CODE>PdfNull</CODE>.
            </summary>
            <returns><CODE>true</CODE> or <CODE>false</CODE></returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfObject.IsBoolean">
            <summary>
            Checks if this <CODE>PdfObject</CODE> is of the type
            <CODE>PdfBoolean</CODE>.
            </summary>
            <returns><CODE>true</CODE> or <CODE>false</CODE></returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfObject.IsNumber">
            <summary>
            Checks if this <CODE>PdfObject</CODE> is of the type
            <CODE>PdfNumber</CODE>.
            </summary>
            <returns><CODE>true</CODE> or <CODE>false</CODE></returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfObject.IsString">
            <summary>
            Checks if this <CODE>PdfObject</CODE> is of the type
            <CODE>PdfString</CODE>.
            </summary>
            <returns><CODE>true</CODE> or <CODE>false</CODE></returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfObject.IsName">
            <summary>
            Checks if this <CODE>PdfObject</CODE> is of the type
            <CODE>PdfName</CODE>.
            </summary>
            <returns><CODE>true</CODE> or <CODE>false</CODE></returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfObject.IsArray">
            <summary>
            Checks if this <CODE>PdfObject</CODE> is of the type
            <CODE>PdfArray</CODE>.
            </summary>
            <returns><CODE>true</CODE> or <CODE>false</CODE></returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfObject.IsDictionary">
            <summary>
            Checks if this <CODE>PdfObject</CODE> is of the type
            <CODE>PdfDictionary</CODE>.
            </summary>
            <returns><CODE>true</CODE> or <CODE>false</CODE></returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfObject.IsStream">
            <summary>
            Checks if this <CODE>PdfObject</CODE> is of the type
            <CODE>PdfStream</CODE>.
            </summary>
            <returns><CODE>true</CODE> or <CODE>false</CODE></returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfObject.IsIndirectReference">
            <summary>
            Checks if this <CODE>PdfObject</CODE> is of the type
            <CODE>PdfIndirectReference</CODE>.
            </summary>
            <returns>
            <CODE>true</CODE> if this is an indirect reference,
            otherwise <CODE>false</CODE>
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfObject.IsLiteral">
            <summary>
            Checks if this <CODE>PdfObject</CODE> is of the type
            <CODE>PdfLiteral</CODE>.
            </summary>
            <returns>
            <CODE>true</CODE> if this is a literal,
            otherwise <CODE>false</CODE>
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfObject.NewInstance">
            <summary>Creates new instance of object.</summary>
            <returns>new instance of object.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfObject.CheckState(System.Int16)">
            <summary>Checks state of the flag of current object.</summary>
            <param name="state">special flag to check</param>
            <returns>true if the state was set.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfObject.SetState(System.Int16)">
            <summary>Sets special states of current object.</summary>
            <param name="state">special flag of current object</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfObject.ClearState(System.Int16)">
            <summary>Clear state of the flag of current object.</summary>
            <param name="state">special flag state to clear</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfObject.CopyContent(iText.Kernel.Pdf.PdfObject,iText.Kernel.Pdf.PdfDocument)">
            <summary>Copies object content from object 'from'.</summary>
            <param name="from">object to copy content from.</param>
            <param name="document">document to copy object to.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Pdf.PdfObject.ProcessCopying(iText.Kernel.Pdf.PdfDocument,System.Boolean)" -->
        <member name="M:iText.Kernel.Pdf.PdfArray.#ctor">
            <summary>Create a new, empty PdfArray.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfArray.#ctor(iText.Kernel.Pdf.PdfObject)">
            <summary>
            Create a new PdfArray with the provided PdfObject as the first item in the
            array.
            </summary>
            <param name="obj">first item in the array</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfArray.#ctor(iText.Kernel.Pdf.PdfArray)">
            <summary>Create a new PdfArray.</summary>
            <remarks>Create a new PdfArray. The array is filled with the items of the provided PdfArray.</remarks>
            <param name="arr">PdfArray containing items that will added to this PdfArray</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfArray.#ctor(iText.Kernel.Geom.Rectangle)">
            <summary>Create a new PdfArray.</summary>
            <remarks>
            Create a new PdfArray. The array is filled with the four values of the Rectangle in the
            follozing order: left, bottom, right, top.
            </remarks>
            <param name="rectangle">Rectangle whose 4 values will be added to the PdfArray</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfArray.#ctor(System.Collections.Generic.IList{iText.Kernel.Pdf.PdfObject})">
            <summary>Create a new PdfArray.</summary>
            <remarks>Create a new PdfArray. The PdfObjects in the list will be added to the PdfArray.</remarks>
            <param name="objects">List of PdfObjects to be added to this PdfArray</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfArray.#ctor(System.Single[])">
            <summary>
            Create a new PdfArray filled with the values in the float[] as
            <see cref="T:iText.Kernel.Pdf.PdfNumber"/>
            .
            </summary>
            <param name="numbers">values to be added to this PdfArray</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfArray.#ctor(System.Double[])">
            <summary>
            Create a new PdfArray filled with the values in the double[] as
            <see cref="T:iText.Kernel.Pdf.PdfNumber"/>
            .
            </summary>
            <param name="numbers">values to be added to this PdfArray</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfArray.#ctor(System.Int32[])">
            <summary>
            Create a new PdfArray filled with the values in the int[] as
            <see cref="T:iText.Kernel.Pdf.PdfNumber"/>
            .
            </summary>
            <param name="numbers">values to be added to this PdfArray</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfArray.#ctor(System.Boolean[])">
            <summary>
            Create a new PdfArray filled with the values in the boolean[] as
            <see cref="T:iText.Kernel.Pdf.PdfBoolean"/>
            .
            </summary>
            <param name="values">values to be added to this PdfArray</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfArray.#ctor(System.Collections.Generic.IList{System.String},System.Boolean)">
            <summary>Create a new PdfArray filled with a list of Strings.</summary>
            <remarks>
            Create a new PdfArray filled with a list of Strings. The boolean value decides if the Strings
            should be added as
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            (true) or as
            <see cref="T:iText.Kernel.Pdf.PdfString"/>
            (false).
            </remarks>
            <param name="strings">list of strings to be added to the list</param>
            <param name="asNames">indicates whether the strings should be added as PdfName (true) or as PdfString (false)
                </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfArray.#ctor(System.Collections.Generic.IEnumerable{iText.Kernel.Pdf.PdfObject},System.Int32)">
            <summary>Create a new PdfArray.</summary>
            <remarks>Create a new PdfArray. The PdfObjects in the iterable object will be added to the PdfArray.</remarks>
            <param name="objects">List of PdfObjects to be added to this PdfArray</param>
            <param name="initialCapacity">Initial capacity of this PdfArray</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfArray.GetEnumerator">
            <summary>Returns an iterator over an array of PdfObject elements.</summary>
            <remarks>
            Returns an iterator over an array of PdfObject elements.
            <br/>
            <b>NOTE:</b> since 7.0.1 it returns collection of direct objects.
            If you want to get
            <see cref="T:iText.Kernel.Pdf.PdfIndirectReference"/>
            instances for the indirect objects value,
            you shall use
            <see cref="M:iText.Kernel.Pdf.PdfArray.Get(System.Int32,System.Boolean)"/>
            method.
            </remarks>
            <returns>an Iterator.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfArray.DirectIterator">
            <summary>Returns an iterator over an array of PdfObject elements.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfArray.Add(System.Int32,iText.Kernel.Pdf.PdfObject)">
            <summary>Adds the specified PdfObject at the specified index.</summary>
            <remarks>Adds the specified PdfObject at the specified index. All objects after this index will be shifted by 1.
                </remarks>
            <param name="index">position to insert the PdfObject</param>
            <param name="element">PdfObject to be added</param>
            <seealso cref="!:System.Collections.IList&lt;E&gt;.Add(int, System.Object)"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfArray.Set(System.Int32,iText.Kernel.Pdf.PdfObject)">
            <summary>Sets the PdfObject at the specified index in the PdfArray.</summary>
            <param name="index">the position to set the PdfObject</param>
            <param name="element">PdfObject to be added</param>
            <returns>true if the operation changed the PdfArray</returns>
            <seealso cref="!:System.Collections.IList&lt;E&gt;.Set(int, System.Object)"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfArray.AddAll(System.Collections.Generic.ICollection{iText.Kernel.Pdf.PdfObject})">
            <summary>Adds the Collection of PdfObjects.</summary>
            <param name="c">the Collection of PdfObjects to be added</param>
            <seealso cref="!:System.Collections.IList&lt;E&gt;.AddAll(System.Collections.ICollection&lt;E&gt;)"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfArray.AddAll(iText.Kernel.Pdf.PdfArray)">
            <summary>
            Adds content of the
            <c>PdfArray</c>
            .
            </summary>
            <param name="a">
            the
            <c>PdfArray</c>
            to be added
            </param>
            <seealso cref="!:System.Collections.IList&lt;E&gt;.AddAll(System.Collections.ICollection&lt;E&gt;)"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfArray.Get(System.Int32)">
            <summary>Gets the (direct) PdfObject at the specified index.</summary>
            <param name="index">index of the PdfObject in the PdfArray</param>
            <returns>the PdfObject at the position in the PdfArray</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfArray.Remove(System.Int32)">
            <summary>Removes the PdfObject at the specified index.</summary>
            <param name="index">position of the PdfObject to be removed</param>
            <seealso cref="!:System.Collections.IList&lt;E&gt;.JRemoveAt(int)"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfArray.Remove(iText.Kernel.Pdf.PdfObject)">
            <summary>Removes the PdfObject at the specified index.</summary>
            <param name="o">a PdfObject to be removed</param>
            <seealso cref="!:System.Collections.IList&lt;E&gt;.Remove(System.Object)"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfArray.IndexOf(iText.Kernel.Pdf.PdfObject)">
            <summary>Gets the first index of the specified PdfObject.</summary>
            <param name="o">PdfObject to find the index of</param>
            <returns>index of the PdfObject</returns>
            <seealso cref="!:System.Collections.IList&lt;E&gt;.IndexOf(System.Object)"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfArray.SubList(System.Int32,System.Int32)">
            <summary>Returns a sublist of this PdfArray, starting at fromIndex (inclusive) and ending at toIndex (exclusive).
                </summary>
            <param name="fromIndex">the position of the first element in the sublist (inclusive)</param>
            <param name="toIndex">the position of the last element in the sublist (exclusive)</param>
            <returns>List of PdfObjects</returns>
            <seealso cref="!:System.Collections.IList&lt;E&gt;.SubList(int, int)"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfArray.MakeIndirect(iText.Kernel.Pdf.PdfDocument)">
            <summary>Marks object to be saved as indirect.</summary>
            <param name="document">a document the indirect reference will belong to.</param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfArray.MakeIndirect(iText.Kernel.Pdf.PdfDocument,iText.Kernel.Pdf.PdfIndirectReference)">
            <summary>Marks object to be saved as indirect.</summary>
            <param name="document">a document the indirect reference will belong to.</param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfArray.CopyTo(iText.Kernel.Pdf.PdfDocument)">
            <summary>Copies object to a specified document.</summary>
            <remarks>
            Copies object to a specified document.
            Works only for objects that are read from existing document, otherwise an exception is thrown.
            </remarks>
            <param name="document">document to copy object to.</param>
            <returns>copied object.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfArray.CopyTo(iText.Kernel.Pdf.PdfDocument,System.Boolean)">
            <summary>Copies object to a specified document.</summary>
            <remarks>
            Copies object to a specified document.
            Works only for objects that are read from existing document, otherwise an exception is thrown.
            </remarks>
            <param name="document">document to copy object to.</param>
            <param name="allowDuplicating">
            indicates if to allow copy objects which already have been copied.
            If object is associated with any indirect reference and allowDuplicating is false then already existing reference will be returned instead of copying object.
            If allowDuplicating is true then object will be copied and new indirect reference will be assigned.
            </param>
            <returns>copied object.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfArray.Get(System.Int32,System.Boolean)">
            <param name="asDirect">true is to extract direct object always.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfArray.GetAsArray(System.Int32)">
            <summary>Returns the element at the specified index as a PdfArray.</summary>
            <remarks>Returns the element at the specified index as a PdfArray. If the element isn't a PdfArray, null is returned.
                </remarks>
            <param name="index">position of the element to be returned</param>
            <returns>the element at the index as a PdfArray</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfArray.GetAsDictionary(System.Int32)">
            <summary>Returns the element at the specified index as a PdfDictionary.</summary>
            <remarks>Returns the element at the specified index as a PdfDictionary. If the element isn't a PdfDictionary, null is returned.
                </remarks>
            <param name="index">position of the element to be returned</param>
            <returns>the element at the index as a PdfDictionary</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfArray.GetAsStream(System.Int32)">
            <summary>Returns the element at the specified index as a PdfStream.</summary>
            <remarks>Returns the element at the specified index as a PdfStream. If the element isn't a PdfStream, null is returned.
                </remarks>
            <param name="index">position of the element to be returned</param>
            <returns>the element at the index as a PdfStream</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfArray.GetAsNumber(System.Int32)">
            <summary>Returns the element at the specified index as a PdfNumber.</summary>
            <remarks>Returns the element at the specified index as a PdfNumber. If the element isn't a PdfNumber, null is returned.
                </remarks>
            <param name="index">position of the element to be returned</param>
            <returns>the element at the index as a PdfNumber</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfArray.GetAsName(System.Int32)">
            <summary>Returns the element at the specified index as a PdfName.</summary>
            <remarks>Returns the element at the specified index as a PdfName. If the element isn't a PdfName, null is returned.
                </remarks>
            <param name="index">position of the element to be returned</param>
            <returns>the element at the index as a PdfName</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfArray.GetAsString(System.Int32)">
            <summary>Returns the element at the specified index as a PdfString.</summary>
            <remarks>Returns the element at the specified index as a PdfString. If the element isn't a PdfString, null is returned.
                </remarks>
            <param name="index">position of the element to be returned</param>
            <returns>the element at the index as a PdfString</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfArray.GetAsBoolean(System.Int32)">
            <summary>Returns the element at the specified index as a PdfBoolean.</summary>
            <remarks>Returns the element at the specified index as a PdfBoolean. If the element isn't a PdfBoolean, null is returned.
                </remarks>
            <param name="index">position of the element to be returned</param>
            <returns>the element at the index as a PdfBoolean</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfArray.ToRectangle">
            <summary>Returns the first four elements of this array as a PdfArray.</summary>
            <remarks>
            Returns the first four elements of this array as a PdfArray. The first four values need to be
            PdfNumbers, if not a PdfException will be thrown.
            </remarks>
            <returns>Rectangle of the first four values</returns>
            <exception cref="T:iText.Kernel.PdfException">if one of the first values isn't a PdfNumber</exception>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfArray.ReleaseContent">
            <summary>Release content of PdfArray.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPrimitiveObject.#ctor(System.Byte[])">
            <summary>Initialize PdfPrimitiveObject from the passed bytes.</summary>
            <param name="content">byte content, shall not be null.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfBoolean.#ctor(System.Boolean)">
            <summary>Store a boolean value</summary>
            <param name="value">value to store</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfBoolean.MakeIndirect(iText.Kernel.Pdf.PdfDocument)">
            <summary>Marks object to be saved as indirect.</summary>
            <param name="document">a document the indirect reference will belong to.</param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfBoolean.MakeIndirect(iText.Kernel.Pdf.PdfDocument,iText.Kernel.Pdf.PdfIndirectReference)">
            <summary>Marks object to be saved as indirect.</summary>
            <param name="document">a document the indirect reference will belong to.</param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfBoolean.CopyTo(iText.Kernel.Pdf.PdfDocument)">
            <summary>Copies object to a specified document.</summary>
            <remarks>
            Copies object to a specified document.
            Works only for objects that are read from existing document, otherwise an exception is thrown.
            </remarks>
            <param name="document">document to copy object to.</param>
            <returns>copied object.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfBoolean.CopyTo(iText.Kernel.Pdf.PdfDocument,System.Boolean)">
            <summary>Copies object to a specified document.</summary>
            <remarks>
            Copies object to a specified document.
            Works only for objects that are read from existing document, otherwise an exception is thrown.
            </remarks>
            <param name="document">document to copy object to.</param>
            <param name="allowDuplicating">
            indicates if to allow copy objects which already have been copied.
            If object is associated with any indirect reference and allowDuplicating is false then already existing reference will be returned instead of copying object.
            If allowDuplicating is true then object will be copied and new indirect reference will be assigned.
            </param>
            <returns>copied object.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfBoolean.ValueOf(System.Boolean)">
            <summary>Gets PdfBoolean existing static class variable equivalent for given boolean value.</summary>
            <remarks>
            Gets PdfBoolean existing static class variable equivalent for given boolean value.
            Note, returned object will be direct only, which means it is impossible to make in indirect.
            If required PdfBoolean has to be indirect,
            use
            <see cref="M:iText.Kernel.Pdf.PdfBoolean.#ctor(System.Boolean)"/>
            constructor instead.
            </remarks>
            <param name="value">boolean variable defining value of PdfBoolean to return.</param>
            <returns>existing static PdfBoolean class variable.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfCatalog.GetOCProperties(System.Boolean)">
            <summary>Use this method to get the <B>Optional Content Properties Dictionary</B>.</summary>
            <remarks>
            Use this method to get the <B>Optional Content Properties Dictionary</B>.
            Note that if you call this method, then the PdfDictionary with OCProperties will be
            generated from PdfOCProperties object right before closing the PdfDocument,
            so if you want to make low-level changes in Pdf structures themselves (PdfArray, PdfDictionary, etc),
            then you should address directly those objects, e.g.:
            <CODE>
            PdfCatalog pdfCatalog = pdfDoc.getCatalog();
            PdfDictionary ocProps = pdfCatalog.getAsDictionary(PdfName.OCProperties);
            // manipulate with ocProps.
            </CODE>
            Also note that this method is implicitly called when creating a new PdfLayer instance,
            so you should either use hi-level logic of operating with layers,
            or manipulate low-level Pdf objects by yourself.
            </remarks>
            <param name="createIfNotExists">
            true to create new /OCProperties entry in catalog if not exists,
            false to return null if /OCProperties entry in catalog is not present.
            </param>
            <returns>the Optional Content Properties Dictionary</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfCatalog.Flush">
            <summary>PdfCatalog will be flushed in PdfDocument.close().</summary>
            <remarks>PdfCatalog will be flushed in PdfDocument.close(). User mustn't flush PdfCatalog!</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Pdf.PdfCatalog.SetPageMode(iText.Kernel.Pdf.PdfName)" -->
        <member name="M:iText.Kernel.Pdf.PdfCatalog.SetPageLayout(iText.Kernel.Pdf.PdfName)">
            <summary>This method sets a page layout of the document</summary>
            <param name="pageLayout"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfCatalog.SetViewerPreferences(iText.Kernel.Pdf.PdfViewerPreferences)">
            <summary>
            This method sets the document viewer preferences, specifying the way the document shall be displayed on the
            screen
            </summary>
            <param name="preferences"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfCatalog.GetNameTree(iText.Kernel.Pdf.PdfName)">
            <summary>This method gets Names tree from the catalog.</summary>
            <param name="treeType">type of the tree (Dests, AP, EmbeddedFiles etc).</param>
            <returns>
            returns
            <see cref="T:iText.Kernel.Pdf.PdfNameTree"/>
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfCatalog.GetPageLabelsTree(System.Boolean)">
            <summary>This method returns the NumberTree of Page Labels</summary>
            <returns>
            returns
            <see cref="T:iText.Kernel.Pdf.PdfNumTree"/>
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfCatalog.SetLang(iText.Kernel.Pdf.PdfString)">
            <summary>An entry specifying the natural language, and optionally locale.</summary>
            <remarks>
            An entry specifying the natural language, and optionally locale. Use this
            to specify the Language attribute on a Tagged Pdf element.
            For the content usage dictionary, use PdfName.Language
            </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfCatalog.SetCollection(iText.Kernel.Pdf.Collection.PdfCollection)">
            <summary>
            Sets collection dictionary that a conforming reader shall use to enhance the presentation of file attachments
            stored in the PDF document.
            </summary>
            <param name="collection"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfCatalog.IsOCPropertiesMayHaveChanged">
            <summary>
            True indicates that getOCProperties() was called, may have been modified,
            and thus its dictionary needs to be reconstructed.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfCatalog.GetPagesWithOutlines">
            <summary>this method return map containing all pages of the document with associated outlines.</summary>
            <returns>map containing all pages of the document with associated outlines</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfCatalog.AddNamedDestination(System.String,iText.Kernel.Pdf.PdfObject)">
            <summary>This methods adds new name to the Dests NameTree.</summary>
            <remarks>This methods adds new name to the Dests NameTree. It throws an exception, if the name already exists.
                </remarks>
            <param name="key">Name of the destination.</param>
            <param name="value">
            An object destination refers to. Must be an array or a dictionary with key /D and array.
            See ISO 32000-1 12.3.2.3 for more info.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfCatalog.AddNameToNameTree(System.String,iText.Kernel.Pdf.PdfObject,iText.Kernel.Pdf.PdfName)">
            <summary>This methods adds a new name to the specified NameTree.</summary>
            <remarks>This methods adds a new name to the specified NameTree. It throws an exception, if the name already exists.
                </remarks>
            <param name="key">key in the name tree</param>
            <param name="value">value in the name tree</param>
            <param name="treeType">type of the tree (Dests, AP, EmbeddedFiles etc).</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfCatalog.GetOutlines(System.Boolean)">
            <summary>This method returns a complete outline tree of the whole document.</summary>
            <param name="updateOutlines">
            if the flag is true, the method read the whole document and creates outline tree.
            If false the method gets cached outline tree (if it was cached via calling getOutlines method before).
            </param>
            <returns>
            fully initialized
            <see cref="T:iText.Kernel.Pdf.PdfOutline"/>
            object.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfCatalog.HasOutlines">
            <summary>Indicates if the catalog has any outlines</summary>
            <returns>
            
            <see langword="true"/>
            , if there are outlines and
            <see langword="false"/>
            otherwise.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfCatalog.IsOutlineMode">
            <summary>This flag determines if Outline tree of the document has been built via calling getOutlines method.
                </summary>
            <remarks>This flag determines if Outline tree of the document has been built via calling getOutlines method. If this flag is false all outline operations will be ignored
                </remarks>
            <returns>state of outline mode.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfCatalog.RemoveOutlines(iText.Kernel.Pdf.PdfPage)">
            <summary>This method removes all outlines associated with a given page</summary>
            <param name="page"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfCatalog.AddRootOutline(iText.Kernel.Pdf.PdfOutline)">
            <summary>This method sets the root outline element in the catalog.</summary>
            <param name="outline"/>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfDashPattern.dash">
            <summary>This is the length of a dash.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfDashPattern.gap">
            <summary>This is the length of a gap.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfDashPattern.phase">
            <summary>This is the phase.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:iText.Kernel.Pdf.PdfDate" -->
        <member name="M:iText.Kernel.Pdf.PdfDate.#ctor(System.DateTime)">
            <summary>
            Constructs a
            <c>PdfDate</c>
            -object.
            </summary>
            <param name="d">
            the date that has to be turned into a
            <c>PdfDate</c>
            &gt;-object
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDate.#ctor">
            <summary>
            Constructs a
            <c>PdfDate</c>
            -object, representing the current day and time.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDate.GetW3CDate">
            <summary>Gives the W3C format of the PdfDate.</summary>
            <returns>a formatted date</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDate.GetW3CDate(System.String)">
            <summary>
            Gives the W3C format of the
            <c>PdfDate</c>
            .
            </summary>
            <param name="d">the date in the format D:YYYYMMDDHHmmSSOHH'mm'</param>
            <returns>a formatted date</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDate.Decode(System.String)">
            <summary>
            Converts a PDF string representing a date into a
            <c>DateTime</c>
            .
            </summary>
            <param name="s">the PDF string representing a date</param>
            <returns>
            a
            <c>DateTime</c>
            representing the date
            </returns>
        </member>
        <member name="T:iText.Kernel.Pdf.PdfDeveloperExtension">
            <summary>
            Beginning with BaseVersion 1.7, the extensions dictionary lets developers
            designate that a given document contains extensions to PDF.
            </summary>
            <remarks>
            Beginning with BaseVersion 1.7, the extensions dictionary lets developers
            designate that a given document contains extensions to PDF. The presence
            of the extension dictionary in a document indicates that it may contain
            developer-specific PDF properties that extend a particular base version
            of the PDF specification.
            The extensions dictionary enables developers to identify their own extensions
            relative to a base version of PDF. Additionally, the convention identifies
            extension levels relative to that base version. The intent of this dictionary
            is to enable developers of PDF-producing applications to identify company-specific
            specifications that PDF-consuming applications use to interpret the extensions.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfDeveloperExtension.ADOBE_1_7_EXTENSIONLEVEL3">
            <summary>An instance of this class for Adobe 1.7 Extension level 3.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfDeveloperExtension.ESIC_1_7_EXTENSIONLEVEL2">
            <summary>An instance of this class for ETSI 1.7 Extension level 2.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfDeveloperExtension.ESIC_1_7_EXTENSIONLEVEL5">
            <summary>An instance of this class for ETSI 1.7 Extension level 5.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfDeveloperExtension.prefix">
            <summary>The prefix used in the Extensions dictionary added to the Catalog.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfDeveloperExtension.baseVersion">
            <summary>The base version.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfDeveloperExtension.extensionLevel">
            <summary>The extension level within the base version.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDeveloperExtension.#ctor(iText.Kernel.Pdf.PdfName,iText.Kernel.Pdf.PdfName,System.Int32)">
            <summary>Creates a PdfDeveloperExtension object.</summary>
            <param name="prefix">the prefix referring to the developer</param>
            <param name="baseVersion">the number of the base version</param>
            <param name="extensionLevel">the extension level within the baseverion.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDeveloperExtension.GetPrefix">
            <summary>Gets the prefix name.</summary>
            <returns>a PdfName</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDeveloperExtension.GetBaseVersion">
            <summary>Gets the baseVersion name.</summary>
            <returns>a PdfName</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDeveloperExtension.GetExtensionLevel">
            <summary>Gets the extension level within the baseVersion.</summary>
            <returns>an integer</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDeveloperExtension.GetDeveloperExtensions">
            <summary>
            Generations the developer extension dictionary corresponding
            with the prefix.
            </summary>
            <returns>a PdfDictionary</returns>
        </member>
        <member name="T:iText.Kernel.Pdf.PdfDictionary">
            <summary>A representation of a Dictionary as described by the PDF Specification.</summary>
            <remarks>
            A representation of a Dictionary as described by the PDF Specification. A Dictionary is a mapping between keys
            and values. Keys are
            <see cref="T:iText.Kernel.Pdf.PdfName">PdfNames</see>
            and the values are
            <see cref="T:iText.Kernel.Pdf.PdfObject">PdfObjects</see>
            . Each key can only be associated with one value and
            adding a new value to an existing key will override the previous value. A value of null should be ignored when
            the PdfDocument is closed.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.#ctor">
            <summary>Creates a new PdfDictionary instance.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.#ctor(System.Collections.Generic.IDictionary{iText.Kernel.Pdf.PdfName,iText.Kernel.Pdf.PdfObject})">
            <summary>Creates a new PdfDictionary instance.</summary>
            <remarks>
            Creates a new PdfDictionary instance. This constructor inserts the content of the specified Map into this
            PdfDictionary instance.
            </remarks>
            <param name="map">Map containing values to be inserted into PdfDictionary</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.#ctor(System.Collections.Generic.ICollection{System.Collections.Generic.KeyValuePair{iText.Kernel.Pdf.PdfName,iText.Kernel.Pdf.PdfObject}})">
            <summary>Creates a new PdfDictionary instance.</summary>
            <remarks>
            Creates a new PdfDictionary instance. This constructor inserts the content of the specified Set into this
            PdfDictionary instance.
            </remarks>
            <param name="entrySet">Set containing Map#Entries to be inserted into PdfDictionary</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.#ctor(iText.Kernel.Pdf.PdfDictionary)">
            <summary>Creates a new PdfDictionary instance.</summary>
            <remarks>
            Creates a new PdfDictionary instance. This constructor inserts the content of the specified PdfDictionary
            into this PdfDictionary instance.
            </remarks>
            <param name="dictionary">PdfDictionary containing values to be inserted into PdfDictionary</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.Size">
            <summary>Returns the number of key-value pairs in this PdfDictionary.</summary>
            <returns>number of key-value pairs</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.IsEmpty">
            <summary>Returns true if there are no key-value pairs in this PdfDictionary.</summary>
            <returns>true if there are no key-value pairs in this PdfDictionary</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.ContainsKey(iText.Kernel.Pdf.PdfName)">
            <summary>Returns true if this PdfDictionary contains the specified key.</summary>
            <param name="key">the key to check</param>
            <returns>true if key is present in the PdfDictionary</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.ContainsValue(iText.Kernel.Pdf.PdfObject)">
            <summary>Returns true if this PdfDictionary contains the specified value.</summary>
            <param name="value">the value to check</param>
            <returns>true if value is present in the PdfDictionary</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.Get(iText.Kernel.Pdf.PdfName)">
            <summary>Returns the value associated to this key.</summary>
            <param name="key">the key of which the associated value needs to be returned</param>
            <returns>the value associated with this key</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.GetAsArray(iText.Kernel.Pdf.PdfName)">
            <summary>Returns the value associated to this key as a PdfArray.</summary>
            <remarks>Returns the value associated to this key as a PdfArray. If the value isn't a PdfArray, null is returned.
                </remarks>
            <param name="key">the key of which the associated value needs to be returned</param>
            <returns>PdfArray associated with this key</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.GetAsDictionary(iText.Kernel.Pdf.PdfName)">
            <summary>Returns the value associated to this key as a PdfDictionary.</summary>
            <remarks>Returns the value associated to this key as a PdfDictionary. If the value isn't a PdfDictionary, null is returned.
                </remarks>
            <param name="key">the key of which the associated value needs to be returned</param>
            <returns>PdfDictionary associated with this key</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.GetAsStream(iText.Kernel.Pdf.PdfName)">
            <summary>Returns the value associated to this key as a PdfStream.</summary>
            <remarks>Returns the value associated to this key as a PdfStream. If the value isn't a PdfStream, null is returned.
                </remarks>
            <param name="key">the key of which the associated value needs to be returned</param>
            <returns>PdfStream associated with this key</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.GetAsNumber(iText.Kernel.Pdf.PdfName)">
            <summary>Returns the value associated to this key as a PdfNumber.</summary>
            <remarks>Returns the value associated to this key as a PdfNumber. If the value isn't a PdfNumber, null is returned.
                </remarks>
            <param name="key">the key of which the associated value needs to be returned</param>
            <returns>PdfNumber associated with this key</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.GetAsName(iText.Kernel.Pdf.PdfName)">
            <summary>Returns the value associated to this key as a PdfName.</summary>
            <remarks>Returns the value associated to this key as a PdfName. If the value isn't a PdfName, null is returned.
                </remarks>
            <param name="key">the key of which the associated value needs to be returned</param>
            <returns>PdfName associated with this key</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.GetAsString(iText.Kernel.Pdf.PdfName)">
            <summary>Returns the value associated to this key as a PdfString.</summary>
            <remarks>Returns the value associated to this key as a PdfString. If the value isn't a PdfString, null is returned.
                </remarks>
            <param name="key">the key of which the associated value needs to be returned</param>
            <returns>PdfString associated with this key</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.GetAsBoolean(iText.Kernel.Pdf.PdfName)">
            <summary>Returns the value associated to this key as a PdfBoolean.</summary>
            <remarks>Returns the value associated to this key as a PdfBoolean. If the value isn't a PdfBoolean, null is returned.
                </remarks>
            <param name="key">the key of which the associated value needs to be returned</param>
            <returns>PdfBoolean associated with this key</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.GetAsRectangle(iText.Kernel.Pdf.PdfName)">
            <summary>Returns the value associated to this key as a Rectangle.</summary>
            <remarks>
            Returns the value associated to this key as a Rectangle. If the value isn't a PdfArray of which the
            firt four elements are PdfNumbers, null is returned.
            </remarks>
            <param name="key">the key of which the associated value needs to be returned</param>
            <returns>PdfArray associated with this key</returns>
            <seealso cref="M:iText.Kernel.Pdf.PdfArray.ToRectangle"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.GetAsFloat(iText.Kernel.Pdf.PdfName)">
            <summary>Returns the value associated to this key as a Float.</summary>
            <remarks>Returns the value associated to this key as a Float. If the value isn't a Pdfnumber, null is returned.
                </remarks>
            <param name="key">the key of which the associated value needs to be returned</param>
            <returns>Float associated with this key</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.GetAsInt(iText.Kernel.Pdf.PdfName)">
            <summary>Returns the value associated to this key as an Integer.</summary>
            <remarks>Returns the value associated to this key as an Integer. If the value isn't a Pdfnumber, null is returned.
                </remarks>
            <param name="key">the key of which the associated value needs to be returned</param>
            <returns>Integer associated with this key</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.GetAsBool(iText.Kernel.Pdf.PdfName)">
            <summary>Returns the value associated to this key as a Boolean.</summary>
            <remarks>Returns the value associated to this key as a Boolean. If the value isn't a PdfBoolean, null is returned.
                </remarks>
            <param name="key">the key of which the associated value needs to be returned</param>
            <returns>Boolean associated with this key</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.Put(iText.Kernel.Pdf.PdfName,iText.Kernel.Pdf.PdfObject)">
            <summary>Inserts the value into this PdfDictionary and associates it with the specified key.</summary>
            <remarks>
            Inserts the value into this PdfDictionary and associates it with the specified key. If the key is already
            present in this PdfDictionary, this method will override the old value with the specified one.
            </remarks>
            <param name="key">key to insert or to override</param>
            <param name="value">the value to associate with the specified key</param>
            <returns>the previous PdfObject associated with this key</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.Remove(iText.Kernel.Pdf.PdfName)">
            <summary>Removes the specified key from this PdfDictionary.</summary>
            <param name="key">key to be removed</param>
            <returns>the removed value associated with the specified key</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.PutAll(iText.Kernel.Pdf.PdfDictionary)">
            <summary>Inserts all the key-value pairs into this PdfDictionary.</summary>
            <param name="d">PdfDictionary holding the key-value pairs to be copied</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.Clear">
            <summary>Removes all key-value pairs from this PdfDictionary.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.KeySet">
            <summary>Returns all the keys of this PdfDictionary as a Set.</summary>
            <returns>Set of keys</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.Values(System.Boolean)">
            <summary>Returns all the values of this map in a Collection.</summary>
            <param name="asDirects">
            if false, collection will contain
            <see cref="T:iText.Kernel.Pdf.PdfIndirectReference"/>
            instances
            for the indirect objects in dictionary, otherwise it will contain collection of direct objects.
            </param>
            <returns>a Collection holding all the values</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.Values">
            <summary>Returns all the values of this map in a Collection.</summary>
            <remarks>
            Returns all the values of this map in a Collection.
            <br/>
            <b>NOTE:</b> since 7.0.1 it returns collection of direct objects.
            If you want to get
            <see cref="T:iText.Kernel.Pdf.PdfIndirectReference"/>
            instances for the indirect objects value,
            you shall use
            <see cref="M:iText.Kernel.Pdf.PdfDictionary.Values(System.Boolean)"/>
            method.
            </remarks>
            <returns>a Collection holding all the values</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.DirectValues">
            <summary>Returns all the values of this map in a Collection.</summary>
            <remarks>
            Returns all the values of this map in a Collection. In opposite to
            <see cref="M:iText.Kernel.Pdf.PdfDictionary.Values"/>
            method,
            this method will resolve all indirect references in the dictionary and return actual objects in collection.
            </remarks>
            <returns>a Collection holding all the values</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.EntrySet">
            <summary>Returns a Set holding the key-value pairs as Map#Entry objects.</summary>
            <remarks>
            Returns a Set holding the key-value pairs as Map#Entry objects.
            <br/>
            <b>NOTE:</b> since 7.0.1 it returns collection of direct objects.
            If you want to get
            <see cref="T:iText.Kernel.Pdf.PdfIndirectReference"/>
            instances for the indirect objects value,
            you shall use
            <see cref="M:iText.Kernel.Pdf.PdfDictionary.Get(iText.Kernel.Pdf.PdfName,System.Boolean)"/>
            method.
            </remarks>
            <returns>a Set of Map.Entry objects</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.DirectEntrySet">
            <summary>Returns a Set holding the key-value pairs as Map#Entry objects.</summary>
            <remarks>
            Returns a Set holding the key-value pairs as Map#Entry objects. In opposite to
            <see cref="M:iText.Kernel.Pdf.PdfDictionary.EntrySet"/>
            method, this method will resolve all indirect references in the dictionary and return actual objects as values of
            entries in the collection.
            </remarks>
            <returns>a Set of Map.Entry objects</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.Clone(System.Collections.Generic.IList{iText.Kernel.Pdf.PdfName})">
            <summary>Creates clones of the dictionary in the current document.</summary>
            <remarks>
            Creates clones of the dictionary in the current document.
            It's possible to pass a list of keys to exclude when cloning.
            </remarks>
            <param name="excludeKeys">list of objects to exclude when cloning dictionary.</param>
            <returns>cloned dictionary.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.MakeIndirect(iText.Kernel.Pdf.PdfDocument)">
            <summary>Marks object to be saved as indirect.</summary>
            <param name="document">a document the indirect reference will belong to.</param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.MakeIndirect(iText.Kernel.Pdf.PdfDocument,iText.Kernel.Pdf.PdfIndirectReference)">
            <summary>Marks object to be saved as indirect.</summary>
            <param name="document">a document the indirect reference will belong to.</param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.CopyTo(iText.Kernel.Pdf.PdfDocument)">
            <summary>Copies object to a specified document.</summary>
            <remarks>
            Copies object to a specified document.
            Works only for objects that are read from existing document, otherwise an exception is thrown.
            </remarks>
            <param name="document">document to copy object to.</param>
            <returns>copied object.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.CopyTo(iText.Kernel.Pdf.PdfDocument,System.Boolean)">
            <summary>Copies object to a specified document.</summary>
            <remarks>
            Copies object to a specified document.
            Works only for objects that are read from existing document, otherwise an exception is thrown.
            </remarks>
            <param name="document">document to copy object to.</param>
            <param name="allowDuplicating">
            indicates if to allow copy objects which already have been copied.
            If object is associated with any indirect reference and allowDuplicating is false then already existing reference will be returned instead of copying object.
            If allowDuplicating is true then object will be copied and new indirect reference will be assigned.
            </param>
            <returns>copied object.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.CopyTo(iText.Kernel.Pdf.PdfDocument,System.Collections.Generic.IList{iText.Kernel.Pdf.PdfName},System.Boolean)">
            <summary>Copies dictionary to specified document.</summary>
            <remarks>
            Copies dictionary to specified document.
            It's possible to pass a list of keys to exclude when copying.
            </remarks>
            <param name="document">document to copy dictionary to.</param>
            <param name="excludeKeys">list of objects to exclude when copying dictionary.</param>
            <param name="allowDuplicating">
            
            <see cref="M:iText.Kernel.Pdf.PdfObject.CopyTo(iText.Kernel.Pdf.PdfDocument,System.Boolean)"/>
            </param>
            <returns>copied dictionary.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.Get(iText.Kernel.Pdf.PdfName,System.Boolean)">
            <param name="asDirect">true is to extract direct object always.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.MergeDifferent(iText.Kernel.Pdf.PdfDictionary)">
            <summary>This method merges different fields from two dictionaries into the current one</summary>
            <param name="other">a dictionary whose fields should be merged into the current dictionary.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDictionary.ReleaseContent">
            <summary>Release content of PdfDictionary.</summary>
        </member>
        <member name="T:iText.Kernel.Pdf.PdfDocument">
            <summary>Main enter point to work with PDF document.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfDocument.currentPage">
            <summary>Currently active page.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfDocument.defaultPageSize">
            <summary>Default page size.</summary>
            <remarks>
            Default page size.
            New page by default will be created with this size.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfDocument.writer">
            <summary>PdfWriter associated with the document.</summary>
            <remarks>
            PdfWriter associated with the document.
            Not null if document opened either in writing or stamping mode.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfDocument.reader">
            <summary>PdfReader associated with the document.</summary>
            <remarks>
            PdfReader associated with the document.
            Not null if document is opened either in reading or stamping mode.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfDocument.xmpMetadata">
            <summary>XMP Metadata for the document.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfDocument.catalog">
            <summary>Document catalog.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfDocument.trailer">
            <summary>Document trailed.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfDocument.info">
            <summary>Document info.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfDocument.pdfVersion">
            <summary>Document version.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfDocument.initialDocumentId">
            <summary>The ID entry that represents the initial identifier.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfDocument.modifiedDocumentId">
            <summary>The ID entry that represents a change in a document.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfDocument.originalModifiedDocumentId">
            <summary>The original second id when the document is read initially.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfDocument.xref">
            <summary>List of indirect objects used in the document.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfDocument.flushUnusedObjects">
            <summary>flag determines whether to write unused objects to result document</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfDocument.linkAnnotations">
            <summary>Yet not copied link annotations from the other documents.</summary>
            <remarks>
            Yet not copied link annotations from the other documents.
            Key - page from the source document, which contains this annotation.
            Value - link annotation from the source document.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfDocument.serializedObjectsCache">
            <summary>Cache of already serialized objects from this document for smart mode.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.#ctor(iText.Kernel.Pdf.PdfReader)">
            <summary>Open PDF document in reading mode.</summary>
            <param name="reader">PDF reader.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.#ctor(iText.Kernel.Pdf.PdfWriter)">
            <summary>Open PDF document in writing mode.</summary>
            <remarks>
            Open PDF document in writing mode.
            Document has no pages when initialized.
            </remarks>
            <param name="writer">PDF writer</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.#ctor(iText.Kernel.Pdf.PdfReader,iText.Kernel.Pdf.PdfWriter)">
            <summary>Opens PDF document in the stamping mode.</summary>
            <remarks>
            Opens PDF document in the stamping mode.
            <br/>
            </remarks>
            <param name="reader">PDF reader.</param>
            <param name="writer">PDF writer.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.#ctor(iText.Kernel.Pdf.PdfReader,iText.Kernel.Pdf.PdfWriter,iText.Kernel.Pdf.StampingProperties)">
            <summary>Open PDF document in stamping mode.</summary>
            <param name="reader">PDF reader.</param>
            <param name="writer">PDF writer.</param>
            <param name="properties">properties of the stamping process</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.SetXmpMetadata(System.Byte[])">
            <summary>Use this method to set the XMP Metadata.</summary>
            <param name="xmpMetadata">The xmpMetadata to set.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.SetXmpMetadata(iText.Kernel.XMP.XMPMeta,iText.Kernel.XMP.Options.SerializeOptions)">
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.SetXmpMetadata(iText.Kernel.XMP.XMPMeta)">
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.GetXmpMetadata">
            <summary>Gets XMPMetadata.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.GetXmpMetadata(System.Boolean)">
            <summary>Gets XMPMetadata or create a new one.</summary>
            <param name="createNew">if true, create a new empty XMPMetadata if it did not present.</param>
            <returns>existed or newly created XMPMetadata byte array.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.GetPdfObject(System.Int32)">
            <summary>Gets PdfObject by object number.</summary>
            <param name="objNum">object number.</param>
            <returns>
            
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            or
            <see langword="null"/>
            , if object not found.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.GetNumberOfPdfObjects">
            <summary>Get number of indirect objects in the document.</summary>
            <returns>number of indirect objects.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.GetPage(System.Int32)">
            <summary>Gets the page by page number.</summary>
            <param name="pageNum">page number.</param>
            <returns>page by page number.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.GetPage(iText.Kernel.Pdf.PdfDictionary)">
            <summary>
            Gets the
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            instance by
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            .
            </summary>
            <param name="pageDictionary">
            
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            that present page.
            </param>
            <returns>
            page by
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.GetFirstPage">
            <summary>Get the first page of the document.</summary>
            <returns>first page of the document.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.GetLastPage">
            <summary>Gets the last page of the document.</summary>
            <returns>last page.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.AddNewPage">
            <summary>Creates and adds new page to the end of document.</summary>
            <returns>added page</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.AddNewPage(iText.Kernel.Geom.PageSize)">
            <summary>Creates and adds new page with the specified page size.</summary>
            <param name="pageSize">page size of the new page</param>
            <returns>added page</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.AddNewPage(System.Int32)">
            <summary>Creates and inserts new page to the document.</summary>
            <param name="index">position to addPage page to</param>
            <returns>inserted page</returns>
            <exception cref="T:iText.Kernel.PdfException">
            in case
            <c>page</c>
            is flushed
            </exception>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.AddNewPage(System.Int32,iText.Kernel.Geom.PageSize)">
            <summary>Creates and inserts new page to the document.</summary>
            <param name="index">position to addPage page to</param>
            <param name="pageSize">page size of the new page</param>
            <returns>inserted page</returns>
            <exception cref="T:iText.Kernel.PdfException">
            in case
            <c>page</c>
            is flushed
            </exception>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.AddPage(iText.Kernel.Pdf.PdfPage)">
            <summary>Adds page to the end of document.</summary>
            <param name="page">page to add.</param>
            <returns>added page.</returns>
            <exception cref="T:iText.Kernel.PdfException">
            in case
            <paramref name="page"/>
            is flushed
            </exception>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.AddPage(System.Int32,iText.Kernel.Pdf.PdfPage)">
            <summary>Inserts page to the document.</summary>
            <param name="index">position to addPage page to</param>
            <param name="page">page to addPage</param>
            <returns>inserted page</returns>
            <exception cref="T:iText.Kernel.PdfException">
            in case
            <paramref name="page"/>
            is flushed
            </exception>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.GetNumberOfPages">
            <summary>Gets number of pages of the document.</summary>
            <returns>number of pages.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.GetPageNumber(iText.Kernel.Pdf.PdfPage)">
            <summary>Gets page number by page.</summary>
            <param name="page">the page.</param>
            <returns>page number.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.GetPageNumber(iText.Kernel.Pdf.PdfDictionary)">
            <summary>
            Gets page number by
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            .
            </summary>
            <param name="pageDictionary">
            
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            that present page.
            </param>
            <returns>
            page number by
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.RemovePage(iText.Kernel.Pdf.PdfPage)">
            <summary>
            Removes the first occurrence of the specified page from this document,
            if it is present.
            </summary>
            <remarks>
            Removes the first occurrence of the specified page from this document,
            if it is present. Returns <tt>true</tt> if this document
            contained the specified element (or equivalently, if this document
            changed as a result of the call).
            </remarks>
            <param name="page">page to be removed from this document, if present</param>
            <returns><tt>true</tt> if this document contained the specified page</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.RemovePage(System.Int32)">
            <summary>Removes page from the document by page number.</summary>
            <param name="pageNum">the one-based index of the PdfPage to be removed</param>
            <returns>the page that was removed from the list</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.GetDocumentInfo">
            <summary>Gets document information dictionary.</summary>
            <returns>document information dictionary.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.GetDefaultPageSize">
            <summary>Gets default page size.</summary>
            <returns>default page size.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.SetDefaultPageSize(iText.Kernel.Geom.PageSize)">
            <summary>Sets default page size.</summary>
            <param name="pageSize">page size to be set as default.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.AddEventHandler(System.String,iText.Kernel.Events.IEventHandler)">
            <summary><inheritDoc/></summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.DispatchEvent(iText.Kernel.Events.Event)">
            <summary><inheritDoc/></summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.DispatchEvent(iText.Kernel.Events.Event,System.Boolean)">
            <summary><inheritDoc/></summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.HasEventHandler(System.String)">
            <summary><inheritDoc/></summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.RemoveEventHandler(System.String,iText.Kernel.Events.IEventHandler)">
            <summary><inheritDoc/></summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.RemoveAllHandlers">
            <summary><inheritDoc/></summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.GetWriter">
            <summary>
            Gets
            <c>PdfWriter</c>
            associated with the document.
            </summary>
            <returns>PdfWriter associated with the document.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.GetReader">
            <summary>
            Gets
            <c>PdfReader</c>
            associated with the document.
            </summary>
            <returns>PdfReader associated with the document.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.IsAppendMode">
            <summary>
            Returns
            <see langword="true"/>
            if the document is opened in append mode, and
            <see langword="false"/>
            otherwise.
            </summary>
            <returns>
            
            <see langword="true"/>
            if the document is opened in append mode, and
            <see langword="false"/>
            otherwise.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.CreateNextIndirectReference">
            <summary>Creates next available indirect reference.</summary>
            <returns>created indirect reference.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.GetPdfVersion">
            <summary>Gets PDF version.</summary>
            <returns>PDF version.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.GetCatalog">
            <summary>Gets PDF catalog.</summary>
            <returns>PDF catalog.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.Close">
            <summary>Close PDF document.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.IsClosed">
            <summary>Gets close status of the document.</summary>
            <returns>true, if the document has already been closed, otherwise false.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.IsTagged">
            <summary>Gets tagged status of the document.</summary>
            <returns>true, if the document has tag structure, otherwise false.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.GetStructTreeRoot">
            <summary>
            Gets
            <see cref="T:iText.Kernel.Pdf.Tagging.PdfStructTreeRoot"/>
            of tagged document.
            </summary>
            <returns>
            
            <see cref="T:iText.Kernel.Pdf.Tagging.PdfStructTreeRoot"/>
            in case tagged document, otherwise false.
            </returns>
            <seealso cref="M:iText.Kernel.Pdf.PdfDocument.IsTagged"/>
            <seealso cref="M:iText.Kernel.Pdf.PdfDocument.GetNextStructParentIndex"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.GetNextStructParentIndex">
            <summary>Gets next parent index of tagged document.</summary>
            <returns>-1 if document is not tagged, or &gt;= 0 if tagged.</returns>
            <seealso cref="M:iText.Kernel.Pdf.PdfDocument.IsTagged"/>
            <seealso cref="M:iText.Kernel.Pdf.PdfDocument.GetNextStructParentIndex"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.GetTagStructureContext">
            <summary>
            Gets document
            <c>TagStructureContext</c>
            .
            The document must be tagged, otherwise an exception will be thrown.
            </summary>
            <returns>
            document
            <c>TagStructureContext</c>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.CopyPagesTo(System.Int32,System.Int32,iText.Kernel.Pdf.PdfDocument,System.Int32)">
            <summary>
            Copies a range of pages from current document to
            <paramref name="toDocument"/>
            .
            Use this method if you want to copy pages across tagged documents.
            This will keep resultant PDF structure consistent.
            </summary>
            <param name="pageFrom">start of the range of pages to be copied.</param>
            <param name="pageTo">end of the range of pages to be copied.</param>
            <param name="toDocument">a document to copy pages to.</param>
            <param name="insertBeforePage">a position where to insert copied pages.</param>
            <returns>list of copied pages</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.CopyPagesTo(System.Int32,System.Int32,iText.Kernel.Pdf.PdfDocument,System.Int32,iText.Kernel.Pdf.IPdfPageExtraCopier)">
            <summary>
            Copies a range of pages from current document to
            <paramref name="toDocument"/>
            .
            Use this method if you want to copy pages across tagged documents.
            This will keep resultant PDF structure consistent.
            </summary>
            <param name="pageFrom">1-based start of the range of pages to be copied.</param>
            <param name="pageTo">1-based end of the range of pages to be copied.</param>
            <param name="toDocument">a document to copy pages to.</param>
            <param name="insertBeforePage">a position where to insert copied pages.</param>
            <param name="copier">
            a copier which bears a special copy logic. May be null.
            It is recommended to use the same instance of
            <see cref="T:iText.Kernel.Pdf.IPdfPageExtraCopier"/>
            for the same output document.
            </param>
            <returns>list of new copied pages</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.CopyPagesTo(System.Int32,System.Int32,iText.Kernel.Pdf.PdfDocument)">
            <summary>
            Copies a range of pages from current document to
            <paramref name="toDocument"/>
            appending copied pages to the end.
            Use this method if you want to copy pages across tagged documents.
            This will keep resultant PDF structure consistent.
            </summary>
            <param name="pageFrom">1-based start of the range of pages to be copied.</param>
            <param name="pageTo">1-based end of the range of pages to be copied.</param>
            <param name="toDocument">a document to copy pages to.</param>
            <returns>list of new copied pages</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.CopyPagesTo(System.Int32,System.Int32,iText.Kernel.Pdf.PdfDocument,iText.Kernel.Pdf.IPdfPageExtraCopier)">
            <summary>
            Copies a range of pages from current document to
            <paramref name="toDocument"/>
            appending copied pages to the end.
            Use this method if you want to copy pages across tagged documents.
            This will keep resultant PDF structure consistent.
            </summary>
            <param name="pageFrom">1-based start of the range of pages to be copied.</param>
            <param name="pageTo">1-based end of the range of pages to be copied.</param>
            <param name="toDocument">a document to copy pages to.</param>
            <param name="copier">
            a copier which bears a special copy logic. May be null.
            It is recommended to use the same instance of
            <see cref="T:iText.Kernel.Pdf.IPdfPageExtraCopier"/>
            for the same output document.
            </param>
            <returns>list of new copied pages.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.CopyPagesTo(System.Collections.Generic.IList{System.Int32},iText.Kernel.Pdf.PdfDocument,System.Int32)">
            <summary>
            Copies a range of pages from current document to
            <paramref name="toDocument"/>
            .
            Use this method if you want to copy pages across tagged documents.
            This will keep resultant PDF structure consistent.
            </summary>
            <param name="pagesToCopy">list of pages to be copied. TreeSet for the order of the pages to be natural.</param>
            <param name="toDocument">a document to copy pages to.</param>
            <param name="insertBeforePage">a position where to insert copied pages.</param>
            <returns>list of new copied pages</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.CopyPagesTo(System.Collections.Generic.IList{System.Int32},iText.Kernel.Pdf.PdfDocument,System.Int32,iText.Kernel.Pdf.IPdfPageExtraCopier)">
            <summary>
            Copies a range of pages from current document to
            <paramref name="toDocument"/>
            .
            Use this method if you want to copy pages across tagged documents.
            This will keep resultant PDF structure consistent.
            </summary>
            <param name="pagesToCopy">list of pages to be copied. TreeSet for the order of the pages to be natural.</param>
            <param name="toDocument">a document to copy pages to.</param>
            <param name="insertBeforePage">a position where to insert copied pages.</param>
            <param name="copier">
            a copier which bears a special copy logic. May be null.
            It is recommended to use the same instance of
            <see cref="T:iText.Kernel.Pdf.IPdfPageExtraCopier"/>
            for the same output document.
            </param>
            <returns>list of new copied pages</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.CopyPagesTo(System.Collections.Generic.IList{System.Int32},iText.Kernel.Pdf.PdfDocument)">
            <summary>
            Copies a range of pages from current document to
            <paramref name="toDocument"/>
            appending copied pages to the end.
            Use this method if you want to copy pages across tagged documents.
            This will keep resultant PDF structure consistent.
            </summary>
            <param name="pagesToCopy">list of pages to be copied. TreeSet for the order of the pages to be natural.</param>
            <param name="toDocument">a document to copy pages to.</param>
            <returns>list of copied pages</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.CopyPagesTo(System.Collections.Generic.IList{System.Int32},iText.Kernel.Pdf.PdfDocument,iText.Kernel.Pdf.IPdfPageExtraCopier)">
            <summary>
            Copies a range of pages from current document to
            <paramref name="toDocument"/>
            appending copied pages to the end.
            Use this method if you want to copy pages across tagged documents.
            This will keep resultant PDF structure consistent.
            </summary>
            <param name="pagesToCopy">list of pages to be copied. TreeSet for the order of the pages to be natural.</param>
            <param name="toDocument">a document to copy pages to.</param>
            <param name="copier">
            a copier which bears a special copy logic. May be null.
            It is recommended to use the same instance of
            <see cref="T:iText.Kernel.Pdf.IPdfPageExtraCopier"/>
            for the same output document.
            </param>
            <returns>list of copied pages</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.FlushCopiedObjects(iText.Kernel.Pdf.PdfDocument)">
            <summary>Flush all copied objects and remove them from copied cache.</summary>
            <remarks>
            Flush all copied objects and remove them from copied cache.
            Note, if you will copy objects from the same document, doublicated objects will be created.
            </remarks>
            <param name="sourceDoc">source document</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.IsCloseReader">
            <summary>
            Checks, whether
            <see cref="M:iText.Kernel.Pdf.PdfDocument.Close"/>
            method will close associated PdfReader.
            </summary>
            <returns>
            true,
            <see cref="M:iText.Kernel.Pdf.PdfDocument.Close"/>
            method is going to close associated PdfReader, otherwise false.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.SetCloseReader(System.Boolean)">
            <summary>
            Sets, whether
            <see cref="M:iText.Kernel.Pdf.PdfDocument.Close"/>
            method shall close associated PdfReader.
            </summary>
            <param name="closeReader">
            true,
            <see cref="M:iText.Kernel.Pdf.PdfDocument.Close"/>
            method shall close associated PdfReader, otherwise false.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.IsCloseWriter">
            <summary>
            Checks, whether
            <see cref="M:iText.Kernel.Pdf.PdfDocument.Close"/>
            method will close associated PdfWriter.
            </summary>
            <returns>
            true,
            <see cref="M:iText.Kernel.Pdf.PdfDocument.Close"/>
            method is going to close associated PdfWriter, otherwise false.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.SetCloseWriter(System.Boolean)">
            <summary>
            Sets, whether
            <see cref="M:iText.Kernel.Pdf.PdfDocument.Close"/>
            method shall close associated PdfWriter.
            </summary>
            <param name="closeWriter">
            true,
            <see cref="M:iText.Kernel.Pdf.PdfDocument.Close"/>
            method shall close associated PdfWriter, otherwise false.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.IsFlushUnusedObjects">
            <summary>
            Checks, whether
            <see cref="M:iText.Kernel.Pdf.PdfDocument.Close"/>
            will flush unused objects,
            e.g. unreachable from PDF Catalog. By default - false.
            </summary>
            <returns>
            false, if
            <see cref="M:iText.Kernel.Pdf.PdfDocument.Close"/>
            shall not flush unused objects, otherwise true.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.SetFlushUnusedObjects(System.Boolean)">
            <summary>
            Sets, whether
            <see cref="M:iText.Kernel.Pdf.PdfDocument.Close"/>
            shall flush unused objects,
            e.g. unreachable from PDF Catalog.
            </summary>
            <param name="flushUnusedObjects">
            false, if
            <see cref="M:iText.Kernel.Pdf.PdfDocument.Close"/>
            shall not flush unused objects, otherwise true.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.GetOutlines(System.Boolean)">
            <summary>This method returns a complete outline tree of the whole document.</summary>
            <param name="updateOutlines">
            if the flag is true, the method read the whole document and creates outline tree.
            If false the method gets cached outline tree (if it was cached via calling getOutlines method before).
            </param>
            <returns>
            fully initialize
            <see cref="T:iText.Kernel.Pdf.PdfOutline"/>
            object.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.InitializeOutlines">
            <summary>This method initializes an outline tree of the document and sets outline mode to true.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.AddNamedDestination(System.String,iText.Kernel.Pdf.PdfObject)">
            <summary>This methods adds new name in the Dests NameTree.</summary>
            <remarks>This methods adds new name in the Dests NameTree. It throws an exception, if the name already exists.
                </remarks>
            <param name="key">Name of the destination.</param>
            <param name="value">
            An object destination refers to. Must be an array or a dictionary with key /D and array.
            See ISO 32000-1 12.3.2.3 for more info.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.ListIndirectReferences">
            <summary>Gets static copy of cross reference table.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.GetTrailer">
            <summary>Gets document trailer.</summary>
            <returns>document trailer.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.AddOutputIntent(iText.Kernel.Pdf.PdfOutputIntent)">
            <summary>
            Adds
            <see cref="T:iText.Kernel.Pdf.PdfOutputIntent"/>
            that shall specify the colour characteristics of output devices
            on which the document might be rendered.
            </summary>
            <param name="outputIntent">
            
            <see cref="T:iText.Kernel.Pdf.PdfOutputIntent"/>
            to add.
            </param>
            <seealso cref="T:iText.Kernel.Pdf.PdfOutputIntent"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.CheckIsoConformance(System.Object,iText.Kernel.Pdf.IsoKey)">
            <summary>Checks whether PDF document conforms a specific standard.</summary>
            <remarks>
            Checks whether PDF document conforms a specific standard.
            Shall be override.
            </remarks>
            <param name="obj">An object to conform.</param>
            <param name="key">type of object to conform.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.CheckIsoConformance(System.Object,iText.Kernel.Pdf.IsoKey,iText.Kernel.Pdf.PdfResources)">
            <summary>Checks whether PDF document conforms a specific standard.</summary>
            <remarks>
            Checks whether PDF document conforms a specific standard.
            Shall be override.
            </remarks>
            <param name="obj">an object to conform.</param>
            <param name="key">type of object to conform.</param>
            <param name="resources">
            
            <see cref="T:iText.Kernel.Pdf.PdfResources"/>
            associated with an object to check.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.CheckShowTextIsoConformance(System.Object,iText.Kernel.Pdf.PdfResources)">
            <summary>Checks whether PDF document conforms a specific standard.</summary>
            <remarks>
            Checks whether PDF document conforms a specific standard.
            Shall be override.
            </remarks>
            <param name="gState">
            a
            <see cref="T:iText.Kernel.Pdf.Canvas.CanvasGraphicsState"/>
            object to conform.
            </param>
            <param name="resources">
            
            <see cref="T:iText.Kernel.Pdf.PdfResources"/>
            associated with an object to check.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.AddFileAttachment(System.String,System.Byte[],System.String,iText.Kernel.Pdf.PdfName,iText.Kernel.Pdf.PdfDictionary,iText.Kernel.Pdf.PdfName)">
            <summary>Adds file attachment at document level.</summary>
            <param name="description">the file description</param>
            <param name="fileStore">an array with the file.</param>
            <param name="fileDisplay">the actual file name stored in the pdf</param>
            <param name="mimeType">mime type of the file</param>
            <param name="fileParameter">the optional extra file parameters such as the creation or modification date</param>
            <param name="afRelationshipValue">
            if
            <see langword="null"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.Unspecified"/>
            will be added. Shall be one of:
            <see cref="F:iText.Kernel.Pdf.PdfName.Source"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.Data"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.Alternative"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.Supplement"/>
            or
            <see cref="F:iText.Kernel.Pdf.PdfName.Unspecified"/>
            .
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.AddFileAttachment(System.String,System.String,System.String,iText.Kernel.Pdf.PdfName,iText.Kernel.Pdf.PdfName)">
            <summary>Adds file attachment at document level.</summary>
            <param name="description">the file description</param>
            <param name="file">the path to the file.</param>
            <param name="fileDisplay">the actual file name stored in the pdf</param>
            <param name="mimeType">mime type of the file</param>
            <param name="afRelationshipValue">
            if
            <see langword="null"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.Unspecified"/>
            will be added. Shall be one of:
            <see cref="F:iText.Kernel.Pdf.PdfName.Source"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.Data"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.Alternative"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.Supplement"/>
            or
            <see cref="F:iText.Kernel.Pdf.PdfName.Unspecified"/>
            .
            </param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.AddFileAttachment(System.String,iText.Kernel.Pdf.Filespec.PdfFileSpec)">
            <summary>Adds file attachment at document level.</summary>
            <param name="description">the file description</param>
            <param name="fs">
            
            <see cref="T:iText.Kernel.Pdf.Filespec.PdfFileSpec"/>
            object.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.GetPageLabels">
            <summary>This method retrieves the page labels from a document as an array of String objects.</summary>
            <returns>
            
            <see cref="T:System.String"/>
            list of page labels if they were found, or
            <see langword="null"/>
            otherwise
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.HasOutlines">
            <summary>Indicates if the document has any outlines</summary>
            <returns>
            
            <see langword="true"/>
            , if there are outlines and
            <see langword="false"/>
            otherwise.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.SetUserProperties(System.Boolean)">
            <summary>Sets the flag indicating the presence of structure elements that contain user properties attributes.
                </summary>
            <param name="userProperties">the user properties flag</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.SetInitialDocumentId(iText.Kernel.Pdf.PdfString)">
            <summary>The /ID entry of a document contains an array with two entries.</summary>
            <remarks>
            The /ID entry of a document contains an array with two entries. The first one represents the initial document id.
            The second one should be the same entry, unless the document has been modified. iText will by default keep thi
            existing initial id. But if you'd like you can set this id yourself using this setter.
            </remarks>
            <param name="initialDocumentId">the new initial document id</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.SetModifiedDocumentId(iText.Kernel.Pdf.PdfString)">
            <summary>The /ID entry of a document contains an array with two entries.</summary>
            <remarks>
            The /ID entry of a document contains an array with two entries. The first one represents the initial document id.
            The second one should be the same entry, unless the document has been modified. iText will by default generate
            a modified id. But if you'd like you can set this id yourself using this setter.
            </remarks>
            <param name="modifiedDocumentId">the new modified document id</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.GetFont(iText.Kernel.Pdf.PdfDictionary)">
            <summary>
            Create a new instance of
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            or load already created one.
            Note, PdfFont which created with
            <see cref="M:iText.Kernel.Font.PdfFontFactory.CreateFont(iText.Kernel.Pdf.PdfDictionary)"/>
            won't be cached
            until it will be added to
            <see cref="T:iText.Kernel.Pdf.Canvas.PdfCanvas"/>
            or
            <see cref="T:iText.Kernel.Pdf.PdfResources"/>
            .
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.GetDefaultFont">
            <summary>Gets default font for the document: Helvetica, WinAnsi.</summary>
            <remarks>
            Gets default font for the document: Helvetica, WinAnsi.
            One instance per document.
            </remarks>
            <returns>
            instance of
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            or
            <see langword="null"/>
            on error.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.AddFont(iText.Kernel.Font.PdfFont)">
            <summary>
            Adds a
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            instance to this document so that this font is flushed automatically
            on document close. As a side effect, the underlying font dictionary is made indirect if it wasn't the case yet
            </summary>
            <returns>the same PdfFont instance.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.GetXref">
            <summary>Gets list of indirect references.</summary>
            <returns>list of indirect references.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.InitTagStructureContext">
            <summary>
            Initialize
            <see cref="T:iText.Kernel.Pdf.Tagutils.TagStructureContext"/>
            .
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.StoreLinkAnnotation(iText.Kernel.Pdf.PdfPage,iText.Kernel.Pdf.Annot.PdfLinkAnnotation)">
            <summary>Save the link annotation in a temporary storage for further copying.</summary>
            <param name="page">
            just copied
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            link annotation belongs to.
            </param>
            <param name="annotation">
            
            <see cref="T:iText.Kernel.Pdf.Annot.PdfLinkAnnotation"/>
            itself.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.CheckIsoConformance">
            <summary>Checks whether PDF document conforms a specific standard.</summary>
            <remarks>
            Checks whether PDF document conforms a specific standard.
            Shall be override.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.MarkObjectAsMustBeFlushed(iText.Kernel.Pdf.PdfObject)">
            <summary>
            Mark an object with
            <see cref="F:iText.Kernel.Pdf.PdfObject.MUST_BE_FLUSHED"/>
            .
            </summary>
            <param name="pdfObject">an object to mark.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.FlushObject(iText.Kernel.Pdf.PdfObject,System.Boolean)">
            <summary>Flush an object.</summary>
            <param name="pdfObject">object to flush.</param>
            <param name="canBeInObjStm">indicates whether object can be placed into object stream.</param>
            <exception cref="T:System.IO.IOException">on error.</exception>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.Open(iText.Kernel.Pdf.PdfVersion)">
            <summary>Initializes document.</summary>
            <param name="newPdfVersion">
            new pdf version of the resultant file if stamper is used and the version needs to be changed,
            or
            <see langword="null"/>
            otherwise
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.AddCustomMetadataExtensions(iText.Kernel.XMP.XMPMeta)">
            <summary>Adds custom XMP metadata extension.</summary>
            <remarks>Adds custom XMP metadata extension. Useful for PDF/UA, ZUGFeRD, etc.</remarks>
            <param name="xmpMeta">
            
            <see cref="T:iText.Kernel.XMP.XMPMeta"/>
            to add custom metadata to.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.UpdateXmpMetadata">
            <summary>Updates XMP metadata.</summary>
            <remarks>
            Updates XMP metadata.
            Shall be override.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.UpdateDefaultXmpMetadata">
            <summary>
            Update XMP metadata values from
            <see cref="T:iText.Kernel.Pdf.PdfDocumentInfo"/>
            .
            </summary>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.GetDocumentFonts">
            <summary>List all newly added or loaded fonts</summary>
            <returns>
            List of
            <see cref="T:iText.Kernel.Font.PdfFont"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.CheckAndAddPage(System.Int32,iText.Kernel.Pdf.PdfPage)">
            <summary>Checks page before adding and add.</summary>
            <param name="index">one-base index of the page.</param>
            <param name="page">
            
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            to add.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.CheckAndAddPage(iText.Kernel.Pdf.PdfPage)">
            <summary>Checks page before adding.</summary>
            <param name="page">
            
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            to add.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.CheckClosingStatus">
            <summary>checks whether a method is invoked at the closed document</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.GetCounter">
            <summary>
            Gets
            <see cref="T:iText.Kernel.Log.Counter"/>
            instance.
            </summary>
            <returns>
            
            <see cref="T:iText.Kernel.Log.Counter"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.RemoveUnusedWidgetsFromFields(iText.Kernel.Pdf.PdfPage)">
            <summary>This method removes all annotation entries from form fields associated with a given page.</summary>
            <param name="page">to remove from.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.CopyOutlines(System.Collections.Generic.ICollection{iText.Kernel.Pdf.PdfOutline},iText.Kernel.Pdf.PdfDocument,System.Collections.Generic.IDictionary{iText.Kernel.Pdf.PdfPage,iText.Kernel.Pdf.PdfPage})">
            <summary>This method copies all given outlines</summary>
            <param name="outlines">outlines to be copied</param>
            <param name="toDocument">document where outlines should be copied</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.GetAllOutlinesToCopy(iText.Kernel.Pdf.PdfOutline,System.Collections.Generic.ICollection{iText.Kernel.Pdf.PdfOutline})">
            <summary>This method gets all outlines to be copied including parent outlines</summary>
            <param name="outline">current outline</param>
            <param name="outlinesToCopy">a Set of outlines to be copied</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.CloneOutlines(System.Collections.Generic.ICollection{iText.Kernel.Pdf.PdfOutline},iText.Kernel.Pdf.PdfOutline,iText.Kernel.Pdf.PdfOutline,System.Collections.Generic.IDictionary{iText.Kernel.Pdf.PdfPage,iText.Kernel.Pdf.PdfPage},iText.Kernel.Pdf.PdfDocument)">
            <summary>This method copies create new outlines in the Document to copy.</summary>
            <param name="outlinesToCopy">- Set of outlines to be copied</param>
            <param name="newParent">- new parent outline</param>
            <param name="oldParent">- old parent outline</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocument.IsXmpMetaHasProperty(iText.Kernel.XMP.XMPMeta,System.String,System.String)">
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="T:iText.Kernel.Pdf.PdfDocument.IndirectRefDescription">
            <summary>A structure storing documentId, object number and generation number.</summary>
            <remarks>
            A structure storing documentId, object number and generation number. This structure is using to calculate
            an unique object key during the copy process.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocumentInfo.#ctor(iText.Kernel.Pdf.PdfDictionary,iText.Kernel.Pdf.PdfDocument)">
            <summary>Create a PdfDocumentInfo based on the passed PdfDictionary and linked to the passed PdfDocument.</summary>
            <param name="pdfObject">PdfDictionary containing PdfDocumentInfo</param>
            <param name="pdfDocument">PdfDocument the PdfDocumentInfo corresponds to.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfDocumentInfo.#ctor(iText.Kernel.Pdf.PdfDocument)">
            <summary>Create a default, empty PdfDocumentInfo and link it to the passed PdfDocument</summary>
            <param name="pdfDocument"/>
        </member>
        <member name="T:iText.Kernel.Pdf.PdfEncryption">
            <author>Paulo Soares</author>
            <author>Kazuya Ujihara</author>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfEncryption.#ctor(System.Byte[],System.Byte[],System.Int32,System.Int32,System.Byte[])">
            <summary>Creates the encryption.</summary>
            <remarks>
            Creates the encryption. The userPassword and the
            ownerPassword can be null or have zero length. In this case the ownerPassword
            is replaced by a random string. The open permissions for the document can be
            AllowPrinting, AllowModifyContents, AllowCopy, AllowModifyAnnotations,
            AllowFillIn, AllowScreenReaders, AllowAssembly and AllowDegradedPrinting.
            The permissions can be combined by ORing them.
            </remarks>
            <param name="userPassword">the user password. Can be null or empty</param>
            <param name="ownerPassword">the owner password. Can be null or empty</param>
            <param name="permissions">the user permissions</param>
            <param name="encryptionType">
            the type of encryption. It can be one of STANDARD_ENCRYPTION_40, STANDARD_ENCRYPTION_128 or ENCRYPTION_AES128.
            Optionally DO_NOT_ENCRYPT_METADATA can be ored to output the metadata in cleartext
            </param>
            <exception cref="T:iText.Kernel.PdfException">if the document is already open</exception>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfEncryption.#ctor(Org.BouncyCastle.X509.X509Certificate[],System.Int32[],System.Int32)">
            <summary>Creates the certificate encryption.</summary>
            <remarks>
            Creates the certificate encryption. An array of one or more public certificates
            must be provided together with an array of the same size for the permissions for each certificate.
            The open permissions for the document can be
            AllowPrinting, AllowModifyContents, AllowCopy, AllowModifyAnnotations,
            AllowFillIn, AllowScreenReaders, AllowAssembly and AllowDegradedPrinting.
            The permissions can be combined by ORing them.
            Optionally DO_NOT_ENCRYPT_METADATA can be ored to output the metadata in cleartext
            </remarks>
            <param name="certs">the public certificates to be used for the encryption</param>
            <param name="permissions">the user permissions for each of the certificates</param>
            <param name="encryptionType">the type of encryption. It can be one of STANDARD_ENCRYPTION_40, STANDARD_ENCRYPTION_128 or ENCRYPTION_AES128.
                </param>
            <exception cref="T:iText.Kernel.PdfException">if the document is already open</exception>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfEncryption.CreateInfoId(System.Byte[],System.Boolean)">
            <summary>Creates a PdfLiteral that contains an array of two id entries.</summary>
            <remarks>
            Creates a PdfLiteral that contains an array of two id entries. These entries are both hexadecimal
            strings containing 16 hex characters. The first entry is the original id, the second entry
            should be different from the first one if the document has changed.
            </remarks>
            <param name="id">the first id</param>
            <param name="modified">whether the document has been changed or not</param>
            <returns>PdfObject containing the two entries.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfEncryption.CreateInfoId(System.Byte[],System.Byte[])">
            <summary>Creates a PdfLiteral that contains an array of two id entries.</summary>
            <remarks>
            Creates a PdfLiteral that contains an array of two id entries. These entries are both hexadecimal
            strings containing 16 hex characters. The first entry is the original id, the second entry
            should be different from the first one if the document has changed.
            </remarks>
            <param name="firstId">the first id</param>
            <param name="secondId">the second id</param>
            <returns>PdfObject containing the two entries.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfEncryption.GetPermissions">
            <summary>Gets the encryption permissions.</summary>
            <remarks>
            Gets the encryption permissions. It can be used directly in
            <see cref="M:iText.Kernel.Pdf.WriterProperties.SetStandardEncryption(System.Byte[],System.Byte[],System.Int32,System.Int32)"/>
            .
            See ISO 32000-1, Table 22 for more details.
            </remarks>
            <returns>the encryption permissions, an unsigned 32-bit quantity.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfEncryption.GetCryptoMode">
            <summary>Gets encryption algorithm and access permissions.</summary>
            <seealso cref="T:iText.Kernel.Pdf.EncryptionConstants"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfEncryption.GetDocumentId">
            <returns>document id which was used for encryption. Could be null, if encryption doesn't rely on document id.
                </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfEncryption.ComputeUserPassword(System.Byte[])">
            <summary>Computes user password if standard encryption handler is used with Standard40, Standard128 or AES128 algorithm.
                </summary>
            <param name="ownerPassword">owner password of the encrypted document.</param>
            <returns>user password, or null if not a standard encryption handler was used.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfEncryption.Flush">
            <summary>
            To manually flush a
            <c>PdfObject</c>
            behind this wrapper, you have to ensure
            that this object is added to the document, i.e. it has an indirect reference.
            Basically this means that before flushing you need to explicitly call
            <see cref="M:iText.Kernel.Pdf.PdfObjectWrapper`1.MakeIndirect(iText.Kernel.Pdf.PdfDocument)"/>
            .
            For example: wrapperInstance.makeIndirect(document).flush();
            Note that not every wrapper require this, only those that have such warning in documentation.
            </summary>
        </member>
        <member name="T:iText.Kernel.Pdf.PdfEncryptor">
            <summary>
            This class takes any PDF and returns exactly the same but
            encrypted.
            </summary>
            <remarks>
            This class takes any PDF and returns exactly the same but
            encrypted. All the content, links, outlines, etc, are kept.
            It is also possible to change the info dictionary.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfEncryptor.Encrypt(iText.Kernel.Pdf.PdfReader,System.IO.Stream,iText.Kernel.Pdf.EncryptionProperties,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>Entry point to encrypt a PDF document.</summary>
            <param name="reader">the read PDF</param>
            <param name="os">the output destination</param>
            <param name="properties">
            encryption properties. See
            <see cref="T:iText.Kernel.Pdf.EncryptionProperties"/>
            .
            </param>
            <param name="newInfo">
            an optional
            <c>String</c>
            map to add or change
            the info dictionary. Entries with
            <see langword="null"/>
            values delete the key in the original info dictionary
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfEncryptor.Encrypt(iText.Kernel.Pdf.PdfReader,System.IO.Stream,iText.Kernel.Pdf.EncryptionProperties)">
            <summary>Entry point to encrypt a PDF document.</summary>
            <param name="reader">the read PDF</param>
            <param name="os">the output destination</param>
            <param name="properties">
            encryption properties. See
            <see cref="T:iText.Kernel.Pdf.EncryptionProperties"/>
            .
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfEncryptor.GetPermissionsVerbose(System.Int32)">
            <summary>Give you a verbose analysis of the permissions.</summary>
            <param name="permissions">the permissions value of a PDF file</param>
            <returns>a String that explains the meaning of the permissions value</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfEncryptor.IsPrintingAllowed(System.Int32)">
            <summary>Tells you if printing is allowed.</summary>
            <param name="permissions">the permissions value of a PDF file</param>
            <returns>true if printing is allowed</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfEncryptor.IsModifyContentsAllowed(System.Int32)">
            <summary>Tells you if modifying content is allowed.</summary>
            <param name="permissions">the permissions value of a PDF file</param>
            <returns>true if modifying content is allowed</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfEncryptor.IsCopyAllowed(System.Int32)">
            <summary>Tells you if copying is allowed.</summary>
            <param name="permissions">the permissions value of a PDF file</param>
            <returns>true if copying is allowed</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfEncryptor.IsModifyAnnotationsAllowed(System.Int32)">
            <summary>Tells you if modifying annotations is allowed.</summary>
            <param name="permissions">the permissions value of a PDF file</param>
            <returns>true if modifying annotations is allowed</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfEncryptor.IsFillInAllowed(System.Int32)">
            <summary>Tells you if filling in fields is allowed.</summary>
            <param name="permissions">the permissions value of a PDF file</param>
            <returns>true if filling in fields is allowed</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfEncryptor.IsScreenReadersAllowed(System.Int32)">
            <summary>Tells you if repurposing for screenreaders is allowed.</summary>
            <param name="permissions">the permissions value of a PDF file</param>
            <returns>true if repurposing for screenreaders is allowed</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfEncryptor.IsAssemblyAllowed(System.Int32)">
            <summary>Tells you if document assembly is allowed.</summary>
            <param name="permissions">the permissions value of a PDF file</param>
            <returns>true if document assembly is allowed</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfEncryptor.IsDegradedPrintingAllowed(System.Int32)">
            <summary>Tells you if degraded printing is allowed.</summary>
            <param name="permissions">the permissions value of a PDF file</param>
            <returns>true if degraded printing is allowed</returns>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfIndirectReference.objNr">
            <summary>Object number.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfIndirectReference.genNr">
            <summary>Object generation.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfIndirectReference.refersTo">
            <summary>PdfObject that current PdfIndirectReference instance refers to.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfIndirectReference.objectStreamNumber">
            <summary>Indirect reference number of object stream containing refersTo object.</summary>
            <remarks>
            Indirect reference number of object stream containing refersTo object.
            If refersTo is not placed into object stream - objectStreamNumber = 0.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfIndirectReference.offsetOrIndex">
            <summary>
            Offset in a document of the
            <c>refersTo</c>
            object.
            If the object placed into object stream then it is an object index inside object stream.
            </summary>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfIndirectReference.pdfDocument">
            <summary>PdfDocument object belongs to.</summary>
            <remarks>PdfDocument object belongs to. For direct objects it is null.</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfIndirectReference.GetRefersTo(System.Boolean)">
            <summary>Gets direct object and try to resolve indirects chain.</summary>
            <remarks>
            Gets direct object and try to resolve indirects chain.
            <p>
            Note: If chain of references has length of more than 32,
            this method return 31st reference in chain.
            </p>
            </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfIndirectReference.GetOffset">
            <summary>Gets refersTo object offset in a document.</summary>
            <returns>object offset in a document. If refersTo object is in object stream then -1.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfIndirectReference.GetIndex">
            <summary>Gets refersTo object index in the object stream.</summary>
            <returns>object index in a document. If refersTo object is not in object stream then -1.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfIndirectReference.SetFree">
            <summary>Releases indirect reference from the document.</summary>
            <remarks>
            Releases indirect reference from the document. Remove link to the referenced indirect object.
            <p>
            Note: Be careful when using this method. Do not use this method for wrapper objects,
            it can be cause of errors.
            Free indirect reference could be reused for a new indirect object.
            </p>
            </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfIndirectReference.GetWriter">
            <summary>Gets a PdfWriter associated with the document object belongs to.</summary>
            <returns>PdfWriter.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfIndirectReference.GetReader">
            <summary>Gets a PdfReader associated with the document object belongs to.</summary>
            <returns>PdfReader.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfIndirectReference.SetState(System.Int16)">
            <summary>Sets special states of current object.</summary>
            <param name="state">special flag of current object</param>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfName.Fl">
            <summary>PdfName for the abbreviation of FlateDecode.</summary>
            <remarks>
            PdfName for the abbreviation of FlateDecode. For the Flatness Tolerance PdfName use
            <see cref="F:iText.Kernel.Pdf.PdfName.FL"/>
            (Uppercase 'L')
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfName.FL">
            <summary>PdfName for Flatness Tolerance.</summary>
            <remarks>
            PdfName for Flatness Tolerance. For the PdfName with the FlateDecode abbreviation use
            <see cref="F:iText.Kernel.Pdf.PdfName.Fl"/>
            (Lowercase 'L')
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfName.staticNames">
            <summary>map strings to all known static names</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfName.#ctor(System.String)">
            <summary>Create a PdfName from the passed string</summary>
            <param name="value">string value, shall not be null.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfName.#ctor(System.Byte[])">
            <summary>Create a PdfName from the passed bytes</summary>
            <param name="content">byte content, shall not be null.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfName.CompareTo(iText.Kernel.Pdf.PdfName)">
            <summary>Compare this PdfName to o.</summary>
            <param name="o">PdfName to compare this object to/</param>
            <returns>Comparison between both values or, if one of the values is null, Comparison between contents. If one of the values and one of the contents are equal to null, generate values and compare those.
                </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfName.MakeIndirect(iText.Kernel.Pdf.PdfDocument)">
            <summary>Marks object to be saved as indirect.</summary>
            <param name="document">a document the indirect reference will belong to.</param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfName.MakeIndirect(iText.Kernel.Pdf.PdfDocument,iText.Kernel.Pdf.PdfIndirectReference)">
            <summary>Marks object to be saved as indirect.</summary>
            <param name="document">a document the indirect reference will belong to.</param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfName.CopyTo(iText.Kernel.Pdf.PdfDocument)">
            <summary>Copies object to a specified document.</summary>
            <remarks>
            Copies object to a specified document.
            Works only for objects that are read from existing document, otherwise an exception is thrown.
            </remarks>
            <param name="document">document to copy object to.</param>
            <returns>copied object.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfName.CopyTo(iText.Kernel.Pdf.PdfDocument,System.Boolean)">
            <summary>Copies object to a specified document.</summary>
            <remarks>
            Copies object to a specified document.
            Works only for objects that are read from existing document, otherwise an exception is thrown.
            </remarks>
            <param name="document">document to copy object to.</param>
            <param name="allowDuplicating">
            indicates if to allow copy objects which already have been copied.
            If object is associated with any indirect reference and allowDuplicating is false then already existing reference will be returned instead of copying object.
            If allowDuplicating is true then object will be copied and new indirect reference will be assigned.
            </param>
            <returns>copied object.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfNameTree.#ctor(iText.Kernel.Pdf.PdfCatalog,iText.Kernel.Pdf.PdfName)">
            <summary>Creates the NameTree of current Document</summary>
            <param name="catalog">Document catalog</param>
            <param name="treeType">the type of tree. Dests Tree, AP Tree etc.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfNameTree.GetNames">
            <summary>Retrieves the names stored in the name tree</summary>
            <returns>Map containing the PdfObjects stored in the tree</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfNameTree.AddEntry(System.String,iText.Kernel.Pdf.PdfObject)">
            <summary>Add an entry to the name tree</summary>
            <param name="key">key of the entry</param>
            <param name="value">object to add</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfNameTree.IsModified">
            <returns>True if the object has been modified, false otherwise.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfNameTree.BuildTree">
            <summary>Build a PdfDictionary containing the name tree</summary>
            <returns>PdfDictionary containing the name tree</returns>
        </member>
        <member name="T:iText.Kernel.Pdf.PdfNull">
            <summary>Representation of the null object in the PDF specification.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfNull.#ctor">
            <summary>Creates a PdfNull instance.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfNull.MakeIndirect(iText.Kernel.Pdf.PdfDocument)">
            <summary>Marks object to be saved as indirect.</summary>
            <param name="document">a document the indirect reference will belong to.</param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfNull.MakeIndirect(iText.Kernel.Pdf.PdfDocument,iText.Kernel.Pdf.PdfIndirectReference)">
            <summary>Marks object to be saved as indirect.</summary>
            <param name="document">a document the indirect reference will belong to.</param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfNull.CopyTo(iText.Kernel.Pdf.PdfDocument)">
            <summary>Copies object to a specified document.</summary>
            <remarks>
            Copies object to a specified document.
            Works only for objects that are read from existing document, otherwise an exception is thrown.
            </remarks>
            <param name="document">document to copy object to.</param>
            <returns>copied object.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfNull.CopyTo(iText.Kernel.Pdf.PdfDocument,System.Boolean)">
            <summary>Copies object to a specified document.</summary>
            <remarks>
            Copies object to a specified document.
            Works only for objects that are read from existing document, otherwise an exception is thrown.
            </remarks>
            <param name="document">document to copy object to.</param>
            <param name="allowDuplicating">
            indicates if to allow copy objects which already have been copied.
            If object is associated with any indirect reference and allowDuplicating is false then already existing reference will be returned instead of copying object.
            If allowDuplicating is true then object will be copied and new indirect reference will be assigned.
            </param>
            <returns>copied object.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfNumber.MakeIndirect(iText.Kernel.Pdf.PdfDocument)">
            <summary>Marks object to be saved as indirect.</summary>
            <param name="document">a document the indirect reference will belong to.</param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfNumber.MakeIndirect(iText.Kernel.Pdf.PdfDocument,iText.Kernel.Pdf.PdfIndirectReference)">
            <summary>Marks object to be saved as indirect.</summary>
            <param name="document">a document the indirect reference will belong to.</param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfNumber.CopyTo(iText.Kernel.Pdf.PdfDocument)">
            <summary>Copies object to a specified document.</summary>
            <remarks>
            Copies object to a specified document.
            Works only for objects that are read from existing document, otherwise an exception is thrown.
            </remarks>
            <param name="document">document to copy object to.</param>
            <returns>copied object.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfNumber.CopyTo(iText.Kernel.Pdf.PdfDocument,System.Boolean)">
            <summary>Copies object to a specified document.</summary>
            <remarks>
            Copies object to a specified document.
            Works only for objects that are read from existing document, otherwise an exception is thrown.
            </remarks>
            <param name="document">document to copy object to.</param>
            <param name="allowDuplicating">
            indicates if to allow copy objects which already have been copied.
            If object is associated with any indirect reference and allowDuplicating is false then already existing reference will be returned instead of copying object.
            If allowDuplicating is true then object will be copied and new indirect reference will be assigned.
            </param>
            <returns>copied object.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfNumTree.#ctor(iText.Kernel.Pdf.PdfCatalog,iText.Kernel.Pdf.PdfName)">
            <summary>Creates the NumberTree of current Document</summary>
            <param name="catalog">Document catalog</param>
            <param name="treeType">the type of tree. ParentTree or PageLabels.</param>
        </member>
        <member name="T:iText.Kernel.Pdf.PdfStream">
            <summary>Representation of a stream as described in the PDF Specification.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfStream.#ctor(System.Byte[],System.Int32)">
            <summary>
            Constructs a
            <c>PdfStream</c>
            -object.
            </summary>
            <param name="bytes">
            initial content of
            <see cref="T:iText.Kernel.Pdf.PdfOutputStream"/>
            .
            </param>
            <param name="compressionLevel">the compression level (0 = best speed, 9 = best compression, -1 is default)
                </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfStream.#ctor(System.Byte[])">
            <summary>Creates a PdfStream instance.</summary>
            <param name="bytes">bytes to write to the PdfStream</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfStream.#ctor(iText.Kernel.Pdf.PdfDocument,System.IO.Stream,System.Int32)">
            <summary>Creates an efficient stream.</summary>
            <remarks>
            Creates an efficient stream. No temporary array is ever created. The
            <c>InputStream</c>
            is totally consumed but is not closed. The general usage is:
            <p/>
            <pre>
            PdfDocument document = ?;
            InputStream in = ?;
            PdfStream stream = new PdfStream(document, in, PdfOutputStream.DEFAULT_COMPRESSION);
            ?
            stream.flush();
            in.close();
            </pre>
            </remarks>
            <param name="inputStream">the data to write to this stream</param>
            <param name="compressionLevel">the compression level (0 = best speed, 9 = best compression, -1 is default)
                </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfStream.#ctor(iText.Kernel.Pdf.PdfDocument,System.IO.Stream)">
            <summary>Creates an efficient stream.</summary>
            <remarks>
            Creates an efficient stream. No temporary array is ever created. The
            <c>InputStream</c>
            is totally consumed but is not closed. The general usage is:
            <p/>
            <pre>
            PdfDocument document = ?;
            InputStream in = ?;
            PdfStream stream = new PdfStream(document, in);
            stream.flush();
            in.close();
            </pre>
            </remarks>
            <param name="inputStream">the data to write to this stream</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfStream.#ctor(System.Int32)">
            <summary>
            Constructs a
            <c>PdfStream</c>
            -object.
            </summary>
            <param name="compressionLevel">the compression level (0 = best speed, 9 = best compression, -1 is default)
                </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfStream.#ctor">
            <summary>Creates an empty PdfStream instance.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfStream.GetOutputStream">
            <summary>Gets output stream.</summary>
            <returns>output stream</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfStream.GetCompressionLevel">
            <summary>Gets compression level of this PdfStream.</summary>
            <remarks>
            Gets compression level of this PdfStream.
            For more details @see
            <see cref="!:Java.Util.Zip.Deflater"/>
            .
            </remarks>
            <returns>compression level.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfStream.SetCompressionLevel(System.Int32)">
            <summary>Sets compression level of this PdfStream.</summary>
            <remarks>
            Sets compression level of this PdfStream.
            For more details @see
            <see cref="!:Java.Util.Zip.Deflater"/>
            .
            </remarks>
            <param name="compressionLevel">the compression level (0 = best speed, 9 = best compression, -1 is default)
                </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfStream.GetBytes">
            <summary>Gets decoded stream bytes.</summary>
            <returns>byte[]</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfStream.GetBytes(System.Boolean)">
            <summary>Gets stream bytes.</summary>
            <param name="decoded">true if to get decoded stream bytes, otherwise false.</param>
            <returns>
            byte content of the
            <c>PdfStream</c>
            . Byte content will be
            <see langword="null"/>
            ,
            if the
            <c>PdfStream</c>
            was created by
            <c>InputStream</c>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfStream.SetData(System.Byte[])">
            <summary>Sets <code>bytes</code> as stream's content.</summary>
            <remarks>
            Sets <code>bytes</code> as stream's content.
            Could not be used with streams which were created by <code>InputStream</code>.
            </remarks>
            <param name="bytes">new content for stream; if <code>null</code> then stream's content will be discarded</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfStream.SetData(System.Byte[],System.Boolean)">
            <summary>Sets or appends <code>bytes</code> to stream content.</summary>
            <remarks>
            Sets or appends <code>bytes</code> to stream content.
            Could not be used with streams which were created by <code>InputStream</code>.
            </remarks>
            <param name="bytes">
            New content for stream. These bytes are considered to be a raw data (i.e. not encoded/compressed/encrypted)
            and if it's not true, the corresponding filters shall be set to the PdfStream object manually.
            Data compression generally should be configured via
            <see cref="M:iText.Kernel.Pdf.PdfStream.SetCompressionLevel(System.Int32)"/>
            and
            is handled on stream writing to the output document.
            If <code>null</code> and <code>append</code> is false then stream's content will be discarded.
            </param>
            <param name="append">
            If set to true then <code>bytes</code> will be appended to the end,
            rather then replace original content. The original content will be decoded if needed.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfStream.MakeIndirect(iText.Kernel.Pdf.PdfDocument)">
            <summary>Marks object to be saved as indirect.</summary>
            <param name="document">a document the indirect reference will belong to.</param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfStream.MakeIndirect(iText.Kernel.Pdf.PdfDocument,iText.Kernel.Pdf.PdfIndirectReference)">
            <summary>Marks object to be saved as indirect.</summary>
            <param name="document">a document the indirect reference will belong to.</param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfStream.CopyTo(iText.Kernel.Pdf.PdfDocument)">
            <summary>Copies object to a specified document.</summary>
            <remarks>
            Copies object to a specified document.
            Works only for objects that are read from existing document, otherwise an exception is thrown.
            </remarks>
            <param name="document">document to copy object to.</param>
            <returns>copied object.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfStream.CopyTo(iText.Kernel.Pdf.PdfDocument,System.Boolean)">
            <summary>Copies object to a specified document.</summary>
            <remarks>
            Copies object to a specified document.
            Works only for objects that are read from existing document, otherwise an exception is thrown.
            </remarks>
            <param name="document">document to copy object to.</param>
            <param name="allowDuplicating">
            indicates if to allow copy objects which already have been copied.
            If object is associated with any indirect reference and allowDuplicating is false then already existing reference will be returned instead of copying object.
            If allowDuplicating is true then object will be copied and new indirect reference will be assigned.
            </param>
            <returns>copied object.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfStream.UpdateLength(System.Int32)">
            <summary>Update length manually in case its correction.</summary>
            <seealso cref="M:iText.Kernel.Pdf.PdfReader.CheckPdfStreamLength(iText.Kernel.Pdf.PdfStream)"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfStream.ReleaseContent">
            <summary>Release content of PdfStream.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfObjectStream.MAX_OBJ_STREAM_SIZE">
            <summary>Max number of objects in object stream.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfObjectStream.size">
            <summary>Current object stream size (number of objects inside).</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfObjectStream.indexStream">
            <summary>Stream containing object indices, a heading part of object stream.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfObjectStream.#ctor(iText.Kernel.Pdf.PdfObjectStream)">
            <summary>This constructor is for reusing ByteArrayOutputStreams of indexStream and outputStream.</summary>
            <remarks>
            This constructor is for reusing ByteArrayOutputStreams of indexStream and outputStream.
            NOTE Only for internal use in PdfWriter!
            </remarks>
            <param name="prev">previous PdfObjectStream.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfObjectStream.AddObject(iText.Kernel.Pdf.PdfObject)">
            <summary>Adds object to the object stream.</summary>
            <param name="object">object to add.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfObjectStream.GetSize">
            <summary>Gets object stream size (number of objects inside).</summary>
            <returns>object stream size.</returns>
        </member>
        <member name="T:iText.Kernel.Pdf.PdfOutline">
            <summary>
            Document outline object
            See ISO-320001, 12.3.3 Document Outline.
            </summary>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfOutline.FLAG_ITALIC">
            <summary>A flag for displaying the outline item’s text with italic font.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfOutline.FLAG_BOLD">
            <summary>A flag for displaying the outline item’s text with bold font.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfOutline.#ctor(System.String,iText.Kernel.Pdf.PdfDictionary,iText.Kernel.Pdf.PdfDocument)">
            <summary>Create instance of document outline.</summary>
            <param name="title">the text that shall be displayed on the screen for this item.</param>
            <param name="content">Outline dictionary</param>
            <param name="pdfDocument">
            
            <see cref="T:iText.Kernel.Pdf.PdfDocument"/>
            the outline belongs to.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfOutline.#ctor(System.String,iText.Kernel.Pdf.PdfDictionary,iText.Kernel.Pdf.PdfOutline)">
            <summary>Create instance of document outline.</summary>
            <param name="title">the text that shall be displayed on the screen for this item.</param>
            <param name="content">Outline dictionary</param>
            <param name="parent">parent outline.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfOutline.#ctor(iText.Kernel.Pdf.PdfDocument)">
            <summary>This constructor creates root outline in the document.</summary>
            <param name="doc">
            
            <see cref="T:iText.Kernel.Pdf.PdfDocument"/>
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfOutline.GetTitle">
            <summary>Gets title of the outline.</summary>
            <returns>String value.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfOutline.SetTitle(System.String)">
            <summary>
            Sets title of the outline with
            <see cref="F:iText.IO.Font.PdfEncodings.UNICODE_BIG"/>
            encoding,
            <c>Title</c>
            key.
            </summary>
            <param name="title">String value.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfOutline.SetColor(iText.Kernel.Colors.Color)">
            <summary>
            Sets color for the outline entry’s text,
            <c>C</c>
            key.
            </summary>
            <param name="color">
            
            <see cref="T:iText.Kernel.Colors.Color"/>
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfOutline.SetStyle(System.Int32)">
            <summary>
            Sets text style for the outline entry’s text,
            <c>F</c>
            key.
            </summary>
            <param name="style">
            Could be either
            <see cref="F:iText.Kernel.Pdf.PdfOutline.FLAG_BOLD"/>
            or
            <see cref="F:iText.Kernel.Pdf.PdfOutline.FLAG_ITALIC"/>
            . Default value is
            <c>0</c>
            .
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfOutline.GetContent">
            <summary>Gets content dictionary.</summary>
            <returns>
            
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfOutline.GetAllChildren">
            <summary>Gets list of children outlines.</summary>
            <returns>
            List of
            <see cref="T:iText.Kernel.Pdf.PdfOutline"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfOutline.GetParent">
            <summary>Gets parent outline.</summary>
            <returns>
            
            <see cref="T:iText.Kernel.Pdf.PdfOutline"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfOutline.GetDestination">
            <summary>
            Gets
            <see cref="T:iText.Kernel.Pdf.Navigation.PdfDestination"/>
            .
            </summary>
            <returns>
            
            <see cref="T:iText.Kernel.Pdf.Navigation.PdfDestination"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfOutline.AddDestination(iText.Kernel.Pdf.Navigation.PdfDestination)">
            <summary>
            Adds
            <see cref="T:iText.Kernel.Pdf.Navigation.PdfDestination"/>
            for the outline,
            <c>Dest</c>
            key.
            </summary>
            <param name="destination">
            instance of
            <see cref="T:iText.Kernel.Pdf.Navigation.PdfDestination"/>
            .
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfOutline.AddAction(iText.Kernel.Pdf.Action.PdfAction)">
            <summary>
            Adds
            <see cref="T:iText.Kernel.Pdf.Action.PdfAction"/>
            for the outline,
            <c>A</c>
            key.
            </summary>
            <param name="action">
            instance of
            <see cref="T:iText.Kernel.Pdf.Action.PdfAction"/>
            .
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfOutline.SetOpen(System.Boolean)">
            <summary>Defines if the outline needs to be closed or not.</summary>
            <remarks>
            Defines if the outline needs to be closed or not.
            By default, outlines are open.
            </remarks>
            <param name="open">if false, the outline will be closed by default</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfOutline.AddOutline(System.String,System.Int32)">
            <summary>
            Adds a new
            <c>PdfOutline</c>
            with specified parameters as a child to existing
            <c>PdfOutline</c>
            and put it to specified position in the existing
            <c>PdfOutline</c>
            children list.
            </summary>
            <param name="title">an outline title</param>
            <param name="position">
            a position in the current outline child List where a new outline should be added.
            If the position equals -1, then the outline will be put in the end of children list.
            </param>
            <returns>just created outline</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfOutline.AddOutline(System.String)">
            <summary>
            Adds an
            <c>PdfOutline</c>
            as a child to existing
            <c>PdfOutline</c>
            and put it in the end of the existing
            <c>PdfOutline</c>
            children list.
            </summary>
            <param name="title">an outline title</param>
            <returns>just created outline</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfOutline.AddOutline(iText.Kernel.Pdf.PdfOutline)">
            <summary>
            Adds an
            <c>PdfOutline</c>
            as a child to existing
            <c>PdfOutline</c>
            and put it to the end of the existing
            <c>PdfOutline</c>
            children list.
            </summary>
            <param name="outline">an outline to add.</param>
            <returns>just created outline</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfOutline.Clear">
            <summary>Clear list of children.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfOutline.SetDestination(iText.Kernel.Pdf.Navigation.PdfDestination)">
            <summary>
            Sets
            <see cref="T:iText.Kernel.Pdf.Navigation.PdfDestination"/>
            .
            </summary>
            <param name="destination">
            instance of
            <see cref="T:iText.Kernel.Pdf.Navigation.PdfDestination"/>
            .
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfOutline.RemoveOutline">
            <summary>Remove this outline from the document.</summary>
        </member>
        <member name="T:iText.Kernel.Pdf.PdfOutputIntent">
            <summary>
            Specify the colour characteristics of output devices on which the document might be rendered
            See ISO 32000-1 14.11.5: Output Intents.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfOutputIntent.#ctor(System.String,System.String,System.String,System.String,System.IO.Stream)">
            <summary>Creates output intent dictionary.</summary>
            <remarks>
            Creates output intent dictionary. Null values are allowed to
            suppress any key.
            By default output intent subtype is GTS_PDFA1, use setter to change it.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfOutputStream.document">
            <summary>Document associated with PdfOutputStream.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfOutputStream.crypto">
            <summary>Contains the business logic for cryptography.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfOutputStream.#ctor(System.IO.Stream)">
            <summary>Create a pdfOutputSteam writing to the passed OutputStream.</summary>
            <param name="outputStream">Outputstream to write to.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfOutputStream.Write(iText.Kernel.Pdf.PdfObject)">
            <summary>Write a PdfObject to the outputstream.</summary>
            <param name="pdfObject">PdfObject to write</param>
            <returns>this PdfOutPutStream</returns>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfPage.ignorePageRotationForContent">
            <summary>Automatically rotate new content if the page has a rotation ( is disabled by default )</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfPage.pageRotationInverseMatrixWritten">
            <summary>
            See
            <see cref="M:iText.Kernel.Pdf.PdfPage.IsPageRotationInverseMatrixWritten"/>
            .
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.GetPageSize">
            <summary>Gets page size, defined by media box object.</summary>
            <remarks>Gets page size, defined by media box object. This method doesn't take page rotation into account.
                </remarks>
            <returns>
            
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            that specify page size.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.GetPageSizeWithRotation">
            <summary>Gets page size, considering page rotation.</summary>
            <returns>
            
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            that specify size of rotated page.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.GetRotation">
            <summary>Gets the number of degrees by which the page shall be rotated clockwise when displayed or printed.
                </summary>
            <remarks>
            Gets the number of degrees by which the page shall be rotated clockwise when displayed or printed.
            Shall be a multiple of 90.
            </remarks>
            <returns>
            
            <c>int</c>
            number of degrees. Default value: 0
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.SetRotation(System.Int32)">
            <summary>Sets the page rotation.</summary>
            <param name="degAngle">
            the
            <c>int</c>
            number of degrees by which the page shall be rotated clockwise
            when displayed or printed. Shall be a multiple of 90.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.GetContentStream(System.Int32)">
            <summary>
            Gets the content stream at specified 0-based index in the Contents object
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            .
            The situation when Contents object is a
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            is treated like a one element array.
            </summary>
            <param name="index">
            the
            <c>int</c>
            index of returned
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            .
            </param>
            <returns>
            
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            object at specified index.
            </returns>
            <exception cref="T:System.IndexOutOfRangeException">if the index is out of range</exception>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.GetContentStreamCount">
            <summary>
            Gets the size of Contents object
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            .
            The situation when Contents object is a
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            is treated like a one element array.
            </summary>
            <returns>
            the
            <c>int</c>
            size of Contents object, or 1 if Contents object is a
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.GetFirstContentStream">
            <summary>
            Returns the Contents object if it is
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            , or first stream in the array if it is
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            .
            </summary>
            <returns>
            first
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            in Contents object, or
            <see langword="null"/>
            if Contents is empty.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.GetLastContentStream">
            <summary>
            Returns the Contents object if it is
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            , or last stream in the array if it is
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            .
            </summary>
            <returns>
            first
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            in Contents object, or
            <see langword="null"/>
            if Contents is empty.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.NewContentStreamBefore">
            <summary>
            Creates new
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            object and puts it at the beginning of Contents array
            (if Contents object is
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            it will be replaced with one-element array).
            </summary>
            <returns>
            Created
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            object.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.NewContentStreamAfter">
            <summary>
            Creates new
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            object and puts it at the end of Contents array
            (if Contents object is
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            it will be replaced with one-element array).
            </summary>
            <returns>
            Created
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            object.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.GetResources">
            <summary>
            Gets the
            <see cref="T:iText.Kernel.Pdf.PdfResources"/>
            wrapper object for this page resources.
            If page doesn't have resource object, then it will be inherited from page's parents.
            If neither parents nor page has the resource object, then the new one is created and added to page dictionary.
            <br/><br/>
            NOTE: If you'll try to modify the inherited resources, then the new resources object will be created,
            so you won't change the parent's resources.
            This new object under the wrapper will be added to page dictionary on
            <see cref="M:iText.Kernel.Pdf.PdfPage.Flush"/>
            ,
            or you can add it manually with this line, if needed:<br/>
            <c>getPdfObject().put(PdfName.Resources, getResources().getPdfObject());</c>
            </summary>
            <returns>
            
            <see cref="T:iText.Kernel.Pdf.PdfResources"/>
            wrapper of the page.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.SetResources(iText.Kernel.Pdf.PdfResources)">
            <summary>
            Sets
            <see cref="T:iText.Kernel.Pdf.PdfResources"/>
            object.
            </summary>
            <param name="pdfResources">
            
            <see cref="T:iText.Kernel.Pdf.PdfResources"/>
            to set.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.SetXmpMetadata(System.Byte[])">
            <summary>Sets the XMP Metadata.</summary>
            <param name="xmpMetadata">
            the
            <c>byte[]</c>
            of XMP Metadata to set.
            </param>
            <exception cref="T:System.IO.IOException">in case of writing error.</exception>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.SetXmpMetadata(iText.Kernel.XMP.XMPMeta,iText.Kernel.XMP.Options.SerializeOptions)">
            <summary>Serializes XMP Metadata to byte array and sets it.</summary>
            <param name="xmpMeta">
            the
            <see cref="T:iText.Kernel.XMP.XMPMeta"/>
            object to set.
            </param>
            <param name="serializeOptions">
            the
            <see cref="T:iText.Kernel.XMP.Options.SerializeOptions"/>
            used while serialization.
            </param>
            <exception cref="T:iText.Kernel.XMP.XMPException">in case of XMP Metadata serialization error.</exception>
            <exception cref="T:System.IO.IOException">in case of writing error.</exception>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.SetXmpMetadata(iText.Kernel.XMP.XMPMeta)">
            <summary>Serializes XMP Metadata to byte array and sets it.</summary>
            <remarks>Serializes XMP Metadata to byte array and sets it. Uses padding equals to 2000.</remarks>
            <param name="xmpMeta">
            the
            <see cref="T:iText.Kernel.XMP.XMPMeta"/>
            object to set.
            </param>
            <exception cref="T:iText.Kernel.XMP.XMPException">in case of XMP Metadata serialization error.</exception>
            <exception cref="T:System.IO.IOException">in case of writing error.</exception>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.GetXmpMetadata">
            <summary>Gets the XMP Metadata object.</summary>
            <returns>
            
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            object, that represent XMP Metadata.
            </returns>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.CopyTo(iText.Kernel.Pdf.PdfDocument)">
            <summary>Copies page to the specified document.</summary>
            <remarks>
            Copies page to the specified document.
            <br/><br/>
            NOTE: Works only for pages from the document opened in reading mode, otherwise an exception is thrown.
            </remarks>
            <param name="toDocument">a document to copy page to.</param>
            <returns>
            copied
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.CopyTo(iText.Kernel.Pdf.PdfDocument,iText.Kernel.Pdf.IPdfPageExtraCopier)">
            <summary>Copies page to the specified document.</summary>
            <remarks>
            Copies page to the specified document.
            <br/><br/>
            NOTE: Works only for pages from the document opened in reading mode, otherwise an exception is thrown.
            </remarks>
            <param name="toDocument">a document to copy page to.</param>
            <param name="copier">
            a copier which bears a special copy logic. May be null.
            It is recommended to use the same instance of
            <see cref="T:iText.Kernel.Pdf.IPdfPageExtraCopier"/>
            for the same output document.
            </param>
            <returns>
            copied
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.CopyAsFormXObject(iText.Kernel.Pdf.PdfDocument)">
            <summary>Copies page as FormXObject to the specified document.</summary>
            <param name="toDocument">a document to copy to.</param>
            <returns>
            copied
            <see cref="T:iText.Kernel.Pdf.Xobject.PdfFormXObject"/>
            object.
            </returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.GetDocument">
            <summary>
            Gets the
            <see cref="T:iText.Kernel.Pdf.PdfDocument"/>
            that owns that page, or
            <see langword="null"/>
            if such document isn't exist.
            </summary>
            <returns>
            
            <see cref="T:iText.Kernel.Pdf.PdfDocument"/>
            that owns that page, or
            <see langword="null"/>
            if such document isn't exist.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.Flush">
            <summary>Flushes page and it's content stream.</summary>
            <remarks>
            Flushes page and it's content stream.
            <br />
            <br />
            If the page belongs to the document which is tagged, page flushing also triggers flushing of the tags,
            which are considered to belong to the page. The logic that defines if the given tag (structure element) belongs
            to the page is the following: if all the marked content references (dictionary or number references), that are the
            descenders of the given structure element, belong to the current page - the tag is considered
            to belong to the page. If tag has descenders from several pages - it is flushed, if all other pages except the
            current one are flushed.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.Flush(System.Boolean)">
            <summary>Flushes page and its content stream.</summary>
            <remarks>
            Flushes page and its content stream. If <code>flushResourcesContentStreams</code> is true, all content streams that are
            rendered on this page (like FormXObjects, annotation appearance streams, patterns) and also all images associated
            with this page will also be flushed.
            <br/>
            For notes about tag structure flushing see
            <see cref="M:iText.Kernel.Pdf.PdfPage.Flush">PdfPage#flush() method</see>
            .
            <br/>
            <br/>
            If <code>PdfADocument</code> is used, flushing will be applied only if <code>flushResourcesContentStreams</code> is true.
            </remarks>
            <param name="flushResourcesContentStreams">
            if true all content streams that are rendered on this page (like form xObjects,
            annotation appearance streams, patterns) and also all images associated with this page
            will be flushed.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.GetMediaBox">
            <summary>
            Gets
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            object specified by page's Media Box, that defines the boundaries of the physical medium
            on which the page shall be displayed or printed
            </summary>
            <returns>
            
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            object specified by page Media Box, expressed in default user space units.
            </returns>
            <exception cref="T:iText.Kernel.PdfException">in case of any error while reading MediaBox object.</exception>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.SetMediaBox(iText.Kernel.Geom.Rectangle)">
            <summary>
            Sets the Media Box object, that defines the boundaries of the physical medium
            on which the page shall be displayed or printed.
            </summary>
            <param name="rectangle">
            the
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            object to set, expressed in default user space units.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.GetCropBox">
            <summary>
            Gets the
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            specified by page's CropBox, that defines the visible region of default user space.
            When the page is displayed or printed, its contents shall be clipped (cropped) to this rectangle
            and then shall be imposed on the output medium in some implementation-defined manner.
            </summary>
            <returns>
            the
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            object specified by pages's CropBox, expressed in default user space units.
            MediaBox by default.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.SetCropBox(iText.Kernel.Geom.Rectangle)">
            <summary>Sets the CropBox object, that defines the visible region of default user space.</summary>
            <remarks>
            Sets the CropBox object, that defines the visible region of default user space.
            When the page is displayed or printed, its contents shall be clipped (cropped) to this rectangle
            and then shall be imposed on the output medium in some implementation-defined manner.
            </remarks>
            <param name="rectangle">
            the
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            object to set, expressed in default user space units.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.SetBleedBox(iText.Kernel.Geom.Rectangle)">
            <summary>
            Sets the BleedBox object, that defines the region to which the contents of the page shall be clipped
            when output in a production environment.
            </summary>
            <param name="rectangle">
            the
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            object to set, expressed in default user space units.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.GetBleedBox">
            <summary>
            Gets the
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            object specified by page's BleedBox, that define the region to which the
            contents of the page shall be clipped when output in a production environment.
            </summary>
            <returns>
            the
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            object specified by page's BleedBox, expressed in default user space units.
            CropBox by default.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.SetArtBox(iText.Kernel.Geom.Rectangle)">
            <summary>
            Sets the ArtBox object, that define the extent of the page’s meaningful content
            (including potential white space) as intended by the page’s creator.
            </summary>
            <param name="rectangle">
            the
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            object to set, expressed in default user space units.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.GetArtBox">
            <summary>
            Gets the
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            object specified by page's ArtBox, that define the extent of the page’s
            meaningful content (including potential white space) as intended by the page’s creator.
            </summary>
            <returns>
            the
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            object specified by page's ArtBox, expressed in default user space units.
            CropBox by default.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.SetTrimBox(iText.Kernel.Geom.Rectangle)">
            <summary>Sets the TrimBox object, that define the intended dimensions of the finished page after trimming.
                </summary>
            <param name="rectangle">
            the
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            object to set, expressed in default user space units.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.GetTrimBox">
            <summary>
            Gets the
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            object specified by page's TrimBox object,
            that define the intended dimensions of the finished page after trimming.
            </summary>
            <returns>
            the
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            object specified by page's TrimBox, expressed in default user space units.
            CropBox by default.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.GetContentBytes">
            <summary>Get decoded bytes for the whole page content.</summary>
            <returns>byte array.</returns>
            <exception cref="T:iText.Kernel.PdfException">
            in case of any
            <see cref="T:System.IO.IOException"/>
            .
            </exception>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.GetStreamBytes(System.Int32)">
            <summary>Gets decoded bytes of a certain stream of a page content.</summary>
            <param name="index">index of stream inside Content.</param>
            <returns>byte array.</returns>
            <exception cref="T:iText.Kernel.PdfException">
            in case of any
            <see cref="T:System.IO.IOException"/>
            .
            </exception>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.GetNextMcid">
            <summary>Calculates and returns next available MCID reference.</summary>
            <returns>calculated MCID reference.</returns>
            <exception cref="T:iText.Kernel.PdfException">in case of not tagged document.</exception>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.GetStructParentIndex">
            <summary>
            Gets
            <see cref="!:int?"/>
            key of the page’s entry in the structural parent tree.
            </summary>
            <returns>
            
            <see cref="!:int?"/>
            key of the page’s entry in the structural parent tree.
            If page has no entry in the structural parent tree, returned value is -1.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.SetAdditionalAction(iText.Kernel.Pdf.PdfName,iText.Kernel.Pdf.Action.PdfAction)">
            <summary>Helper method to add an additional action to this page.</summary>
            <remarks>
            Helper method to add an additional action to this page.
            May be used in chain.
            </remarks>
            <param name="key">
            a
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            specifying the name of an additional action
            </param>
            <param name="action">
            the
            <see cref="T:iText.Kernel.Pdf.Action.PdfAction"/>
            to add as an additional action
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.GetAnnotations">
            <summary>
            Gets array of annotation dictionaries that shall contain indirect references
            to all annotations associated with the page.
            </summary>
            <returns>
            the
            <see cref="!:System.Collections.IList&lt;E&gt;"/>
            &lt;
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            &gt; containing all page's annotations.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.ContainsAnnotation(iText.Kernel.Pdf.Annot.PdfAnnotation)">
            <summary>Checks if page contains the specified annotation.</summary>
            <param name="annotation">
            the
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            to check.
            </param>
            <returns>
            
            <see langword="true"/>
            if page contains specified annotation and
            <see langword="false"/>
            otherwise.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.AddAnnotation(iText.Kernel.Pdf.Annot.PdfAnnotation)">
            <summary>Adds specified annotation to the end of annotations array and tagged it.</summary>
            <remarks>
            Adds specified annotation to the end of annotations array and tagged it.
            May be used in chain.
            </remarks>
            <param name="annotation">
            the
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            to add.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.AddAnnotation(System.Int32,iText.Kernel.Pdf.Annot.PdfAnnotation,System.Boolean)">
            <summary>
            Adds specified
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            to specified index in annotations array with or without autotagging.
            May be used in chain.
            </summary>
            <param name="index">
            the index at which specified annotation will be added. If
            <c>-1</c>
            then annotation will be added
            to the end of array.
            </param>
            <param name="annotation">
            the
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            to add.
            </param>
            <param name="tagAnnotation">
            if
            <see langword="true"/>
            the added annotation will be autotagged. <br/>
            (see
            <see cref="M:iText.Kernel.Pdf.Tagutils.TagStructureContext.GetAutoTaggingPointer"/>
            )
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.RemoveAnnotation(iText.Kernel.Pdf.Annot.PdfAnnotation)">
            <summary>Removes an annotation from the page.</summary>
            <remarks>
            Removes an annotation from the page.
            <br/><br/>
            NOTE: If document is tagged, PdfDocument's PdfTagStructure instance will point at annotation tag parent after method call.
            </remarks>
            <param name="annotation">an annotation to be removed.</param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.GetAnnotsSize">
            <summary>
            Gets the number of
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            associated with this page.
            </summary>
            <returns>
            the
            <c>int</c>
            number of
            <see cref="T:iText.Kernel.Pdf.Annot.PdfAnnotation"/>
            associated with this page.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.GetOutlines(System.Boolean)">
            <summary>This method gets outlines of a current page</summary>
            <param name="updateOutlines"/>
            <returns>return all outlines of a current page</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.IsIgnorePageRotationForContent">
            <returns>
            true - if in case the page has a rotation, then new content will be automatically rotated in the
            opposite direction. On the rotated page this would look like if new content ignores page rotation.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.SetPageLabel(iText.Kernel.Pdf.PageLabelNumberingStyleConstants,System.String)">
            <summary>This method adds or replaces a page label.</summary>
            <param name="numberingStyle">
            The numbering style that shall be used for the numeric portion of each page label.
            May be NULL
            </param>
            <param name="labelPrefix">The label prefix for page labels in this range. May be NULL</param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.SetPageLabel(iText.Kernel.Pdf.PageLabelNumberingStyleConstants,System.String,System.Int32)">
            <summary>This method adds or replaces a page label.</summary>
            <param name="numberingStyle">
            The numbering style that shall be used for the numeric portion of each page label.
            May be NULL
            </param>
            <param name="labelPrefix">The label prefix for page labels in this range. May be NULL</param>
            <param name="firstPage">
            The value of the numeric portion for the first page label in the range. Must be greater or
            equal 1.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.SetIgnorePageRotationForContent(System.Boolean)">
            <summary>
            If true - defines that in case the page has a rotation, then new content will be automatically rotated in the
            opposite direction.
            </summary>
            <remarks>
            If true - defines that in case the page has a rotation, then new content will be automatically rotated in the
            opposite direction. On the rotated page this would look like if new content ignores page rotation.
            Default value -
            <see langword="false"/>
            .
            </remarks>
            <param name="ignorePageRotationForContent">- true to ignore rotation of the new content on the rotated page.
                </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.SetPageLabel(System.Nullable{iText.Kernel.Pdf.PageLabelNumberingStyleConstants},System.String)">
            <summary>This method adds or replaces a page label.</summary>
            <param name="numberingStyle">
            The numbering style that shall be used for the numeric portion of each page label.
            May be NULL
            </param>
            <param name="labelPrefix">The label prefix for page labels in this range. May be NULL</param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.SetPageLabel(System.Nullable{iText.Kernel.Pdf.PageLabelNumberingStyleConstants},System.String,System.Int32)">
            <summary>This method adds or replaces a page label.</summary>
            <param name="numberingStyle">
            The numbering style that shall be used for the numeric portion of each page label.
            May be NULL
            </param>
            <param name="labelPrefix">The label prefix for page labels in this range. May be NULL</param>
            <param name="firstPage">
            The value of the numeric portion for the first page label in the range. Must be greater or
            equal 1.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.SetTabOrder(iText.Kernel.Pdf.PdfName)">
            <summary>Sets a name specifying the tab order that shall be used for annotations on the page.</summary>
            <remarks>
            Sets a name specifying the tab order that shall be used for annotations on the page.
            The possible values are
            <see cref="F:iText.Kernel.Pdf.PdfName.R"/>
            (row order),
            <see cref="F:iText.Kernel.Pdf.PdfName.C"/>
            (column order), and
            <see cref="F:iText.Kernel.Pdf.PdfName.S"/>
            (structure order).
            See ISO 32000 12.5, "Annotations" for details.
            </remarks>
            <param name="tabOrder">
            a
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            specifying the annotations tab order. See method description for the allowed values.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.GetTabOrder">
            <summary>Gets a name specifying the tab order that shall be used for annotations on the page.</summary>
            <remarks>
            Gets a name specifying the tab order that shall be used for annotations on the page.
            The possible values are
            <see cref="F:iText.Kernel.Pdf.PdfName.R"/>
            (row order),
            <see cref="F:iText.Kernel.Pdf.PdfName.C"/>
            (column order), and
            <see cref="F:iText.Kernel.Pdf.PdfName.S"/>
            (structure order).
            See ISO 32000 12.5, "Annotations" for details.
            </remarks>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            specifying the annotations tab order or null if tab order is not defined.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.Put(iText.Kernel.Pdf.PdfName,iText.Kernel.Pdf.PdfObject)">
            <summary>
            Helper method that associate specified value with specified key in the underlined
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            .
            May be used in chain.
            </summary>
            <param name="key">
            the
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            key with which the specified value is to be associated.
            </param>
            <param name="value">
            the
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            value to be associated with the specified key.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            object.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.IsPageRotationInverseMatrixWritten">
            <summary>
            This flag is meaningful for the case, when page rotation is applied and ignorePageRotationForContent
            is set to true.
            </summary>
            <remarks>
            This flag is meaningful for the case, when page rotation is applied and ignorePageRotationForContent
            is set to true. NOTE: It is needed for the internal usage.
            <br/><br/>
            This flag defines if inverse matrix (which rotates content into the opposite direction from page rotation
            direction in order to give the impression of the not rotated text) is already applied to the page content stream.
            See
            <see cref="M:iText.Kernel.Pdf.PdfPage.SetIgnorePageRotationForContent(System.Boolean)"/>
            </remarks>
            <returns>true, if inverse matrix is already applied, false otherwise.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPage.SetPageRotationInverseMatrixWritten">
            <summary>NOTE: For internal usage! Use this method only if you know what you are doing.</summary>
            <remarks>
            NOTE: For internal usage! Use this method only if you know what you are doing.
            <br/><br/>
            This method is called when inverse matrix (which rotates content into the opposite direction from page rotation
            direction in order to give the impression of the not rotated text) is applied to the page content stream.
            See
            <see cref="M:iText.Kernel.Pdf.PdfPage.SetIgnorePageRotationForContent(System.Boolean)"/>
            </remarks>
        </member>
        <member name="T:iText.Kernel.Pdf.PdfPagesTree">
            <summary>
            Algorithm for construction
            <see cref="T:iText.Kernel.Pdf.PdfPages"/>
            tree
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPagesTree.#ctor(iText.Kernel.Pdf.PdfCatalog)">
            <summary>Create PdfPages tree.</summary>
            <param name="pdfCatalog">
            
            <seealso>PdfCatalog</seealso>
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPagesTree.GetPage(System.Int32)">
            <summary>
            Returns the
            <seealso>PdfPage</seealso>
            at the specified position in this list.
            </summary>
            <param name="pageNum">one-based index of the element to return</param>
            <returns>
            the
            <seealso>PdfPage</seealso>
            at the specified position in this list
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPagesTree.GetPage(iText.Kernel.Pdf.PdfDictionary)">
            <summary>
            Returns the
            <seealso>PdfPage</seealso>
            by page's PdfDictionary.
            </summary>
            <param name="pageDictionary">page's PdfDictionary</param>
            <returns>
            the
            <c>PdfPage</c>
            object, that wraps
            <paramref name="pageDictionary"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPagesTree.GetNumberOfPages">
            <summary>Gets total number of @see PdfPages.</summary>
            <returns>total number of pages</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPagesTree.GetPageNumber(iText.Kernel.Pdf.PdfPage)">
            <summary>
            Returns the index of the first occurrence of the specified page
            in this tree, or 0 if this tree does not contain the page.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPagesTree.GetPageNumber(iText.Kernel.Pdf.PdfDictionary)">
            <summary>
            Returns the index of the first occurrence of the page in this tree
            specified by it's PdfDictionary, or 0 if this tree does not contain the page.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPagesTree.AddPage(iText.Kernel.Pdf.PdfPage)">
            <summary>
            Appends the specified
            <seealso>PdfPage</seealso>
            to the end of this tree.
            </summary>
            <param name="pdfPage">
            
            <seealso>PdfPage</seealso>
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPagesTree.AddPage(System.Int32,iText.Kernel.Pdf.PdfPage)">
            <summary>
            Insert
            <seealso>PdfPage</seealso>
            into specific one-based position.
            </summary>
            <param name="index">one-base index of the page</param>
            <param name="pdfPage">
            
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            to insert.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPagesTree.RemovePage(System.Int32)">
            <summary>Removes the page at the specified position in this tree.</summary>
            <remarks>
            Removes the page at the specified position in this tree.
            Shifts any subsequent elements to the left (subtracts one from their
            indices).
            </remarks>
            <param name="pageNum">the one-based index of the PdfPage to be removed</param>
            <returns>the page that was removed from the list</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfPagesTree.GenerateTree">
            <summary>Generate PdfPages tree.</summary>
            <returns>
            root
            <see cref="T:iText.Kernel.Pdf.PdfPages"/>
            </returns>
            <exception cref="T:iText.Kernel.PdfException">in case empty document</exception>
        </member>
        <member name="T:iText.Kernel.Pdf.PdfReader">
            <summary>Reads a PDF document.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.#ctor(iText.IO.Source.IRandomAccessSource,iText.Kernel.Pdf.ReaderProperties)">
            <summary>Constructs a new PdfReader.</summary>
            <param name="byteSource">source of bytes for the reader</param>
            <param name="properties">properties of the created reader</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.#ctor(System.IO.Stream,iText.Kernel.Pdf.ReaderProperties)">
            <summary>Reads and parses a PDF document.</summary>
            <param name="is">
            the
            <c>InputStream</c>
            containing the document. The stream is read to the
            end but is not closed.
            </param>
            <param name="properties">properties of the created reader</param>
            <exception cref="T:System.IO.IOException">on error</exception>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.#ctor(System.IO.FileInfo)">
            <summary>Reads and parses a PDF document.</summary>
            <param name="file">
            the
            <c>File</c>
            containing the document.
            </param>
            <exception cref="T:System.IO.IOException">on error</exception>
            <exception cref="T:System.IO.FileNotFoundException">when the specified File is not found</exception>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.#ctor(System.IO.Stream)">
            <summary>Reads and parses a PDF document.</summary>
            <param name="is">
            the
            <c>InputStream</c>
            containing the document. the
            <c>InputStream</c>
            containing the document. The stream is read to the
            end but is not closed.
            </param>
            <exception cref="T:System.IO.IOException">on error</exception>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.#ctor(System.String,iText.Kernel.Pdf.ReaderProperties)">
            <summary>Reads and parses a PDF document.</summary>
            <param name="filename">the file name of the document</param>
            <param name="properties">properties of the created reader</param>
            <exception cref="T:System.IO.IOException">on error</exception>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.#ctor(System.String)">
            <summary>Reads and parses a PDF document.</summary>
            <param name="filename">the file name of the document</param>
            <exception cref="T:System.IO.IOException">on error</exception>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.Close">
            <summary>
            Close
            <see cref="T:iText.IO.Source.PdfTokenizer"/>
            .
            </summary>
            <exception cref="T:System.IO.IOException">on error.</exception>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.SetUnethicalReading(System.Boolean)">
            <summary>
            The iText is not responsible if you decide to change the
            value of this parameter.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.IsCloseStream">
            <summary>
            Gets whether
            <see cref="M:iText.Kernel.Pdf.PdfReader.Close"/>
            method shall close input stream.
            </summary>
            <returns>
            true, if
            <see cref="M:iText.Kernel.Pdf.PdfReader.Close"/>
            method will close input stream,
            otherwise false.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.SetCloseStream(System.Boolean)">
            <summary>
            Sets whether
            <see cref="M:iText.Kernel.Pdf.PdfReader.Close"/>
            method shall close input stream.
            </summary>
            <param name="closeStream">
            true, if
            <see cref="M:iText.Kernel.Pdf.PdfReader.Close"/>
            method shall close input stream,
            otherwise false.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.HasRebuiltXref">
            <summary>If any exception generated while reading XRef section, PdfReader will try to rebuild it.</summary>
            <returns>true, if PdfReader rebuilt Cross-Reference section.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.HasHybridXref">
            <summary>
            Some documents contain hybrid XRef, for more information see "7.5.8.4 Compatibility with Applications
            That Do Not Support Compressed Reference Streams" in PDF 32000-1:2008 spec.
            </summary>
            <returns>true, if the document has hybrid Cross-Reference section.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.HasXrefStm">
            <summary>Indicates whether the document has Cross-Reference Streams.</summary>
            <returns>true, if the document has Cross-Reference Streams.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.HasFixedXref">
            <summary>If any exception generated while reading PdfObject, PdfReader will try to fix offsets of all objects.
                </summary>
            <returns>true, if PdfReader fixed offsets of PdfObjects.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.GetLastXref">
            <summary>Gets position of the last Cross-Reference table.</summary>
            <returns>-1 if Cross-Reference table has rebuilt, otherwise position of the last Cross-Reference table.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.ReadStreamBytes(iText.Kernel.Pdf.PdfStream,System.Boolean)">
            <summary>Reads, decrypt and optionally decode stream bytes.</summary>
            <remarks>
            Reads, decrypt and optionally decode stream bytes.
            Note, this method doesn't store actual bytes in any internal structures.
            </remarks>
            <param name="decode">true if to get decoded stream bytes, false if to leave it originally encoded.</param>
            <returns>byte[] array.</returns>
            <exception cref="T:System.IO.IOException">on error.</exception>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.ReadStreamBytesRaw(iText.Kernel.Pdf.PdfStream)">
            <summary>Reads and decrypt stream bytes.</summary>
            <remarks>
            Reads and decrypt stream bytes.
            Note, this method doesn't store actual bytes in any internal structures.
            </remarks>
            <returns>byte[] array.</returns>
            <exception cref="T:System.IO.IOException">on error.</exception>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.ReadStream(iText.Kernel.Pdf.PdfStream,System.Boolean)">
            <summary>
            Reads, decrypt and optionally decode stream bytes into
            <see cref="T:System.IO.MemoryStream"/>
            .
            User is responsible for closing returned stream.
            </summary>
            <param name="decode">true if to get decoded stream, false if to leave it originally encoded.</param>
            <returns>
            InputStream or
            <see langword="null"/>
            if reading was failed.
            </returns>
            <exception cref="T:System.IO.IOException">on error.</exception>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.DecodeBytes(System.Byte[],iText.Kernel.Pdf.PdfDictionary)">
            <summary>Decode bytes applying the filters specified in the provided dictionary using default filter handlers.
                </summary>
            <param name="b">the bytes to decode</param>
            <param name="streamDictionary">the dictionary that contains filter information</param>
            <returns>the decoded bytes</returns>
            <exception cref="T:iText.Kernel.PdfException">if there are any problems decoding the bytes</exception>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.DecodeBytes(System.Byte[],iText.Kernel.Pdf.PdfDictionary,System.Collections.Generic.IDictionary{iText.Kernel.Pdf.PdfName,iText.Kernel.Pdf.Filters.IFilterHandler})">
            <summary>Decode a byte[] applying the filters specified in the provided dictionary using the provided filter handlers.
                </summary>
            <param name="b">the bytes to decode</param>
            <param name="streamDictionary">the dictionary that contains filter information</param>
            <param name="filterHandlers">the map used to look up a handler for each type of filter</param>
            <returns>the decoded bytes</returns>
            <exception cref="T:iText.Kernel.PdfException">if there are any problems decoding the bytes</exception>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.GetSafeFile">
            <summary>
            Gets a new file instance of the original PDF
            document.
            </summary>
            <returns>a new file instance of the original PDF document</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.GetFileLength">
            <summary>Provides the size of the opened file.</summary>
            <returns>The size of the opened file.</returns>
            <exception cref="T:System.IO.IOException">on error.</exception>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.IsOpenedWithFullPermission">
            <summary>
            Checks if the document was opened with the owner password so that the end application
            can decide what level of access restrictions to apply.
            </summary>
            <remarks>
            Checks if the document was opened with the owner password so that the end application
            can decide what level of access restrictions to apply. If the document is not encrypted
            it will return
            <see langword="true"/>
            .
            </remarks>
            <returns>
            
            <see langword="true"/>
            if the document was opened with the owner password or if it's not encrypted,
            <see langword="false"/>
            if the document was opened with the user password.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.GetPermissions">
            <summary>Gets the encryption permissions.</summary>
            <remarks>
            Gets the encryption permissions. It can be used directly in
            <see cref="M:iText.Kernel.Pdf.WriterProperties.SetStandardEncryption(System.Byte[],System.Byte[],System.Int32,System.Int32)"/>
            .
            See ISO 32000-1, Table 22 for more details.
            </remarks>
            <returns>the encryption permissions, an unsigned 32-bit quantity.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.GetCryptoMode">
            <summary>Gets encryption algorithm and access permissions.</summary>
            <seealso cref="T:iText.Kernel.Pdf.EncryptionConstants"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.GetPdfAConformanceLevel">
            <summary>Gets the declared Pdf/A conformance level of the source document that is being read.</summary>
            <remarks>
            Gets the declared Pdf/A conformance level of the source document that is being read.
            Note that this information is provided via XMP metadata and is not verified by iText.
            </remarks>
            <returns>
            conformance level of the source document, or
            <see langword="null"/>
            if no Pdf/A
            conformance level information is specified.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.ComputeUserPassword">
            <summary>Computes user password if standard encryption handler is used with Standard40, Standard128 or AES128 encryption algorithm.
                </summary>
            <returns>user password, or null if not a standard encryption handler was used or if ownerPasswordUsed wasn't use to open the document.
                </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.GetOriginalFileId">
            <summary>
            Gets file ID, either
            <see cref="F:iText.Kernel.Pdf.PdfName.ID"/>
            key of trailer or a newly generated id.
            </summary>
            <returns>byte array represents file ID.</returns>
            <seealso cref="M:iText.Kernel.Pdf.PdfEncryption.GenerateNewDocumentId"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.ReadPdf">
            <summary>Parses the entire PDF</summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.ReadObjectStream(iText.Kernel.Pdf.PdfStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.ReadObject(System.Boolean)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.ReadObject(System.Boolean,System.Boolean)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.ReadDictionary(System.Boolean)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.ReadArray(System.Boolean)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.ReadXref">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.ReadXrefSection">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.ReadXrefStream(System.Int64)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.FixXref">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.RebuildXref">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.GetOffsetTokeniser(iText.IO.Source.IRandomAccessSource)">
            <summary>Utility method that checks the provided byte source to see if it has junk bytes at the beginning.
                </summary>
            <remarks>
            Utility method that checks the provided byte source to see if it has junk bytes at the beginning.  If junk bytes
            are found, construct a tokeniser that ignores the junk.  Otherwise, construct a tokeniser for the byte source as it is
            </remarks>
            <param name="byteSource">the source to check</param>
            <returns>a tokeniser that is guaranteed to start at the PDF header</returns>
            <exception cref="T:System.IO.IOException">if there is a problem reading the byte source</exception>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.CheckPdfStreamLength(iText.Kernel.Pdf.PdfStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfReader.ReusableRandomAccessSource.Close">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.Kernel.Pdf.PdfResources">
            <summary>
            Wrapper class that represent resource dictionary - that define named resources
            used by content streams operators.
            </summary>
            <remarks>
            Wrapper class that represent resource dictionary - that define named resources
            used by content streams operators. (ISO 32000-1, 7.8.3 Resource Dictionaries)
            </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.#ctor(iText.Kernel.Pdf.PdfDictionary)">
            <summary>Creates new instance from given dictionary.</summary>
            <param name="pdfObject">
            the
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            object from which the resource object will be created.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.#ctor">
            <summary>Creates new instance from empty dictionary.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.AddFont(iText.Kernel.Pdf.PdfDocument,iText.Kernel.Font.PdfFont)">
            <summary>Adds font to resources and register PdfFont in the document for further flushing.</summary>
            <returns>added font resource name.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.AddImage(iText.Kernel.Pdf.Xobject.PdfImageXObject)">
            <summary>
            Adds
            <see cref="T:iText.Kernel.Pdf.Xobject.PdfImageXObject"/>
            object to the resources.
            </summary>
            <param name="image">
            the
            <see cref="T:iText.Kernel.Pdf.Xobject.PdfImageXObject"/>
            to add.
            </param>
            <returns>added image resource name.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.AddImage(iText.Kernel.Pdf.PdfStream)">
            <summary>
            Adds
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            to the resources as image.
            </summary>
            <param name="image">
            the
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            to add.
            </param>
            <returns>added image resources name.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.AddImage(iText.Kernel.Pdf.PdfObject)">
            <summary>
            Adds
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            to the resources as image.
            </summary>
            <param name="image">
            the
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            to add. Should be
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            .
            </param>
            <returns>added image resources name.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.AddForm(iText.Kernel.Pdf.Xobject.PdfFormXObject)">
            <summary>
            Adds
            <see cref="T:iText.Kernel.Pdf.Xobject.PdfFormXObject"/>
            object to the resources.
            </summary>
            <param name="form">
            the
            <see cref="T:iText.Kernel.Pdf.Xobject.PdfFormXObject"/>
            to add.
            </param>
            <returns>added form resource name.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.AddForm(iText.Kernel.Pdf.PdfStream)">
            <summary>
            Adds
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            to the resources as form.
            </summary>
            <param name="form">
            the
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            to add.
            </param>
            <returns>added form resources name.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.AddForm(iText.Kernel.Pdf.PdfObject)">
            <summary>
            Adds
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            to the resources as form.
            </summary>
            <param name="form">
            the
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            to add. Should be
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            .
            </param>
            <returns>added form resources name.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.AddForm(iText.Kernel.Pdf.Xobject.PdfFormXObject,iText.Kernel.Pdf.PdfName)">
            <summary>
            Adds the given Form XObject to the current instance of
            <see cref="T:iText.Kernel.Pdf.PdfResources"/>
            .
            </summary>
            <param name="form">Form XObject.</param>
            <param name="name">Preferred name for the given Form XObject.</param>
            <returns>
            the
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            of the newly added resource
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.AddExtGState(iText.Kernel.Pdf.Extgstate.PdfExtGState)">
            <summary>
            Adds
            <see cref="T:iText.Kernel.Pdf.Extgstate.PdfExtGState"/>
            object to the resources.
            </summary>
            <param name="extGState">
            the
            <see cref="T:iText.Kernel.Pdf.Extgstate.PdfExtGState"/>
            to add.
            </param>
            <returns>added graphics state parameter dictionary resource name.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.AddExtGState(iText.Kernel.Pdf.PdfDictionary)">
            <summary>
            Adds
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            to the resources as graphics state parameter dictionary.
            </summary>
            <param name="extGState">
            the
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            to add.
            </param>
            <returns>added graphics state parameter dictionary resources name.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.AddExtGState(iText.Kernel.Pdf.PdfObject)">
            <summary>
            Adds
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            to the resources as graphics state parameter dictionary.
            </summary>
            <param name="extGState">
            the
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            to add. Should be
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            .
            </param>
            <returns>added graphics state parameter dictionary resources name.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.AddProperties(iText.Kernel.Pdf.PdfDictionary)">
            <summary>
            Adds
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            to the resources as properties list.
            </summary>
            <param name="properties">
            the
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            to add.
            </param>
            <returns>added properties list resources name.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.AddProperties(iText.Kernel.Pdf.PdfObject)">
            <summary>
            Adds
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            to the resources as properties list.
            </summary>
            <param name="properties">
            the
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            to add. Should be
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            .
            </param>
            <returns>added properties list resources name.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.AddColorSpace(iText.Kernel.Pdf.Colorspace.PdfColorSpace)">
            <summary>
            Adds
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfColorSpace"/>
            object to the resources.
            </summary>
            <param name="cs">
            the
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfColorSpace"/>
            to add.
            </param>
            <returns>added color space resource name.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.AddColorSpace(iText.Kernel.Pdf.PdfObject)">
            <summary>
            Adds
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            to the resources as color space.
            </summary>
            <param name="colorSpace">
            the
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            to add.
            </param>
            <returns>added color space resources name.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.AddPattern(iText.Kernel.Pdf.Colorspace.PdfPattern)">
            <summary>
            Adds
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfPattern"/>
            object to the resources.
            </summary>
            <param name="pattern">
            the
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfPattern"/>
            to add.
            </param>
            <returns>added pattern resource name.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.AddPattern(iText.Kernel.Pdf.PdfDictionary)">
            <summary>
            Adds
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            to the resources as pattern.
            </summary>
            <param name="pattern">
            the
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            to add.
            </param>
            <returns>added pattern resources name.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.AddPattern(iText.Kernel.Pdf.PdfObject)">
            <summary>
            Adds
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            to the resources as pattern.
            </summary>
            <param name="pattern">
            the
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            to add. Should be
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            or
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            .
            </param>
            <returns>added pattern resources name.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.AddShading(iText.Kernel.Pdf.Colorspace.PdfShading)">
            <summary>
            Adds
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfShading"/>
            object to the resources.
            </summary>
            <param name="shading">
            the
            <see cref="T:iText.Kernel.Pdf.Colorspace.PdfShading"/>
            to add.
            </param>
            <returns>added shading resource name.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.AddShading(iText.Kernel.Pdf.PdfDictionary)">
            <summary>
            Adds
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            to the resources as shading dictionary.
            </summary>
            <param name="shading">
            the
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            to add.
            </param>
            <returns>added shading dictionary resources name.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.AddShading(iText.Kernel.Pdf.PdfObject)">
            <summary>
            Adds
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            to the resources as shading dictionary.
            </summary>
            <param name="shading">
            the
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            to add. Should be
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            or
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            .
            </param>
            <returns>added shading dictionary resources name.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.SetDefaultColorSpace(iText.Kernel.Pdf.PdfName,iText.Kernel.Pdf.Colorspace.PdfColorSpace)">
            <summary>Sets the default color space (see ISO-320001 Paragraph 8.6.5.6).</summary>
            <param name="defaultCsKey">
            the name of Default Color Space. Should be
            <see cref="F:iText.Kernel.Pdf.PdfName.DefaultGray"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.DefaultRGB"/>
            , or
            <see cref="F:iText.Kernel.Pdf.PdfName.DefaultCMYK"/>
            .
            </param>
            <param name="defaultCsValue">the value of the default color space to be set.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.SetDefaultGray(iText.Kernel.Pdf.Colorspace.PdfColorSpace)">
            <summary>Sets the value of default Gray Color Space (see ISO-320001 Paragraph 8.6.5.6).</summary>
            <param name="defaultCs">the color space to set.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.SetDefaultRgb(iText.Kernel.Pdf.Colorspace.PdfColorSpace)">
            <summary>Sets the value of default RGB Color Space (see ISO-320001 Paragraph 8.6.5.6).</summary>
            <param name="defaultCs">the color space to set.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.SetDefaultCmyk(iText.Kernel.Pdf.Colorspace.PdfColorSpace)">
            <summary>Sets the value of default CMYK Color Space (see ISO-320001 Paragraph 8.6.5.6).</summary>
            <param name="defaultCs">the color space to set.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Pdf.PdfResources.GetResourceName``1(iText.Kernel.Pdf.PdfObjectWrapper{``0})" -->
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Pdf.PdfResources.GetResourceName(iText.Kernel.Pdf.PdfObject)" -->
        <member name="M:iText.Kernel.Pdf.PdfResources.GetResourceNames">
            <summary>Gets the names of all the added resources.</summary>
            <returns>the name of all the added resources.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.GetProcSet">
            <summary>Gets the array of predefined procedure set names (see ISO-320001 Paragraph 14.2).</summary>
            <returns>the array of predefined procedure set names.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.SetProcSet(iText.Kernel.Pdf.PdfArray)">
            <summary>Sets the array of predefined procedure set names (see ISO-320001 Paragraph 14.2).</summary>
            <param name="array">the array of predefined procedure set names to be set.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.GetResourceNames(iText.Kernel.Pdf.PdfName)">
            <summary>Gets the names of all resources of specified type.</summary>
            <param name="resType">
            the resource type. Should be
            <see cref="F:iText.Kernel.Pdf.PdfName.ColorSpace"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.ExtGState"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.Pattern"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.Shading"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.XObject"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.Font"/>
            .
            </param>
            <returns>
            set of resources name of corresponding type. May be empty.
            Will be empty in case of incorrect resource type.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.GetResource(iText.Kernel.Pdf.PdfName)">
            <summary>
            Get the
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            object that that contain resources of specified type.
            </summary>
            <param name="resType">
            the resource type. Should be
            <see cref="F:iText.Kernel.Pdf.PdfName.ColorSpace"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.ExtGState"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.Pattern"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.Shading"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.XObject"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.Font"/>
            .
            </param>
            <returns>
            the
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            object containing all resources of specified type,
            or
            <see langword="null"/>
            in case of incorrect resource type.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.GetResourceObject(iText.Kernel.Pdf.PdfName,iText.Kernel.Pdf.PdfName)">
            <summary>
            Get the
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            object with specified type and name.
            </summary>
            <param name="resType">
            the resource type. Should be
            <see cref="F:iText.Kernel.Pdf.PdfName.ColorSpace"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.ExtGState"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.Pattern"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.Shading"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.XObject"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.Font"/>
            .
            </param>
            <param name="resName">the name of the resource object.</param>
            <returns>
            the
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            with specified name in the resources of specified type or
            <see langword="null"/>
            in case of incorrect type or missing resource with such name.
            </returns>
        </member>
        <member name="T:iText.Kernel.Pdf.PdfResources.ResourceNameGenerator">
            <summary>Represents a resource name generator.</summary>
            <remarks>
            Represents a resource name generator. The generator takes into account
            the names of already existing resources thus providing us a unique name.
            The name consists of the following parts: prefix (literal) and number.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.ResourceNameGenerator.#ctor(iText.Kernel.Pdf.PdfName,System.String,System.Int32)">
            <summary>
            Constructs an instance of
            <see cref="T:iText.Kernel.Pdf.PdfResources.ResourceNameGenerator"/>
            class.
            </summary>
            <param name="resourceType">
            Type of resource. Should be
            <see cref="F:iText.Kernel.Pdf.PdfName.ColorSpace"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.ExtGState"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.Pattern"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.Shading"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.XObject"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.Font"/>
            .
            </param>
            <param name="prefix">Prefix used for generating names.</param>
            <param name="seed">
            Seed for the value which is appended to the number each time
            new name is generated.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.ResourceNameGenerator.#ctor(iText.Kernel.Pdf.PdfName,System.String)">
            <summary>
            Constructs an instance of
            <see cref="T:iText.Kernel.Pdf.PdfResources.ResourceNameGenerator"/>
            class.
            </summary>
            <param name="resourceType">
            Type of resource. Should be
            <see cref="F:iText.Kernel.Pdf.PdfName.ColorSpace"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.ExtGState"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.Pattern"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.Shading"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.XObject"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.Font"/>
            .
            </param>
            <param name="prefix">Prefix used for generating names.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.ResourceNameGenerator.GetResourceType">
            <summary>Gets the resource type of generator.</summary>
            <returns>
            Type of resource. May be
            <see cref="F:iText.Kernel.Pdf.PdfName.ColorSpace"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.ExtGState"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.Pattern"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.Shading"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.XObject"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.Font"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfResources.ResourceNameGenerator.Generate(iText.Kernel.Pdf.PdfResources)">
            <summary>Generates new (unique) resource name.</summary>
            <param name="resources">
            the
            <see cref="T:iText.Kernel.Pdf.PdfResources"/>
            object for which name will be generated.
            </param>
            <returns>new (unique) resource name.</returns>
        </member>
        <member name="T:iText.Kernel.Pdf.PdfString">
            <summary>
            A
            <c>PdfString</c>
            -class is the PDF-equivalent of a
            JAVA-
            <c>String</c>
            -object.
            <p/>
            A string is a sequence of characters delimited by parenthesis.
            If a string is too long to be conveniently placed on a single line, it may
            be split across multiple lines by using the backslash character (\) at the
            end of a line to indicate that the string continues on the following line.
            Within a string, the backslash character is used as an escape to specify
            unbalanced parenthesis, non-printing ASCII characters, and the backslash
            character itself. Use of the \<i>ddd</i> escape sequence is the preferred
            way to represent characters outside the printable ASCII character set.<br/>
            This object is described in the 'Portable Document Format Reference Manual
            version 1.7' section 3.2.3 (page 53-56).
            <p/>
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfString.#ctor(System.Byte[],System.Boolean)">
            <summary>Only PdfReader can use this method!</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfString.GetEncoding">
            <summary>Gets the encoding of this string.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfString.SetEncoding(System.String)">
            <summary>Sets the encoding of this string.</summary>
            <remarks>
            Sets the encoding of this string.
            NOTE. Byte content will be removed.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfString.ToUnicodeString">
            <summary>
            Returns the Unicode
            <c>String</c>
            value of this
            <c>PdfString</c>
            -object.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfString.GetValueBytes">
            <summary>Gets bytes of String-value considering encoding.</summary>
            <returns>byte array</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfString.MakeIndirect(iText.Kernel.Pdf.PdfDocument)">
            <summary>Marks object to be saved as indirect.</summary>
            <param name="document">a document the indirect reference will belong to.</param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfString.MakeIndirect(iText.Kernel.Pdf.PdfDocument,iText.Kernel.Pdf.PdfIndirectReference)">
            <summary>Marks object to be saved as indirect.</summary>
            <param name="document">a document the indirect reference will belong to.</param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfString.CopyTo(iText.Kernel.Pdf.PdfDocument)">
            <summary>Copies object to a specified document.</summary>
            <remarks>
            Copies object to a specified document.
            Works only for objects that are read from existing document, otherwise an exception is thrown.
            </remarks>
            <param name="document">document to copy object to.</param>
            <returns>copied object.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfString.CopyTo(iText.Kernel.Pdf.PdfDocument,System.Boolean)">
            <summary>Copies object to a specified document.</summary>
            <remarks>
            Copies object to a specified document.
            Works only for objects that are read from existing document, otherwise an exception is thrown.
            </remarks>
            <param name="document">document to copy object to.</param>
            <param name="allowDuplicating">
            indicates if to allow copy objects which already have been copied.
            If object is associated with any indirect reference and allowDuplicating is false then already existing reference will be returned instead of copying object.
            If allowDuplicating is true then object will be copied and new indirect reference will be assigned.
            </param>
            <returns>copied object.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfString.MarkAsUnencryptedObject">
            <summary>Marks this string object as not encrypted in the encrypted document.</summary>
            <remarks>
            Marks this string object as not encrypted in the encrypted document.
            <p>
            If it's marked so, it will be considered as already in plaintext and decryption will not be performed for it.
            In order to have effect, this method shall be called before
            <see cref="M:iText.Kernel.Pdf.PdfString.GetValue"/>
            and
            <see cref="M:iText.Kernel.Pdf.PdfString.GetValueBytes"/>
            methods.
            </p>
            <p>
            NOTE: this method is only needed in a very specific cases of encrypted documents. E.g. digital signature dictionary
            /Contents entry shall not be encrypted. Also this method isn't meaningful in non-encrypted documents.
            </p>
            </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfString.Decrypt(iText.Kernel.Pdf.PdfEncryption)">
            <summary>
            Decrypt content of an encrypted
            <c>PdfString</c>
            .
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfString.Encrypt(iText.Kernel.Pdf.PdfEncryption)">
            <summary>
            Encrypt content of
            <c>value</c>
            and set as content.
            <c>generateContent()</c>
            won't be called.
            </summary>
            <param name="encrypt">@see PdfEncryption</param>
            <returns>true if value was encrypted, otherwise false.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfString.EncodeBytes(System.Byte[])">
            <summary>Escape special symbols or convert to hexadecimal string.</summary>
            <remarks>
            Escape special symbols or convert to hexadecimal string.
            This method don't change either
            <c>value</c>
            or
            <c>content</c>
            ot the
            <c>PdfString</c>
            .
            </remarks>
            <param name="bytes">byte array to manipulate with.</param>
            <returns>Hexadecimal string or string with escaped symbols in byte array view.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:iText.Kernel.Pdf.PdfTextArray" -->
        <member name="M:iText.Kernel.Pdf.PdfTextArray.AddAll(iText.Kernel.Pdf.PdfArray)">
            <summary>
            Adds content of the
            <c>PdfArray</c>
            .
            </summary>
            <param name="a">
            the
            <c>PdfArray</c>
            to be added
            </param>
            <seealso cref="!:System.Collections.IList&lt;E&gt;.AddAll(System.Collections.ICollection&lt;E&gt;)"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfTextArray.AddAll(System.Collections.Generic.ICollection{iText.Kernel.Pdf.PdfObject})">
            <summary>Adds the Collection of PdfObjects.</summary>
            <param name="c">the Collection of PdfObjects to be added</param>
            <seealso cref="!:System.Collections.IList&lt;E&gt;.AddAll(System.Collections.ICollection&lt;E&gt;)"/>
        </member>
        <member name="T:iText.Kernel.Pdf.PdfVersion">
            <summary>This class represents all official PDF versions.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfVersion.#ctor(System.Int32,System.Int32)">
            <summary>Creates a PdfVersion class.</summary>
            <param name="major">major version number</param>
            <param name="minor">minor version number</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfVersion.FromString(System.String)">
            <summary>
            Creates a PdfVersion class from a String object if the specified version
            can be found.
            </summary>
            <param name="value">version number</param>
            <returns>PdfVersion of the specified version</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfVersion.FromPdfName(iText.Kernel.Pdf.PdfName)">
            <summary>
            Creates a PdfVersion class from a
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            object if the specified version
            can be found.
            </summary>
            <param name="name">version number</param>
            <returns>PdfVersion of the specified version</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfViewerPreferences.SetHideToolbar(System.Boolean)">
            <summary>This method sets HideToolBar flag to true or false</summary>
            <param name="hideToolbar"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfViewerPreferences.SetHideMenubar(System.Boolean)">
            <summary>This method sets HideMenuBar flag to true or false</summary>
            <param name="hideMenubar"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfViewerPreferences.SetHideWindowUI(System.Boolean)">
            <summary>This method sets HideWindowUI flag to true or false</summary>
            <param name="hideWindowUI"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfViewerPreferences.SetFitWindow(System.Boolean)">
            <summary>This method sets FitWindow flag to true or false</summary>
            <param name="fitWindow"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfViewerPreferences.SetCenterWindow(System.Boolean)">
            <summary>This method sets CenterWindow flag to true or false</summary>
            <param name="centerWindow"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfViewerPreferences.SetDisplayDocTitle(System.Boolean)">
            <summary>This method sets DisplayDocTitle flag to true or false</summary>
            <param name="displayDocTitle"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfViewerPreferences.SetNonFullScreenPageMode(iText.Kernel.Pdf.PdfViewerPreferences.PdfViewerPreferencesConstants)">
            <summary>This method sets NonFullScreenPageMode property.</summary>
            <remarks>
            This method sets NonFullScreenPageMode property. Allowed values are UseNone, UseOutlines, useThumbs, UseOC.
            This entry is meaningful only if the value of the PageMode entry in the Catalog dictionary is FullScreen
            </remarks>
            <param name="nonFullScreenPageMode"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfViewerPreferences.SetDirection(iText.Kernel.Pdf.PdfViewerPreferences.PdfViewerPreferencesConstants)">
            <summary>This method sets predominant reading order of text.</summary>
            <param name="direction"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfViewerPreferences.SetViewArea(iText.Kernel.Pdf.PdfViewerPreferences.PdfViewerPreferencesConstants)">
            <summary>
            This method sets the name of the page boundary representing the area of a page that shall be displayed when
            viewing the document on the screen.
            </summary>
            <param name="pageBoundary"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfViewerPreferences.SetViewClip(iText.Kernel.Pdf.PdfViewerPreferences.PdfViewerPreferencesConstants)">
            <summary>
            This method sets the name of the page boundary to which the contents of a page shall be clipped when
            viewing the document on the screen.
            </summary>
            <param name="pageBoundary"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfViewerPreferences.SetPrintArea(iText.Kernel.Pdf.PdfViewerPreferences.PdfViewerPreferencesConstants)">
            <summary>
            This method sets the name of the page boundary representing the area of a page that shall be
            rendered when printing the document.
            </summary>
            <param name="pageBoundary"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfViewerPreferences.SetPrintClip(iText.Kernel.Pdf.PdfViewerPreferences.PdfViewerPreferencesConstants)">
            <summary>
            This method sets the name of the page boundary to which the contents of a page shall be clipped when
            printing the document.
            </summary>
            <param name="pageBoundary"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfViewerPreferences.SetPrintScaling(iText.Kernel.Pdf.PdfViewerPreferences.PdfViewerPreferencesConstants)">
            <summary>
            This method sets the page scaling option that shall be selected when a print dialog is displayed for this
            document.
            </summary>
            <remarks>
            This method sets the page scaling option that shall be selected when a print dialog is displayed for this
            document. Valid values are None and AppDefault.
            </remarks>
            <param name="printScaling"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfViewerPreferences.SetDuplex(iText.Kernel.Pdf.PdfViewerPreferences.PdfViewerPreferencesConstants)">
            <summary>This method sets the paper handling option that shall be used when printing the file from the print dialog.
                </summary>
            <remarks>
            This method sets the paper handling option that shall be used when printing the file from the print dialog.
            The following values are valid: Simplex, DuplexFlipShortEdge, DuplexFlipLongEdge.
            </remarks>
            <param name="duplex"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfViewerPreferences.SetPickTrayByPDFSize(System.Boolean)">
            <summary>This method sets PickTrayByPDFSize flag to true or false.</summary>
            <param name="pickTrayByPdfSize"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfViewerPreferences.SetPrintPageRange(System.Int32[])">
            <summary>This method sets the page numbers used to initialize the print dialog box when the file is printed.
                </summary>
            <param name="printPageRange"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfViewerPreferences.SetNumCopies(System.Int32)">
            <summary>This method sets the number of copies that shall be printed when the print dialog is opened for this file.
                </summary>
            <param name="numCopies"/>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfWriter.objectStream">
            <summary>Currently active object stream.</summary>
            <remarks>
            Currently active object stream.
            Objects are written to the object stream if fullCompression set to true.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfWriter.copiedObjects">
            <summary>Is used to avoid duplications on object copying.</summary>
            <remarks>
            Is used to avoid duplications on object copying.
            It stores hashes of the indirect reference from the source document and the corresponding
            indirect references of the copied objects from the new document.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.PdfWriter.smartModeSerializer">
            <summary>Is used in smart mode to serialize and store serialized objects content.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfWriter.#ctor(System.IO.FileInfo)">
            <summary>Create a PdfWriter writing to the passed File and with default writer properties.</summary>
            <param name="file">File to write to.</param>
            <exception cref="T:System.IO.FileNotFoundException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfWriter.#ctor(System.IO.Stream)">
            <summary>Create a PdfWriter writing to the passed outputstream and with default writer properties.</summary>
            <param name="os">Outputstream to write to.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfWriter.#ctor(System.String)">
            <summary>Create a PdfWriter writing to the passed filename and with default writer properties.</summary>
            <param name="filename">filename of the resulting pdf.</param>
            <exception cref="T:System.IO.FileNotFoundException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfWriter.#ctor(System.String,iText.Kernel.Pdf.WriterProperties)">
            <summary>Create a PdfWriter writing to the passed filename and using the passed writer properties.</summary>
            <param name="filename">filename of the resulting pdf.</param>
            <param name="properties">writerproperties to use.</param>
            <exception cref="T:System.IO.FileNotFoundException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfWriter.IsFullCompression">
            <summary>Indicates if to use full compression mode.</summary>
            <returns>true if to use full compression, false otherwise.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfWriter.GetCompressionLevel">
            <summary>Gets default compression level for @see PdfStream.</summary>
            <remarks>
            Gets default compression level for @see PdfStream.
            For more details @see
            <see cref="!:Java.Util.Zip.Deflater"/>
            .
            </remarks>
            <returns>compression level.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfWriter.SetCompressionLevel(System.Int32)">
            <summary>Sets default compression level for @see PdfStream.</summary>
            <remarks>
            Sets default compression level for @see PdfStream.
            For more details @see
            <see cref="!:Java.Util.Zip.Deflater"/>
            .
            </remarks>
            <param name="compressionLevel">compression level.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfWriter.SetSmartMode(System.Boolean)">
            <summary>Sets the smart mode.</summary>
            <remarks>
            Sets the smart mode.
            <p/>
            In smart mode when resources (such as fonts, images,...) are
            encountered, a reference to these resources is saved
            in a cache, so that they can be reused.
            This requires more memory, but reduces the file size
            of the resulting PDF document.
            </remarks>
            <param name="smartMode">True for enabling smart mode.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfWriter.GetObjectStream">
            <summary>Gets the current object stream.</summary>
            <returns>object stream.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfWriter.FlushObject(iText.Kernel.Pdf.PdfObject,System.Boolean)">
            <summary>Flushes the object.</summary>
            <remarks>Flushes the object. Override this method if you want to define custom behaviour for object flushing.
                </remarks>
            <param name="pdfObject">object to flush.</param>
            <param name="canBeInObjStm">indicates whether object can be placed into object stream.</param>
            <exception cref="T:System.IO.IOException">on error.</exception>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfWriter.WriteToBody(iText.Kernel.Pdf.PdfObject)">
            <summary>Writes object to body of PDF document.</summary>
            <param name="pdfObj">object to write.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfWriter.WriteHeader">
            <summary>Writes PDF header.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfWriter.FlushWaitingObjects">
            <summary>Flushes all objects which have not been flushed yet.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfWriter.FlushModifiedWaitingObjects">
            <summary>Flushes all modified objects which have not been flushed yet.</summary>
            <remarks>Flushes all modified objects which have not been flushed yet. Used in case incremental updates.</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfWriter.CalculateIndRefKey(iText.Kernel.Pdf.PdfIndirectReference)">
            <summary>Calculates hash code for the indirect reference taking into account the document it belongs to.</summary>
            <param name="indRef">object to be hashed.</param>
            <returns>calculated hash code.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfWriter.GetCopyObjectKey(iText.Kernel.Pdf.PdfObject)">
            <summary>Calculates hash code for object to be copied.</summary>
            <remarks>
            Calculates hash code for object to be copied.
            The hash code and the copied object is the stored in @{link copiedObjects} hash map to avoid duplications.
            </remarks>
            <param name="obj">object to be copied.</param>
            <returns>calculated hash code.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfWriter.FlushCopiedObjects(System.Int64)">
            <summary>Flush all copied objects.</summary>
            <param name="docId">id of the source document</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfXrefTable.Add(iText.Kernel.Pdf.PdfIndirectReference)">
            <summary>Adds indirect reference to list of indirect objects.</summary>
            <param name="reference">indirect reference to add.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfXrefTable.CreateNextIndirectReference(iText.Kernel.Pdf.PdfDocument)">
            <summary>Creates next available indirect reference.</summary>
            <returns>created indirect reference.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfXrefTable.WriteXrefTableAndTrailer(iText.Kernel.Pdf.PdfDocument,iText.Kernel.Pdf.PdfObject,iText.Kernel.Pdf.PdfObject)">
            <summary>Writes cross reference table and trailer to PDF.</summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.PdfXrefTable.WriteKeyInfo(iText.Kernel.Pdf.PdfWriter)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.ReaderProperties.SetPassword(System.Byte[])">
            <summary>Defines the password which will be used if the document is encrypted with standard encryption.</summary>
            <remarks>
            Defines the password which will be used if the document is encrypted with standard encryption.
            This could be either user or owner password.
            </remarks>
            <param name="password">the password to use in order to open the document.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.ReaderProperties.SetPublicKeySecurityParams(Org.BouncyCastle.X509.X509Certificate,Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Defines the certificate which will be used if the document is encrypted with public key encryption.
                </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.ReaderProperties.SetPublicKeySecurityParams(Org.BouncyCastle.X509.X509Certificate)">
            <summary>Defines the certificate which will be used if the document is encrypted with public key encryption.
                </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.StampingProperties.UseAppendMode">
            <summary>Defines if the document will be edited in append mode.</summary>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.StampingProperties"/>
            instance
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.StampingProperties.PreserveEncryption">
            <summary>Defines if the encryption of the original document (if it was encrypted) will be preserved.</summary>
            <remarks>
            Defines if the encryption of the original document (if it was encrypted) will be preserved.
            By default, the resultant document doesn't preserve the original encryption.
            </remarks>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.StampingProperties"/>
            instance
            </returns>
        </member>
        <member name="T:iText.Kernel.Pdf.Tagging.ParentTreeHandler">
            <summary>
            Internal helper class which is used to effectively build parent tree and also find marked content references:
            for specified page, by MCID or by struct parent index.
            </summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Tagging.ParentTreeHandler.parentTree">
            <summary>Represents parentTree in structTreeRoot.</summary>
            <remarks>Represents parentTree in structTreeRoot. It contains only those entries that belong to the already flushed pages.
                </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.Tagging.ParentTreeHandler.pageToPageMcrs">
            <summary>Contains marked content references for every page.</summary>
            <remarks>
            Contains marked content references for every page.
            If new mcrs are added to the tag structure, these new mcrs are also added to this map. So for each adding or
            removing mcr, register/unregister calls must be made (this is done automatically if addKid or removeKid methods
            of PdfStructElem are used).
            Keys in this map are page references, values - a map which contains all mcrs that belong to the given page.
            This inner map of mcrs is of following structure:
            * for McrDictionary and McrNumber values the keys are their MCIDs;
            * for ObjRef values the keys are struct parent indexes, but with one trick. Struct parent indexes and MCIDs have the
            same value domains: the increasing numbers starting from zero. So, in order to store them in one map, for
            struct parent indexes simple transformation is applied via
            <c>#structParentIndexIntoKey</c>
            and
            <c>#keyIntoStructParentIndex</c>
            . With this we simply store struct parent indexes as negative numbers.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagging.ParentTreeHandler.#ctor(iText.Kernel.Pdf.Tagging.PdfStructTreeRoot)">
            <summary>Init ParentTreeHandler.</summary>
            <remarks>Init ParentTreeHandler. On init the parent tree is read and stored in this instance.</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagging.ParentTreeHandler.GetPageMarkedContentReferences(iText.Kernel.Pdf.PdfPage)">
            <summary>Gets a list of marked content references on page.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagging.ParentTreeHandler.CreateParentTreeEntryForPage(iText.Kernel.Pdf.PdfPage)">
            <summary>Creates and flushes parent tree entry for the page.</summary>
            <remarks>
            Creates and flushes parent tree entry for the page.
            Effectively this means that new content mustn't be added to the page.
            </remarks>
            <param name="page">
            
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            for which to create parent tree entry. Typically this page is flushed after this call.
            </param>
        </member>
        <member name="T:iText.Kernel.Pdf.Tagging.PdfMcr">
            <summary>Represents Marked Content Reference (MCR) object wrapper.</summary>
        </member>
        <member name="T:iText.Kernel.Pdf.Tagging.PdfStructElem">
            <summary>
            To be able to be wrapped with this
            <see cref="T:iText.Kernel.Pdf.PdfObjectWrapper`1"/>
            the
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            must be indirect.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagging.PdfStructElem.#ctor(iText.Kernel.Pdf.PdfDictionary)">
            <param name="pdfObject">must be an indirect object.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagging.PdfStructElem.IsStructElem(iText.Kernel.Pdf.PdfDictionary)">
            <summary>Method to to distinguish struct elements from other elements of the logical tree (like mcr or struct tree root).
                </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagging.PdfStructElem.GetAttributes(System.Boolean)">
            <summary>Gets attributes object.</summary>
            <param name="createNewIfNull">
            sometimes attributes object may not exist.
            Pass
            <see langword="true"/>
            if you want to create empty dictionary in such case.
            The attributes dictionary will be stored inside element.
            </param>
            <returns>attributes dictionary.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagging.PdfStructElem.GetParent">
            <returns>parent of the current structure element. If parent is already flushed it returns null.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagging.PdfStructElem.GetKids">
            <summary>Gets list of the direct kids of structure element.</summary>
            <remarks>
            Gets list of the direct kids of structure element.
            If certain kid is flushed, there will be a
            <see langword="null"/>
            in the list on it's place.
            </remarks>
            <returns>list of the direct kids of structure element.</returns>
        </member>
        <member name="T:iText.Kernel.Pdf.Tagging.PdfStructTreeRoot">
            <summary>
            To be able to be wrapped with this
            <see cref="T:iText.Kernel.Pdf.PdfObjectWrapper`1"/>
            the
            <see cref="T:iText.Kernel.Pdf.PdfObject"/>
            must be indirect.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagging.PdfStructTreeRoot.#ctor(iText.Kernel.Pdf.PdfDictionary)">
            <param name="pdfObject">must be an indirect object.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagging.PdfStructTreeRoot.GetKids">
            <summary>Gets list of the direct kids of StructTreeRoot.</summary>
            <remarks>
            Gets list of the direct kids of StructTreeRoot.
            If certain kid is flushed, there will be a
            <see langword="null"/>
            in the list on it's place.
            </remarks>
            <returns>list of the direct kids of StructTreeRoot.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagging.PdfStructTreeRoot.CreateParentTreeEntryForPage(iText.Kernel.Pdf.PdfPage)">
            <summary>Creates and flushes parent tree entry for the page.</summary>
            <remarks>
            Creates and flushes parent tree entry for the page.
            Effectively this means that new content mustn't be added to the page.
            </remarks>
            <param name="page">
            
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            for which to create parent tree entry. Typically this page is flushed after this call.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagging.PdfStructTreeRoot.GetPageMarkedContentReferences(iText.Kernel.Pdf.PdfPage)">
            <summary>Gets an unmodifiable collection of marked content references on page.</summary>
            <remarks>
            Gets an unmodifiable collection of marked content references on page.
            <br/><br/>
            NOTE: Do not remove tags when iterating over returned collection, this could
            lead to the ConcurrentModificationException, because returned collection is backed by the internal list of the
            actual page tags.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagging.PdfStructTreeRoot.CopyTo(iText.Kernel.Pdf.PdfDocument,System.Collections.Generic.IDictionary{iText.Kernel.Pdf.PdfPage,iText.Kernel.Pdf.PdfPage})">
            <summary>
            Copies structure to a
            <paramref name="destDocument"/>
            .
            <br/><br/>
            NOTE: Works only for
            <c>PdfStructTreeRoot</c>
            that is read from the document opened in reading mode,
            otherwise an exception is thrown.
            </summary>
            <param name="destDocument">document to copy structure to. Shall not be current document.</param>
            <param name="page2page">association between original page and copied page.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagging.PdfStructTreeRoot.CopyTo(iText.Kernel.Pdf.PdfDocument,System.Int32,System.Collections.Generic.IDictionary{iText.Kernel.Pdf.PdfPage,iText.Kernel.Pdf.PdfPage})">
            <summary>
            Copies structure to a
            <paramref name="destDocument"/>
            and insert it in a specified position in the document.
            <br/><br/>
            NOTE: Works only for
            <c>PdfStructTreeRoot</c>
            that is read from the document opened in reading mode,
            otherwise an exception is thrown.
            </summary>
            <param name="destDocument">document to copy structure to.</param>
            <param name="insertBeforePage">indicates where the structure to be inserted.</param>
            <param name="page2page">association between original page and copied page.</param>
        </member>
        <member name="T:iText.Kernel.Pdf.Tagging.StructureTreeCopier">
            <summary>Internal helper class which is used to copy tag structure across documents.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagging.StructureTreeCopier.CopyTo(iText.Kernel.Pdf.PdfDocument,System.Collections.Generic.IDictionary{iText.Kernel.Pdf.PdfPage,iText.Kernel.Pdf.PdfPage},iText.Kernel.Pdf.PdfDocument)">
            <summary>
            Copies structure to a
            <paramref name="destDocument"/>
            .
            <br/><br/>
            NOTE: Works only for
            <c>PdfStructTreeRoot</c>
            that is read from the document opened in reading mode,
            otherwise an exception is thrown.
            </summary>
            <param name="destDocument">document to copy structure to. Shall not be current document.</param>
            <param name="page2page">association between original page and copied page.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagging.StructureTreeCopier.CopyTo(iText.Kernel.Pdf.PdfDocument,System.Int32,System.Collections.Generic.IDictionary{iText.Kernel.Pdf.PdfPage,iText.Kernel.Pdf.PdfPage},iText.Kernel.Pdf.PdfDocument)">
            <summary>
            Copies structure to a
            <paramref name="destDocument"/>
            and insert it in a specified position in the document.
            <br/><br/>
            NOTE: Works only for
            <c>PdfStructTreeRoot</c>
            that is read from the document opened in reading mode,
            otherwise an exception is thrown.
            <br/>
            Also, to insert a tagged page into existing tag structure, existing tag structure shouldn't be flushed, otherwise
            an exception may be raised.
            </summary>
            <param name="destDocument">document to copy structure to.</param>
            <param name="insertBeforePage">indicates where the structure to be inserted.</param>
            <param name="page2page">association between original page and copied page.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagging.StructureTreeCopier.CopyTo(iText.Kernel.Pdf.PdfDocument,System.Collections.Generic.IDictionary{iText.Kernel.Pdf.PdfPage,iText.Kernel.Pdf.PdfPage},iText.Kernel.Pdf.PdfDocument,System.Boolean)">
            <summary>
            Copies structure to a
            <paramref name="destDocument"/>
            .
            </summary>
            <param name="destDocument">document to cpt structure to.</param>
            <param name="page2page">association between original page and copied page.</param>
            <param name="copyFromDestDocument">
            indicates if <code>page2page</code> keys and values represent pages from
            <paramref name="destDocument"/>
            .
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagging.StructureTreeCopier.AddAllParentsToSet(iText.Kernel.Pdf.Tagging.PdfMcr,System.Collections.Generic.ICollection{iText.Kernel.Pdf.PdfObject})">
            <returns>the topmost parent added to set. If encountered flushed element - stops and returns this flushed element.
                </returns>
        </member>
        <member name="T:iText.Kernel.Pdf.Tagutils.IAccessibleElement">
            <summary>A layout element which can have a <em>role</em>.</summary>
            <remarks>
            A layout element which can have a <em>role</em>. The name of the role will be
            used to tag the element if it is added to a Tagged PDF document. It can also
            have
            <see cref="T:iText.Kernel.Pdf.Tagutils.AccessibilityProperties"/>
            , metadata for the tag dictionary.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.IAccessibleElement.GetRole">
            <summary>Gets the element's role.</summary>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            containing the name of the role
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.IAccessibleElement.SetRole(iText.Kernel.Pdf.PdfName)">
            <summary>Sets the element's role.</summary>
            <param name="role">
            the new role which the
            <see cref="T:iText.Kernel.Pdf.Tagutils.IAccessibleElement"/>
            should take
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.IAccessibleElement.GetAccessibilityProperties">
            <summary>
            Gets the
            <see cref="T:iText.Kernel.Pdf.Tagutils.AccessibilityProperties">accessibility properties</see>
            .
            </summary>
            <returns>a properties wrapper object specific to a tagged element in Tagged PDF</returns>
        </member>
        <member name="T:iText.Kernel.Pdf.Tagutils.TagStructureContext">
            <summary>
            <c>TagStructureContext</c>
            class is used to track necessary information of document's tag structure.
            It is also used to make some global modifications of the tag tree like removing or flushing page tags, however
            these two methods and also others are called automatically and are for the most part for internal usage.
            <br/><br/>
            There shall be only one instance of this class per
            <c>PdfDocument</c>
            . To obtain instance of this class use
            <see cref="M:iText.Kernel.Pdf.PdfDocument.GetTagStructureContext"/>
            .
            </summary>
        </member>
        <member name="F:iText.Kernel.Pdf.Tagutils.TagStructureContext.connectedModelToStruct">
            <summary>
            These two fields define the connections between tags (
            <c>PdfStructElem</c>
            ) and
            layout model elements (
            <c>IAccessibleElement</c>
            ). This connection is used as
            a sign that tag is not yet finished and therefore should not be flushed or removed
            if page tags are flushed or removed. Also, any
            <c>TagTreePointer</c>
            could be
            immediately moved to the tag with connection via it's connected element
            <see cref="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.MoveToTag(iText.Kernel.Pdf.Tagutils.IAccessibleElement)"/>
            .
            When connection is removed, accessible element role and properties are set to the structure element.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagStructureContext.#ctor(iText.Kernel.Pdf.PdfDocument)">
            <summary>
            Do not use this constructor, instead use
            <see cref="M:iText.Kernel.Pdf.PdfDocument.GetTagStructureContext"/>
            method.
            <br/><br/>
            Creates
            <c>TagStructureContext</c>
            for document. There shall be only one instance of this
            class per
            <c>PdfDocument</c>
            .
            </summary>
            <param name="document">the document which tag structure will be manipulated with this class.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagStructureContext.SetForbidUnknownRoles(System.Boolean)">
            <summary>
            If forbidUnknownRoles is set to true, then if you would try to add new tag which has not a standard role and
            it's role is not mapped through RoleMap, an exception will be raised.
            </summary>
            <remarks>
            If forbidUnknownRoles is set to true, then if you would try to add new tag which has not a standard role and
            it's role is not mapped through RoleMap, an exception will be raised.
            Default value - true.
            </remarks>
            <param name="forbidUnknownRoles">new value of the flag</param>
            <returns>
            current
            <see cref="T:iText.Kernel.Pdf.Tagutils.TagStructureContext"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagStructureContext.GetAutoTaggingPointer">
            <summary>
            All document auto tagging logic uses
            <see cref="T:iText.Kernel.Pdf.Tagutils.TagTreePointer"/>
            returned by this method to manipulate tag structure.
            Typically it points at the root tag. This pointer also could be used to tweak auto tagging process
            (e.g. move this pointer to the Sect tag, which would result in placing all automatically tagged content
            under Sect tag).
            </summary>
            <returns>
            the
            <c>TagTreePointer</c>
            which is used for all auto tagging of the document.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagStructureContext.IsElementConnectedToTag(iText.Kernel.Pdf.Tagutils.IAccessibleElement)">
            <summary>
            Checks if given
            <c>IAccessibleElement</c>
            is connected to some tag.
            </summary>
            <param name="element">element to check if it has a connected tag.</param>
            <returns>true, if there is a tag which retains the connection to the given accessible element.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagStructureContext.RemoveElementConnectionToTag(iText.Kernel.Pdf.Tagutils.IAccessibleElement)">
            <summary>Destroys the connection between the given accessible element and the tag to which this element is connected to.
                </summary>
            <param name="element">
            
            <c>IAccessibleElement</c>
            which connection to the tag (if there is one) will be removed.
            </param>
            <returns>
            current
            <see cref="T:iText.Kernel.Pdf.Tagutils.TagStructureContext"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagStructureContext.RemoveAnnotationTag(iText.Kernel.Pdf.Annot.PdfAnnotation)">
            <summary>Removes annotation content item from the tag structure.</summary>
            <remarks>
            Removes annotation content item from the tag structure.
            If annotation is not added to the document or is not tagged, nothing will happen.
            </remarks>
            <returns>
            
            <see cref="T:iText.Kernel.Pdf.Tagutils.TagTreePointer"/>
            instance which points at annotation tag parent if annotation was removed,
            otherwise returns null.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagStructureContext.RemoveContentItem(iText.Kernel.Pdf.PdfPage,System.Int32)">
            <summary>Removes content item from the tag structure.</summary>
            <remarks>
            Removes content item from the tag structure.
            <br/>
            Nothing happens if there is no such mcid on given page.
            </remarks>
            <param name="page">page, which contains this content item</param>
            <param name="mcid">marked content id of this content item</param>
            <returns>
            
            <c>TagTreePointer</c>
            which points at the parent of the removed content item, or null if there is no
            such mcid on given page.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagStructureContext.RemovePageTags(iText.Kernel.Pdf.PdfPage)">
            <summary>Removes all tags that belong only to this page.</summary>
            <remarks>
            Removes all tags that belong only to this page. The logic which defines if tag belongs to the page is described
            at
            <see cref="M:iText.Kernel.Pdf.Tagutils.TagStructureContext.FlushPageTags(iText.Kernel.Pdf.PdfPage)"/>
            .
            </remarks>
            <param name="page">page that defines which tags are to be removed</param>
            <returns>
            current
            <see cref="T:iText.Kernel.Pdf.Tagutils.TagStructureContext"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagStructureContext.MoveTagPointerToTag(iText.Kernel.Pdf.Tagutils.IAccessibleElement,iText.Kernel.Pdf.Tagutils.TagTreePointer)">
            <summary>
            Sets the tag, which is connected with the given accessible element, as a current tag for the given
            <see cref="T:iText.Kernel.Pdf.Tagutils.TagTreePointer"/>
            . An exception will be thrown, if given accessible element is not connected to any tag.
            </summary>
            <param name="element">an element which has a connection with some tag.</param>
            <param name="tagPointer">
            
            <see cref="T:iText.Kernel.Pdf.Tagutils.TagTreePointer"/>
            which will be moved to the tag connected to the given accessible element.
            </param>
            <returns>
            current
            <see cref="T:iText.Kernel.Pdf.Tagutils.TagStructureContext"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagStructureContext.RemoveAllConnectionsToTags">
            <summary>Destroys all the retained connections.</summary>
            <returns>
            current
            <see cref="T:iText.Kernel.Pdf.Tagutils.TagStructureContext"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagStructureContext.FlushPageTags(iText.Kernel.Pdf.PdfPage)">
            <summary>Flushes the tags which are considered to belong to the given page.</summary>
            <remarks>
            Flushes the tags which are considered to belong to the given page.
            The logic that defines if the given tag (structure element) belongs to the page is the following:
            if all the marked content references (dictionary or number references), that are the
            descenders of the given structure element, belong to the current page - the tag is considered
            to belong to the page. If tag has descenders from several pages - it is flushed, if all other pages except the
            current one are flushed.
            <br /><br />
            If some of the page's tags are still connected to the accessible elements, in this case these tags are considered
            as not yet finished ones, and they won't be flushed.
            </remarks>
            <param name="page">a page which tags will be flushed.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagStructureContext.NormalizeDocumentRootTag">
            <summary>Transforms root tags in a way that complies with the PDF References.</summary>
            <remarks>
            Transforms root tags in a way that complies with the PDF References.
            <br/><br/>
            PDF Reference
            10.7.3 Grouping Elements:
            <br/><br/>
            For most content extraction formats, the document must be a tree with a single top-level element;
            the structure tree root (identified by the StructTreeRoot entry in the document catalog) must have
            only one child in its K (kids) array. If the PDF file contains a complete document, the structure
            type Document is recommended for this top-level element in the logical structure hierarchy. If the
            file contains a well-formed document fragment, one of the structure types Part, Art, Sect, or Div
            may be used instead.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagStructureContext.ActualizeTagsProperties">
            <summary>Method for internal usages.</summary>
            <remarks>
            Method for internal usages.
            Essentially, all it does is just making sure that for connected tags the properties are
            up to date with the connected accessible elements properties.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagStructureContext.GetPointerStructElem(iText.Kernel.Pdf.Tagutils.TagTreePointer)">
            <summary>
            <p>
            Gets
            <see cref="T:iText.Kernel.Pdf.Tagging.PdfStructElem"/>
            at which
            <see cref="T:iText.Kernel.Pdf.Tagutils.TagTreePointer"/>
            points.
            </p>
            NOTE: Be aware that
            <see cref="T:iText.Kernel.Pdf.Tagging.PdfStructElem"/>
            is a low level class, use it carefully,
            especially in conjunction with high level
            <see cref="T:iText.Kernel.Pdf.Tagutils.TagTreePointer"/>
            and
            <see cref="T:iText.Kernel.Pdf.Tagutils.TagStructureContext"/>
            classes.
            </summary>
            <param name="pointer">
            a
            <see cref="T:iText.Kernel.Pdf.Tagutils.TagTreePointer"/>
            which points at desired
            <see cref="T:iText.Kernel.Pdf.Tagging.PdfStructElem"/>
            .
            </param>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.Tagging.PdfStructElem"/>
            at which given
            <see cref="T:iText.Kernel.Pdf.Tagutils.TagTreePointer"/>
            points.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagStructureContext.CreatePointerForStructElem(iText.Kernel.Pdf.Tagging.PdfStructElem)">
            <summary>
            Creates a new
            <see cref="T:iText.Kernel.Pdf.Tagutils.TagTreePointer"/>
            which points at given
            <see cref="T:iText.Kernel.Pdf.Tagging.PdfStructElem"/>
            .
            </summary>
            <param name="structElem">
            a
            <see cref="T:iText.Kernel.Pdf.Tagging.PdfStructElem"/>
            for which
            <see cref="T:iText.Kernel.Pdf.Tagutils.TagTreePointer"/>
            will be created.
            </param>
            <returns>
            a new
            <see cref="T:iText.Kernel.Pdf.Tagutils.TagTreePointer"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagStructureContext.FlushTag(iText.Kernel.Pdf.Tagging.PdfStructElem)">
            <returns>parent of the flushed tag</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:iText.Kernel.Pdf.Tagutils.TagTreePointer" -->
        <member name="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.#ctor(iText.Kernel.Pdf.PdfDocument)">
            <summary>
            Creates
            <c>TagTreePointer</c>
            instance. After creation
            <c>TagTreePointer</c>
            points at the root tag.
            </summary>
            <param name="document">the document, at which tag structure this instance will point.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.#ctor(iText.Kernel.Pdf.Tagutils.TagTreePointer)">
            <summary>A copy constructor.</summary>
            <param name="tagPointer">
            the
            <c>TagTreePointer</c>
            from which current position and page are copied.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.SetPageForTagging(iText.Kernel.Pdf.PdfPage)">
            <summary>
            Sets a page which content will be tagged with this instance of
            <c>TagTreePointer</c>
            .
            To tag page content:
            <ol>
            <li>Set pointer position to the tag which will be the parent of the page content item;</li>
            <li>Call
            <see cref="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.GetTagReference"/>
            to obtain the reference to the current tag;</li>
            <li>Pass
            <c>PdfTagReference</c>
            to the
            <see cref="M:iText.Kernel.Pdf.Canvas.PdfCanvas.OpenTag(iText.Kernel.Pdf.Tagutils.TagReference)"/>
            method of the page's
            <see cref="T:iText.Kernel.Pdf.Canvas.PdfCanvas"/>
            to start marked content item;</li>
            <li>Draw content on
            <c>PdfCanvas</c>
            ;</li>
            <li>Use
            <see cref="M:iText.Kernel.Pdf.Canvas.PdfCanvas.CloseTag"/>
            to finish marked content item.</li>
            </ol>
            </summary>
            <param name="page">
            the page which content will be tagged with this instance of
            <c>TagTreePointer</c>
            .
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Tagutils.TagTreePointer"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.GetCurrentPage">
            <returns>
            a page which content will be tagged with this instance of
            <c>TagTreePointer</c>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.SetContentStreamForTagging(iText.Kernel.Pdf.PdfStream)">
            <summary>
            Sometimes, tags are desired to be connected with the content that resides not in the page's content stream,
            but rather in the some appearance stream or in the form xObject stream.
            </summary>
            <remarks>
            Sometimes, tags are desired to be connected with the content that resides not in the page's content stream,
            but rather in the some appearance stream or in the form xObject stream. In that case, to have a valid tag structure,
            one shall set not only the page, on which the content will be rendered, but also the content stream in which
            the tagged content will reside.
            <br /><br />
            NOTE: It's important to set a
            <see langword="null"/>
            for this value, when tagging of this stream content is finished.
            </remarks>
            <param name="contentStream">
            the content stream which content will be tagged with this instance of
            <c>TagTreePointer</c>
            or
            <see langword="null"/>
            if content stream tagging is finished.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.GetCurrentContentStream">
            <returns>
            the content stream which content will be tagged with this instance of
            <c>TagTreePointer</c>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.GetDocument">
            <returns>the document, at which tag structure this instance points.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.AddTag(iText.Kernel.Pdf.PdfName)">
            <summary>Adds a new tag with given role to the tag structure.</summary>
            <remarks>
            Adds a new tag with given role to the tag structure.
            This method call moves this
            <c>TagTreePointer</c>
            to the added kid.
            </remarks>
            <param name="role">role of the new tag.</param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Tagutils.TagTreePointer"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.AddTag(System.Int32,iText.Kernel.Pdf.PdfName)">
            <summary>Adds a new tag with given role to the tag structure.</summary>
            <remarks>
            Adds a new tag with given role to the tag structure.
            This method call moves this
            <c>TagTreePointer</c>
            to the added kid.
            <br/>
            This call is equivalent of calling sequentially
            <see cref="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.SetNextNewKidIndex(System.Int32)"/>
            and
            <see cref="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.AddTag(iText.Kernel.Pdf.PdfName)"/>
            .
            </remarks>
            <param name="index">zero-based index in kids array of parent tag at which new tag will be added.</param>
            <param name="role">role of the new tag.</param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Tagutils.TagTreePointer"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.AddTag(iText.Kernel.Pdf.Tagutils.IAccessibleElement)">
            <summary>Adds a new tag to the tag structure.</summary>
            <remarks>
            Adds a new tag to the tag structure.
            This method call moves this
            <c>TagTreePointer</c>
            to the added kid.
            <br/>
            New tag will have a role and attributes defined by the given IAccessibleElement.
            </remarks>
            <param name="element">accessible element which represents a new tag.</param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Tagutils.TagTreePointer"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.AddTag(iText.Kernel.Pdf.Tagutils.IAccessibleElement,System.Boolean)">
            <summary>Adds a new tag to the tag structure.</summary>
            <remarks>
            Adds a new tag to the tag structure.
            This method call moves this
            <c>TagTreePointer</c>
            to the added kid.
            <br/>
            New tag will have a role and attributes defined by the given IAccessibleElement.
            <br/><br/>
            If <i>keepConnectedToTag</i> is true then a newly created tag will retain the connection with given
            accessible element. See
            <see cref="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.MoveToTag(iText.Kernel.Pdf.Tagutils.IAccessibleElement)"/>
            for more explanations about tag connections concept.
            <br/><br/>
            If the same accessible element is connected to the tag and is added twice to the same parent -
            this
            <c>TagTreePointer</c>
            instance would move to connected kid instead of creating tag twice.
            But if it is added to some other parent, then connection will be removed.
            </remarks>
            <param name="element">accessible element which represents a new tag.</param>
            <param name="keepConnectedToTag">defines if to retain the connection between accessible element and the tag.
                </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Tagutils.TagTreePointer"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.AddTag(System.Int32,iText.Kernel.Pdf.Tagutils.IAccessibleElement)">
            <summary>Adds a new tag to the tag structure.</summary>
            <remarks>
            Adds a new tag to the tag structure.
            This method call moves this
            <c>TagTreePointer</c>
            to the added kid.
            <br/>
            New tag will have a role and attributes defined by the given IAccessibleElement.
            This call is equivalent of calling sequentially
            <see cref="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.SetNextNewKidIndex(System.Int32)"/>
            and
            <see cref="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.AddTag(iText.Kernel.Pdf.Tagutils.IAccessibleElement)"/>
            .
            </remarks>
            <param name="index">zero-based index in kids array of parent tag at which new tag will be added.</param>
            <param name="element">accessible element which represents a new tag.</param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Tagutils.TagTreePointer"/>
            instance.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Pdf.Tagutils.TagTreePointer.AddTag(System.Int32,iText.Kernel.Pdf.Tagutils.IAccessibleElement,System.Boolean)" -->
        <member name="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.AddAnnotationTag(iText.Kernel.Pdf.Annot.PdfAnnotation)">
            <summary>
            Adds a new content item for the given
            <c>PdfAnnotation</c>
            under the current tag.
            <br/><br/>
            By default, when annotation is added to the page it is automatically tagged with auto tagging pointer
            (see
            <see cref="M:iText.Kernel.Pdf.Tagutils.TagStructureContext.GetAutoTaggingPointer"/>
            ). If you want to add annotation tag manually, be sure to use
            <see cref="M:iText.Kernel.Pdf.PdfPage.AddAnnotation(System.Int32,iText.Kernel.Pdf.Annot.PdfAnnotation,System.Boolean)"/>
            method with <i>false</i> for boolean flag.
            </summary>
            <param name="annotation">
            
            <c>PdfAnnotation</c>
            to be tagged.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Tagutils.TagTreePointer"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.SetNextNewKidIndex(System.Int32)">
            <summary>Sets index of the next added to the current tag kid, which could be another tag or content item.</summary>
            <remarks>
            Sets index of the next added to the current tag kid, which could be another tag or content item.
            By default, new tag is added at the end of the parent kids array. This property affects only the next added tag,
            all tags added after will be added with the default behaviour.
            <br/><br/>
            This method could be used with any overload of
            <see cref="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.AddTag(iText.Kernel.Pdf.PdfName)"/>
            method,
            with
            <see cref="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.RelocateKid(System.Int32,iText.Kernel.Pdf.Tagutils.TagTreePointer)"/>
            and
            <see cref="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.AddAnnotationTag(iText.Kernel.Pdf.Annot.PdfAnnotation)"/>
            .
            <br/>
            Keep in mind, that this method set property to the
            <c>TagTreePointer</c>
            and not to the tag itself, which means
            that if you would move the pointer, this property would be applied to the new current tag.
            </remarks>
            <param name="nextNewKidIndex">index of the next added kid.</param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Tagutils.TagTreePointer"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.IsElementConnectedToTag(iText.Kernel.Pdf.Tagutils.IAccessibleElement)">
            <summary>
            Checks if given
            <c>IAccessibleElement</c>
            is connected to some tag.
            See
            <see cref="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.MoveToTag(iText.Kernel.Pdf.Tagutils.IAccessibleElement)"/>
            for more explanations about tag connections concept.
            </summary>
            <param name="element">element to check if it has a connected tag.</param>
            <returns>true, if there is a tag which retains the connection to the given accessible element.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.RemoveElementConnectionToTag(iText.Kernel.Pdf.Tagutils.IAccessibleElement)">
            <summary>Destroys the connection between the given accessible element and the tag to which this element is connected to.
                </summary>
            <remarks>
            Destroys the connection between the given accessible element and the tag to which this element is connected to.
            See
            <see cref="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.MoveToTag(iText.Kernel.Pdf.Tagutils.IAccessibleElement)"/>
            for more explanations about tag connections concept.
            </remarks>
            <param name="element">
            
            <c>IAccessibleElement</c>
            which connection to the tag (if there is one) will be removed.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Tagutils.TagStructureContext"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.RemoveTag">
            <summary>Removes the current tag.</summary>
            <remarks>
            Removes the current tag. If it has kids, they will become kids of the current tag parent.
            This method call moves this
            <c>TagTreePointer</c>
            to the current tag parent.
            <br/><br/>
            You cannot remove root tag, and also you cannot remove any tag if document's tag structure was partially flushed;
            in this two cases an exception will be thrown.
            </remarks>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Tagutils.TagStructureContext"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.RelocateKid(System.Int32,iText.Kernel.Pdf.Tagutils.TagTreePointer)">
            <summary>
            Moves kid of the current tag to the tag at which given
            <c>TagTreePointer</c>
            points.
            This method doesn't change pointerToNewParent position.
            </summary>
            <param name="kidIndex">zero-based index of the current tag's kid to be relocated.</param>
            <param name="pointerToNewParent">
            the
            <c>TagTreePointer</c>
            which is positioned at the tag which will become kid's new parent.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Tagutils.TagStructureContext"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.GetTagReference">
            <summary>Creates a reference to the current tag, which could be used to associate a content on the PdfCanvas with current tag.
                </summary>
            <remarks>
            Creates a reference to the current tag, which could be used to associate a content on the PdfCanvas with current tag.
            See
            <see cref="M:iText.Kernel.Pdf.Canvas.PdfCanvas.OpenTag(iText.Kernel.Pdf.Tagutils.TagReference)"/>
            and
            <see cref="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.SetPageForTagging(iText.Kernel.Pdf.PdfPage)"/>
            .
            </remarks>
            <returns>the reference to the current tag.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.GetTagReference(System.Int32)">
            <summary>Creates a reference to the current tag, which could be used to associate a content on the PdfCanvas with current tag.
                </summary>
            <remarks>
            Creates a reference to the current tag, which could be used to associate a content on the PdfCanvas with current tag.
            See
            <see cref="M:iText.Kernel.Pdf.Canvas.PdfCanvas.OpenTag(iText.Kernel.Pdf.Tagutils.TagReference)"/>
            and
            <see cref="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.SetPageForTagging(iText.Kernel.Pdf.PdfPage)"/>
            .
            </remarks>
            <param name="index">zero-based index in kids array of tag. These indexes define the logical order of the content on the page.
                </param>
            <returns>the reference to the current tag.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.MoveToRoot">
            <summary>
            Moves this
            <c>TagTreePointer</c>
            instance to the document root tag.
            </summary>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Tagutils.TagStructureContext"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.MoveToParent">
            <summary>
            Moves this
            <c>TagTreePointer</c>
            instance to the parent of the current tag.
            </summary>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Tagutils.TagStructureContext"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.MoveToKid(System.Int32)">
            <summary>
            Moves this
            <c>TagTreePointer</c>
            instance to the kid of the current tag.
            </summary>
            <param name="kidIndex">zero-based index of the current tag kid to which pointer will be moved.</param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Tagutils.TagStructureContext"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.MoveToKid(iText.Kernel.Pdf.PdfName)">
            <summary>
            Moves this
            <c>TagTreePointer</c>
            instance to the kid of the current tag.
            </summary>
            <param name="role">
            role of the current tag kid to which pointer will be moved.
            If there is several kids with this role, pointer will be moved to the first kid with such role.
            </param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Tagutils.TagStructureContext"/>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.MoveToKid(System.Int32,iText.Kernel.Pdf.PdfName)">
            <summary>
            Moves this
            <c>TagTreePointer</c>
            instance to the kid of the current tag.
            </summary>
            <param name="n">
            if there is several kids with the given role, pointer will be moved to the kid
            which is the n'th if you count kids with such role.
            </param>
            <param name="role">role of the current tag kid to which pointer will be moved.</param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Tagutils.TagStructureContext"/>
            instance.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Pdf.Tagutils.TagTreePointer.MoveToTag(iText.Kernel.Pdf.Tagutils.IAccessibleElement)" -->
        <member name="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.GetKidsRoles">
            <summary>Gets current element kids roles.</summary>
            <remarks>
            Gets current element kids roles.
            If certain kid is already flushed, at its position there will be a
            <see langword="null"/>
            .
            If kid is content item, at its position there will be "MCR" (Marked Content Reference).
            </remarks>
            <returns>current element kids roles</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Pdf.Tagutils.TagTreePointer.FlushTag" -->
        <member name="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.GetConnectedElement(System.Boolean)">
            <summary>Gets connected accessible element for the current tag.</summary>
            <remarks>
            Gets connected accessible element for the current tag. If tag is not connected to element, behaviour is defined
            by the createIfNotExist flag.
            See
            <see cref="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.MoveToTag(iText.Kernel.Pdf.Tagutils.IAccessibleElement)"/>
            for more explanations about tag connections concept.
            </remarks>
            <param name="createIfNotExist">
            if <i>true</i>, creates an
            <c>IAccessibleElement</c>
            and connects it to the tag.
            </param>
            <returns>
            connected
            <c>IAccessibleElement</c>
            if there is one (or if it is created), otherwise null.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.GetProperties">
            <summary>Gets accessibility properties of the current tag.</summary>
            <returns>accessibility properties of the current tag.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.GetRole">
            <summary>Gets current tag role.</summary>
            <returns>current tag role.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Tagutils.TagTreePointer.SetRole(iText.Kernel.Pdf.PdfName)">
            <summary>Sets new role to the current tag.</summary>
            <param name="role">new role to be set.</param>
            <returns>
            this
            <see cref="T:iText.Kernel.Pdf.Tagutils.TagStructureContext"/>
            instance.
            </returns>
        </member>
        <member name="F:iText.Kernel.Pdf.WriterProperties.isFullCompression">
            <summary>Indicates if to use full compression (using object streams).</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.WriterProperties.smartMode">
            <summary>Indicates if the writer copy objects in a smart mode.</summary>
            <remarks>
            Indicates if the writer copy objects in a smart mode. If so PdfDictionary and PdfStream will be hashed
            and reused if there's an object with the same content later.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Pdf.WriterProperties.initialDocumentId">
            <summary>The ID entry that represents the initial identifier.</summary>
        </member>
        <member name="F:iText.Kernel.Pdf.WriterProperties.modifiedDocumentId">
            <summary>The ID entry that represents a change in a document.</summary>
        </member>
        <member name="M:iText.Kernel.Pdf.WriterProperties.SetPdfVersion(iText.Kernel.Pdf.PdfVersion)">
            <summary>Defines pdf version for the created document.</summary>
            <remarks>Defines pdf version for the created document. Default value is PDF_1_7.</remarks>
            <param name="version">version for the document.</param>
            <returns>
            this
            <c>WriterProperties</c>
            instance
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.WriterProperties.UseSmartMode">
            <summary>Enables smart mode.</summary>
            <remarks>
            Enables smart mode.
            <p/>
            In smart mode when resources (such as fonts, images,...) are
            encountered, a reference to these resources is saved
            in a cache, so that they can be reused.
            This requires more memory, but reduces the file size
            of the resulting PDF document.
            </remarks>
            <returns>
            this
            <c>WriterProperties</c>
            instance
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.WriterProperties.AddXmpMetadata">
            <summary>
            If true, default XMPMetadata based on
            <see cref="T:iText.Kernel.Pdf.PdfDocumentInfo"/>
            will be added.
            </summary>
            <returns>
            this
            <c>WriterProperties</c>
            instance
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.WriterProperties.SetCompressionLevel(System.Int32)">
            <summary>Defines the level of compression for the document.</summary>
            <remarks>
            Defines the level of compression for the document.
            See
            <see cref="T:iText.Kernel.Pdf.CompressionConstants"/>
            </remarks>
            <param name="compressionLevel"/>
            <returns>
            this
            <c>WriterProperties</c>
            instance
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.WriterProperties.SetFullCompressionMode(System.Boolean)">
            <summary>Defines if full compression mode is enabled.</summary>
            <remarks>
            Defines if full compression mode is enabled. If enabled, not only the content of the pdf document will be
            compressed, but also the pdf document inner structure.
            </remarks>
            <param name="fullCompressionMode">true - to enable full compression mode, false to disable it</param>
            <returns>
            this
            <c>WriterProperties</c>
            instance
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Pdf.WriterProperties.SetStandardEncryption(System.Byte[],System.Byte[],System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Pdf.WriterProperties.SetPublicKeyEncryption(Org.BouncyCastle.X509.X509Certificate[],System.Int32[],System.Int32)" -->
        <member name="M:iText.Kernel.Pdf.WriterProperties.SetInitialDocumentId(iText.Kernel.Pdf.PdfString)">
            <summary>The /ID entry of a document contains an array with two entries.</summary>
            <remarks>
            The /ID entry of a document contains an array with two entries. The first one (initial id) represents the initial document id.
            It's a permanent identifier based on the contents of the file at the time it was originally created
            and does not change when the file is incrementally updated.
            To help ensure the uniqueness of file identifiers, it is recommend to be computed by means of a message digest algorithm such as MD5.
            iText will by default keep the existing initial id. But if you'd like you can set this id yourself using this setter.
            </remarks>
            <param name="initialDocumentId">the new initial document id</param>
            <returns>
            this
            <c>WriterProperties</c>
            instance
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.WriterProperties.SetModifiedDocumentId(iText.Kernel.Pdf.PdfString)">
            <summary>The /ID entry of a document contains an array with two entries.</summary>
            <remarks>
            The /ID entry of a document contains an array with two entries.
            The second one (modified id) should be the same entry, unless the document has been modified. iText will by default generate
            a modified id. But if you'd like you can set this id yourself using this setter.
            </remarks>
            <param name="modifiedDocumentId">the new modified document id</param>
            <returns>
            this
            <c>WriterProperties</c>
            instance
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.WriterProperties.UseDebugMode">
            <summary>This activates debug mode with pdfDebug tool.</summary>
            <remarks>
            This activates debug mode with pdfDebug tool.
            It causes additional overhead of duplicating document bytes into memory, so use it careful.
            NEVER use it in production or in any other cases except pdfDebug.
            </remarks>
            <returns>
            this
            <c>WriterProperties</c>
            instance
            </returns>
        </member>
        <member name="T:iText.Kernel.Pdf.Xobject.PdfFormXObject">
            <summary>A wrapper for Form XObject.</summary>
            <remarks>A wrapper for Form XObject. ISO 32000-1, 8.10 FormXObjects.</remarks>
        </member>
        <member name="T:iText.Kernel.Pdf.Xobject.PdfXObject">
            <summary>An abstract wrapper for supported types of XObject.</summary>
            <seealso cref="T:iText.Kernel.Pdf.Xobject.PdfFormXObject"/>
            <seealso cref="T:iText.Kernel.Pdf.Xobject.PdfImageXObject"/>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfXObject.MakeXObject(iText.Kernel.Pdf.PdfStream)">
            <summary>
            Create
            <see cref="T:iText.Kernel.Pdf.Xobject.PdfFormXObject"/>
            or
            <see cref="T:iText.Kernel.Pdf.Xobject.PdfImageXObject"/>
            by
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            .
            </summary>
            <param name="stream">
            
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            with either
            <see cref="F:iText.Kernel.Pdf.PdfName.Form"/>
            or
            <see cref="F:iText.Kernel.Pdf.PdfName.Image"/>
            
            <see cref="F:iText.Kernel.Pdf.PdfName.Subtype"/>
            </param>
            <returns>
            either
            <see cref="T:iText.Kernel.Pdf.Xobject.PdfFormXObject"/>
            or
            <see cref="T:iText.Kernel.Pdf.Xobject.PdfImageXObject"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfXObject.SetLayer(iText.Kernel.Pdf.Layer.IPdfOCG)">
            <summary>Sets the layer this XObject belongs to.</summary>
            <param name="layer">the layer this XObject belongs to.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfXObject.GetWidth">
            <summary>Gets width of XObject.</summary>
            <returns>float value.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfXObject.GetHeight">
            <summary>Gets height of XObject.</summary>
            <returns>float value.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfXObject.IsWrappedObjectMustBeIndirect">
            <summary><inheritDoc/></summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfFormXObject.#ctor(iText.Kernel.Geom.Rectangle)">
            <summary>Creates a new instance of Form XObject.</summary>
            <param name="bBox">the form XObject’s bounding box.</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfFormXObject.#ctor(iText.Kernel.Pdf.PdfStream)">
            <summary>
            Create
            <see cref="T:iText.Kernel.Pdf.Xobject.PdfFormXObject"/>
            instance by
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            .
            Note, this constructor doesn't perform any additional checks
            </summary>
            <param name="pdfStream">
            
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            with Form XObject.
            </param>
            <seealso cref="M:iText.Kernel.Pdf.Xobject.PdfXObject.MakeXObject(iText.Kernel.Pdf.PdfStream)"/>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfFormXObject.#ctor(iText.Kernel.Pdf.PdfPage)">
            <summary>Creates form XObject from page content.</summary>
            <remarks>
            Creates form XObject from page content.
            The page shall be from the document, to which FormXObject will be added.
            </remarks>
            <param name="page">
            an instance of
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfFormXObject.#ctor(iText.Kernel.Pdf.Canvas.Wmf.WmfImageData,iText.Kernel.Pdf.PdfDocument)">
            <summary>
            Creates a form XObject from
            <see cref="T:iText.Kernel.Pdf.Canvas.Wmf.WmfImageData"/>
            .
            Unlike other images,
            <see cref="T:iText.Kernel.Pdf.Canvas.Wmf.WmfImageData"/>
            images are represented as
            <see cref="T:iText.Kernel.Pdf.Xobject.PdfFormXObject"/>
            , not as
            <see cref="T:iText.Kernel.Pdf.Xobject.PdfImageXObject"/>
            .
            </summary>
            <param name="image">image to create form object from</param>
            <param name="pdfDocument">document instance which is needed for writing form stream contents</param>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfFormXObject.GetResources">
            <summary>
            Gets
            <see cref="T:iText.Kernel.Pdf.PdfResources"/>
            of the Form XObject.
            Note, if there is no resources, a new instance will be created.
            </summary>
            <returns>
            not null instance of
            <see cref="T:iText.Kernel.Pdf.PdfResources"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfFormXObject.GetBBox">
            <summary>
            Gets Form XObject's BBox,
            <see cref="F:iText.Kernel.Pdf.PdfName.BBox"/>
            key.
            </summary>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            , that represents
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfFormXObject.SetBBox(iText.Kernel.Pdf.PdfArray)">
            <summary>
            Sets Form XObject's BBox,
            <see cref="F:iText.Kernel.Pdf.PdfName.BBox"/>
            key.
            </summary>
            <param name="bBox">
            a
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            , that represents
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            .
            </param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfFormXObject.SetGroup(iText.Kernel.Pdf.Xobject.PdfTransparencyGroup)">
            <summary>
            Sets a group attributes dictionary indicating that the contents of the form XObject
            shall be treated as a group and specifying the attributes of that group.
            </summary>
            <remarks>
            Sets a group attributes dictionary indicating that the contents of the form XObject
            shall be treated as a group and specifying the attributes of that group.
            <see cref="F:iText.Kernel.Pdf.PdfName.Group"/>
            key.
            </remarks>
            <param name="transparency">
            instance of
            <see cref="T:iText.Kernel.Pdf.Xobject.PdfTransparencyGroup"/>
            .
            </param>
            <returns>object itself.</returns>
            <seealso cref="T:iText.Kernel.Pdf.Xobject.PdfTransparencyGroup"/>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfFormXObject.GetWidth">
            <summary>Gets width based on XObject's BBox.</summary>
            <returns>float value.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfFormXObject.GetHeight">
            <summary>Gets height based on XObject's BBox.</summary>
            <returns>float value.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfFormXObject.Flush">
            <summary>
            To manually flush a
            <c>PdfObject</c>
            behind this wrapper, you have to ensure
            that this object is added to the document, i.e. it has an indirect reference.
            Basically this means that before flushing you need to explicitly call
            <see cref="M:iText.Kernel.Pdf.PdfObjectWrapper`1.MakeIndirect(iText.Kernel.Pdf.PdfDocument)"/>
            .
            For example: wrapperInstance.makeIndirect(document).flush();
            Note that not every wrapper require this, only those that have such warning in documentation.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfFormXObject.SetProcessColorModel(iText.Kernel.Pdf.PdfName)">
            <summary>
            Sets process color model for trap network appearance,
            <see cref="F:iText.Kernel.Pdf.PdfName.PCM"/>
            key.
            </summary>
            <param name="model">
            shall be one of the valid values:
            <see cref="F:iText.Kernel.Pdf.PdfName.DeviceGray"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.DeviceRGB"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.DeviceCMYK"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.DeviceCMY"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.DeviceRGBK"/>
            , and
            <see cref="F:iText.Kernel.Pdf.PdfName.DeviceN"/>
            .
            </param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfFormXObject.GetProcessColorModel">
            <summary>
            Gets process color model of trap network appearance,
            <see cref="F:iText.Kernel.Pdf.PdfName.PCM"/>
            key.
            </summary>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            instance, possible values:
            <see cref="F:iText.Kernel.Pdf.PdfName.DeviceGray"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.DeviceRGB"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.DeviceCMYK"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.DeviceCMY"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.DeviceRGBK"/>
            , and
            <see cref="F:iText.Kernel.Pdf.PdfName.DeviceN"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfFormXObject.SetSeparationColorNames(iText.Kernel.Pdf.PdfArray)">
            <summary>
            Sets separation color names for the trap network appearance,
            <see cref="F:iText.Kernel.Pdf.PdfName.SeparationColorNames"/>
            key.
            </summary>
            <param name="colorNames">
            an array of names identifying the colorants that were assumed
            when the trap network appearance was created.
            </param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfFormXObject.GetSeparationColorNames">
            <summary>
            Gets separation color names of trap network appearance,
            <see cref="F:iText.Kernel.Pdf.PdfName.SeparationColorNames"/>
            key.
            </summary>
            <returns>
            an
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            of names identifying the colorants.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfFormXObject.SetTrapRegions(iText.Kernel.Pdf.PdfArray)">
            <summary>
            Sets an array of <b>TrapRegion</b> objects defining the page’s trapping zones
            and the associated trapping parameters, as described in Adobe Technical Note #5620,
            Portable Job Ticket Format.
            </summary>
            <remarks>
            Sets an array of <b>TrapRegion</b> objects defining the page’s trapping zones
            and the associated trapping parameters, as described in Adobe Technical Note #5620,
            Portable Job Ticket Format.
            <see cref="F:iText.Kernel.Pdf.PdfName.TrapRegions"/>
            key.
            </remarks>
            <param name="regions">
            A
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            of indirect references to <b>TrapRegion</b> objects.
            </param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfFormXObject.GetTrapRegions">
            <summary>
            Gets an array of <b>TrapRegion</b> objects defining the page’s trapping zones
            and the associated trapping parameters, as described in Adobe Technical Note #5620,
            Portable Job Ticket Format.
            </summary>
            <remarks>
            Gets an array of <b>TrapRegion</b> objects defining the page’s trapping zones
            and the associated trapping parameters, as described in Adobe Technical Note #5620,
            Portable Job Ticket Format.
            <see cref="F:iText.Kernel.Pdf.PdfName.TrapRegions"/>
            key.
            </remarks>
            <returns>
            A
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            of indirect references to <b>TrapRegion</b> objects.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfFormXObject.SetTrapStyles(iText.Kernel.Pdf.PdfString)">
            <summary>Sets a human-readable text string that described this trap network to the user.</summary>
            <remarks>
            Sets a human-readable text string that described this trap network to the user.
            <see cref="F:iText.Kernel.Pdf.PdfName.TrapStyles"/>
            key.
            </remarks>
            <param name="trapStyles">
            a
            <see cref="T:iText.Kernel.Pdf.PdfString"/>
            value.
            </param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfFormXObject.GetTrapStyles">
            <summary>Gets a human-readable text string that described this trap network to the user.</summary>
            <remarks>
            Gets a human-readable text string that described this trap network to the user.
            <see cref="F:iText.Kernel.Pdf.PdfName.TrapStyles"/>
            key.
            </remarks>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.PdfString"/>
            value.
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfFormXObject.SetMarkStyle(iText.Kernel.Pdf.PdfString)">
            <summary>Sets a text string representing the printer’s mark in human-readable form.</summary>
            <param name="markStyle">a string value.</param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfFormXObject.GetMarkStyle">
            <summary>Gets a text string representing the printer’s mark in human-readable form.</summary>
            <returns>a string value.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfFormXObject.Put(iText.Kernel.Pdf.PdfName,iText.Kernel.Pdf.PdfObject)">
            <summary>Puts the value into Image XObject dictionary and associates it with the specified key.</summary>
            <remarks>
            Puts the value into Image XObject dictionary and associates it with the specified key.
            If the key is already present, it will override the old value with the specified one.
            </remarks>
            <param name="key">key to insert or to override</param>
            <param name="value">the value to associate with the specified key</param>
            <returns>object itself.</returns>
        </member>
        <member name="T:iText.Kernel.Pdf.Xobject.PdfImageXObject">
            <summary>A wrapper for Image XObject.</summary>
            <remarks>A wrapper for Image XObject. ISO 32000-1, 8.9 Images.</remarks>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfImageXObject.#ctor(iText.IO.Image.ImageData)">
            <summary>Creates Image XObject by image.</summary>
            <param name="image">
            
            <see cref="T:iText.IO.Image.ImageData"/>
            with actual image data.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfImageXObject.#ctor(iText.IO.Image.ImageData,iText.Kernel.Pdf.Xobject.PdfImageXObject)">
            <summary>Creates Image XObject by image.</summary>
            <param name="image">
            
            <see cref="T:iText.IO.Image.ImageData"/>
            with actual image data.
            </param>
            <param name="imageMask">
            
            <see cref="T:iText.Kernel.Pdf.Xobject.PdfImageXObject"/>
            with image mask.
            </param>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfImageXObject.#ctor(iText.Kernel.Pdf.PdfStream)">
            <summary>
            Create
            <see cref="T:iText.Kernel.Pdf.Xobject.PdfImageXObject"/>
            instance by
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            .
            Note, this constructor doesn't perform any additional checks
            </summary>
            <param name="pdfStream">
            
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            with Image XObject.
            </param>
            <seealso cref="M:iText.Kernel.Pdf.Xobject.PdfXObject.MakeXObject(iText.Kernel.Pdf.PdfStream)"/>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfImageXObject.GetWidth">
            <summary>
            Gets width of image,
            <c>Width</c>
            key.
            </summary>
            <returns>float value.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfImageXObject.GetHeight">
            <summary>
            Gets height of image,
            <c>Height</c>
            key.
            </summary>
            <returns>float value.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfImageXObject.Flush">
            <summary>
            To manually flush a
            <c>PdfObject</c>
            behind this wrapper, you have to ensure
            that this object is added to the document, i.e. it has an indirect reference.
            Basically this means that before flushing you need to explicitly call
            <see cref="M:iText.Kernel.Pdf.PdfObjectWrapper`1.MakeIndirect(iText.Kernel.Pdf.PdfDocument)"/>
            .
            For example: wrapperInstance.makeIndirect(document).flush();
            Note, that not every wrapper require this, only those that have such warning in documentation.
            </summary>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfImageXObject.CopyTo(iText.Kernel.Pdf.PdfDocument)">
            <summary>Copy Image XObject to the specified document.</summary>
            <param name="document">target document</param>
            <returns>
            just created instance of
            <see cref="T:iText.Kernel.Pdf.Xobject.PdfImageXObject"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfImageXObject.GetImageBytes">
            <summary>Gets decoded image bytes.</summary>
            <returns>byte array.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfImageXObject.GetImageBytes(System.Boolean)">
            <summary>Gets image bytes.</summary>
            <remarks>
            Gets image bytes.
            Note,
            <see cref="F:iText.Kernel.Pdf.PdfName.DCTDecode"/>
            ,
            <see cref="F:iText.Kernel.Pdf.PdfName.JBIG2Decode"/>
            and
            <see cref="F:iText.Kernel.Pdf.PdfName.JPXDecode"/>
            filters will be ignored.
            </remarks>
            <param name="decoded">
            if
            <see langword="true"/>
            , decodes stream bytes.
            </param>
            <returns>byte array.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfImageXObject.IdentifyImageType">
            <summary>
            Identifies the type of the image that is stored in the bytes of this
            <see cref="T:iText.Kernel.Pdf.Xobject.PdfImageXObject"/>
            .
            Note that this has nothing to do with the original type of the image. For instance, the return value
            of this method will never be
            <see cref="F:iText.IO.Image.ImageType.PNG"/>
            as we loose this information when converting a
            PNG image into something that can be put into a PDF file.
            The possible values are:
            <see cref="F:iText.IO.Image.ImageType.JPEG"/>
            ,
            <see cref="F:iText.IO.Image.ImageType.JPEG2000"/>
            ,
            <see cref="F:iText.IO.Image.ImageType.JBIG2"/>
            ,
            <see cref="F:iText.IO.Image.ImageType.TIFF"/>
            ,
            <see cref="F:iText.IO.Image.ImageType.PNG"/>
            </summary>
            <returns>the identified type of image</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfImageXObject.IdentifyImageFileExtension">
            <summary>
            Identifies recommended file extension to store the bytes of this
            <see cref="T:iText.Kernel.Pdf.Xobject.PdfImageXObject"/>
            .
            Possible values are: 'png', 'jpg', 'jp2', 'tif', 'jbig2'.
            This extension can later be used together with the result of
            <see cref="M:iText.Kernel.Pdf.Xobject.PdfImageXObject.GetImageBytes"/>
            .
            </summary>
            <returns>
            a
            <see cref="T:System.String"/>
            with recommended file extension
            </returns>
            <seealso cref="M:iText.Kernel.Pdf.Xobject.PdfImageXObject.IdentifyImageType"/>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfImageXObject.Put(iText.Kernel.Pdf.PdfName,iText.Kernel.Pdf.PdfObject)">
            <summary>Puts the value into Image XObject dictionary and associates it with the specified key.</summary>
            <remarks>
            Puts the value into Image XObject dictionary and associates it with the specified key.
            If the key is already present, it will override the old value with the specified one.
            </remarks>
            <param name="key">key to insert or to override</param>
            <param name="value">the value to associate with the specified key</param>
            <returns>object itself.</returns>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfImageXObject.DecodeTiffAndPngBytes(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfImageXObject.FindColorspace(iText.Kernel.Pdf.PdfObject,System.Boolean)">
            <summary>Sets state of this object according to the color space</summary>
            <param name="colorspace">the colorspace to use</param>
            <param name="allowIndexed">whether indexed color spaces will be resolved (used for recursive call)</param>
            <exception cref="T:System.IO.IOException">if there is a problem with reading from the underlying stream</exception>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfTransparencyGroup.SetIsolated(System.Boolean)">
            <summary>Determining the initial backdrop against which its stack is composited.</summary>
            <param name="isolated"/>
        </member>
        <member name="M:iText.Kernel.Pdf.Xobject.PdfTransparencyGroup.SetKnockout(System.Boolean)">
            <summary>Determining whether the objects within the stack are composited with one another or only with the group's backdrop.
                </summary>
            <param name="knockout"/>
        </member>
        <member name="T:iText.Kernel.Utils.CompareTool">
            <summary>
            This class provides means to compare two PDF files both by content and visually
            and gives the report of their differences.
            </summary>
            <remarks>
            This class provides means to compare two PDF files both by content and visually
            and gives the report of their differences.
            <br/><br/>
            For visual comparison it uses external tools: Ghostscript and ImageMagick, which
            should be installed on your machine. To allow CompareTool to use them, you need
            to pass either java properties or environment variables with names "gsExec" and
            "compareExec", which would contain the paths to the executables of correspondingly
            Ghostscript and ImageMagick tools.
            <br/><br/>
            CompareTool class was mainly designed for the testing purposes of iText in order to
            ensure that the same code produces the same PDF document. For this reason you will
            often encounter such parameter names as "outDoc" and "cmpDoc" which stand for output
            document and document-for-comparison. The first one is viewed as the current result,
            and the second one is referred as normal or ideal result. OutDoc is compared to the
            ideal cmpDoc. Therefore all reports of the comparison are in the form: "Expected ...,
            but was ...". This should be interpreted in the following way: "expected" part stands
            for the content of the cmpDoc and "but was" part stands for the content of the outDoc.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.#ctor">
            <summary>Creates an instance of the CompareTool.</summary>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.CompareByCatalog(iText.Kernel.Pdf.PdfDocument,iText.Kernel.Pdf.PdfDocument)">
            <summary>
            Compares two PDF documents by content starting from Catalog dictionary and then recursively comparing
            corresponding objects which are referenced from it.
            </summary>
            <remarks>
            Compares two PDF documents by content starting from Catalog dictionary and then recursively comparing
            corresponding objects which are referenced from it. You can roughly imagine it as depth-first traversal
            of the two trees that represent pdf objects structure of the documents.
            <br/><br/>
            The main difference between this method and the
            <see cref="M:iText.Kernel.Utils.CompareTool.CompareByContent(System.String,System.String,System.String,System.String)"/>
            methods is the return value. This method returns a
            <see cref="T:iText.Kernel.Utils.CompareTool.CompareResult"/>
            class instance, which could be used
            in code, however compareByContent methods in case of the differences simply return String value, which could
            only be printed. Also, keep in mind that this method doesn't perform visual comparison of the documents.
            <br/><br/>
            For more explanations about what is outDoc and cmpDoc see last paragraph of the
            <see cref="T:iText.Kernel.Utils.CompareTool"/>
            class description.
            </remarks>
            <param name="outDocument">the absolute path to the output file, which is to be compared to cmp-file.</param>
            <param name="cmpDocument">the absolute path to the cmp-file, which is to be compared to output file.</param>
            <returns>
            the report of comparison of two files in the form of the custom class instance.
            See
            <see cref="T:iText.Kernel.Utils.CompareTool.CompareResult"/>
            for more info.
            </returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Utils.CompareTool.DisableCachedPagesComparison" -->
        <member name="M:iText.Kernel.Utils.CompareTool.SetCompareByContentErrorsLimit(System.Int32)">
            <summary>Sets the maximum errors count which will be returned as the result of the comparison.</summary>
            <param name="compareByContentMaxErrorCount">the errors count.</param>
            <returns>this CompareTool instance.</returns>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.SetGenerateCompareByContentXmlReport(System.Boolean)">
            <summary>Enables or disables the generation of the comparison report in the form of the xml document.</summary>
            <remarks>
            Enables or disables the generation of the comparison report in the form of the xml document.
            <br/>
            IMPORTANT NOTE: this flag affect only the comparison made by compareByContent methods!
            </remarks>
            <param name="generateCompareByContentXmlReport">true to enable xml report generation, false - to disable.</param>
            <returns>this CompareTool instance.</returns>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.EnableEncryptionCompare">
            <summary>Enables the comparison of the encryption properties of the documents.</summary>
            <remarks>
            Enables the comparison of the encryption properties of the documents. Encryption properties comparison
            results are returned along with all other comparison results.
            <br/>
            IMPORTANT NOTE: this flag affect only the comparison made by compareByContent methods!
            </remarks>
            <returns>this CompareTool instance.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Utils.CompareTool.GetOutReaderProperties" -->
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Utils.CompareTool.GetCmpReaderProperties" -->
        <member name="M:iText.Kernel.Utils.CompareTool.CompareVisually(System.String,System.String,System.String,System.String)">
            <summary>Compares two documents visually.</summary>
            <remarks>
            Compares two documents visually. For the comparison two external tools are used: Ghostscript and ImageMagick.
            For more info about needed configuration for visual comparison process see
            <see cref="T:iText.Kernel.Utils.CompareTool"/>
            class description.
            <br/>
            During comparison for every page of two documents an image file will be created in the folder specified by
            outPath absolute path. Then those page images will be compared and if there are any differences for some pages,
            another image file will be created with marked differences on it.
            </remarks>
            <param name="outPdf">the absolute path to the output file, which is to be compared to cmp-file.</param>
            <param name="cmpPdf">the absolute path to the cmp-file, which is to be compared to output file.</param>
            <param name="outPath">the absolute path to the folder, which will be used to store image files for visual comparison.
                </param>
            <param name="differenceImagePrefix">file name prefix for image files with marked differences if there is any.
                </param>
            <returns>string containing list of the pages that are visually different, or null if there are no visual differences.
                </returns>
            <exception cref="T:System.Exception"/>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.CompareVisually(System.String,System.String,System.String,System.String,System.Collections.Generic.IDictionary{System.Int32,System.Collections.Generic.IList{iText.Kernel.Geom.Rectangle}})">
            <summary>Compares two documents visually.</summary>
            <remarks>
            Compares two documents visually. For the comparison two external tools are used: Ghostscript and ImageMagick.
            For more info about needed configuration for visual comparison process see
            <see cref="T:iText.Kernel.Utils.CompareTool"/>
            class description.
            <br/>
            During comparison for every page of two documents an image file will be created in the folder specified by
            outPath absolute path. Then those page images will be compared and if there are any differences for some pages,
            another image file will be created with marked differences on it.
            <br/>
            It is possible to ignore certain areas of the document pages during visual comparison. This is useful for example
            in case if documents should be the same except certain page area with date on it. In this case, in the folder
            specified by the outPath, new pdf documents will be created with the black rectangles at the specified ignored
            areas, and visual comparison will be performed on these new documents.
            </remarks>
            <param name="outPdf">the absolute path to the output file, which is to be compared to cmp-file.</param>
            <param name="cmpPdf">the absolute path to the cmp-file, which is to be compared to output file.</param>
            <param name="outPath">the absolute path to the folder, which will be used to store image files for visual comparison.
                </param>
            <param name="differenceImagePrefix">file name prefix for image files with marked differences if there is any.
                </param>
            <param name="ignoredAreas">a map with one-based page numbers as keys and lists of ignored rectangles as values.
                </param>
            <returns>string containing list of the pages that are visually different, or null if there are no visual differences.
                </returns>
            <exception cref="T:System.Exception"/>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.CompareByContent(System.String,System.String,System.String,System.String)">
            <summary>
            Compares two PDF documents by content starting from page dictionaries and then recursively comparing
            corresponding objects which are referenced from them.
            </summary>
            <remarks>
            Compares two PDF documents by content starting from page dictionaries and then recursively comparing
            corresponding objects which are referenced from them. You can roughly imagine it as depth-first traversal
            of the two trees that represent pdf objects structure of the documents.
            <br/><br/>
            Unlike
            <see cref="M:iText.Kernel.Utils.CompareTool.CompareByCatalog(iText.Kernel.Pdf.PdfDocument,iText.Kernel.Pdf.PdfDocument)"/>
            this method performs content comparison page by page
            and doesn't compare the tag structure, acroforms and all other things that doesn't belong to specific pages.
            <br/>
            When comparison by content is finished, if any differences were found, visual comparison is automatically started.
            For more info see
            <see cref="M:iText.Kernel.Utils.CompareTool.CompareVisually(System.String,System.String,System.String,System.String)"/>
            .
            <br/><br/>
            For more explanations about what is outPdf and cmpPdf see last paragraph of the
            <see cref="T:iText.Kernel.Utils.CompareTool"/>
            class description.
            </remarks>
            <param name="outPdf">the absolute path to the output file, which is to be compared to cmp-file.</param>
            <param name="cmpPdf">the absolute path to the cmp-file, which is to be compared to output file.</param>
            <param name="outPath">the absolute path to the folder, which will be used to store image files for visual comparison.
                </param>
            <param name="differenceImagePrefix">file name prefix for image files with marked visual differences if there is any.
                </param>
            <returns>
            string containing text report of the encountered content differences and also list of the pages that are
            visually different, or null if there are no content and therefore no visual differences.
            </returns>
            <exception cref="T:System.Exception"/>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.CompareByContent(System.String,System.String,System.String,System.String,System.Byte[],System.Byte[])">
            <summary>This method overload is used to compare two encrypted PDF documents.</summary>
            <remarks>
            This method overload is used to compare two encrypted PDF documents. Document passwords are passed with
            outPass and cmpPass parameters.
            <br/><br/>
            Compares two PDF documents by content starting from page dictionaries and then recursively comparing
            corresponding objects which are referenced from them. You can roughly imagine it as depth-first traversal
            of the two trees that represent pdf objects structure of the documents.
            <br/><br/>
            Unlike
            <see cref="M:iText.Kernel.Utils.CompareTool.CompareByCatalog(iText.Kernel.Pdf.PdfDocument,iText.Kernel.Pdf.PdfDocument)"/>
            this method performs content comparison page by page
            and doesn't compare the tag structure, acroforms and all other things that doesn't belong to specific pages.
            <br/>
            When comparison by content is finished, if any differences were found, visual comparison is automatically started.
            For more info see
            <see cref="M:iText.Kernel.Utils.CompareTool.CompareVisually(System.String,System.String,System.String,System.String)"/>
            .
            <br/><br/>
            For more explanations about what is outPdf and cmpPdf see last paragraph of the
            <see cref="T:iText.Kernel.Utils.CompareTool"/>
            class description.
            </remarks>
            <param name="outPdf">the absolute path to the output file, which is to be compared to cmp-file.</param>
            <param name="cmpPdf">the absolute path to the cmp-file, which is to be compared to output file.</param>
            <param name="outPath">the absolute path to the folder, which will be used to store image files for visual comparison.
                </param>
            <param name="differenceImagePrefix">file name prefix for image files with marked visual differences if there is any.
                </param>
            <param name="outPass">password for the encrypted document specified by the outPdf absolute path.</param>
            <param name="cmpPass">password for the encrypted document specified by the cmpPdf absolute path.</param>
            <returns>
            string containing text report of the encountered content differences and also list of the pages that are
            visually different, or null if there are no content and therefore no visual differences.
            </returns>
            <exception cref="T:System.Exception"/>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.CompareByContent(System.String,System.String,System.String,System.String,System.Collections.Generic.IDictionary{System.Int32,System.Collections.Generic.IList{iText.Kernel.Geom.Rectangle}})">
            <summary>
            Compares two PDF documents by content starting from page dictionaries and then recursively comparing
            corresponding objects which are referenced from them.
            </summary>
            <remarks>
            Compares two PDF documents by content starting from page dictionaries and then recursively comparing
            corresponding objects which are referenced from them. You can roughly imagine it as depth-first traversal
            of the two trees that represent pdf objects structure of the documents.
            <br/><br/>
            Unlike
            <see cref="M:iText.Kernel.Utils.CompareTool.CompareByCatalog(iText.Kernel.Pdf.PdfDocument,iText.Kernel.Pdf.PdfDocument)"/>
            this method performs content comparison page by page
            and doesn't compare the tag structure, acroforms and all other things that doesn't belong to specific pages.
            <br/>
            When comparison by content is finished, if any differences were found, visual comparison is automatically started.
            For more info see
            <see cref="!:CompareVisually(System.String, System.String, System.String, System.String, System.Collections.Generic.IDictionary&lt;K, V&gt;)&#xA;                "/>
            .
            <br/><br/>
            For more explanations about what is outPdf and cmpPdf see last paragraph of the
            <see cref="T:iText.Kernel.Utils.CompareTool"/>
            class description.
            </remarks>
            <param name="outPdf">the absolute path to the output file, which is to be compared to cmp-file.</param>
            <param name="cmpPdf">the absolute path to the cmp-file, which is to be compared to output file.</param>
            <param name="outPath">the absolute path to the folder, which will be used to store image files for visual comparison.
                </param>
            <param name="differenceImagePrefix">file name prefix for image files with marked visual differences if there is any.
                </param>
            <param name="ignoredAreas">a map with one-based page numbers as keys and lists of ignored rectangles as values.
                </param>
            <returns>
            string containing text report of the encountered content differences and also list of the pages that are
            visually different, or null if there are no content and therefore no visual differences.
            </returns>
            <exception cref="T:System.Exception"/>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.CompareByContent(System.String,System.String,System.String,System.String,System.Collections.Generic.IDictionary{System.Int32,System.Collections.Generic.IList{iText.Kernel.Geom.Rectangle}},System.Byte[],System.Byte[])">
            <summary>This method overload is used to compare two encrypted PDF documents.</summary>
            <remarks>
            This method overload is used to compare two encrypted PDF documents. Document passwords are passed with
            outPass and cmpPass parameters.
            <br/><br/>
            Compares two PDF documents by content starting from page dictionaries and then recursively comparing
            corresponding objects which are referenced from them. You can roughly imagine it as depth-first traversal
            of the two trees that represent pdf objects structure of the documents.
            <br/><br/>
            Unlike
            <see cref="M:iText.Kernel.Utils.CompareTool.CompareByCatalog(iText.Kernel.Pdf.PdfDocument,iText.Kernel.Pdf.PdfDocument)"/>
            this method performs content comparison page by page
            and doesn't compare the tag structure, acroforms and all other things that doesn't belong to specific pages.
            <br/>
            When comparison by content is finished, if any differences were found, visual comparison is automatically started.
            For more info see
            <see cref="!:CompareVisually(System.String, System.String, System.String, System.String, System.Collections.Generic.IDictionary&lt;K, V&gt;)&#xA;                "/>
            .
            <br/><br/>
            For more explanations about what is outPdf and cmpPdf see last paragraph of the
            <see cref="T:iText.Kernel.Utils.CompareTool"/>
            class description.
            </remarks>
            <param name="outPdf">the absolute path to the output file, which is to be compared to cmp-file.</param>
            <param name="cmpPdf">the absolute path to the cmp-file, which is to be compared to output file.</param>
            <param name="outPath">the absolute path to the folder, which will be used to store image files for visual comparison.
                </param>
            <param name="differenceImagePrefix">file name prefix for image files with marked visual differences if there is any.
                </param>
            <param name="ignoredAreas">a map with one-based page numbers as keys and lists of ignored rectangles as values.
                </param>
            <param name="outPass">password for the encrypted document specified by the outPdf absolute path.</param>
            <param name="cmpPass">password for the encrypted document specified by the cmpPdf absolute path.</param>
            <returns>
            string containing text report of the encountered content differences and also list of the pages that are
            visually different, or null if there are no content and therefore no visual differences.
            </returns>
            <exception cref="T:System.Exception"/>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.CompareDictionaries(iText.Kernel.Pdf.PdfDictionary,iText.Kernel.Pdf.PdfDictionary)">
            <summary>Simple method that compares two given PdfDictionaries by content.</summary>
            <remarks>
            Simple method that compares two given PdfDictionaries by content. This is "deep" comparing, which means that all
            nested objects are also compared by content.
            </remarks>
            <param name="outDict">dictionary to compare.</param>
            <param name="cmpDict">dictionary to compare.</param>
            <returns>true if dictionaries are equal by content, otherwise false.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.CompareStreams(iText.Kernel.Pdf.PdfStream,iText.Kernel.Pdf.PdfStream)">
            <summary>Simple method that compares two given PdfStreams by content.</summary>
            <remarks>
            Simple method that compares two given PdfStreams by content. This is "deep" comparing, which means that all
            nested objects are also compared by content.
            </remarks>
            <param name="outStream">stream to compare.</param>
            <param name="cmpStream">stream to compare.</param>
            <returns>true if stream are equal by content, otherwise false.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.CompareArrays(iText.Kernel.Pdf.PdfArray,iText.Kernel.Pdf.PdfArray)">
            <summary>Simple method that compares two given PdfArrays by content.</summary>
            <remarks>
            Simple method that compares two given PdfArrays by content. This is "deep" comparing, which means that all
            nested objects are also compared by content.
            </remarks>
            <param name="outArray">array to compare.</param>
            <param name="cmpArray">array to compare.</param>
            <returns>true if arrays are equal by content, otherwise false.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.CompareNames(iText.Kernel.Pdf.PdfName,iText.Kernel.Pdf.PdfName)">
            <summary>Simple method that compares two given PdfNames.</summary>
            <param name="outName">name to compare.</param>
            <param name="cmpName">name to compare.</param>
            <returns>true if names are equal, otherwise false.</returns>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.CompareNumbers(iText.Kernel.Pdf.PdfNumber,iText.Kernel.Pdf.PdfNumber)">
            <summary>Simple method that compares two given PdfNumbers.</summary>
            <param name="outNumber">number to compare.</param>
            <param name="cmpNumber">number to compare.</param>
            <returns>true if numbers are equal, otherwise false.</returns>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.CompareStrings(iText.Kernel.Pdf.PdfString,iText.Kernel.Pdf.PdfString)">
            <summary>Simple method that compares two given PdfStrings.</summary>
            <param name="outString">string to compare.</param>
            <param name="cmpString">string to compare.</param>
            <returns>true if strings are equal, otherwise false.</returns>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.CompareBooleans(iText.Kernel.Pdf.PdfBoolean,iText.Kernel.Pdf.PdfBoolean)">
            <summary>Simple method that compares two given PdfBooleans.</summary>
            <param name="outBoolean">boolean to compare.</param>
            <param name="cmpBoolean">boolean to compare.</param>
            <returns>true if booleans are equal, otherwise false.</returns>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.CompareXmp(System.String,System.String)">
            <summary>Compares xmp metadata of the two given PDF documents.</summary>
            <param name="outPdf">the absolute path to the output file, which xmp is to be compared to cmp-file.</param>
            <param name="cmpPdf">the absolute path to the cmp-file, which xmp is to be compared to output file.</param>
            <returns>text report of the xmp differences, or null if there are no differences.</returns>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.CompareXmp(System.String,System.String,System.Boolean)">
            <summary>Compares xmp metadata of the two given PDF documents.</summary>
            <param name="outPdf">the absolute path to the output file, which xmp is to be compared to cmp-file.</param>
            <param name="cmpPdf">the absolute path to the cmp-file, which xmp is to be compared to output file.</param>
            <param name="ignoreDateAndProducerProperties">
            true, if to ignore differences in date or producer xmp metadata
            properties.
            </param>
            <returns>text report of the xmp differences, or null if there are no differences.</returns>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.CompareXmls(System.Byte[],System.Byte[])">
            <summary>Utility method that provides simple comparison of the two xml files stored in byte arrays.</summary>
            <param name="xml1">first xml file data to compare.</param>
            <param name="xml2">second xml file data to compare.</param>
            <returns>true if xml structures are identical, false otherwise.</returns>
            <exception cref="!:Javax.Xml.Parsers.ParserConfigurationException"/>
            <exception cref="!:Org.Xml.Sax.SAXException"/>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.CompareXmls(System.String,System.String)">
            <summary>Utility method that provides simple comparison of the two xml files.</summary>
            <param name="xmlFilePath1">absolute path to the first xml file to compare.</param>
            <param name="xmlFilePath2">absolute path to the second xml file to compare.</param>
            <returns>true if xml structures are identical, false otherwise.</returns>
            <exception cref="!:Javax.Xml.Parsers.ParserConfigurationException"/>
            <exception cref="!:Org.Xml.Sax.SAXException"/>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.CompareDocumentInfo(System.String,System.String,System.Byte[],System.Byte[])">
            <summary>This method overload is used to compare two encrypted PDF documents.</summary>
            <remarks>
            This method overload is used to compare two encrypted PDF documents. Document passwords are passed with
            outPass and cmpPass parameters.
            <br/><br/>
            Compares document info dictionaries of two pdf documents.
            </remarks>
            <param name="outPdf">the absolute path to the output file, which info is to be compared to cmp-file info.</param>
            <param name="cmpPdf">the absolute path to the cmp-file, which info is to be compared to output file info.</param>
            <param name="outPass">password for the encrypted document specified by the outPdf absolute path.</param>
            <param name="cmpPass">password for the encrypted document specified by the cmpPdf absolute path.</param>
            <returns>text report of the differences in documents infos.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.CompareDocumentInfo(System.String,System.String)">
            <summary>Compares document info dictionaries of two pdf documents.</summary>
            <param name="outPdf">the absolute path to the output file, which info is to be compared to cmp-file info.</param>
            <param name="cmpPdf">the absolute path to the cmp-file, which info is to be compared to output file info.</param>
            <returns>text report of the differences in documents infos.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.CompareLinkAnnotations(System.String,System.String)">
            <summary>Compares if two documents has identical link annotations on corresponding pages.</summary>
            <param name="outPdf">the absolute path to the output file, which links are to be compared to cmp-file links.
                </param>
            <param name="cmpPdf">the absolute path to the cmp-file, which links are to be compared to output file links.
                </param>
            <returns>text report of the differences in documents links.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.CompareTagStructures(System.String,System.String)">
            <summary>Compares tag structures of the two PDF documents.</summary>
            <remarks>
            Compares tag structures of the two PDF documents.
            <br/>
            This method creates xml files in the same folder with outPdf file. These xml files contain documents tag structures
            converted into the xml structure. These xml files are compared if they are equal.
            </remarks>
            <param name="outPdf">the absolute path to the output file, which tags are to be compared to cmp-file tags.
                </param>
            <param name="cmpPdf">the absolute path to the cmp-file, which tags are to be compared to output file tags.
                </param>
            <returns>text report of the differences in documents tags.</returns>
            <exception cref="T:System.IO.IOException"/>
            <exception cref="!:Javax.Xml.Parsers.ParserConfigurationException"/>
            <exception cref="!:Org.Xml.Sax.SAXException"/>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.CompareVisually(System.String,System.String,System.Collections.Generic.IDictionary{System.Int32,System.Collections.Generic.IList{iText.Kernel.Geom.Rectangle}})">
            <exception cref="T:System.Exception"/>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.CompareVisually(System.String,System.String,System.Collections.Generic.IDictionary{System.Int32,System.Collections.Generic.IList{iText.Kernel.Geom.Rectangle}},System.Collections.Generic.IList{System.Int32})">
            <exception cref="T:System.IO.IOException"/>
            <exception cref="T:System.Exception"/>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.CompareImagesOfPdfs(System.String,System.String,System.Collections.Generic.IList{System.Int32})">
            <exception cref="T:System.IO.IOException"/>
            <exception cref="T:System.Exception"/>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.CreateIgnoredAreasPdfs(System.String,System.Collections.Generic.IDictionary{System.Int32,System.Collections.Generic.IList{iText.Kernel.Geom.Rectangle}})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.RunGhostScriptImageGeneration(System.String)">
            <summary>Runs ghostscript to create images of pdfs.</summary>
            <param name="outPath">Path to the output folder.</param>
            <exception cref="T:iText.Kernel.Utils.CompareTool.CompareToolExecutionException"/>
            <exception cref="T:System.IO.IOException"/>
            <exception cref="T:System.Exception"/>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.CompareByContent(System.String,System.String,System.Collections.Generic.IDictionary{System.Int32,System.Collections.Generic.IList{iText.Kernel.Geom.Rectangle}})">
            <exception cref="T:System.Exception"/>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.CompareVisuallyAndCombineReports(System.String,System.String,System.String,System.Collections.Generic.IDictionary{System.Int32,System.Collections.Generic.IList{iText.Kernel.Geom.Rectangle}},System.Collections.Generic.IList{System.Int32})">
            <exception cref="T:System.IO.IOException"/>
            <exception cref="T:System.Exception"/>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.CompareDocumentsEncryption(iText.Kernel.Pdf.PdfDocument,iText.Kernel.Pdf.PdfDocument,iText.Kernel.Utils.CompareTool.CompareResult)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.CompareStreams(System.IO.Stream,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.FindBytesDifference(System.Byte[],System.Byte[],System.Text.StringBuilder)">
            <returns>first difference offset</returns>
        </member>
        <member name="T:iText.Kernel.Utils.CompareTool.CompareResult">
            <summary>Class containing results of the comparison of two documents.</summary>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.CompareResult.#ctor(iText.Kernel.Utils.CompareTool,System.Int32)">
            <summary>Creates new empty instance of CompareResult with given limit of difference messages.</summary>
            <param name="messageLimit">maximum number of difference messages handled by this CompareResult.</param>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.CompareResult.IsOk">
            <summary>Is used to define if documents are considered equal after comparison.</summary>
            <returns>true if documents are equal, false otherwise.</returns>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.CompareResult.GetErrorCount">
            <summary>Returns number of differences between two documents met during comparison.</summary>
            <returns>number of differences.</returns>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.CompareResult.GetReport">
            <summary>Converts this CompareResult into text form.</summary>
            <returns>text report of the differences between two documents.</returns>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.CompareResult.GetDifferences">
            <summary>
            Returns map with
            <see cref="T:iText.Kernel.Utils.CompareTool.ObjectPath"/>
            as keys and difference descriptions as values.
            </summary>
            <returns>differences map which could be used to find in the document objects that are different.</returns>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.CompareResult.WriteReportToXml(System.IO.Stream)">
            <summary>Converts this CompareResult into xml form.</summary>
            <param name="stream">output stream to which xml report will be written.</param>
            <exception cref="!:Javax.Xml.Parsers.ParserConfigurationException"/>
            <exception cref="!:Javax.Xml.Transform.TransformerException"/>
        </member>
        <!-- Badly formed XML comment ignored for member "T:iText.Kernel.Utils.CompareTool.ObjectPath" -->
        <member name="M:iText.Kernel.Utils.CompareTool.ObjectPath.#ctor">
            <summary>Creates empty ObjectPath.</summary>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.ObjectPath.#ctor(iText.Kernel.Pdf.PdfIndirectReference,iText.Kernel.Pdf.PdfIndirectReference)">
            <summary>Creates ObjectPath with corresponding base objects in two documents.</summary>
            <param name="baseCmpObject">base object in cmp document.</param>
            <param name="baseOutObject">base object in out document.</param>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.ObjectPath.ResetDirectPath(iText.Kernel.Pdf.PdfIndirectReference,iText.Kernel.Pdf.PdfIndirectReference)">
            <summary>
            Creates a new ObjectPath instance with two new given base objects, which are supposed to be nested in the base
            objects of the current instance of the ObjectPath.
            </summary>
            <remarks>
            Creates a new ObjectPath instance with two new given base objects, which are supposed to be nested in the base
            objects of the current instance of the ObjectPath. This method is used to avoid infinite loop in case of
            circular references in pdf documents objects structure.
            <br/>
            Basically, this method creates copy of the current ObjectPath instance, but resets information of the direct
            paths, and also adds current ObjectPath instance base objects to the indirect references chain that denotes
            a path to the new base objects.
            </remarks>
            <param name="baseCmpObject">new base object in cmp document.</param>
            <param name="baseOutObject">new base object in out document.</param>
            <returns>
            new ObjectPath instance, which stores chain of the indirect references which were already met to get
            to the new base objects.
            </returns>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.ObjectPath.IsComparing(iText.Kernel.Pdf.PdfIndirectReference,iText.Kernel.Pdf.PdfIndirectReference)">
            <summary>This method is used to define if given objects were already met in the path to the current base objects.
                </summary>
            <remarks>
            This method is used to define if given objects were already met in the path to the current base objects.
            If this method returns true it basically means that we found a loop in the objects structure and that we
            already compared these objects.
            </remarks>
            <param name="cmpObject">cmp object to check if it was already met in base objects path.</param>
            <param name="outObject">out object to check if it was already met in base objects path.</param>
            <returns>true if given objects are contained in the path and therefore were already compared.</returns>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.ObjectPath.PushArrayItemToPath(System.Int32)">
            <summary>Adds array item to the direct path.</summary>
            <remarks>
            Adds array item to the direct path. See
            <see cref="T:iText.Kernel.Utils.CompareTool.ObjectPath.ArrayPathItem"/>
            .
            </remarks>
            <param name="index">index in the array of the direct object to be compared.</param>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.ObjectPath.PushDictItemToPath(iText.Kernel.Pdf.PdfName)">
            <summary>Adds dictionary item to the direct path.</summary>
            <remarks>
            Adds dictionary item to the direct path. See
            <see cref="T:iText.Kernel.Utils.CompareTool.ObjectPath.DictPathItem"/>
            .
            </remarks>
            <param name="key">key in the dictionary to which corresponds direct object to be compared.</param>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.ObjectPath.PushOffsetToPath(System.Int32)">
            <summary>Adds offset item to the direct path.</summary>
            <remarks>
            Adds offset item to the direct path. See
            <see cref="T:iText.Kernel.Utils.CompareTool.ObjectPath.OffsetPathItem"/>
            .
            </remarks>
            <param name="offset">offset to the specific byte in the stream that is compared.</param>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.ObjectPath.Pop">
            <summary>Removes the last path item from the direct path.</summary>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.ObjectPath.GetLocalPath">
            <summary>
            Gets local (or direct) path that denotes sequence of the path items from base object to the comparing
            direct object.
            </summary>
            <returns>direct path to the comparing object.</returns>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.ObjectPath.GetIndirectPath">
            <summary>
            Gets indirect path which denotes sequence of the indirect references that were passed in comparing process
            to get to the current base objects.
            </summary>
            <returns>indirect path to the current base objects.</returns>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.ObjectPath.GetBaseCmpObject">
            <returns>current base object in the cmp document.</returns>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.ObjectPath.GetBaseOutObject">
            <returns>current base object in the out document.</returns>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.ObjectPath.ToXmlNode(System.Xml.XmlDocument)">
            <summary>Creates an xml node that describes a direct path stored in this ObjectPath instance.</summary>
            <param name="document">xml document, to which this xml node will be added.</param>
            <returns>an xml node describing direct path.</returns>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.ObjectPath.ToString">
            <returns>string representation of the direct path stored in this ObjectPath instance.</returns>
        </member>
        <member name="T:iText.Kernel.Utils.CompareTool.ObjectPath.IndirectPathItem">
            <summary>
            An item in the indirect path (see
            <see cref="T:iText.Kernel.Utils.CompareTool.ObjectPath"/>
            . It encapsulates two corresponding objects from the two
            comparing documents that were met to get to the path base objects during comparing process.
            </summary>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.ObjectPath.IndirectPathItem.#ctor(iText.Kernel.Utils.CompareTool.ObjectPath,iText.Kernel.Pdf.PdfIndirectReference,iText.Kernel.Pdf.PdfIndirectReference)">
            <summary>Creates IndirectPathItem instance for two corresponding objects from two comparing documents.</summary>
            <param name="cmpObject">an object from the cmp document.</param>
            <param name="outObject">an object from the out document.</param>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.ObjectPath.IndirectPathItem.GetCmpObject">
            <returns>an object from the cmp object that was met to get to the path base objects during comparing process.
                </returns>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.ObjectPath.IndirectPathItem.GetOutObject">
            <returns>an object from the out object that was met to get to the path base objects during comparing process.
                </returns>
        </member>
        <member name="T:iText.Kernel.Utils.CompareTool.ObjectPath.LocalPathItem">
            <summary>
            An abstract class for the items in the direct path (see
            <see cref="T:iText.Kernel.Utils.CompareTool.ObjectPath"/>
            .
            </summary>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.ObjectPath.LocalPathItem.ToXmlNode(System.Xml.XmlDocument)">
            <summary>Creates an xml node that describes this direct path item.</summary>
            <param name="document">xml document, to which this xml node will be added.</param>
            <returns>an xml node describing direct path item.</returns>
        </member>
        <member name="T:iText.Kernel.Utils.CompareTool.ObjectPath.DictPathItem">
            <summary>
            Direct path item (see
            <see cref="T:iText.Kernel.Utils.CompareTool.ObjectPath"/>
            , which describes transition to the
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            entry which value is now a currently comparing direct object.
            </summary>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.ObjectPath.DictPathItem.#ctor(iText.Kernel.Pdf.PdfName)">
            <summary>
            Creates an instance of the
            <see cref="T:iText.Kernel.Utils.CompareTool.ObjectPath.DictPathItem"/>
            .
            </summary>
            <param name="key">
            the key which defines to which entry of the
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            the transition was performed.
            </param>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.ObjectPath.DictPathItem.GetKey">
            <summary>
            The key which defines to which entry of the
            <see cref="T:iText.Kernel.Pdf.PdfDictionary"/>
            the transition was performed.
            See
            <see cref="T:iText.Kernel.Utils.CompareTool.ObjectPath.DictPathItem"/>
            for more info.
            </summary>
            <returns>
            a
            <see cref="T:iText.Kernel.Pdf.PdfName"/>
            which is the key which defines to which entry of the dictionary
            the transition was performed.
            </returns>
        </member>
        <member name="T:iText.Kernel.Utils.CompareTool.ObjectPath.ArrayPathItem">
            <summary>
            Direct path item (see
            <see cref="T:iText.Kernel.Utils.CompareTool.ObjectPath"/>
            , which describes transition to the
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            element which is now a currently comparing direct object.
            </summary>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.ObjectPath.ArrayPathItem.#ctor(System.Int32)">
            <summary>
            Creates an instance of the
            <see cref="T:iText.Kernel.Utils.CompareTool.ObjectPath.ArrayPathItem"/>
            .
            </summary>
            <param name="index">
            the index which defines element of the
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            to which
            the transition was performed.
            </param>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.ObjectPath.ArrayPathItem.GetIndex">
            <summary>
            The index which defines element of the
            <see cref="T:iText.Kernel.Pdf.PdfArray"/>
            to which the transition was performed.
            See
            <see cref="T:iText.Kernel.Utils.CompareTool.ObjectPath.ArrayPathItem"/>
            for more info.
            </summary>
            <returns>the index which defines element of the array to which the transition was performed</returns>
        </member>
        <member name="T:iText.Kernel.Utils.CompareTool.ObjectPath.OffsetPathItem">
            <summary>
            Direct path item (see
            <see cref="T:iText.Kernel.Utils.CompareTool.ObjectPath"/>
            , which describes transition to the
            specific position in
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            .
            </summary>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.ObjectPath.OffsetPathItem.#ctor(System.Int32)">
            <summary>
            Creates an instance of the
            <see cref="T:iText.Kernel.Utils.CompareTool.ObjectPath.OffsetPathItem"/>
            .
            </summary>
            <param name="offset">
            bytes offset to the specific position in
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            .
            </param>
        </member>
        <member name="M:iText.Kernel.Utils.CompareTool.ObjectPath.OffsetPathItem.GetOffset">
            <summary>
            The bytes offset of the stream which defines specific position in the
            <see cref="T:iText.Kernel.Pdf.PdfStream"/>
            , to which transition
            was performed.
            </summary>
            <returns>an integer defining bytes offset to the specific position in stream.</returns>
        </member>
        <member name="T:iText.Kernel.Utils.PageRange">
            <summary>
            Class representing a page range, for instance a page range can contain pages
            5, then pages 10 through 15, then page 18, then page 21 and so on.
            </summary>
        </member>
        <member name="M:iText.Kernel.Utils.PageRange.#ctor">
            <summary>
            Constructs an empty
            <see cref="T:iText.Kernel.Utils.PageRange"/>
            instance.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.Utils.PageRange.#ctor(System.String)" -->
        <member name="M:iText.Kernel.Utils.PageRange.AddPageRangePart(iText.Kernel.Utils.PageRange.IPageRangePart)">
            <summary>Adds any page range part to this page range.</summary>
            <remarks>
            Adds any page range part to this page range. Users may define and plug in
            custom implementations for behavior not found in the standard library.
            </remarks>
            <param name="part">
            a custom implementation of
            <see cref="T:iText.Kernel.Utils.PageRange.IPageRangePart"/>
            </param>
            <returns>this range, already modified</returns>
        </member>
        <member name="M:iText.Kernel.Utils.PageRange.AddPageSequence(System.Int32,System.Int32)">
            <summary>Adds a page sequence to the range.</summary>
            <param name="startPageNumber">the starting page number of the sequence</param>
            <param name="endPageNumber">the finishing page number of the sequence</param>
            <returns>this range, already modified</returns>
        </member>
        <member name="M:iText.Kernel.Utils.PageRange.AddSinglePage(System.Int32)">
            <summary>Adds a single page to the range.</summary>
            <param name="pageNumber">the page number to add</param>
            <returns>this range, already modified</returns>
        </member>
        <member name="M:iText.Kernel.Utils.PageRange.GetAllPages">
            <summary>Gets the list of pages that have been added to the range so far.</summary>
            <remarks>
            Gets the list of pages that have been added to the range so far.
            This method has been deprecated in favor of an alternative method that
            requires the user to supply the total number of pages in the document.
            This number is necessary in order to limit open-ended ranges like "4-".
            </remarks>
            <returns>the list containing page numbers added to the range</returns>
        </member>
        <member name="M:iText.Kernel.Utils.PageRange.GetQualifyingPageNums(System.Int32)">
            <summary>Gets the list of pages that have been added to the range so far.</summary>
            <param name="nbPages">
            number of pages of the document to get the pages, to list
            only the pages eligible for this document.
            </param>
            <returns>
            the list containing page numbers added to the range matching this
            document
            </returns>
        </member>
        <member name="M:iText.Kernel.Utils.PageRange.IsPageInRange(System.Int32)">
            <summary>Checks if a given page is present in the range built so far.</summary>
            <param name="pageNumber">the page number to check</param>
            <returns>
            <code>true</code> if the page is present in this range,
            <code>false</code> otherwise
            </returns>
        </member>
        <member name="M:iText.Kernel.Utils.PageRange.Equals(System.Object)">
            <summary><inheritDoc/></summary>
        </member>
        <member name="M:iText.Kernel.Utils.PageRange.GetHashCode">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Utils.PageRange.IPageRangePart">
            <summary>Inner interface for range parts definition</summary>
        </member>
        <member name="T:iText.Kernel.Utils.PageRange.PageRangePartSingle">
            <summary>Class for range part containing a single page</summary>
        </member>
        <member name="M:iText.Kernel.Utils.PageRange.PageRangePartSingle.Equals(System.Object)">
            <summary><inheritDoc/></summary>
        </member>
        <member name="M:iText.Kernel.Utils.PageRange.PageRangePartSingle.GetHashCode">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Utils.PageRange.PageRangePartSequence">
            <summary>
            Class for range part containing a range of pages represented by a start
            and an end page
            </summary>
        </member>
        <member name="M:iText.Kernel.Utils.PageRange.PageRangePartSequence.Equals(System.Object)">
            <summary><inheritDoc/></summary>
        </member>
        <member name="M:iText.Kernel.Utils.PageRange.PageRangePartSequence.GetHashCode">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Utils.PageRange.PageRangePartAfter">
            <summary>
            Class for range part containing a range of pages for all pages after a
            given start page
            </summary>
        </member>
        <member name="M:iText.Kernel.Utils.PageRange.PageRangePartAfter.Equals(System.Object)">
            <summary><inheritDoc/></summary>
        </member>
        <member name="M:iText.Kernel.Utils.PageRange.PageRangePartAfter.GetHashCode">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Utils.PageRange.PageRangePartOddEven">
            <summary>Class for range part for all even or odd pages.</summary>
            <remarks>
            Class for range part for all even or odd pages. The class contains only 2
            instances, one for odd pages and one for even pages.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Utils.PageRange.PageRangePartOddEven.Equals(System.Object)">
            <summary><inheritDoc/></summary>
        </member>
        <member name="M:iText.Kernel.Utils.PageRange.PageRangePartOddEven.GetHashCode">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.Kernel.Utils.PageRange.PageRangePartAnd">
            <summary>Class for range part based on several range parts.</summary>
            <remarks>
            Class for range part based on several range parts. A 'and' is performed
            between all conditions. This allows for example to configure odd pages
            between page 19 and 25.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Utils.PageRange.PageRangePartAnd.Equals(System.Object)">
            <summary><inheritDoc/></summary>
        </member>
        <member name="M:iText.Kernel.Utils.PageRange.PageRangePartAnd.GetHashCode">
            <summary><inheritDoc/></summary>
        </member>
        <member name="M:iText.Kernel.Utils.PdfMerger.#ctor(iText.Kernel.Pdf.PdfDocument)">
            <summary>This class is used to merge a number of existing documents into one.</summary>
            <remarks>
            This class is used to merge a number of existing documents into one. By default, if source document
            contains tags and outlines, they will be also copied to the destination document.
            </remarks>
            <param name="pdfDocument">the document into which source documents will be merged.</param>
        </member>
        <member name="M:iText.Kernel.Utils.PdfMerger.#ctor(iText.Kernel.Pdf.PdfDocument,System.Boolean,System.Boolean)">
            <summary>This class is used to merge a number of existing documents into one.</summary>
            <param name="pdfDocument">the document into which source documents will be merged.</param>
            <param name="mergeTags">
            if true, then tags from the source document are copied even if destination document is not set as
            tagged. Note, that if false, tag structure is still could be copied if the destination document
            is explicitly marked as tagged with
            <see cref="M:iText.Kernel.Pdf.PdfDocument.SetTagged"/>
            .
            </param>
            <param name="mergeOutlines">
            if true, then outlines from the source document are copied even if in destination document
            outlines are not initialized. Note, that if false, outlines are still could be copied if the
            destination document outlines were explicitly initialized with
            <see cref="M:iText.Kernel.Pdf.PdfDocument.InitializeOutlines"/>
            .
            </param>
        </member>
        <member name="M:iText.Kernel.Utils.PdfMerger.SetCloseSourceDocuments(System.Boolean)">
            <summary>
            If set to <i>true</i> then passed to the <i>
            <c>PdfMerger#merge</c>
            </i> method source documents will be closed
            immediately after merging specified pages into current document. If <i>false</i> - PdfDocuments are left open.
            Default value - <i>false</i>.
            </summary>
            <param name="closeSourceDocuments">should be true to close pdf documents in merge method.</param>
            <returns>
            this
            <c>PdfMerger</c>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Utils.PdfMerger.Merge(iText.Kernel.Pdf.PdfDocument,System.Int32,System.Int32)">
            <summary>This method merges pages from the source document to the current one.</summary>
            <remarks>
            This method merges pages from the source document to the current one.
            <br/><br/>
            If <i>closeSourceDocuments</i> flag is set to <i>true</i> (see
            <see cref="M:iText.Kernel.Utils.PdfMerger.SetCloseSourceDocuments(System.Boolean)"/>
            ),
            passed
            <c>PdfDocument</c>
            will be closed after pages are merged.
            </remarks>
            <param name="from">- document, from which pages will be copied.</param>
            <param name="fromPage">- start page in the range of pages to be copied.</param>
            <param name="toPage">- end page in the range to be copied.</param>
            <returns>
            this
            <c>PdfMerger</c>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Utils.PdfMerger.Merge(iText.Kernel.Pdf.PdfDocument,System.Collections.Generic.IList{System.Int32})">
            <summary>This method merges pages from the source document to the current one.</summary>
            <remarks>
            This method merges pages from the source document to the current one.
            <br/><br/>
            If <i>closeSourceDocuments</i> flag is set to <i>true</i> (see
            <see cref="M:iText.Kernel.Utils.PdfMerger.SetCloseSourceDocuments(System.Boolean)"/>
            ),
            passed
            <c>PdfDocument</c>
            will be closed after pages are merged.
            </remarks>
            <param name="from">- document, from which pages will be copied.</param>
            <param name="pages">- List of numbers of pages which will be copied.</param>
            <returns>
            this
            <c>PdfMerger</c>
            instance.
            </returns>
        </member>
        <member name="M:iText.Kernel.Utils.PdfMerger.Close">
            <summary>Closes the current document.</summary>
            <remarks>
            Closes the current document. It is a complete equivalent of calling
            <c>PdfDocument#close</c>
            on the PdfDocument
            passed to the constructor of this PdfMerger instance. This means that it is enough to call <i>close</i> either on
            passed PdfDocument or on this PdfMerger instance, but there is no need to call them both.
            </remarks>
        </member>
        <member name="T:iText.Kernel.Utils.PdfResourceCounter">
            <summary>
            This class can be used to count the number of bytes needed when copying
            pages from an existing PDF into a newly created PDF.
            </summary>
        </member>
        <member name="F:iText.Kernel.Utils.PdfResourceCounter.resources">
            <summary>A map of the resources that are already taken into account</summary>
        </member>
        <member name="M:iText.Kernel.Utils.PdfResourceCounter.#ctor(iText.Kernel.Pdf.PdfObject)">
            <summary>
            Creates a PdfResourceCounter instance to be used to count the resources
            needed for either a page (in this case pass a page dictionary) or the
            trailer (root and info dictionary) of a PDF file.
            </summary>
            <param name="obj">the object we want to examine</param>
        </member>
        <member name="M:iText.Kernel.Utils.PdfResourceCounter.Process(iText.Kernel.Pdf.PdfObject)">
            <summary>Processes an object.</summary>
            <remarks>
            Processes an object. If the object is indirect, it is added to the
            list of resources. If not, it is just processed.
            </remarks>
            <param name="obj">the object to process</param>
        </member>
        <member name="M:iText.Kernel.Utils.PdfResourceCounter.LoopOver(iText.Kernel.Pdf.PdfObject)">
            <summary>
            In case an object is an array, a dictionary or a stream,
            we need to loop over the entries and process them one by one.
            </summary>
            <param name="obj">the object to examine</param>
        </member>
        <member name="M:iText.Kernel.Utils.PdfResourceCounter.GetResources">
            <summary>Returns a map with the resources.</summary>
            <returns>the resources</returns>
        </member>
        <member name="M:iText.Kernel.Utils.PdfResourceCounter.GetLength(System.Collections.Generic.IDictionary{System.Int32,iText.Kernel.Pdf.PdfObject})">
            <summary>
            Returns the resources needed for the object that was used to create
            this PdfResourceCounter.
            </summary>
            <remarks>
            Returns the resources needed for the object that was used to create
            this PdfResourceCounter. If you pass a Map with resources that were
            already used by other objects, these objects will not be taken into
            account.
            </remarks>
            <param name="res">The resources that can be excluded when counting the bytes.</param>
            <returns>The number of bytes needed for an object.</returns>
        </member>
        <member name="M:iText.Kernel.Utils.PdfSplitter.#ctor(iText.Kernel.Pdf.PdfDocument)">
            <summary>Creates a new instance of PdfSplitter class.</summary>
            <param name="pdfDocument">the document to be split.</param>
        </member>
        <member name="M:iText.Kernel.Utils.PdfSplitter.SetPreserveTagged(System.Boolean)">
            <summary>If original document is tagged, then by default all resultant document will also be tagged.</summary>
            <remarks>
            If original document is tagged, then by default all resultant document will also be tagged.
            This could be changed with this flag - if set to false, resultant documents will be not tagged, even if
            original document is tagged.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Utils.PdfSplitter.SetPreserveOutlines(System.Boolean)">
            <summary>If original document has outlines, then by default all resultant document will also have outlines.
                </summary>
            <remarks>
            If original document has outlines, then by default all resultant document will also have outlines.
            This could be changed with this flag - if set to false, resultant documents won't contain outlines, even if
            original document had them.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Utils.PdfSplitter.SplitBySize(System.Int64)">
            <summary>Splits the document basing on the given size.</summary>
            <param name="size"><strog>Preferred</strog> size for splitting.</param>
            <returns>
            The documents which the source document was split into.
            Be warned that these documents are not closed.
            </returns>
        </member>
        <member name="M:iText.Kernel.Utils.PdfSplitter.SplitByPageNumbers(System.Collections.Generic.IList{System.Int32},iText.Kernel.Utils.PdfSplitter.IDocumentReadyListener)">
            <summary>Splits the document by page numbers.</summary>
            <param name="pageNumbers">
            the numbers of pages from which another document is to be started.
            If the first element is not 1, then 1 is implied (i.e. the first split document will start from page 1 in any case).
            </param>
            <param name="documentReady">
            the event listener which is called when another document is ready.
            You can close this document in this listener, for instance.
            </param>
        </member>
        <member name="M:iText.Kernel.Utils.PdfSplitter.SplitByPageNumbers(System.Collections.Generic.IList{System.Int32})">
            <summary>Splits the document by page numbers.</summary>
            <param name="pageNumbers">
            the numbers of pages from which another document is to be started.
            If the first element is not 1, then 1 is implied (i.e. the first split document will start from page 1 in any case).
            </param>
            <returns>the list of resultant documents. By warned that they are not closed.</returns>
        </member>
        <member name="M:iText.Kernel.Utils.PdfSplitter.SplitByPageCount(System.Int32,iText.Kernel.Utils.PdfSplitter.IDocumentReadyListener)">
            <summary>Splits a document into smaller documents with no more than @pageCount pages each.</summary>
            <param name="pageCount">the biggest possible number of pages in a split document.</param>
            <param name="documentReady">
            the event listener which is called when another document is ready.
            You can close this document in this listener, for instance.
            </param>
        </member>
        <member name="M:iText.Kernel.Utils.PdfSplitter.SplitByPageCount(System.Int32)">
            <summary>Splits a document into smaller documents with no more than @pageCount pages each.</summary>
            <param name="pageCount">the biggest possible number of pages in a split document.</param>
            <returns>the list of resultant documents. By warned that they are not closed.</returns>
        </member>
        <member name="M:iText.Kernel.Utils.PdfSplitter.ExtractPageRanges(System.Collections.Generic.IList{iText.Kernel.Utils.PageRange})">
            <summary>Extracts the specified page ranges from a document.</summary>
            <param name="pageRanges">the list of page ranges for each of the resultant document.</param>
            <returns>
            the list of the resultant documents for each of the specified page range.
            Be warned that these documents are not closed.
            </returns>
        </member>
        <member name="M:iText.Kernel.Utils.PdfSplitter.ExtractPageRange(iText.Kernel.Utils.PageRange)">
            <summary>Extracts the specified page ranges from a document.</summary>
            <param name="pageRange">the page range to be extracted from the document.</param>
            <returns>
            the resultant document containing the pages specified by the provided page range.
            Be warned that this document is not closed.
            </returns>
        </member>
        <member name="M:iText.Kernel.Utils.PdfSplitter.GetNextPdfWriter(iText.Kernel.Utils.PageRange)">
            <summary>This method is called when another split document is to be created.</summary>
            <remarks>
            This method is called when another split document is to be created.
            You can override this method and return your own
            <see cref="T:iText.Kernel.Pdf.PdfWriter"/>
            depending on your needs.
            </remarks>
            <param name="documentPageRange">the page range of the original document to be included in the document being created now.
                </param>
            <returns>the PdfWriter instance for the document which is being created.</returns>
        </member>
        <member name="M:iText.Kernel.Utils.PdfSplitter.SplitByOutlines(System.Collections.Generic.IList{System.String})">
            <summary>
            Split a document by outline title (bookmark name), find outline by name
            and places the entire hierarchy in a separate document ( outlines and pages ) .
            </summary>
            <param name="outlineTitles">list of outline titles .</param>
        </member>
        <member name="M:iText.Kernel.Utils.PdfSplitter.GetAbsoluteTreeNextOutline(iText.Kernel.Pdf.PdfOutline)">
            <summary>the next element in the entire hierarchy</summary>
            <param name="outline"></param>
        </member>
        <member name="T:iText.Kernel.Utils.TaggedPdfReaderTool">
            <summary>Converts a tagged PDF document into an XML file.</summary>
        </member>
        <member name="M:iText.Kernel.Utils.TaggedPdfReaderTool.#ctor(iText.Kernel.Pdf.PdfDocument)">
            <summary>
            Constructs a
            <see cref="T:iText.Kernel.Utils.TaggedPdfReaderTool"/>
            via a given
            <see cref="T:iText.Kernel.Pdf.PdfDocument"/>
            .
            </summary>
            <param name="document">the document to read tag structure from</param>
        </member>
        <member name="M:iText.Kernel.Utils.TaggedPdfReaderTool.IsValidCharacterValue(System.Int32)">
            <summary>Checks if a character value should be escaped/unescaped.</summary>
            <param name="c">a character value</param>
            <returns>true if it's OK to escape or unescape this value</returns>
        </member>
        <member name="M:iText.Kernel.Utils.TaggedPdfReaderTool.ConvertToXml(System.IO.Stream)">
            <summary>Converts the current tag structure into an XML file with default encoding (UTF-8).</summary>
            <param name="os">the output stream to save XML file to</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Utils.TaggedPdfReaderTool.ConvertToXml(System.IO.Stream,System.String)">
            <summary>Converts the current tag structure into an XML file with provided encoding.</summary>
            <param name="os">the output stream to save XML file to</param>
            <param name="charset">the charset of the resultant XML file</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.Utils.TaggedPdfReaderTool.SetRootTag(System.String)">
            <summary>Sets the name of the root tag of the resultant XML file</summary>
            <param name="rootTagName">the name of the root tag</param>
            <returns>this object</returns>
        </member>
        <member name="M:iText.Kernel.Utils.TaggedPdfReaderTool.EscapeXML(System.String,System.Boolean)">
            <summary>
            NOTE: copied from itext5 XMLUtils class
            Escapes a string with the appropriated XML codes.
            </summary>
            <param name="s">the string to be escaped</param>
            <param name="onlyASCII">codes above 127 will always be escaped with &amp;#nn; if <CODE>true</CODE></param>
            <returns>the escaped string</returns>
        </member>
        <member name="T:iText.Kernel.Version">
            <summary>This class contains version information about iText.</summary>
            <remarks>
            This class contains version information about iText.
            DO NOT CHANGE THE VERSION INFORMATION WITHOUT PERMISSION OF THE COPYRIGHT HOLDERS OF ITEXT.
            Changing the version makes it extremely difficult to debug an application.
            Also, the nature of open source software is that you honor the copyright of the original creators of the software.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Version.AGPL">
            <summary>String that will indicate if the AGPL version is used.</summary>
        </member>
        <member name="F:iText.Kernel.Version.version">
            <summary>The iText version instance.</summary>
        </member>
        <member name="F:iText.Kernel.Version.iText">
            <summary>This String contains the name of the product.</summary>
            <remarks>
            This String contains the name of the product.
            iText is a registered trademark by iText Group NV.
            Please don't change this constant.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Version.release">
            <summary>This String contains the version number of this iText release.</summary>
            <remarks>
            This String contains the version number of this iText release.
            For debugging purposes, we request you NOT to change this constant.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Version.iTextVersion">
            <summary>This String contains the iText version as shown in the producer line.</summary>
            <remarks>
            This String contains the iText version as shown in the producer line.
            iText is a product developed by iText Group NV.
            iText Group requests that you retain the iText producer line
            in every PDF that is created or manipulated using iText.
            </remarks>
        </member>
        <member name="F:iText.Kernel.Version.key">
            <summary>The license key.</summary>
        </member>
        <member name="M:iText.Kernel.Version.GetInstance">
            <summary>Gets an instance of the iText version that is currently used.</summary>
            <remarks>
            Gets an instance of the iText version that is currently used.
            Note that iText Group requests that you retain the iText producer line
            in every PDF that is created or manipulated using iText.
            </remarks>
        </member>
        <member name="M:iText.Kernel.Version.IsAGPLVersion">
            <summary>Checks if the AGPL version is used.</summary>
            <returns>returns true if the AGPL version is used.</returns>
        </member>
        <member name="M:iText.Kernel.Version.IsExpired">
            <summary>Is the license expired?</summary>
            <returns>true if expired</returns>
        </member>
        <member name="M:iText.Kernel.Version.GetProduct">
            <summary>Gets the product name.</summary>
            <remarks>
            Gets the product name.
            iText Group NV requests that you retain the iText producer line
            in every PDF that is created or manipulated using iText.
            </remarks>
            <returns>the product name</returns>
        </member>
        <member name="M:iText.Kernel.Version.GetRelease">
            <summary>Gets the release number.</summary>
            <remarks>
            Gets the release number.
            iText Group NV requests that you retain the iText producer line
            in every PDF that is created or manipulated using iText.
            </remarks>
            <returns>the release number</returns>
        </member>
        <member name="M:iText.Kernel.Version.GetVersion">
            <summary>Returns the iText version as shown in the producer line.</summary>
            <remarks>
            Returns the iText version as shown in the producer line.
            iText is a product developed by iText Group NV.
            iText Group requests that you retain the iText producer line
            in every PDF that is created or manipulated using iText.
            </remarks>
            <returns>iText version</returns>
        </member>
        <member name="M:iText.Kernel.Version.GetKey">
            <summary>Returns a license key if one was provided, or null if not.</summary>
            <returns>a license key.</returns>
        </member>
        <member name="T:iText.Kernel.XMP.EncodingNoPreamble">
            <summary>
            A wrapper for an Encoding to suppress the preamble.
            </summary>
        </member>
        <member name="T:iText.Kernel.XMP.Impl.Base64">
            <summary>
            A utility class to perform base64 encoding and decoding as specified
            in RFC-1521.
            </summary>
            <remarks>
            A utility class to perform base64 encoding and decoding as specified
            in RFC-1521. See also RFC 1421.
            </remarks>
            <version>$Revision: 1.4 $</version>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.Base64.INVALID">
            <summary>marker for invalid bytes</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.Base64.WHITESPACE">
            <summary>marker for accepted whitespace bytes</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.Base64.EQUAL">
            <summary>marker for an equal symbol</summary>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.Base64.Encode(System.Byte[])">
            <summary>Encode the given byte[].</summary>
            <param name="src">the source string.</param>
            <returns>the base64-encoded data.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.Base64.Encode(System.Byte[],System.Int32)">
            <summary>Encode the given byte[].</summary>
            <param name="src">the source string.</param>
            <param name="lineFeed">
            a linefeed is added after <code>linefeed</code> characters;
            must be dividable by four; 0 means no linefeeds
            </param>
            <returns>the base64-encoded data.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.Base64.Encode(System.String)">
            <summary>Encode the given string.</summary>
            <param name="src">the source string.</param>
            <returns>the base64-encoded string.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.Base64.Decode(System.Byte[])">
            <summary>Decode the given byte[].</summary>
            <param name="src">the base64-encoded data.</param>
            <returns>the decoded data.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown if the base 64 strings contains non-valid characters,
            beside the bas64 chars, LF, CR, tab and space are accepted.
            </exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.Base64.Decode(System.String)">
            <summary>Decode the given string.</summary>
            <param name="src">the base64-encoded string.</param>
            <returns>the decoded string.</returns>
        </member>
        <member name="T:iText.Kernel.XMP.Impl.ByteBuffer">
            <summary>Byte buffer container including length of valid data.</summary>
            <since>11.10.2006</since>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ByteBuffer.#ctor(System.Int32)">
            <param name="initialCapacity">the initial capacity for this buffer</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ByteBuffer.#ctor(System.Byte[])">
            <param name="buffer">a byte array that will be wrapped with <code>ByteBuffer</code>.</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ByteBuffer.#ctor(System.Byte[],System.Int32)">
            <param name="buffer">a byte array that will be wrapped with <code>ByteBuffer</code>.</param>
            <param name="length">the length of valid bytes in the array</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ByteBuffer.#ctor(System.IO.Stream)">
            <summary>Loads the stream into a buffer.</summary>
            <param name="in">an InputStream</param>
            <exception cref="T:System.IO.IOException">If the stream cannot be read.</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ByteBuffer.#ctor(System.Byte[],System.Int32,System.Int32)">
            <param name="buffer">a byte array that will be wrapped with <code>ByteBuffer</code>.</param>
            <param name="offset">the offset of the provided buffer.</param>
            <param name="length">the length of valid bytes in the array</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ByteBuffer.GetByteStream">
            <returns>Returns a byte stream that is limited to the valid amount of bytes.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ByteBuffer.Length">
            <returns>
            Returns the length, that means the number of valid bytes, of the buffer;
            the inner byte array might be bigger than that.
            </returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ByteBuffer.ByteAt(System.Int32)">
            <param name="index">the index to retrieve the byte from</param>
            <returns>Returns a byte from the buffer</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ByteBuffer.CharAt(System.Int32)">
            <param name="index">the index to retrieve a byte as int or char.</param>
            <returns>Returns a byte from the buffer</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ByteBuffer.Append(System.Byte)">
            <summary>Appends a byte to the buffer.</summary>
            <param name="b">a byte</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ByteBuffer.Append(System.Byte[],System.Int32,System.Int32)">
            <summary>Appends a byte array or part of to the buffer.</summary>
            <param name="bytes">a byte array</param>
            <param name="offset">an offset with</param>
            <param name="len"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ByteBuffer.Append(System.Byte[])">
            <summary>Append a byte array to the buffer</summary>
            <param name="bytes">a byte array</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ByteBuffer.Append(iText.Kernel.XMP.Impl.ByteBuffer)">
            <summary>Append another buffer to this buffer.</summary>
            <param name="anotherBuffer">another <code>ByteBuffer</code></param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ByteBuffer.GetEncoding">
            <summary>Detects the encoding of the byte buffer, stores and returns it.</summary>
            <remarks>
            Detects the encoding of the byte buffer, stores and returns it.
            Only UTF-8, UTF-16LE/BE and UTF-32LE/BE are recognized.
            <em>Note:</em> UTF-32 flavors are not supported by Java, the XML-parser will complain.
            </remarks>
            <returns>Returns the encoding string.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ByteBuffer.EnsureCapacity(System.Int32)">
            <summary>
            Ensures the requested capacity by increasing the buffer size when the
            current length is exceeded.
            </summary>
            <param name="requestedLength">requested new buffer length</param>
        </member>
        <member name="T:iText.Kernel.XMP.Impl.CountOutputStream">
            <summary>
            An <code>OutputStream</code> that counts the written bytes.
            
            @since   08.11.2006
            </summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.CountOutputStream.output">
            <summary>
            the decorated output stream </summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.CountOutputStream.bytesWritten">
            <summary>
            the byte counter </summary>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.CountOutputStream.#ctor(System.IO.Stream)">
            <summary>
            Constructor with providing the output stream to decorate. </summary>
            <param name="output"> an <code>OutputStream</code> </param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.CountOutputStream.GetBytesWritten">
            <returns> the bytesWritten </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.Impl.CountOutputStream.Write(System.Byte[],System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.Impl.CountOutputStream.Write(System.Byte[])" -->
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.Impl.CountOutputStream.Write(System.Int32)" -->
        <member name="T:iText.Kernel.XMP.Impl.FixASCIIControlsReader">
            <since>22.08.2006</since>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.FixASCIIControlsReader.state">
            <summary>the state of the automaton</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.FixASCIIControlsReader.control">
            <summary>the result of the escaping sequence</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.FixASCIIControlsReader.digits">
            <summary>count the digits of the sequence</summary>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.FixASCIIControlsReader.#ctor(System.IO.TextReader)">
            <summary>The look-ahead size is 6 at maximum (&amp;#xAB;)</summary>
            <seealso cref="M:iText.IO.Util.PushbackReader.#ctor(System.IO.TextReader,System.Int32)"/>
            <param name="input">a Reader</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.FixASCIIControlsReader.Read(System.Char[],System.Int32,System.Int32)">
            <seealso cref="M:System.IO.TextReader.Read(System.Char[],System.Int32,System.Int32)"/>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.FixASCIIControlsReader.ProcessChar(System.Char)">
            <summary>Processes numeric escaped chars to find out if they are a control character.</summary>
            <param name="ch">a char</param>
            <returns>Returns the char directly or as replacement for the escaped sequence.</returns>
        </member>
        <member name="T:iText.Kernel.XMP.Impl.ISO8601Converter">
            <summary>Converts between ISO 8601 Strings and <code>Calendar</code> with millisecond resolution.
            	</summary>
            <since>16.02.2006</since>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ISO8601Converter.#ctor">
            <summary>Hides public constructor</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.Impl.ISO8601Converter.Parse(System.String)" -->
        <member name="M:iText.Kernel.XMP.Impl.ISO8601Converter.Parse(System.String,iText.Kernel.XMP.XMPDateTime)">
            <param name="iso8601String">a date string that is ISO 8601 conform.</param>
            <param name="binValue">an existing XMPDateTime to set with the parsed date</param>
            <returns>Returns an XMPDateTime-object containing the ISO8601-date.</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">Is thrown when the string is non-conform.
            	</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.Impl.ISO8601Converter.Render(iText.Kernel.XMP.XMPDateTime)" -->
        <member name="T:iText.Kernel.XMP.Impl.ParseState">
            <since>22.08.2006</since>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParseState.#ctor(System.String)">
            <param name="str">initializes the parser container</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParseState.Length">
            <returns>Returns the length of the input.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParseState.HasNext">
            <returns>Returns whether there are more chars to come.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParseState.Ch(System.Int32)">
            <param name="index">index of char</param>
            <returns>Returns char at a certain index.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParseState.Ch">
            <returns>Returns the current char or 0x0000 if there are no more chars.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParseState.Skip">
            <summary>Skips the next char.</summary>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParseState.Pos">
            <returns>Returns the current position.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParseState.GatherInt(System.String,System.Int32)">
            <summary>Parses a integer from the source and sets the pointer after it.</summary>
            <param name="errorMsg">Error message to put in the exception if no number can be found
            	</param>
            <param name="maxValue">the max value of the number to return</param>
            <returns>Returns the parsed integer.</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">Thrown if no integer can be found.
            	</exception>
        </member>
        <member name="T:iText.Kernel.XMP.Impl.Latin1Converter">
            <since>12.10.2006</since>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.Latin1Converter.#ctor">
            <summary>Private constructor</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.Impl.Latin1Converter.Convert(iText.Kernel.XMP.Impl.ByteBuffer)" -->
        <member name="M:iText.Kernel.XMP.Impl.Latin1Converter.ConvertToUTF8(System.Byte)">
            <summary>
            Converts a Cp1252 char (contains all Latin-1 chars above 0x80) into a
            UTF-8 byte sequence.
            </summary>
            <remarks>
            Converts a Cp1252 char (contains all Latin-1 chars above 0x80) into a
            UTF-8 byte sequence. The bytes 0x81, 0x8D, 0x8F, 0x90, and 0x9D are
            formally undefined by Windows 1252 and therefore replaced by a space
            (0x20).
            </remarks>
            <param name="ch">an Cp1252 / Latin-1 byte</param>
            <returns>Returns a byte array containing a UTF-8 byte sequence.</returns>
        </member>
        <member name="T:iText.Kernel.XMP.Impl.ParameterAsserts">
            <since>11.08.2006</since>
        </member>
        <member name="T:iText.Kernel.XMP.XMPConst">
            <summary>Common constants for the XMP Toolkit.</summary>
            <since>20.01.2006</since>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.NS_XML">
            <summary>The XML namespace for XML.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.NS_RDF">
            <summary>The XML namespace for RDF.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.NS_DC">
            <summary>The XML namespace for the Dublin Core schema.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.NS_IPTCCORE">
            <summary>The XML namespace for the IPTC Core schema.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.NS_IPTCEXT">
            <summary>The XML namespace for the IPTC Extension schema.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.NS_DICOM">
            <summary>The XML namespace for the DICOM medical schema.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.NS_PLUS">
            <summary>The XML namespace for the PLUS (Picture Licensing Universal System, http://www.useplus.org)</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.NS_X">
            <summary>The XML namespace Adobe XMP Metadata.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.NS_XMP">
            <summary>The XML namespace for the XMP "basic" schema.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.NS_XMP_RIGHTS">
            <summary>The XML namespace for the XMP copyright schema.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.NS_XMP_MM">
            <summary>The XML namespace for the XMP digital asset management schema.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.NS_XMP_BJ">
            <summary>The XML namespace for the job management schema.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.NS_XMP_NOTE">
            <summary>The XML namespace for the job management schema.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.NS_PDF">
            <summary>The XML namespace for the PDF schema.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.NS_PDFX">
            <summary>The XML namespace for the PDF schema.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.NS_PHOTOSHOP">
            <summary>The XML namespace for the Photoshop custom schema.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.NS_PSALBUM">
            <summary>The XML namespace for the Photoshop Album schema.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.NS_EXIF">
            <summary>The XML namespace for Adobe's EXIF schema.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.NS_EXIFX">
            <summary>NS for the CIPA XMP for Exif document v1.1</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.NS_TIFF">
            <summary>The XML namespace for Adobe's TIFF schema.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.NS_BWF">
            <summary>BExt Schema</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.NS_RIFFINFO">
            <summary>RIFF Info Schema</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.NS_TXMP">
            <summary>Transform XMP</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.NS_SWF">
            <summary>Adobe Flash SWF</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.NS_DC_DEPRECATED">
            <summary>legacy Dublin Core NS, will be converted to NS_DC</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.TYPE_IDENTIFIERQUAL">
            <summary>The XML namespace for qualifiers of the xmp:Identifier property.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.TYPE_DIMENSIONS">
            <summary>The XML namespace for fields of the Dimensions type.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.TYPE_IMAGE">
            <summary>The XML namespace for fields of a graphical image.</summary>
            <remarks>The XML namespace for fields of a graphical image. Used for the Thumbnail type.</remarks>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.TYPE_RESOURCEEVENT">
            <summary>The XML namespace for fields of the ResourceEvent type.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.TYPE_RESOURCEREF">
            <summary>The XML namespace for fields of the ResourceRef type.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.TYPE_ST_VERSION">
            <summary>The XML namespace for fields of the Version type.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.TYPE_ST_JOB">
            <summary>The XML namespace for fields of the JobRef type.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.TRUESTR">
            <summary>The canonical true string value for Booleans in serialized XMP.</summary>
            <remarks>
            The canonical true string value for Booleans in serialized XMP. Code that converts from the
            string to a bool should be case insensitive, and even allow "1".
            </remarks>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.FALSESTR">
            <summary>The canonical false string value for Booleans in serialized XMP.</summary>
            <remarks>
            The canonical false string value for Booleans in serialized XMP. Code that converts from the
            string to a bool should be case insensitive, and even allow "0".
            </remarks>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.ARRAY_LAST_ITEM">
            <summary>Index that has the meaning to be always the last item in an array.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.ARRAY_ITEM_NAME">
            <summary>Node name of an array item.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.X_DEFAULT">
            <summary>The x-default string for localized properties</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.XML_LANG">
            <summary>xml:lang qualfifier</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.RDF_TYPE">
            <summary>rdf:type qualfifier</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.XMP_PI">
            <summary>Processing Instruction (PI) for xmp packet</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.TAG_XMPMETA">
            <summary>XMP meta tag version new</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.TAG_XAPMETA">
            <summary>XMP meta tag version old</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.PART">
            <summary>Part, 1, 2, or 3</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPConst.CONFORMANCE">
            <summary>Conformance, A, B, or U.</summary>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParameterAsserts.#ctor">
            <summary>private constructor</summary>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParameterAsserts.AssertArrayName(System.String)">
            <summary>Asserts that an array name is set.</summary>
            <param name="arrayName">an array name</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Array name is null or empty</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParameterAsserts.AssertPropName(System.String)">
            <summary>Asserts that a property name is set.</summary>
            <param name="propName">a property name or path</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Property name is null or empty</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParameterAsserts.AssertSchemaNS(System.String)">
            <summary>Asserts that a schema namespace is set.</summary>
            <param name="schemaNS">a schema namespace</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Schema is null or empty</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParameterAsserts.AssertPrefix(System.String)">
            <summary>Asserts that a prefix is set.</summary>
            <param name="prefix">a prefix</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Prefix is null or empty</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParameterAsserts.AssertSpecificLang(System.String)">
            <summary>Asserts that a specific language is set.</summary>
            <param name="specificLang">a specific lang</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Specific language is null or empty</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParameterAsserts.AssertStructName(System.String)">
            <summary>Asserts that a struct name is set.</summary>
            <param name="structName">a struct name</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Struct name is null or empty</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParameterAsserts.AssertNotNull(System.Object)">
            <summary>Asserts that any string parameter is set.</summary>
            <param name="param">any string parameter</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Thrown if the parameter is null or has length 0.</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParameterAsserts.AssertImplementation(iText.Kernel.XMP.XMPMeta)">
            <summary>
            Asserts that the xmp object is of this implemention
            (
            <see cref="T:iText.Kernel.XMP.Impl.XMPMetaImpl"/>
            ).
            </summary>
            <param name="xmp">the XMP object</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">A wrong implentaion is used.</exception>
        </member>
        <member name="T:iText.Kernel.XMP.Impl.ParseRdf">
            <summary>Parser for "normal" XML serialisation of RDF.</summary>
            <since>14.07.2006</since>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.ParseRdf.RDFTERM_RDF">
            <summary>Start of coreSyntaxTerms.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.ParseRdf.RDFTERM_DATATYPE">
            <summary>End of coreSyntaxTerms</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.ParseRdf.RDFTERM_DESCRIPTION">
            <summary>Start of additions for syntax Terms.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.ParseRdf.RDFTERM_LI">
            <summary>End of of additions for syntaxTerms.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.ParseRdf.RDFTERM_ABOUT_EACH">
            <summary>Start of oldTerms.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.ParseRdf.RDFTERM_BAG_ID">
            <summary>End of oldTerms.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.ParseRdf.RDFTERM_FIRST_SYNTAX">
            <summary>! Yes, the syntax terms include the core terms.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.ParseRdf.DEFAULT_PREFIX">
            <summary>this prefix is used for default namespaces</summary>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParseRdf.Parse(System.Xml.XmlNode)">
            <summary>The main parsing method.</summary>
            <remarks>
            The main parsing method. The XML tree is walked through from the root node and and XMP tree
            is created. This is a raw parse, the normalisation of the XMP tree happens outside.
            </remarks>
            <param name="xmlRoot">the XML root node</param>
            <returns>Returns an XMP metadata object (not normalized)</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">Occurs if the parsing fails for any reason.
            	</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParseRdf.Rdf_RDF(iText.Kernel.XMP.Impl.XMPMetaImpl,System.Xml.XmlNode)">
            <summary>
            Each of these parsing methods is responsible for recognizing an RDF
            syntax production and adding the appropriate structure to the XMP tree.
            </summary>
            <remarks>
            Each of these parsing methods is responsible for recognizing an RDF
            syntax production and adding the appropriate structure to the XMP tree.
            They simply return for success, failures will throw an exception.
            </remarks>
            <param name="xmp">the xmp metadata object that is generated</param>
            <param name="rdfRdfNode">the top-level xml node</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">thown on parsing errors</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParseRdf.Rdf_NodeElementList(iText.Kernel.XMP.Impl.XMPMetaImpl,iText.Kernel.XMP.Impl.XMPNode,System.Xml.XmlNode)">
            <summary>
            7.2.10 nodeElementList<br/>
            ws* ( nodeElement ws* )
            Note: this method is only called from the rdf:RDF-node (top level)
            </summary>
            <param name="xmp">the xmp metadata object that is generated</param>
            <param name="xmpParent">the parent xmp node</param>
            <param name="rdfRdfNode">the top-level xml node</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">thown on parsing errors</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParseRdf.Rdf_NodeElement(iText.Kernel.XMP.Impl.XMPMetaImpl,iText.Kernel.XMP.Impl.XMPNode,System.Xml.XmlNode,System.Boolean)">
            <summary>
            7.2.5 nodeElementURIs
            anyURI - ( coreSyntaxTerms | rdf:li | oldTerms )
            7.2.11 nodeElement
            start-element ( URI == nodeElementURIs,
            attributes == set ( ( idAttr | nodeIdAttr | aboutAttr )?, propertyAttr* ) )
            propertyEltList
            end-element()
            A node element URI is rdf:Description or anything else that is not an RDF
            term.
            </summary>
            <param name="xmp">the xmp metadata object that is generated</param>
            <param name="xmpParent">the parent xmp node</param>
            <param name="xmlNode">the currently processed XML node</param>
            <param name="isTopLevel">Flag if the node is a top-level node</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">thown on parsing errors</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParseRdf.Rdf_NodeElementAttrs(iText.Kernel.XMP.Impl.XMPMetaImpl,iText.Kernel.XMP.Impl.XMPNode,System.Xml.XmlNode,System.Boolean)">
            <summary>
            7.2.7 propertyAttributeURIs
            anyURI - ( coreSyntaxTerms | rdf:Description | rdf:li | oldTerms )
            7.2.11 nodeElement
            start-element ( URI == nodeElementURIs,
            attributes == set ( ( idAttr | nodeIdAttr | aboutAttr )?, propertyAttr* ) )
            propertyEltList
            end-element()
            Process the attribute list for an RDF node element.
            </summary>
            <remarks>
            7.2.7 propertyAttributeURIs
            anyURI - ( coreSyntaxTerms | rdf:Description | rdf:li | oldTerms )
            7.2.11 nodeElement
            start-element ( URI == nodeElementURIs,
            attributes == set ( ( idAttr | nodeIdAttr | aboutAttr )?, propertyAttr* ) )
            propertyEltList
            end-element()
            Process the attribute list for an RDF node element. A property attribute URI is
            anything other than an RDF term. The rdf:ID and rdf:nodeID attributes are simply ignored,
            as are rdf:about attributes on inner nodes.
            </remarks>
            <param name="xmp">the xmp metadata object that is generated</param>
            <param name="xmpParent">the parent xmp node</param>
            <param name="xmlNode">the currently processed XML node</param>
            <param name="isTopLevel">Flag if the node is a top-level node</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">thown on parsing errors</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParseRdf.Rdf_PropertyElementList(iText.Kernel.XMP.Impl.XMPMetaImpl,iText.Kernel.XMP.Impl.XMPNode,System.Xml.XmlNode,System.Boolean)">
            <summary>
            7.2.13 propertyEltList
            ws* ( propertyElt ws* )
            </summary>
            <param name="xmp">the xmp metadata object that is generated</param>
            <param name="xmpParent">the parent xmp node</param>
            <param name="xmlParent">the currently processed XML node</param>
            <param name="isTopLevel">Flag if the node is a top-level node</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">thown on parsing errors</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParseRdf.Rdf_PropertyElement(iText.Kernel.XMP.Impl.XMPMetaImpl,iText.Kernel.XMP.Impl.XMPNode,System.Xml.XmlNode,System.Boolean)">
            <summary>
            7.2.14 propertyElt
            resourcePropertyElt | literalPropertyElt | parseTypeLiteralPropertyElt |
            parseTypeResourcePropertyElt | parseTypeCollectionPropertyElt |
            parseTypeOtherPropertyElt | emptyPropertyElt
            7.2.15 resourcePropertyElt
            start-element ( URI == propertyElementURIs, attributes == set ( idAttr? ) )
            ws* nodeElement ws
            end-element()
            7.2.16 literalPropertyElt
            start-element (
            URI == propertyElementURIs, attributes == set ( idAttr?, datatypeAttr?) )
            text()
            end-element()
            7.2.17 parseTypeLiteralPropertyElt
            start-element (
            URI == propertyElementURIs, attributes == set ( idAttr?, parseLiteral ) )
            literal
            end-element()
            7.2.18 parseTypeResourcePropertyElt
            start-element (
            URI == propertyElementURIs, attributes == set ( idAttr?, parseResource ) )
            propertyEltList
            end-element()
            7.2.19 parseTypeCollectionPropertyElt
            start-element (
            URI == propertyElementURIs, attributes == set ( idAttr?, parseCollection ) )
            nodeElementList
            end-element()
            7.2.20 parseTypeOtherPropertyElt
            start-element ( URI == propertyElementURIs, attributes == set ( idAttr?, parseOther ) )
            propertyEltList
            end-element()
            7.2.21 emptyPropertyElt
            start-element ( URI == propertyElementURIs,
            attributes == set ( idAttr?, ( resourceAttr | nodeIdAttr )?, propertyAttr* ) )
            end-element()
            The various property element forms are not distinguished by the XML element name,
            but by their attributes for the most part.
            </summary>
            <remarks>
            7.2.14 propertyElt
            resourcePropertyElt | literalPropertyElt | parseTypeLiteralPropertyElt |
            parseTypeResourcePropertyElt | parseTypeCollectionPropertyElt |
            parseTypeOtherPropertyElt | emptyPropertyElt
            7.2.15 resourcePropertyElt
            start-element ( URI == propertyElementURIs, attributes == set ( idAttr? ) )
            ws* nodeElement ws
            end-element()
            7.2.16 literalPropertyElt
            start-element (
            URI == propertyElementURIs, attributes == set ( idAttr?, datatypeAttr?) )
            text()
            end-element()
            7.2.17 parseTypeLiteralPropertyElt
            start-element (
            URI == propertyElementURIs, attributes == set ( idAttr?, parseLiteral ) )
            literal
            end-element()
            7.2.18 parseTypeResourcePropertyElt
            start-element (
            URI == propertyElementURIs, attributes == set ( idAttr?, parseResource ) )
            propertyEltList
            end-element()
            7.2.19 parseTypeCollectionPropertyElt
            start-element (
            URI == propertyElementURIs, attributes == set ( idAttr?, parseCollection ) )
            nodeElementList
            end-element()
            7.2.20 parseTypeOtherPropertyElt
            start-element ( URI == propertyElementURIs, attributes == set ( idAttr?, parseOther ) )
            propertyEltList
            end-element()
            7.2.21 emptyPropertyElt
            start-element ( URI == propertyElementURIs,
            attributes == set ( idAttr?, ( resourceAttr | nodeIdAttr )?, propertyAttr* ) )
            end-element()
            The various property element forms are not distinguished by the XML element name,
            but by their attributes for the most part. The exceptions are resourcePropertyElt and
            literalPropertyElt. They are distinguished by their XML element content.
            NOTE: The RDF syntax does not explicitly include the xml:lang attribute although it can
            appear in many of these. We have to allow for it in the attibute counts below.
            </remarks>
            <param name="xmp">the xmp metadata object that is generated</param>
            <param name="xmpParent">the parent xmp node</param>
            <param name="xmlNode">the currently processed XML node</param>
            <param name="isTopLevel">Flag if the node is a top-level node</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">thown on parsing errors</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParseRdf.Rdf_ResourcePropertyElement(iText.Kernel.XMP.Impl.XMPMetaImpl,iText.Kernel.XMP.Impl.XMPNode,System.Xml.XmlNode,System.Boolean)">
            <summary>
            7.2.15 resourcePropertyElt
            start-element ( URI == propertyElementURIs, attributes == set ( idAttr? ) )
            ws* nodeElement ws
            end-element()
            This handles structs using an rdf:Description node,
            arrays using rdf:Bag/Seq/Alt, and typedNodes.
            </summary>
            <remarks>
            7.2.15 resourcePropertyElt
            start-element ( URI == propertyElementURIs, attributes == set ( idAttr? ) )
            ws* nodeElement ws
            end-element()
            This handles structs using an rdf:Description node,
            arrays using rdf:Bag/Seq/Alt, and typedNodes. It also catches and cleans up qualified
            properties written with rdf:Description and rdf:value.
            </remarks>
            <param name="xmp">the xmp metadata object that is generated</param>
            <param name="xmpParent">the parent xmp node</param>
            <param name="xmlNode">the currently processed XML node</param>
            <param name="isTopLevel">Flag if the node is a top-level node</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">thown on parsing errors</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParseRdf.Rdf_LiteralPropertyElement(iText.Kernel.XMP.Impl.XMPMetaImpl,iText.Kernel.XMP.Impl.XMPNode,System.Xml.XmlNode,System.Boolean)">
            <summary>
            7.2.16 literalPropertyElt
            start-element ( URI == propertyElementURIs,
            attributes == set ( idAttr?, datatypeAttr?) )
            text()
            end-element()
            Add a leaf node with the text value and qualifiers for the attributes.
            </summary>
            <param name="xmp">the xmp metadata object that is generated</param>
            <param name="xmpParent">the parent xmp node</param>
            <param name="xmlNode">the currently processed XML node</param>
            <param name="isTopLevel">Flag if the node is a top-level node</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">thown on parsing errors</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParseRdf.Rdf_ParseTypeLiteralPropertyElement">
            <summary>
            7.2.17 parseTypeLiteralPropertyElt
            start-element ( URI == propertyElementURIs,
            attributes == set ( idAttr?, parseLiteral ) )
            literal
            end-element()
            </summary>
            <exception cref="T:iText.Kernel.XMP.XMPException">thown on parsing errors</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParseRdf.Rdf_ParseTypeResourcePropertyElement(iText.Kernel.XMP.Impl.XMPMetaImpl,iText.Kernel.XMP.Impl.XMPNode,System.Xml.XmlNode,System.Boolean)">
            <summary>
            7.2.18 parseTypeResourcePropertyElt
            start-element ( URI == propertyElementURIs,
            attributes == set ( idAttr?, parseResource ) )
            propertyEltList
            end-element()
            Add a new struct node with a qualifier for the possible rdf:ID attribute.
            </summary>
            <remarks>
            7.2.18 parseTypeResourcePropertyElt
            start-element ( URI == propertyElementURIs,
            attributes == set ( idAttr?, parseResource ) )
            propertyEltList
            end-element()
            Add a new struct node with a qualifier for the possible rdf:ID attribute.
            Then process the XML child nodes to get the struct fields.
            </remarks>
            <param name="xmp">the xmp metadata object that is generated</param>
            <param name="xmpParent">the parent xmp node</param>
            <param name="xmlNode">the currently processed XML node</param>
            <param name="isTopLevel">Flag if the node is a top-level node</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">thown on parsing errors</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParseRdf.Rdf_ParseTypeCollectionPropertyElement">
            <summary>
            7.2.19 parseTypeCollectionPropertyElt
            start-element ( URI == propertyElementURIs,
            attributes == set ( idAttr?, parseCollection ) )
            nodeElementList
            end-element()
            </summary>
            <exception cref="T:iText.Kernel.XMP.XMPException">thown on parsing errors</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParseRdf.Rdf_ParseTypeOtherPropertyElement">
            <summary>
            7.2.20 parseTypeOtherPropertyElt
            start-element ( URI == propertyElementURIs, attributes == set ( idAttr?, parseOther ) )
            propertyEltList
            end-element()
            </summary>
            <exception cref="T:iText.Kernel.XMP.XMPException">thown on parsing errors</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.Impl.ParseRdf.Rdf_EmptyPropertyElement(iText.Kernel.XMP.Impl.XMPMetaImpl,iText.Kernel.XMP.Impl.XMPNode,System.Xml.XmlNode,System.Boolean)" -->
        <member name="M:iText.Kernel.XMP.Impl.ParseRdf.AddChildNode(iText.Kernel.XMP.Impl.XMPMetaImpl,iText.Kernel.XMP.Impl.XMPNode,System.Xml.XmlNode,System.String,System.Boolean)">
            <summary>Adds a child node.</summary>
            <param name="xmp">the xmp metadata object that is generated</param>
            <param name="xmpParent">the parent xmp node</param>
            <param name="xmlNode">the currently processed XML node</param>
            <param name="value">Node value</param>
            <param name="isTopLevel">Flag if the node is a top-level node</param>
            <returns>Returns the newly created child node.</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">thown on parsing errors</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParseRdf.AddQualifierNode(iText.Kernel.XMP.Impl.XMPNode,System.String,System.String)">
            <summary>Adds a qualifier node.</summary>
            <param name="xmpParent">the parent xmp node</param>
            <param name="name">
            the name of the qualifier which has to be
            QName including the <b>default prefix</b>
            </param>
            <param name="value">the value of the qualifier</param>
            <returns>Returns the newly created child node.</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">thown on parsing errors</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParseRdf.FixupQualifiedNode(iText.Kernel.XMP.Impl.XMPNode)">
            <summary>The parent is an RDF pseudo-struct containing an rdf:value field.</summary>
            <remarks>
            The parent is an RDF pseudo-struct containing an rdf:value field. Fix the
            XMP data model. The rdf:value node must be the first child, the other
            children are qualifiers. The form, value, and children of the rdf:value
            node are the real ones. The rdf:value node's qualifiers must be added to
            the others.
            </remarks>
            <param name="xmpParent">the parent xmp node</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">thown on parsing errors</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParseRdf.IsWhitespaceNode(System.Xml.XmlNode)">
            <summary>Checks if the node is a white space.</summary>
            <param name="node">an XML-node</param>
            <returns>
            Returns whether the node is a whitespace node,
            i.e. a text node that contains only whitespaces.
            </returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParseRdf.IsPropertyElementName(System.Int32)">
            <summary>
            7.2.6 propertyElementURIs
            anyURI - ( coreSyntaxTerms | rdf:Description | oldTerms )
            </summary>
            <param name="term">the term id</param>
            <returns>Return true if the term is a property element name.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParseRdf.IsOldTerm(System.Int32)">
            <summary>
            7.2.4 oldTerms<br />
            rdf:aboutEach | rdf:aboutEachPrefix | rdf:bagID
            </summary>
            <param name="term">the term id</param>
            <returns>Returns true if the term is an old term.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParseRdf.IsCoreSyntaxTerm(System.Int32)">
            <summary>
            7.2.2 coreSyntaxTerms<br />
            rdf:RDF | rdf:ID | rdf:about | rdf:parseType | rdf:resource | rdf:nodeID |
            rdf:datatype
            </summary>
            <param name="term">the term id</param>
            <returns>Return true if the term is a core syntax term</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.ParseRdf.GetRdfTermKind(System.Xml.XmlNode)">
            <summary>Determines the ID for a certain RDF Term.</summary>
            <remarks>
            Determines the ID for a certain RDF Term.
            Arranged to hopefully minimize the parse time for large XMP.
            </remarks>
            <param name="node">an XML node</param>
            <returns>Returns the term ID.</returns>
        </member>
        <member name="T:iText.Kernel.XMP.Impl.QName">
            <since>09.11.2006</since>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.QName.prefix">
            <summary>XML namespace prefix</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.QName.localName">
            <summary>XML localname</summary>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.QName.#ctor(System.String)">
            <summary>Splits a qname into prefix and localname.</summary>
            <param name="qname">a QName</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.QName.#ctor(System.String,System.String)">
            <summary>Constructor that initializes the fields</summary>
            <param name="prefix">the prefix</param>
            <param name="localName">the name</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.QName.HasPrefix">
            <returns>Returns whether the QName has a prefix.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.QName.GetLocalName">
            <returns>the localName</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.QName.GetPrefix">
            <returns>the prefix</returns>
        </member>
        <member name="T:iText.Kernel.XMP.Impl.Utils">
            <summary>Utility functions for the XMPToolkit implementation.</summary>
            <since>06.06.2006</since>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.Utils.UUID_SEGMENT_COUNT">
            <summary>segments of a UUID</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.Utils.UUID_LENGTH">
            <summary>length of a UUID</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.Utils.xmlNameStartChars">
            <summary>table of XML name start chars (&lt;= 0xFF)</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.Utils.xmlNameChars">
            <summary>table of XML name chars (&lt;= 0xFF)</summary>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.Utils.#ctor">
            <summary>Private constructor</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.Impl.Utils.NormalizeLangValue(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.Impl.Utils.SplitNameAndValue(System.String)" -->
        <member name="M:iText.Kernel.XMP.Impl.Utils.IsInternalProperty(System.String,System.String)">
            <param name="schema">a schema namespace</param>
            <param name="prop">an XMP Property</param>
            <returns>
            Returns true if the property is defined as &quot;Internal
            Property&quot;, see XMP Specification.
            </returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.Utils.CheckUUIDFormat(System.String)">
            <summary>
            Check some requirements for an UUID:
            <ul>
            <li>Length of the UUID is 32</li>
            <li>The Delimiter count is 4 and all the 4 delimiter are on their right
            position (8,13,18,23)</li>
            </ul>
            </summary>
            <param name="uuid">uuid to test</param>
            <returns>true - this is a well formed UUID, false - UUID has not the expected format</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.Utils.IsXMLName(System.String)">
            <summary>Simple check for valid XMLNames.</summary>
            <remarks>
            Simple check for valid XMLNames. Within ASCII range<br />
            ":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6]<br />
            are accepted, above all characters (which is not entirely
            correct according to the XML Spec.
            </remarks>
            <param name="name">an XML Name</param>
            <returns>Return <code>true</code> if the name is correct.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.Utils.IsXMLNameNS(System.String)">
            <summary>
            Checks if the value is a legal "unqualified" XML name, as
            defined in the XML Namespaces proposed recommendation.
            </summary>
            <remarks>
            Checks if the value is a legal "unqualified" XML name, as
            defined in the XML Namespaces proposed recommendation.
            These are XML names, except that they must not contain a colon.
            </remarks>
            <param name="name">the value to check</param>
            <returns>Returns true if the name is a valid "unqualified" XML name.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.Utils.IsControlChar(System.Char)">
            <param name="c">a char</param>
            <returns>Returns true if the char is an ASCII control char.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.Utils.EscapeXML(System.String,System.Boolean,System.Boolean)">
            <summary>Serializes the node value in XML encoding.</summary>
            <remarks>
            Serializes the node value in XML encoding. Its used for tag bodies and
            attributes.<br />
            <em>Note:</em> The attribute is always limited by quotes,
            thats why <code>&amp;apos;</code> is never serialized.<br />
            <em>Note:</em> Control chars are written unescaped, but if the user uses others than tab, LF
            and CR the resulting XML will become invalid.
            </remarks>
            <param name="value">a string</param>
            <param name="forAttribute">flag if string is attribute value (need to additional escape quotes)</param>
            <param name="escapeWhitespaces">Decides if LF, CR and TAB are escaped.</param>
            <returns>Returns the value ready for XML output.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.Utils.RemoveControlChars(System.String)">
            <summary>Replaces the ASCII control chars with a space.</summary>
            <param name="value">a node value</param>
            <returns>Returns the cleaned up value</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.Utils.IsNameStartChar(System.Char)">
            <summary>Simple check if a character is a valid XML start name char.</summary>
            <remarks>
            Simple check if a character is a valid XML start name char.
            All characters according to the XML Spec 1.1 are accepted:
            http://www.w3.org/TR/xml11/#NT-NameStartChar
            </remarks>
            <param name="ch">a character</param>
            <returns>Returns true if the character is a valid first char of an XML name.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.Utils.IsNameChar(System.Char)">
            <summary>
            Simple check if a character is a valid XML name char
            (every char except the first one), according to the XML Spec 1.1:
            http://www.w3.org/TR/xml11/#NT-NameChar
            </summary>
            <param name="ch">a character</param>
            <returns>Returns true if the character is a valid char of an XML name.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.Utils.InitCharTables">
            <summary>
            Initializes the char tables for the chars 0x00-0xFF for later use,
            according to the XML 1.1 specification
            http://www.w3.org/TR/xml11
            </summary>
        </member>
        <member name="T:iText.Kernel.XMP.Impl.XMPDateTimeImpl">
            <summary>The implementation of <code>XMPDateTime</code>.</summary>
            <remarks>
            The implementation of <code>XMPDateTime</code>. Internally a <code>calendar</code> is used
            plus an additional nano seconds field, because <code>Calendar</code> supports only milli
            seconds. The <code>nanoSeconds</code> convers only the resolution beyond a milli second.
            </remarks>
            <since>16.02.2006</since>
        </member>
        <!-- Badly formed XML comment ignored for member "T:iText.Kernel.XMP.XMPDateTime" -->
        <member name="M:iText.Kernel.XMP.XMPDateTime.GetYear">
            <returns>Returns the year, can be negative.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPDateTime.SetYear(System.Int32)">
            <param name="year">Sets the year</param>
        </member>
        <member name="M:iText.Kernel.XMP.XMPDateTime.GetMonth">
            <returns>Returns The month in the range 1..12.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPDateTime.SetMonth(System.Int32)">
            <param name="month">Sets the month 1..12</param>
        </member>
        <member name="M:iText.Kernel.XMP.XMPDateTime.GetDay">
            <returns>Returns the day of the month in the range 1..31.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPDateTime.SetDay(System.Int32)">
            <param name="day">Sets the day 1..31</param>
        </member>
        <member name="M:iText.Kernel.XMP.XMPDateTime.GetHour">
            <returns>Returns hour - The hour in the range 0..23.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPDateTime.SetHour(System.Int32)">
            <param name="hour">Sets the hour in the range 0..23.</param>
        </member>
        <member name="M:iText.Kernel.XMP.XMPDateTime.GetMinute">
            <returns>Returns the minute in the range 0..59.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPDateTime.SetMinute(System.Int32)">
            <param name="minute">Sets the minute in the range 0..59.</param>
        </member>
        <member name="M:iText.Kernel.XMP.XMPDateTime.GetSecond">
            <returns>Returns the second in the range 0..59.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPDateTime.SetSecond(System.Int32)">
            <param name="second">Sets the second in the range 0..59.</param>
        </member>
        <member name="M:iText.Kernel.XMP.XMPDateTime.GetNanoSecond">
            <returns>
            Returns milli-, micro- and nano seconds.
            Nanoseconds within a second, often left as zero?
            </returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPDateTime.SetNanoSecond(System.Int32)">
            <param name="nanoSecond">
            Sets the milli-, micro- and nano seconds.
            Granularity goes down to milli seconds.
            </param>
        </member>
        <member name="M:iText.Kernel.XMP.XMPDateTime.GetTimeZone">
            <returns>Returns the time zone.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPDateTime.SetTimeZone(System.TimeZone)">
            <param name="tz">a time zone to set</param>
        </member>
        <member name="M:iText.Kernel.XMP.XMPDateTime.HasDate">
            <summary>This flag is set either by parsing or by setting year, month or day.</summary>
            <returns>Returns true if the XMPDateTime object has a date portion.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPDateTime.HasTime">
            <summary>This flag is set either by parsing or by setting hours, minutes, seconds or milliseconds.
            	</summary>
            <returns>Returns true if the XMPDateTime object has a time portion.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPDateTime.HasTimeZone">
            <summary>This flag is set either by parsing or by setting hours, minutes, seconds or milliseconds.
            	</summary>
            <returns>Returns true if the XMPDateTime object has a defined timezone.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPDateTime.GetCalendar">
            <returns>
            Returns a <code>Calendar</code> (only with milli second precision). <br />
            <em>Note:</em> the dates before Oct 15th 1585 (which normally fall into validity of
            the Julian calendar) are also rendered internally as Gregorian dates.
            </returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPDateTime.GetIso8601String">
            <returns>Returns the ISO 8601 string representation of the date and time.</returns>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPDateTimeImpl.timeZone">
            <summary>Use NO time zone as default</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPDateTimeImpl.nanoSeconds">
            <summary>The nano seconds take micro and nano seconds, while the milli seconds are in the calendar.
            	</summary>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPDateTimeImpl.#ctor">
            <summary>
            Creates an <code>XMPDateTime</code>-instance with the current time in the default time
            zone.
            </summary>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPDateTimeImpl.#ctor(iText.Kernel.XMP.XMPCalendar)">
            <summary>
            Creates an <code>XMPDateTime</code>-instance from a calendar.
            </summary>
            <param name="calendar"> a <code>Calendar</code> </param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPDateTimeImpl.#ctor(System.DateTime,System.TimeZone)">
            <summary>
            Creates an <code>XMPDateTime</code>-instance from 
            a <code>Date</code> and a <code>TimeZone</code>.
            </summary>
            <param name="date"> a date describing an absolute point in time </param>
            <param name="timeZone"> a TimeZone how to interpret the date </param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPDateTimeImpl.#ctor(System.String)">
            <summary>Creates an <code>XMPDateTime</code>-instance from an ISO 8601 string.</summary>
            <param name="strValue">an ISO 8601 string</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">If the string is a non-conform ISO 8601 string, an exception is thrown
            	</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPDateTimeImpl.GetYear">
            <seealso cref="M:iText.Kernel.XMP.XMPDateTime.GetYear"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPDateTimeImpl.SetYear(System.Int32)">
            <seealso cref="M:iText.Kernel.XMP.XMPDateTime.SetYear(System.Int32)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPDateTimeImpl.GetMonth">
            <seealso cref="M:iText.Kernel.XMP.XMPDateTime.GetMonth"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPDateTimeImpl.SetMonth(System.Int32)">
            <seealso cref="M:iText.Kernel.XMP.XMPDateTime.SetMonth(System.Int32)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPDateTimeImpl.GetDay">
            <seealso cref="M:iText.Kernel.XMP.XMPDateTime.GetDay"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPDateTimeImpl.SetDay(System.Int32)">
            <seealso cref="M:iText.Kernel.XMP.XMPDateTime.SetDay(System.Int32)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPDateTimeImpl.GetHour">
            <seealso cref="M:iText.Kernel.XMP.XMPDateTime.GetHour"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPDateTimeImpl.SetHour(System.Int32)">
            <seealso cref="M:iText.Kernel.XMP.XMPDateTime.SetHour(System.Int32)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPDateTimeImpl.GetMinute">
            <seealso cref="M:iText.Kernel.XMP.XMPDateTime.GetMinute"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPDateTimeImpl.SetMinute(System.Int32)">
            <seealso cref="M:iText.Kernel.XMP.XMPDateTime.SetMinute(System.Int32)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPDateTimeImpl.GetSecond">
            <seealso cref="M:iText.Kernel.XMP.XMPDateTime.GetSecond"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPDateTimeImpl.SetSecond(System.Int32)">
            <seealso cref="M:iText.Kernel.XMP.XMPDateTime.SetSecond(System.Int32)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPDateTimeImpl.GetNanoSecond">
            <seealso cref="M:iText.Kernel.XMP.XMPDateTime.GetNanoSecond"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPDateTimeImpl.SetNanoSecond(System.Int32)">
            <seealso cref="M:iText.Kernel.XMP.XMPDateTime.SetNanoSecond(System.Int32)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPDateTimeImpl.CompareTo(System.Object)">
            <seealso cref="!:System.IComparable&lt;T&gt;.CompareTo(System.Object)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPDateTimeImpl.GetTimeZone">
            <seealso cref="M:iText.Kernel.XMP.XMPDateTime.GetTimeZone"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPDateTimeImpl.SetTimeZone(System.TimeZone)">
            <seealso cref="!:iText.Kernel.XMP.XMPDateTime.SetTimeZone(Java.Util.TimeZone)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPDateTimeImpl.HasDate">
            <seealso cref="M:iText.Kernel.XMP.XMPDateTime.HasDate"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPDateTimeImpl.HasTime">
            <seealso cref="M:iText.Kernel.XMP.XMPDateTime.HasTime"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPDateTimeImpl.HasTimeZone">
            <seealso cref="M:iText.Kernel.XMP.XMPDateTime.HasTimeZone"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPDateTimeImpl.GetCalendar">
            <seealso cref="M:iText.Kernel.XMP.XMPDateTime.GetCalendar"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPDateTimeImpl.GetIso8601String">
            <seealso cref="!:iText.Kernel.XMP.XMPDateTime.GetISO8601String()"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPDateTimeImpl.ToString">
            <returns>Returns the ISO string representation.</returns>
        </member>
        <member name="T:iText.Kernel.XMP.Impl.XMPIteratorImpl">
            <summary>The <code>XMPIterator</code> implementation.</summary>
            <remarks>
            The <code>XMPIterator</code> implementation.
            Iterates the XMP Tree according to a set of options.
            During the iteration the XMPMeta-object must not be changed.
            Calls to <code>skipSubtree()</code> / <code>skipSiblings()</code> will affect the iteration.
            </remarks>
            <since>29.06.2006</since>
        </member>
        <!-- Badly formed XML comment ignored for member "T:iText.Kernel.XMP.XMPIterator" -->
        <member name="M:iText.Kernel.XMP.XMPIterator.SkipSubtree">
            <summary>
            Skip the subtree below the current node when <code>next()</code> is
            called.
            </summary>
        </member>
        <member name="M:iText.Kernel.XMP.XMPIterator.SkipSiblings">
            <summary>
            Skip the subtree below and remaining siblings of the current node when
            <code>next()</code> is called.
            </summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPIteratorImpl.options">
            <summary>stores the iterator options</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPIteratorImpl.baseNS">
            <summary>the base namespace of the property path, will be changed during the iteration
            	</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPIteratorImpl.skipSiblings">
            <summary>flag to indicate that skipSiblings() has been called.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPIteratorImpl.skipSubtree">
            <summary>flag to indicate that skipSiblings() has been called.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPIteratorImpl.nodeIterator">
            <summary>the node iterator doing the work</summary>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPIteratorImpl.#ctor(iText.Kernel.XMP.Impl.XMPMetaImpl,System.String,System.String,iText.Kernel.XMP.Options.IteratorOptions)">
            <summary>Constructor with optionsl initial values.</summary>
            <remarks>
            Constructor with optionsl initial values. If <code>propName</code> is provided,
            <code>schemaNS</code> has also be provided.
            </remarks>
            <param name="xmp">the iterated metadata object.</param>
            <param name="schemaNS">the iteration is reduced to this schema (optional)</param>
            <param name="propPath">the iteration is redurce to this property within the <code>schemaNS</code>
            	</param>
            <param name="options">
            advanced iteration options, see
            <see cref="T:iText.Kernel.XMP.Options.IteratorOptions"/>
            </param>
            <exception cref="T:iText.Kernel.XMP.XMPException">If the node defined by the paramters is not existing.
            	</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPIteratorImpl.SkipSubtree">
            <seealso cref="M:iText.Kernel.XMP.XMPIterator.SkipSubtree"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPIteratorImpl.SkipSiblings">
            <seealso cref="M:iText.Kernel.XMP.XMPIterator.SkipSiblings"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPIteratorImpl.MoveNext">
            <seealso cref="!:System.Collections.IEnumerator&lt;E&gt;.MoveNext()"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPIteratorImpl.GetOptions">
            <returns>Exposes the options for inner class.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPIteratorImpl.GetBaseNS">
            <returns>Exposes the options for inner class.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPIteratorImpl.SetBaseNS(System.String)">
            <param name="baseNS">sets the baseNS from the inner class.</param>
        </member>
        <member name="P:iText.Kernel.XMP.Impl.XMPIteratorImpl.Current">
            <seealso cref="!:System.Collections.IEnumerator&lt;E&gt;.Current()"/>
        </member>
        <member name="T:iText.Kernel.XMP.Impl.XMPIteratorImpl.NodeIterator">
            <summary>The <code>XMPIterator</code> implementation.</summary>
            <remarks>
            The <code>XMPIterator</code> implementation.
            It first returns the node itself, then recursivly the children and qualifier of the node.
            </remarks>
            <since>29.06.2006</since>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPIteratorImpl.NodeIterator.ITERATE_NODE">
            <summary>
            iteration state </summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPIteratorImpl.NodeIterator.ITERATE_CHILDREN">
            <summary>
            iteration state </summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPIteratorImpl.NodeIterator.ITERATE_QUALIFIER">
            <summary>
            iteration state </summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPIteratorImpl.NodeIterator.path">
            <summary>
            the recursively accumulated path </summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPIteratorImpl.NodeIterator.visitedNode">
            <summary>
            the currently visited node </summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPIteratorImpl.NodeIterator.childrenIterator">
            <summary>
            the iterator that goes through the children and qualifier list </summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPIteratorImpl.NodeIterator.index">
            <summary>
            index of node with parent, only interesting for arrays </summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPIteratorImpl.NodeIterator.returnProperty">
            <summary>
            the cached <code>PropertyInfo</code> to return </summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPIteratorImpl.NodeIterator.state">
            <summary>
            the state of the iteration </summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPIteratorImpl.NodeIterator.subIterator">
            <summary>
            the iterator for each child </summary>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPIteratorImpl.NodeIterator.#ctor(iText.Kernel.XMP.Impl.XMPIteratorImpl,iText.Kernel.XMP.Impl.XMPNode,System.String,System.Int32)">
            <summary>
            Constructor for the node iterator. </summary>
            <param name="visitedNode"> the currently visited node </param>
            <param name="parentPath"> the accumulated path of the node </param>
            <param name="index"> the index within the parent node (only for arrays) </param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPIteratorImpl.NodeIterator.GetChildrenIterator">
            <returns> the childrenIterator </returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPIteratorImpl.NodeIterator.GetReturnProperty">
            <returns> Returns the returnProperty. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.Impl.XMPIteratorImpl.NodeIterator.MoveNext" -->
        <member name="M:iText.Kernel.XMP.Impl.XMPIteratorImpl.NodeIterator.ReportNode">
            <summary>
            Sets the returnProperty as next item or recurses into <code>hasNext()</code>. </summary>
            <returns> Returns if there is a next item to return.  </returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPIteratorImpl.NodeIterator.IterateChildren(System.Collections.IEnumerator)">
            <summary>
            Handles the iteration of the children or qualfier </summary>
            <param name="iterator"> an iterator </param>
            <returns> Returns if there are more elements available. </returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPIteratorImpl.NodeIterator.AccumulatePath(iText.Kernel.XMP.Impl.XMPNode,System.String,System.Int32)">
            <param name="currNode"> the node that will be added to the path. </param>
            <param name="parentPath"> the path up to this node. </param>
            <param name="currentIndex"> the current array index if an arrey is traversed </param>
            <returns> Returns the updated path. </returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPIteratorImpl.NodeIterator.CreatePropertyInfo(iText.Kernel.XMP.Impl.XMPNode,System.String,System.String)">
            <summary>
            Creates a property info object from an <code>XMPNode</code>. </summary>
            <param name="node"> an <code>XMPNode</code> </param>
            <param name="baseNs"> the base namespace to report </param>
            <param name="path"> the full property path </param>
            <returns> Returns a <code>XMPProperty</code>-object that serves representation of the node. </returns>
        </member>
        <member name="T:iText.Kernel.XMP.Properties.XMPPropertyInfo">
            <summary>This interface is used to return a property together with its path and namespace.</summary>
            <remarks>
            This interface is used to return a property together with its path and namespace.
            It is returned when properties are iterated with the <code>XMPIterator</code>.
            </remarks>
            <since>06.07.2006</since>
        </member>
        <member name="T:iText.Kernel.XMP.Properties.XMPProperty">
            <summary>This interface is used to return a text property together with its and options.</summary>
            <since>23.01.2006</since>
        </member>
        <member name="M:iText.Kernel.XMP.Properties.XMPProperty.GetValue">
            <returns>Returns the value of the property.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Properties.XMPProperty.GetOptions">
            <returns>Returns the options of the property.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Properties.XMPProperty.GetLanguage">
            <summary>
            Only set by
            <see cref="M:iText.Kernel.XMP.XMPMeta.GetLocalizedText(System.String,System.String,System.String,System.String)"/>
            .
            </summary>
            <returns>Returns the language of the alt-text item.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Properties.XMPPropertyInfo.GetNamespace">
            <returns>Returns the namespace of the property</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Properties.XMPPropertyInfo.GetPath">
            <returns>Returns the path of the property, but only if returned by the iterator.</returns>
        </member>
        <member name="T:iText.Kernel.XMP.Impl.XMPIteratorImpl.NodeIteratorChildren">
            <summary>
            This iterator is derived from the default <code>NodeIterator</code>,
            and is only used for the option <seealso cref="F:iText.Kernel.XMP.Options.IteratorOptions.JUST_CHILDREN"/>.
            
            @since 02.10.2006
            </summary>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPIteratorImpl.NodeIteratorChildren.#ctor(iText.Kernel.XMP.Impl.XMPIteratorImpl,iText.Kernel.XMP.Impl.XMPNode,System.String)">
            <summary>
            Constructor </summary>
            <param name="parentNode"> the node which children shall be iterated. </param>
            <param name="parentPath"> the full path of the former node without the leaf node. </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.Impl.XMPIteratorImpl.NodeIteratorChildren.MoveNext" -->
        <member name="T:iText.Kernel.XMP.Impl.XMPMetaImpl">
            <summary>
            Implementation for
            <see cref="T:iText.Kernel.XMP.XMPMeta"/>
            .
            </summary>
            <since>17.02.2006</since>
        </member>
        <member name="T:iText.Kernel.XMP.XMPMeta">
            <summary>This class represents the set of XMP metadata as a DOM representation.</summary>
            <remarks>
            This class represents the set of XMP metadata as a DOM representation. It has methods to read and
            modify all kinds of properties, create an iterator over all properties and serialize the metadata
            to a String, byte-array or <code>OutputStream</code>.
            </remarks>
            <since>20.01.2006</since>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.XMPMeta.GetProperty(System.String,System.String)" -->
        <member name="M:iText.Kernel.XMP.XMPMeta.GetArrayItem(System.String,System.String,System.Int32)">
            <summary>Provides access to items within an array.</summary>
            <remarks>
            Provides access to items within an array. The index is passed as an integer, you need not
            worry about the path string syntax for array items, convert a loop index to a string, etc.
            </remarks>
            <param name="schemaNS">The namespace URI for the array. Has the same usage as in getProperty.</param>
            <param name="arrayName">
            The name of the array. May be a general path expression, must not be
            <code>null</code> or the empty string. Has the same namespace prefix usage as
            propName in <code>getProperty()</code>.
            </param>
            <param name="itemIndex">
            The index of the desired item. Arrays in XMP are indexed from 1. The
            constant
            <see cref="F:iText.Kernel.XMP.XMPConst.ARRAY_LAST_ITEM"/>
            always refers to the last existing array
            item.
            </param>
            <returns>
            Returns a <code>XMPProperty</code> containing the value and the options or
            <code>null</code> if the property does not exist.
            </returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">Wraps all errors and exceptions that may occur.</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.CountArrayItems(System.String,System.String)">
            <summary>Returns the number of items in the array.</summary>
            <param name="schemaNS">The namespace URI for the array. Has the same usage as in getProperty.</param>
            <param name="arrayName">
            The name of the array. May be a general path expression, must not be
            <code>null</code> or the empty string. Has the same namespace prefix usage as
            propName in <code>getProperty()</code>.
            </param>
            <returns>Returns the number of items in the array.</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">Wraps all errors and exceptions that may occur.</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.XMPMeta.GetStructField(System.String,System.String,System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.XMPMeta.GetQualifier(System.String,System.String,System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.XMPMeta.SetProperty(System.String,System.String,System.Object,iText.Kernel.XMP.Options.PropertyOptions)" -->
        <member name="M:iText.Kernel.XMP.XMPMeta.SetProperty(System.String,System.String,System.Object)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetProperty(System.String,System.String,System.Object,iText.Kernel.XMP.Options.PropertyOptions)"/>
            <param name="schemaNS">The namespace URI</param>
            <param name="propName">The name of the property</param>
            <param name="propValue">the value for the property</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Wraps all errors and exceptions</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.SetArrayItem(System.String,System.String,System.Int32,System.String,iText.Kernel.XMP.Options.PropertyOptions)">
            <summary>Replaces an item within an array.</summary>
            <remarks>
            Replaces an item within an array. The index is passed as an integer, you need not worry about
            the path string syntax for array items, convert a loop index to a string, etc. The array
            passed must already exist. In normal usage the selected array item is modified. A new item is
            automatically appended if the index is the array size plus 1.
            </remarks>
            <param name="schemaNS">The namespace URI for the array. Has the same usage as in getProperty.</param>
            <param name="arrayName">
            The name of the array. May be a general path expression, must not be
            <code>null</code> or the empty string. Has the same namespace prefix usage as
            propName in getProperty.
            </param>
            <param name="itemIndex">
            The index of the desired item. Arrays in XMP are indexed from 1. To address
            the last existing item, use
            <see cref="M:iText.Kernel.XMP.XMPMeta.CountArrayItems(System.String,System.String)"/>
            to find
            out the length of the array.
            </param>
            <param name="itemValue">
            the new value of the array item. Has the same usage as propValue in
            <code>setProperty()</code>.
            </param>
            <param name="options">the set options for the item.</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Wraps all errors and exceptions that may occur.</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.SetArrayItem(System.String,System.String,System.Int32,System.String)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetArrayItem(System.String,System.String,System.Int32,System.String,iText.Kernel.XMP.Options.PropertyOptions)"/>
            <param name="schemaNS">The namespace URI</param>
            <param name="arrayName">The name of the array</param>
            <param name="itemIndex">The index to insert the new item</param>
            <param name="itemValue">the new value of the array item</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Wraps all errors and exceptions</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.InsertArrayItem(System.String,System.String,System.Int32,System.String,iText.Kernel.XMP.Options.PropertyOptions)">
            <summary>Inserts an item into an array previous to the given index.</summary>
            <remarks>
            Inserts an item into an array previous to the given index. The index is passed as an integer,
            you need not worry about the path string syntax for array items, convert a loop index to a
            string, etc. The array passed must already exist. In normal usage the selected array item is
            modified. A new item is automatically appended if the index is the array size plus 1.
            </remarks>
            <param name="schemaNS">The namespace URI for the array. Has the same usage as in getProperty.</param>
            <param name="arrayName">
            The name of the array. May be a general path expression, must not be
            <code>null</code> or the empty string. Has the same namespace prefix usage as
            propName in getProperty.
            </param>
            <param name="itemIndex">
            The index to insert the new item. Arrays in XMP are indexed from 1. Use
            <code>XMPConst.ARRAY_LAST_ITEM</code> to append items.
            </param>
            <param name="itemValue">
            the new value of the array item. Has the same usage as
            propValue in <code>setProperty()</code>.
            </param>
            <param name="options">the set options that decide about the kind of the node.</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Wraps all errors and exceptions that may occur.</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.InsertArrayItem(System.String,System.String,System.Int32,System.String)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.InsertArrayItem(System.String,System.String,System.Int32,System.String,iText.Kernel.XMP.Options.PropertyOptions)"/>
            <param name="schemaNS">The namespace URI for the array</param>
            <param name="arrayName">The name of the array</param>
            <param name="itemIndex">The index to insert the new item</param>
            <param name="itemValue">the value of the array item</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Wraps all errors and exceptions</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.XMPMeta.AppendArrayItem(System.String,System.String,iText.Kernel.XMP.Options.PropertyOptions,System.String,iText.Kernel.XMP.Options.PropertyOptions)" -->
        <member name="M:iText.Kernel.XMP.XMPMeta.AppendArrayItem(System.String,System.String,System.String)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.AppendArrayItem(System.String,System.String,iText.Kernel.XMP.Options.PropertyOptions,System.String,iText.Kernel.XMP.Options.PropertyOptions)"/>
            <param name="schemaNS">The namespace URI for the array</param>
            <param name="arrayName">The name of the array</param>
            <param name="itemValue">the value of the array item</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Wraps all errors and exceptions</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.SetStructField(System.String,System.String,System.String,System.String,System.String,iText.Kernel.XMP.Options.PropertyOptions)">
            <summary>Provides access to fields within a nested structure.</summary>
            <remarks>
            Provides access to fields within a nested structure. The namespace for the field is passed as
            a URI, you need not worry about the path string syntax. The names of fields should be XML
            qualified names, that is within an XML namespace. The path syntax for a qualified name uses
            the namespace prefix, which is unreliable because the prefix is never guaranteed. The URI is
            the formal name, the prefix is just a local shorthand in a given sequence of XML text.
            </remarks>
            <param name="schemaNS">The namespace URI for the struct. Has the same usage as in getProperty.</param>
            <param name="structName">
            The name of the struct. May be a general path expression, must not be null
            or the empty string. Has the same namespace prefix usage as propName in getProperty.
            </param>
            <param name="fieldNS">
            The namespace URI for the field. Has the same URI and prefix usage as the
            schemaNS parameter.
            </param>
            <param name="fieldName">
            The name of the field. Must be a single XML name, must not be null or the
            empty string. Has the same namespace prefix usage as the structName parameter.
            </param>
            <param name="fieldValue">
            the value of thefield, if the field has a value.
            Has the same usage as propValue in getProperty.
            </param>
            <param name="options">Option flags describing the field. See the earlier description.</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Wraps all errors and exceptions that may occur.</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.SetStructField(System.String,System.String,System.String,System.String,System.String)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetStructField(System.String,System.String,System.String,System.String,System.String,iText.Kernel.XMP.Options.PropertyOptions)"/>
            <param name="schemaNS">The namespace URI for the struct</param>
            <param name="structName">The name of the struct</param>
            <param name="fieldNS">The namespace URI for the field</param>
            <param name="fieldName">The name of the field</param>
            <param name="fieldValue">the value of the field</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Wraps all errors and exceptions</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.SetQualifier(System.String,System.String,System.String,System.String,System.String,iText.Kernel.XMP.Options.PropertyOptions)">
            <summary>Provides access to a qualifier attached to a property.</summary>
            <remarks>
            Provides access to a qualifier attached to a property. The namespace for the qualifier is
            passed as a URI, you need not worry about the path string syntax. In many regards qualifiers
            are like struct fields. See the introductory discussion of qualified properties for more
            information. The names of qualifiers should be XML qualified names, that is within an XML
            namespace. The path syntax for a qualified name uses the namespace prefix, which is
            unreliable because the prefix is never guaranteed. The URI is the formal name, the prefix is
            just a local shorthand in a given sequence of XML text. The property the qualifier
            will be attached has to exist.
            </remarks>
            <param name="schemaNS">The namespace URI for the struct. Has the same usage as in getProperty.</param>
            <param name="propName">
            The name of the property to which the qualifier is attached. Has the same
            usage as in getProperty.
            </param>
            <param name="qualNS">
            The namespace URI for the qualifier. Has the same URI and prefix usage as the
            schemaNS parameter.
            </param>
            <param name="qualName">
            The name of the qualifier. Must be a single XML name, must not be
            <code>null</code> or the empty string. Has the same namespace prefix usage as the
            propName parameter.
            </param>
            <param name="qualValue">
            A pointer to the <code>null</code> terminated UTF-8 string that is the
            value of the qualifier, if the qualifier has a value. Has the same usage as propValue
            in getProperty.
            </param>
            <param name="options">Option flags describing the qualifier. See the earlier description.</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Wraps all errors and exceptions that may occur.</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.SetQualifier(System.String,System.String,System.String,System.String,System.String)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetQualifier(System.String,System.String,System.String,System.String,System.String,iText.Kernel.XMP.Options.PropertyOptions)"/>
            <param name="schemaNS">The namespace URI for the struct</param>
            <param name="propName">The name of the property to which the qualifier is attached</param>
            <param name="qualNS">The namespace URI for the qualifier</param>
            <param name="qualName">The name of the qualifier</param>
            <param name="qualValue">the value of the qualifier</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Wraps all errors and exceptions</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.DeleteProperty(System.String,System.String)">
            <summary>Deletes the given XMP subtree rooted at the given property.</summary>
            <remarks>
            Deletes the given XMP subtree rooted at the given property. It is not an error if the
            property does not exist.
            </remarks>
            <param name="schemaNS">
            The namespace URI for the property. Has the same usage as in
            <code>getProperty()</code>.
            </param>
            <param name="propName">The name of the property. Has the same usage as in getProperty.</param>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.DeleteArrayItem(System.String,System.String,System.Int32)">
            <summary>Deletes the given XMP subtree rooted at the given array item.</summary>
            <remarks>
            Deletes the given XMP subtree rooted at the given array item. It is not an error if the array
            item does not exist.
            </remarks>
            <param name="schemaNS">The namespace URI for the array. Has the same usage as in getProperty.</param>
            <param name="arrayName">
            The name of the array. May be a general path expression, must not be
            <code>null</code> or the empty string. Has the same namespace prefix usage as
            propName in <code>getProperty()</code>.
            </param>
            <param name="itemIndex">
            The index of the desired item. Arrays in XMP are indexed from 1. The
            constant <code>XMPConst.ARRAY_LAST_ITEM</code> always refers to the last
            existing array item.
            </param>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.DeleteStructField(System.String,System.String,System.String,System.String)">
            <summary>Deletes the given XMP subtree rooted at the given struct field.</summary>
            <remarks>
            Deletes the given XMP subtree rooted at the given struct field. It is not an error if the
            field does not exist.
            </remarks>
            <param name="schemaNS">
            The namespace URI for the struct. Has the same usage as in
            <code>getProperty()</code>.
            </param>
            <param name="structName">
            The name of the struct. May be a general path expression, must not be
            <code>null</code> or the empty string. Has the same namespace prefix usage as
            propName in getProperty.
            </param>
            <param name="fieldNS">
            The namespace URI for the field. Has the same URI and prefix usage as the
            schemaNS parameter.
            </param>
            <param name="fieldName">
            The name of the field. Must be a single XML name, must not be
            <code>null</code> or the empty string. Has the same namespace prefix usage as the
            structName parameter.
            </param>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.DeleteQualifier(System.String,System.String,System.String,System.String)">
            <summary>Deletes the given XMP subtree rooted at the given qualifier.</summary>
            <remarks>
            Deletes the given XMP subtree rooted at the given qualifier. It is not an error if the
            qualifier does not exist.
            </remarks>
            <param name="schemaNS">
            The namespace URI for the struct. Has the same usage as in
            <code>getProperty()</code>.
            </param>
            <param name="propName">
            The name of the property to which the qualifier is attached. Has the same
            usage as in getProperty.
            </param>
            <param name="qualNS">
            The namespace URI for the qualifier. Has the same URI and prefix usage as the
            schemaNS parameter.
            </param>
            <param name="qualName">
            The name of the qualifier. Must be a single XML name, must not be
            <code>null</code> or the empty string. Has the same namespace prefix usage as the
            propName parameter.
            </param>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.DoesPropertyExist(System.String,System.String)">
            <summary>Returns whether the property exists.</summary>
            <param name="schemaNS">
            The namespace URI for the property. Has the same usage as in
            <code>getProperty()</code>.
            </param>
            <param name="propName">
            The name of the property.
            Has the same usage as in <code>getProperty()</code>.
            </param>
            <returns>Returns true if the property exists.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.DoesArrayItemExist(System.String,System.String,System.Int32)">
            <summary>Tells if the array item exists.</summary>
            <param name="schemaNS">
            The namespace URI for the array. Has the same usage as in
            <code>getProperty()</code>.
            </param>
            <param name="arrayName">
            The name of the array. May be a general path expression, must not be
            <code>null</code> or the empty string. Has the same namespace prefix usage as
            propName in <code>getProperty()</code>.
            </param>
            <param name="itemIndex">
            The index of the desired item. Arrays in XMP are indexed from 1. The
            constant <code>XMPConst.ARRAY_LAST_ITEM</code> always refers to the last
            existing array item.
            </param>
            <returns>Returns <code>true</code> if the array exists, <code>false</code> otherwise.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.DoesStructFieldExist(System.String,System.String,System.String,System.String)">
            <summary>DoesStructFieldExist tells if the struct field exists.</summary>
            <param name="schemaNS">
            The namespace URI for the struct. Has the same usage as in
            <code>getProperty()</code>.
            </param>
            <param name="structName">
            The name of the struct. May be a general path expression, must not be
            <code>null</code> or the empty string. Has the same namespace prefix usage as
            propName in <code>getProperty()</code>.
            </param>
            <param name="fieldNS">
            The namespace URI for the field. Has the same URI and prefix usage as the
            schemaNS parameter.
            </param>
            <param name="fieldName">
            The name of the field. Must be a single XML name, must not be
            <code>null</code> or the empty string. Has the same namespace prefix usage as the
            structName parameter.
            </param>
            <returns>Returns true if the field exists.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.DoesQualifierExist(System.String,System.String,System.String,System.String)">
            <summary>DoesQualifierExist tells if the qualifier exists.</summary>
            <param name="schemaNS">
            The namespace URI for the struct. Has the same usage as in
            <code>getProperty()</code>.
            </param>
            <param name="propName">
            The name of the property to which the qualifier is attached. Has the same
            usage as in <code>getProperty()</code>.
            </param>
            <param name="qualNS">
            The namespace URI for the qualifier. Has the same URI and prefix usage as the
            schemaNS parameter.
            </param>
            <param name="qualName">
            The name of the qualifier. Must be a single XML name, must not be
            <code>null</code> or the empty string. Has the same namespace prefix usage as the
            propName parameter.
            </param>
            <returns>Returns true if the qualifier exists.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.XMPMeta.GetLocalizedText(System.String,System.String,System.String,System.String)" -->
        <member name="M:iText.Kernel.XMP.XMPMeta.SetLocalizedText(System.String,System.String,System.String,System.String,System.String,iText.Kernel.XMP.Options.PropertyOptions)">
            <summary>Modifies the value of a selected item in an alt-text array.</summary>
            <remarks>
            Modifies the value of a selected item in an alt-text array. Creates an appropriate array item
            if necessary, and handles special cases for the x-default item. If the selected item is from
            a match with the specific language, the value of that item is modified. If the existing value
            of that item matches the existing value of the x-default item, the x-default item is also
            modified. If the array only has 1 existing item (which is not x-default), an x-default item
            is added with the given value. If the selected item is from a match with the generic language
            and there are no other generic matches, the value of that item is modified. If the existing
            value of that item matches the existing value of the x-default item, the x-default item is
            also modified. If the array only has 1 existing item (which is not x-default), an x-default
            item is added with the given value. If the selected item is from a partial match with the
            generic language and there are other partial matches, a new item is created for the specific
            language. The x-default item is not modified. If the selected item is from the last 2 rules
            then a new item is created for the specific language. If the array only had an x-default
            item, the x-default item is also modified. If the array was empty, items are created for the
            specific language and x-default.
            <em>Note:</em> In a future version of this API a method
            using Java <code>java.lang.Locale</code> will be added.
            </remarks>
            <param name="schemaNS">
            The namespace URI for the alt-text array. Has the same usage as in
            <code>getProperty()</code>.
            </param>
            <param name="altTextName">
            The name of the alt-text array. May be a general path expression, must not
            be <code>null</code> or the empty string. Has the same namespace prefix usage as
            propName in <code>getProperty()</code>.
            </param>
            <param name="genericLang">
            The name of the generic language as an RFC 3066 primary subtag. May be
            <code>null</code> or the empty string if no generic language is wanted.
            </param>
            <param name="specificLang">
            The name of the specific language as an RFC 3066 tag. Must not be
            <code>null</code> or the empty string.
            </param>
            <param name="itemValue">
            A pointer to the <code>null</code> terminated UTF-8 string that is the new
            value for the appropriate array item.
            </param>
            <param name="options">Option flags, none are defined at present.</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Wraps all errors and exceptions that may occur.</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.SetLocalizedText(System.String,System.String,System.String,System.String,System.String)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetLocalizedText(System.String,System.String,System.String,System.String,System.String,iText.Kernel.XMP.Options.PropertyOptions)"/>
            <param name="schemaNS">The namespace URI for the alt-text array</param>
            <param name="altTextName">The name of the alt-text array</param>
            <param name="genericLang">The name of the generic language</param>
            <param name="specificLang">The name of the specific language</param>
            <param name="itemValue">the new value for the appropriate array item</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Wraps all errors and exceptions</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.GetPropertyBoolean(System.String,System.String)">
            <summary>
            These are very similar to <code>getProperty()</code> and <code>SetProperty()</code> above,
            but the value is returned or provided in a literal form instead of as a UTF-8 string.
            </summary>
            <remarks>
            These are very similar to <code>getProperty()</code> and <code>SetProperty()</code> above,
            but the value is returned or provided in a literal form instead of as a UTF-8 string.
            The path composition functions in <code>XMPPathFactory</code> may be used to compose an path
            expression for fields in nested structures, items in arrays, or qualifiers.
            </remarks>
            <param name="schemaNS">
            The namespace URI for the property. Has the same usage as in
            <code>getProperty()</code>.
            </param>
            <param name="propName">
            The name of the property.
            Has the same usage as in <code>getProperty()</code>.
            </param>
            <returns>
            Returns a <code>Boolean</code> value or <code>null</code>
            if the property does not exist.
            </returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">
            Wraps all exceptions that may occur,
            especially conversion errors.
            </exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.GetPropertyInteger(System.String,System.String)">
            <summary>Convenience method to retrieve the literal value of a property.</summary>
            <param name="schemaNS">
            The namespace URI for the property. Has the same usage as in
            <code>getProperty()</code>.
            </param>
            <param name="propName">
            The name of the property.
            Has the same usage as in <code>getProperty()</code>.
            </param>
            <returns>
            Returns an <code>Integer</code> value or <code>null</code>
            if the property does not exist.
            </returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">
            Wraps all exceptions that may occur,
            especially conversion errors.
            </exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.GetPropertyLong(System.String,System.String)">
            <summary>Convenience method to retrieve the literal value of a property.</summary>
            <param name="schemaNS">
            The namespace URI for the property. Has the same usage as in
            <code>getProperty()</code>.
            </param>
            <param name="propName">
            The name of the property.
            Has the same usage as in <code>getProperty()</code>.
            </param>
            <returns>
            Returns a <code>Long</code> value or <code>null</code>
            if the property does not exist.
            </returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">
            Wraps all exceptions that may occur,
            especially conversion errors.
            </exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.GetPropertyDouble(System.String,System.String)">
            <summary>Convenience method to retrieve the literal value of a property.</summary>
            <param name="schemaNS">
            The namespace URI for the property. Has the same usage as in
            <code>getProperty()</code>.
            </param>
            <param name="propName">
            The name of the property.
            Has the same usage as in <code>getProperty()</code>.
            </param>
            <returns>
            Returns a <code>Double</code> value or <code>null</code>
            if the property does not exist.
            </returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">
            Wraps all exceptions that may occur,
            especially conversion errors.
            </exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.GetPropertyDate(System.String,System.String)">
            <summary>Convenience method to retrieve the literal value of a property.</summary>
            <param name="schemaNS">
            The namespace URI for the property. Has the same usage as in
            <code>getProperty()</code>.
            </param>
            <param name="propName">
            The name of the property.
            Has the same usage as in <code>getProperty()</code>.
            </param>
            <returns>
            Returns a <code>XMPDateTime</code>-object or <code>null</code>
            if the property does not exist.
            </returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">
            Wraps all exceptions that may occur,
            especially conversion errors.
            </exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.GetPropertyCalendar(System.String,System.String)">
            <summary>Convenience method to retrieve the literal value of a property.</summary>
            <param name="schemaNS">
            The namespace URI for the property. Has the same usage as in
            <code>getProperty()</code>.
            </param>
            <param name="propName">
            The name of the property.
            Has the same usage as in <code>getProperty()</code>.
            </param>
            <returns>
            Returns a Java <code>Calendar</code>-object or <code>null</code>
            if the property does not exist.
            </returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">
            Wraps all exceptions that may occur,
            especially conversion errors.
            </exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.GetPropertyBase64(System.String,System.String)">
            <summary>Convenience method to retrieve the literal value of a property.</summary>
            <param name="schemaNS">
            The namespace URI for the property. Has the same usage as in
            <code>getProperty()</code>.
            </param>
            <param name="propName">
            The name of the property.
            Has the same usage as in <code>getProperty()</code>.
            </param>
            <returns>
            Returns a <code>byte[]</code>-array contained the decoded base64 value
            or <code>null</code> if the property does not exist.
            </returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">
            Wraps all exceptions that may occur,
            especially conversion errors.
            </exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.GetPropertyString(System.String,System.String)">
            <summary>Convenience method to retrieve the literal value of a property.</summary>
            <remarks>
            Convenience method to retrieve the literal value of a property.
            <em>Note:</em> There is no <code>setPropertyString()</code>,
            because <code>setProperty()</code> sets a string value.
            </remarks>
            <param name="schemaNS">
            The namespace URI for the property. Has the same usage as in
            <code>getProperty()</code>.
            </param>
            <param name="propName">
            The name of the property.
            Has the same usage as in <code>getProperty()</code>.
            </param>
            <returns>
            Returns a <code>String</code> value or <code>null</code>
            if the property does not exist.
            </returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">
            Wraps all exceptions that may occur,
            especially conversion errors.
            </exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.SetPropertyBoolean(System.String,System.String,System.Boolean,iText.Kernel.XMP.Options.PropertyOptions)">
            <summary>Convenience method to set a property to a literal <code>boolean</code> value.</summary>
            <param name="schemaNS">
            The namespace URI for the property. Has the same usage as in
            <code>setProperty()</code>.
            </param>
            <param name="propName">
            The name of the property.
            Has the same usage as in <code>getProperty()</code>.
            </param>
            <param name="propValue">the literal property value as <code>boolean</code>.</param>
            <param name="options">options of the property to set (optional).</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Wraps all exceptions that may occur.</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.SetPropertyBoolean(System.String,System.String,System.Boolean)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetPropertyBoolean(System.String,System.String,System.Boolean,iText.Kernel.XMP.Options.PropertyOptions)"/>
            <param name="schemaNS">The namespace URI for the property</param>
            <param name="propName">The name of the property</param>
            <param name="propValue">the literal property value as <code>boolean</code></param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Wraps all exceptions</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.SetPropertyInteger(System.String,System.String,System.Int32,iText.Kernel.XMP.Options.PropertyOptions)">
            <summary>Convenience method to set a property to a literal <code>int</code> value.</summary>
            <param name="schemaNS">
            The namespace URI for the property. Has the same usage as in
            <code>setProperty()</code>.
            </param>
            <param name="propName">
            The name of the property.
            Has the same usage as in <code>getProperty()</code>.
            </param>
            <param name="propValue">the literal property value as <code>int</code>.</param>
            <param name="options">options of the property to set (optional).</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Wraps all exceptions that may occur.</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.SetPropertyInteger(System.String,System.String,System.Int32)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetPropertyInteger(System.String,System.String,System.Int32,iText.Kernel.XMP.Options.PropertyOptions)"/>
            <param name="schemaNS">The namespace URI for the property</param>
            <param name="propName">The name of the property</param>
            <param name="propValue">the literal property value as <code>int</code></param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Wraps all exceptions</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.SetPropertyLong(System.String,System.String,System.Int64,iText.Kernel.XMP.Options.PropertyOptions)">
            <summary>Convenience method to set a property to a literal <code>long</code> value.</summary>
            <param name="schemaNS">
            The namespace URI for the property. Has the same usage as in
            <code>setProperty()</code>.
            </param>
            <param name="propName">
            The name of the property.
            Has the same usage as in <code>getProperty()</code>.
            </param>
            <param name="propValue">the literal property value as <code>long</code>.</param>
            <param name="options">options of the property to set (optional).</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Wraps all exceptions that may occur.</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.SetPropertyLong(System.String,System.String,System.Int64)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetPropertyLong(System.String,System.String,System.Int64,iText.Kernel.XMP.Options.PropertyOptions)"/>
            <param name="schemaNS">The namespace URI for the property</param>
            <param name="propName">The name of the property</param>
            <param name="propValue">the literal property value as <code>long</code></param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Wraps all exceptions</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.SetPropertyDouble(System.String,System.String,System.Double,iText.Kernel.XMP.Options.PropertyOptions)">
            <summary>Convenience method to set a property to a literal <code>double</code> value.</summary>
            <param name="schemaNS">
            The namespace URI for the property. Has the same usage as in
            <code>setProperty()</code>.
            </param>
            <param name="propName">
            The name of the property.
            Has the same usage as in <code>getProperty()</code>.
            </param>
            <param name="propValue">the literal property value as <code>double</code>.</param>
            <param name="options">options of the property to set (optional).</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Wraps all exceptions that may occur.</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.SetPropertyDouble(System.String,System.String,System.Double)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetPropertyDouble(System.String,System.String,System.Double,iText.Kernel.XMP.Options.PropertyOptions)"/>
            <param name="schemaNS">The namespace URI for the property</param>
            <param name="propName">The name of the property</param>
            <param name="propValue">the literal property value as <code>double</code></param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Wraps all exceptions</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.SetPropertyDate(System.String,System.String,iText.Kernel.XMP.XMPDateTime,iText.Kernel.XMP.Options.PropertyOptions)">
            <summary>
            Convenience method to set a property with an XMPDateTime-object,
            which is serialized to an ISO8601 date.
            </summary>
            <param name="schemaNS">
            The namespace URI for the property. Has the same usage as in
            <code>setProperty()</code>.
            </param>
            <param name="propName">
            The name of the property.
            Has the same usage as in <code>getProperty()</code>.
            </param>
            <param name="propValue">the property value as <code>XMPDateTime</code>.</param>
            <param name="options">options of the property to set (optional).</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Wraps all exceptions that may occur.</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.SetPropertyDate(System.String,System.String,iText.Kernel.XMP.XMPDateTime)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetPropertyDate(System.String,System.String,iText.Kernel.XMP.XMPDateTime,iText.Kernel.XMP.Options.PropertyOptions)"/>
            <param name="schemaNS">The namespace URI for the property</param>
            <param name="propName">The name of the property</param>
            <param name="propValue">the property value as <code>XMPDateTime</code></param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Wraps all exceptions</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.SetPropertyCalendar(System.String,System.String,System.DateTime,iText.Kernel.XMP.Options.PropertyOptions)">
            <summary>
            Convenience method to set a property with a Java Calendar-object,
            which is serialized to an ISO8601 date.
            </summary>
            <param name="schemaNS">
            The namespace URI for the property. Has the same usage as in
            <code>setProperty()</code>.
            </param>
            <param name="propName">
            The name of the property.
            Has the same usage as in <code>getProperty()</code>.
            </param>
            <param name="propValue">the property value as Java <code>Calendar</code>.</param>
            <param name="options">options of the property to set (optional).</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Wraps all exceptions that may occur.</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.SetPropertyCalendar(System.String,System.String,System.DateTime)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetPropertyCalendar(System.String,System.String,System.DateTime,iText.Kernel.XMP.Options.PropertyOptions)"/>
            <param name="schemaNS">The namespace URI for the property</param>
            <param name="propName">The name of the property</param>
            <param name="propValue">the property value as <code>Calendar</code></param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Wraps all exceptions</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.SetPropertyBase64(System.String,System.String,System.Byte[],iText.Kernel.XMP.Options.PropertyOptions)">
            <summary>
            Convenience method to set a property from a binary <code>byte[]</code>-array,
            which is serialized as base64-string.
            </summary>
            <param name="schemaNS">
            The namespace URI for the property. Has the same usage as in
            <code>setProperty()</code>.
            </param>
            <param name="propName">
            The name of the property.
            Has the same usage as in <code>getProperty()</code>.
            </param>
            <param name="propValue">the literal property value as byte array.</param>
            <param name="options">options of the property to set (optional).</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Wraps all exceptions that may occur.</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.SetPropertyBase64(System.String,System.String,System.Byte[])">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetPropertyBase64(System.String,System.String,System.Byte[],iText.Kernel.XMP.Options.PropertyOptions)"/>
            <param name="schemaNS">The namespace URI for the property</param>
            <param name="propName">The name of the property</param>
            <param name="propValue">the literal property value as byte array</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Wraps all exceptions</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.Iterator">
            <summary>Constructs an iterator for the properties within this XMP object.</summary>
            <returns>Returns an <code>XMPIterator</code>.</returns>
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.Iterator(System.String,System.String,iText.Kernel.XMP.Options.IteratorOptions)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException">Wraps all errors and exceptions that may occur.</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.Iterator(iText.Kernel.XMP.Options.IteratorOptions)">
            <summary>Constructs an iterator for the properties within this XMP object using some options.</summary>
            <param name="options">Option flags to control the iteration.</param>
            <returns>Returns an <code>XMPIterator</code>.</returns>
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.Iterator(System.String,System.String,iText.Kernel.XMP.Options.IteratorOptions)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException">Wraps all errors and exceptions that may occur.</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.Iterator(System.String,System.String,iText.Kernel.XMP.Options.IteratorOptions)">
            <summary>Construct an iterator for the properties within an XMP object.</summary>
            <remarks>
            Construct an iterator for the properties within an XMP object. According to the parameters it iterates the entire data tree,
            properties within a specific schema, or a subtree rooted at a specific node.
            </remarks>
            <param name="schemaNS">
            Optional schema namespace URI to restrict the iteration. Omitted (visit all
            schema) by passing <code>null</code> or empty String.
            </param>
            <param name="propName">
            Optional property name to restrict the iteration. May be an arbitrary path
            expression. Omitted (visit all properties) by passing <code>null</code> or empty
            String. If no schema URI is given, it is ignored.
            </param>
            <param name="options">
            Option flags to control the iteration. See
            <see cref="T:iText.Kernel.XMP.Options.IteratorOptions"/>
            for
            details.
            </param>
            <returns>
            Returns an <code>XMPIterator</code> for this <code>XMPMeta</code>-object
            considering the given options.
            </returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">Wraps all errors and exceptions that may occur.</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.GetObjectName">
            <summary>
            This correlates to the about-attribute,
            returns the empty String if no name is set.
            </summary>
            <returns>Returns the name of the XMP object.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.SetObjectName(System.String)">
            <param name="name">Sets the name of the XMP object.</param>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.GetPacketHeader">
            <returns>
            Returns the unparsed content of the &lt;?xpacket&gt; processing instruction.
            This contains normally the attribute-like elements 'begin="&lt;BOM&gt;"
            id="W5M0MpCehiHzreSzNTczkc9d"' and possibly the deprecated elements 'bytes="1234"' or
            'encoding="XXX"'. If the parsed packet has not been wrapped into an xpacket,
            <code>null</code> is returned.
            </returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.Clone">
            <summary>Clones the complete metadata tree.</summary>
            <returns>Returns a deep copy of this instance.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.XMPMeta.Sort" -->
        <member name="M:iText.Kernel.XMP.XMPMeta.Normalize(iText.Kernel.XMP.Options.ParseOptions)">
            <summary>Perform the normalization as a separate parsing step.</summary>
            <remarks>
            Perform the normalization as a separate parsing step.
            Normally it is done during parsing, unless the parsing option
            <see cref="F:iText.Kernel.XMP.Options.ParseOptions.OMIT_NORMALIZATION"/>
            is set to <code>true</code>.
            <em>Note:</em> It does no harm to call this method to an already normalized xmp object.
            It was a PDF/A requirement to get hand on the unnormalized <code>XMPMeta</code> object.
            </remarks>
            <param name="options">optional parsing options.</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Wraps all errors and exceptions that may occur.</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMeta.DumpObject">
            <summary>Renders this node and the tree unter this node in a human readable form.</summary>
            <returns>Returns a multiline string containing the dump.</returns>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPMetaImpl.VALUE_STRING">
            <summary>Property values are Strings by default</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPMetaImpl.tree">
            <summary>root of the metadata tree</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPMetaImpl.packetHeader">
            <summary>the xpacket processing instructions content</summary>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.#ctor">
            <summary>Constructor for an empty metadata object.</summary>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.#ctor(iText.Kernel.XMP.Impl.XMPNode)">
            <summary>Constructor for a cloned metadata tree.</summary>
            <param name="tree">
            an prefilled metadata tree which fulfills all
            <code>XMPNode</code> contracts.
            </param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.AppendArrayItem(System.String,System.String,iText.Kernel.XMP.Options.PropertyOptions,System.String,iText.Kernel.XMP.Options.PropertyOptions)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.AppendArrayItem(System.String,System.String,iText.Kernel.XMP.Options.PropertyOptions,System.String,iText.Kernel.XMP.Options.PropertyOptions)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.AppendArrayItem(System.String,System.String,System.String)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.AppendArrayItem(System.String,System.String,System.String)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.CountArrayItems(System.String,System.String)">
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.CountArrayItems(System.String,System.String)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.DeleteArrayItem(System.String,System.String,System.Int32)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.DeleteArrayItem(System.String,System.String,System.Int32)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.DeleteProperty(System.String,System.String)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.DeleteProperty(System.String,System.String)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.DeleteQualifier(System.String,System.String,System.String,System.String)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.DeleteQualifier(System.String,System.String,System.String,System.String)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.DeleteStructField(System.String,System.String,System.String,System.String)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.DeleteStructField(System.String,System.String,System.String,System.String)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.DoesPropertyExist(System.String,System.String)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.DoesPropertyExist(System.String,System.String)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.DoesArrayItemExist(System.String,System.String,System.Int32)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.DoesArrayItemExist(System.String,System.String,System.Int32)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.DoesStructFieldExist(System.String,System.String,System.String,System.String)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.DoesStructFieldExist(System.String,System.String,System.String,System.String)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.DoesQualifierExist(System.String,System.String,System.String,System.String)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.DoesQualifierExist(System.String,System.String,System.String,System.String)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.GetArrayItem(System.String,System.String,System.Int32)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.GetArrayItem(System.String,System.String,System.Int32)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.GetLocalizedText(System.String,System.String,System.String,System.String)">
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.GetLocalizedText(System.String,System.String,System.String,System.String)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.SetLocalizedText(System.String,System.String,System.String,System.String,System.String,iText.Kernel.XMP.Options.PropertyOptions)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetLocalizedText(System.String,System.String,System.String,System.String,System.String,iText.Kernel.XMP.Options.PropertyOptions)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.SetLocalizedText(System.String,System.String,System.String,System.String,System.String)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetLocalizedText(System.String,System.String,System.String,System.String,System.String)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.GetProperty(System.String,System.String)">
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.GetProperty(System.String,System.String)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.GetProperty(System.String,System.String,System.Int32)">
            <summary>Returns a property, but the result value can be requested.</summary>
            <remarks>
            Returns a property, but the result value can be requested. It can be one
            of
            <see cref="F:iText.Kernel.XMP.Impl.XMPMetaImpl.VALUE_STRING"/>
            ,
            <see cref="F:iText.Kernel.XMP.Impl.XMPMetaImpl.VALUE_BOOLEAN"/>
            ,
            <see cref="F:iText.Kernel.XMP.Impl.XMPMetaImpl.VALUE_INTEGER"/>
            ,
            <see cref="F:iText.Kernel.XMP.Impl.XMPMetaImpl.VALUE_LONG"/>
            ,
            <see cref="F:iText.Kernel.XMP.Impl.XMPMetaImpl.VALUE_DOUBLE"/>
            ,
            <see cref="F:iText.Kernel.XMP.Impl.XMPMetaImpl.VALUE_DATE"/>
            ,
            <see cref="F:iText.Kernel.XMP.Impl.XMPMetaImpl.VALUE_CALENDAR"/>
            ,
            <see cref="F:iText.Kernel.XMP.Impl.XMPMetaImpl.VALUE_BASE64"/>
            .
            </remarks>
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.GetProperty(System.String,System.String)"/>
            <param name="schemaNS">a schema namespace</param>
            <param name="propName">a property name or path</param>
            <param name="valueType">the type of the value, see VALUE_...</param>
            <returns>Returns an <code>XMPProperty</code></returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">Collects any exception that occurs.
            	</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.GetPropertyObject(System.String,System.String,System.Int32)">
            <summary>Returns a property, but the result value can be requested.</summary>
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.GetProperty(System.String,System.String)"/>
            <param name="schemaNS">a schema namespace</param>
            <param name="propName">a property name or path</param>
            <param name="valueType">the type of the value, see VALUE_...</param>
            <returns>
            Returns the node value as an object according to the
            <code>valueType</code>.
            </returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">Collects any exception that occurs.
            	</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.GetPropertyBoolean(System.String,System.String)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.GetPropertyBoolean(System.String,System.String)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.SetPropertyBoolean(System.String,System.String,System.Boolean,iText.Kernel.XMP.Options.PropertyOptions)">
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetPropertyBoolean(System.String,System.String,System.Boolean,iText.Kernel.XMP.Options.PropertyOptions)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.SetPropertyBoolean(System.String,System.String,System.Boolean)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetPropertyBoolean(System.String,System.String,System.Boolean)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.GetPropertyInteger(System.String,System.String)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.GetPropertyInteger(System.String,System.String)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.SetPropertyInteger(System.String,System.String,System.Int32,iText.Kernel.XMP.Options.PropertyOptions)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetPropertyInteger(System.String,System.String,System.Int32,iText.Kernel.XMP.Options.PropertyOptions)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.SetPropertyInteger(System.String,System.String,System.Int32)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetPropertyInteger(System.String,System.String,System.Int32)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.GetPropertyLong(System.String,System.String)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.GetPropertyLong(System.String,System.String)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.SetPropertyLong(System.String,System.String,System.Int64,iText.Kernel.XMP.Options.PropertyOptions)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetPropertyLong(System.String,System.String,System.Int64,iText.Kernel.XMP.Options.PropertyOptions)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.SetPropertyLong(System.String,System.String,System.Int64)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetPropertyLong(System.String,System.String,System.Int64)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.GetPropertyDouble(System.String,System.String)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.GetPropertyDouble(System.String,System.String)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.SetPropertyDouble(System.String,System.String,System.Double,iText.Kernel.XMP.Options.PropertyOptions)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetPropertyDouble(System.String,System.String,System.Double,iText.Kernel.XMP.Options.PropertyOptions)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.SetPropertyDouble(System.String,System.String,System.Double)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetPropertyDouble(System.String,System.String,System.Double)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.GetPropertyDate(System.String,System.String)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.GetPropertyDate(System.String,System.String)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.SetPropertyDate(System.String,System.String,iText.Kernel.XMP.XMPDateTime,iText.Kernel.XMP.Options.PropertyOptions)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetPropertyDate(System.String,System.String,iText.Kernel.XMP.XMPDateTime,iText.Kernel.XMP.Options.PropertyOptions)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.SetPropertyDate(System.String,System.String,iText.Kernel.XMP.XMPDateTime)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetPropertyDate(System.String,System.String,iText.Kernel.XMP.XMPDateTime)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.GetPropertyCalendar(System.String,System.String)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.GetPropertyCalendar(System.String,System.String)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.SetPropertyCalendar(System.String,System.String,System.DateTime,iText.Kernel.XMP.Options.PropertyOptions)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetPropertyCalendar(System.String,System.String,System.DateTime,iText.Kernel.XMP.Options.PropertyOptions)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.SetPropertyCalendar(System.String,System.String,System.DateTime)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetPropertyCalendar(System.String,System.String,System.DateTime)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.GetPropertyBase64(System.String,System.String)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.GetPropertyBase64(System.String,System.String)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.GetPropertyString(System.String,System.String)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.GetPropertyString(System.String,System.String)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.SetPropertyBase64(System.String,System.String,System.Byte[],iText.Kernel.XMP.Options.PropertyOptions)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetPropertyBase64(System.String,System.String,System.Byte[],iText.Kernel.XMP.Options.PropertyOptions)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.SetPropertyBase64(System.String,System.String,System.Byte[])">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetPropertyBase64(System.String,System.String,System.Byte[])"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.GetQualifier(System.String,System.String,System.String,System.String)">
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.GetQualifier(System.String,System.String,System.String,System.String)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.GetStructField(System.String,System.String,System.String,System.String)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.GetStructField(System.String,System.String,System.String,System.String)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.Iterator">
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.Iterator"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.Iterator(iText.Kernel.XMP.Options.IteratorOptions)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.Iterator(iText.Kernel.XMP.Options.IteratorOptions)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.Iterator(System.String,System.String,iText.Kernel.XMP.Options.IteratorOptions)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.Iterator(System.String,System.String,iText.Kernel.XMP.Options.IteratorOptions)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.SetArrayItem(System.String,System.String,System.Int32,System.String,iText.Kernel.XMP.Options.PropertyOptions)">
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetArrayItem(System.String,System.String,System.Int32,System.String,iText.Kernel.XMP.Options.PropertyOptions)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.SetArrayItem(System.String,System.String,System.Int32,System.String)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetArrayItem(System.String,System.String,System.Int32,System.String)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.InsertArrayItem(System.String,System.String,System.Int32,System.String,iText.Kernel.XMP.Options.PropertyOptions)">
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.InsertArrayItem(System.String,System.String,System.Int32,System.String,iText.Kernel.XMP.Options.PropertyOptions)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.InsertArrayItem(System.String,System.String,System.Int32,System.String)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.InsertArrayItem(System.String,System.String,System.Int32,System.String)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.SetProperty(System.String,System.String,System.Object,iText.Kernel.XMP.Options.PropertyOptions)">
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetProperty(System.String,System.String,System.Object,iText.Kernel.XMP.Options.PropertyOptions)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.SetProperty(System.String,System.String,System.Object)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetProperty(System.String,System.String,System.Object)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.SetQualifier(System.String,System.String,System.String,System.String,System.String,iText.Kernel.XMP.Options.PropertyOptions)">
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetQualifier(System.String,System.String,System.String,System.String,System.String,iText.Kernel.XMP.Options.PropertyOptions)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.SetQualifier(System.String,System.String,System.String,System.String,System.String)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetQualifier(System.String,System.String,System.String,System.String,System.String)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.SetStructField(System.String,System.String,System.String,System.String,System.String,iText.Kernel.XMP.Options.PropertyOptions)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetStructField(System.String,System.String,System.String,System.String,System.String,iText.Kernel.XMP.Options.PropertyOptions)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.SetStructField(System.String,System.String,System.String,System.String,System.String)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetStructField(System.String,System.String,System.String,System.String,System.String)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.GetObjectName">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.GetObjectName"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.SetObjectName(System.String)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.SetObjectName(System.String)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.GetPacketHeader">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.GetPacketHeader"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.SetPacketHeader(System.String)">
            <summary>Sets the packetHeader attributes, only used by the parser.</summary>
            <param name="packetHeader">the processing instruction content</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.Clone">
            <summary>Performs a deep clone of the XMPMeta-object</summary>
            <seealso cref="!:System.Object.Clone()"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.DumpObject">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.DumpObject"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.Sort">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.Sort"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.Normalize(iText.Kernel.XMP.Options.ParseOptions)">
            <seealso cref="M:iText.Kernel.XMP.XMPMeta.Normalize(iText.Kernel.XMP.Options.ParseOptions)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.GetRoot">
            <returns>Returns the root node of the XMP tree.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.DoSetArrayItem(iText.Kernel.XMP.Impl.XMPNode,System.Int32,System.String,iText.Kernel.XMP.Options.PropertyOptions,System.Boolean)">
            <summary>Locate or create the item node and set the value.</summary>
            <remarks>
            Locate or create the item node and set the value. Note the index
            parameter is one-based! The index can be in the range [1..size + 1] or
            "last()", normalize it and check the insert flags. The order of the
            normalization checks is important. If the array is empty we end up with
            an index and location to set item size + 1.
            </remarks>
            <param name="arrayNode">an array node</param>
            <param name="itemIndex">the index where to insert the item</param>
            <param name="itemValue">the item value</param>
            <param name="itemOptions">the options for the new item</param>
            <param name="insert">insert oder overwrite at index position?</param>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.SetNode(iText.Kernel.XMP.Impl.XMPNode,System.Object,iText.Kernel.XMP.Options.PropertyOptions,System.Boolean)">
            <summary>
            The internals for setProperty() and related calls, used after the node is
            found or created.
            </summary>
            <param name="node">the newly created node</param>
            <param name="value">the node value, can be <code>null</code></param>
            <param name="newOptions">options for the new node, must not be <code>null</code>.
            	</param>
            <param name="deleteExisting">flag if the existing value is to be overwritten</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">thrown if options and value do not correspond
            	</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaImpl.EvaluateNodeValue(System.Int32,iText.Kernel.XMP.Impl.XMPNode)">
            <summary>
            Evaluates a raw node value to the given value type, apply special
            conversions for defined types in XMP.
            </summary>
            <param name="valueType">an int indicating the value type</param>
            <param name="propNode">the node containing the value</param>
            <returns>Returns a literal value for the node.</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="T:iText.Kernel.XMP.Impl.XMPMetaParser">
            <summary>
            This class replaces the <code>ExpatAdapter.cpp</code> and does the
            XML-parsing and fixes the prefix.
            </summary>
            <remarks>
            This class replaces the <code>ExpatAdapter.cpp</code> and does the
            XML-parsing and fixes the prefix. After the parsing several normalisations
            are applied to the XMPTree.
            </remarks>
            <since>01.02.2006</since>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaParser.#ctor">
            <summary>Hidden constructor, initialises the SAX parser handler.</summary>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaParser.Parse(System.Object,iText.Kernel.XMP.Options.ParseOptions)">
            <summary>
            Parses the input source into an XMP metadata object, including
            de-aliasing and normalisation.
            </summary>
            <param name="input">
            the input can be an <code>InputStream</code>, a <code>String</code> or
            a byte buffer containing the XMP packet.
            </param>
            <param name="options">the parse options</param>
            <returns>Returns the resulting XMP metadata object</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">Thrown if parsing or normalisation fails.
            	</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.Impl.XMPMetaParser.ParseXml(System.Object,iText.Kernel.XMP.Options.ParseOptions)" -->
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaParser.ParseXmlFromInputStream(System.IO.Stream,iText.Kernel.XMP.Options.ParseOptions)">
            <summary>
            Parses XML from an <seealso cref="T:System.IO.Stream"/>,
            fixing the encoding (Latin-1 to UTF-8) and illegal control character optionally.
            </summary>
            <param name="stream"> an <code>InputStream</code> </param>
            <param name="options"> the parsing options </param>
            <returns> Returns an XML DOM-Document. </returns>
            <exception cref="T:iText.Kernel.XMP.XMPException"> Thrown when the parsing fails. </exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaParser.ParseXmlFromBytebuffer(iText.Kernel.XMP.Impl.ByteBuffer,iText.Kernel.XMP.Options.ParseOptions)">
            <summary>
            Parses XML from a byte buffer,
            fixing the encoding (Latin-1 to UTF-8) and illegal control character optionally.
            </summary>
            <param name="buffer">a byte buffer containing the XMP packet</param>
            <param name="options">the parsing options</param>
            <returns>Returns an XML DOM-Document.</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">Thrown when the parsing fails.
            	</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPMetaParser.ParseXmlFromString(System.String,iText.Kernel.XMP.Options.ParseOptions)">
            <summary>
            Parses XML from a
            <see cref="T:System.String"/>
            ,
            fixing the illegal control character optionally.
            </summary>
            <param name="input">a <code>String</code> containing the XMP packet</param>
            <param name="options">the parsing options</param>
            <returns>Returns an XML DOM-Document.</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">Thrown when the parsing fails.
            	</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.Impl.XMPMetaParser.FindRootNode(System.Xml.XmlNode,System.Boolean,System.Object[])" -->
        <member name="T:iText.Kernel.XMP.Impl.XMPNode">
            <summary>
            A node in the internally XMP tree, which can be a schema node, a property node, an array node,
            an array item, a struct node or a qualifier node (without '?').
            </summary>
            <remarks>
            A node in the internally XMP tree, which can be a schema node, a property node, an array node,
            an array item, a struct node or a qualifier node (without '?').
            Possible improvements:
            1. The kind Node of node might be better represented by a class-hierarchy of different nodes.
            2. The array type should be an enum
            3. isImplicitNode should be removed completely and replaced by return values of fi.
            4. hasLanguage, hasType should be automatically maintained by XMPNode
            </remarks>
            <since>21.02.2006</since>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPNode.name">
            <summary>name of the node, contains different information depending of the node kind
            	</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPNode.value">
            <summary>value of the node, contains different information depending of the node kind
            	</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPNode.parent">
            <summary>link to the parent node</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPNode.children">
            <summary>list of child nodes, lazy initialized</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPNode.qualifier">
            <summary>list of qualifier of the node, lazy initialized</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPNode.options">
            <summary>options describing the kind of the node</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPNode.implicit">
            <summary>flag if the node is implicitly created</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPNode.hasAliases">
            <summary>flag if the node has aliases</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPNode.alias">
            <summary>flag if the node is an alias</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPNode.hasValueChild">
            <summary>flag if the node has an "rdf:value" child node.</summary>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.#ctor(System.String,System.String,iText.Kernel.XMP.Options.PropertyOptions)">
            <summary>Creates an <code>XMPNode</code> with initial values.</summary>
            <param name="name">the name of the node</param>
            <param name="value">the value of the node</param>
            <param name="options">the options of the node</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.#ctor(System.String,iText.Kernel.XMP.Options.PropertyOptions)">
            <summary>Constructor for the node without value.</summary>
            <param name="name">the name of the node</param>
            <param name="options">the options of the node</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.Clear">
            <summary>Resets the node.</summary>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.GetParent">
            <returns>Returns the parent node.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.GetChild(System.Int32)">
            <param name="index">an index [1..size]</param>
            <returns>Returns the child with the requested index.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.AddChild(iText.Kernel.XMP.Impl.XMPNode)">
            <summary>Adds a node as child to this node.</summary>
            <param name="node">an XMPNode</param>
            <exception cref="T:iText.Kernel.XMP.XMPException"></exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.AddChild(System.Int32,iText.Kernel.XMP.Impl.XMPNode)">
            <summary>Adds a node as child to this node.</summary>
            <param name="index">
            the index of the node <em>before</em> which the new one is inserted.
            <em>Note:</em> The node children are indexed from [1..size]!
            An index of size + 1 appends a node.
            </param>
            <param name="node">an XMPNode</param>
            <exception cref="T:iText.Kernel.XMP.XMPException"></exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.ReplaceChild(System.Int32,iText.Kernel.XMP.Impl.XMPNode)">
            <summary>Replaces a node with another one.</summary>
            <param name="index">
            the index of the node that will be replaced.
            <em>Note:</em> The node children are indexed from [1..size]!
            </param>
            <param name="node">the replacement XMPNode</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.RemoveChild(System.Int32)">
            <summary>Removes a child at the requested index.</summary>
            <param name="itemIndex">the index to remove [1..size]</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.RemoveChild(iText.Kernel.XMP.Impl.XMPNode)">
            <summary>Removes a child node.</summary>
            <remarks>
            Removes a child node.
            If its a schema node and doesn't have any children anymore, its deleted.
            </remarks>
            <param name="node">the child node to delete.</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.CleanupChildren">
            <summary>
            Removes the children list if this node has no children anymore;
            checks if the provided node is a schema node and doesn't have any children anymore,
            its deleted.
            </summary>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.RemoveChildren">
            <summary>Removes all children from the node.</summary>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.GetChildrenLength">
            <returns>Returns the number of children without neccessarily creating a list.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.FindChildByName(System.String)">
            <param name="expr">child node name to look for</param>
            <returns>Returns an <code>XMPNode</code> if node has been found, <code>null</code> otherwise.
            	</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.GetQualifier(System.Int32)">
            <param name="index">an index [1..size]</param>
            <returns>Returns the qualifier with the requested index.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.GetQualifierLength">
            <returns>Returns the number of qualifier without neccessarily creating a list.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.AddQualifier(iText.Kernel.XMP.Impl.XMPNode)">
            <summary>Appends a qualifier to the qualifier list and sets respective options.</summary>
            <param name="qualNode">a qualifier node.</param>
            <exception cref="T:iText.Kernel.XMP.XMPException"></exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.RemoveQualifier(iText.Kernel.XMP.Impl.XMPNode)">
            <summary>Removes one qualifier node and fixes the options.</summary>
            <param name="qualNode">qualifier to remove</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.RemoveQualifiers">
            <summary>Removes all qualifiers from the node and sets the options appropriate.</summary>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.FindQualifierByName(System.String)">
            <param name="expr">qualifier node name to look for</param>
            <returns>
            Returns a qualifier <code>XMPNode</code> if node has been found,
            <code>null</code> otherwise.
            </returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.HasChildren">
            <returns>Returns whether the node has children.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.IterateChildren">
            <returns>
            Returns an iterator for the children.
            <em>Note:</em> take care to use it.remove(), as the flag are not adjusted in that case.
            </returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.HasQualifier">
            <returns>Returns whether the node has qualifier attached.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.IterateQualifier">
            <returns>
            Returns an iterator for the qualifier.
            <em>Note:</em> take care to use it.remove(), as the flag are not adjusted in that case.
            </returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.Clone">
            <summary>Performs a <b>deep clone</b> of the node and the complete subtree.</summary>
            <seealso cref="!:System.Object.Clone()"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.CloneSubtree(iText.Kernel.XMP.Impl.XMPNode)">
            <summary>
            Performs a <b>deep clone</b> of the complete subtree (children and
            qualifier )into and add it to the destination node.
            </summary>
            <param name="destination">the node to add the cloned subtree</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.DumpNode(System.Boolean)">
            <summary>Renders this node and the tree unter this node in a human readable form.
            	</summary>
            <param name="recursive">Flag is qualifier and child nodes shall be rendered too</param>
            <returns>Returns a multiline string containing the dump.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.CompareTo(System.Object)">
            <seealso cref="!:System.IComparable&lt;T&gt;.CompareTo(System.Object)"></seealso>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.GetName">
            <returns>Returns the name.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.SetName(System.String)">
            <param name="name">The name to set.</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.GetValue">
            <returns>Returns the value.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.SetValue(System.String)">
            <param name="value">The value to set.</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.GetOptions">
            <returns>Returns the options.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.SetOptions(iText.Kernel.XMP.Options.PropertyOptions)">
            <summary>Updates the options of the node.</summary>
            <param name="options">the options to set.</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.IsImplicit">
            <returns>Returns the implicit flag</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.SetImplicit(System.Boolean)">
            <param name="implicit">Sets the implicit node flag</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.GetHasAliases">
            <returns>Returns if the node contains aliases (applies only to schema nodes)</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.SetHasAliases(System.Boolean)">
            <param name="hasAliases">sets the flag that the node contains aliases</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.IsAlias">
            <returns>Returns if the node contains aliases (applies only to schema nodes)</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.SetAlias(System.Boolean)">
            <param name="alias">sets the flag that the node is an alias</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.GetHasValueChild">
            <returns>the hasValueChild</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.SetHasValueChild(System.Boolean)">
            <param name="hasValueChild">the hasValueChild to set</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.Impl.XMPNode.Sort" -->
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.DumpNode(System.Text.StringBuilder,System.Boolean,System.Int32,System.Int32)">
            <summary>Dumps this node and its qualifier and children recursively.</summary>
            <remarks>
            Dumps this node and its qualifier and children recursively.
            <em>Note:</em> It creats empty options on every node.
            </remarks>
            <param name="result">the buffer to append the dump.</param>
            <param name="recursive">Flag is qualifier and child nodes shall be rendered too</param>
            <param name="indent">the current indent level.</param>
            <param name="index">the index within the parent node (important for arrays)</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.IsLanguageNode">
            <returns>Returns whether this node is a language qualifier.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.IsTypeNode">
            <returns>Returns whether this node is a type qualifier.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.GetChildren">
            <summary>
            <em>Note:</em> This method should always be called when accessing 'children' to be sure
            that its initialized.
            </summary>
            <returns>Returns list of children that is lazy initialized.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.GetUnmodifiableChildren">
            <returns>Returns a read-only copy of child nodes list.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.GetQualifier">
            <returns>Returns list of qualifier that is lazy initialized.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.SetParent(iText.Kernel.XMP.Impl.XMPNode)">
            <summary>
            Sets the parent node, this is solely done by <code>addChild(...)</code>
            and <code>addQualifier()</code>.
            </summary>
            <param name="parent">Sets the parent node.</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.Find(System.Collections.IList,System.String)">
            <summary>Internal find.</summary>
            <param name="list">the list to search in</param>
            <param name="expr">the search expression</param>
            <returns>Returns the found node or <code>nulls</code>.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.AssertChildNotExisting(System.String)">
            <summary>Checks that a node name is not existing on the same level, except for array items.
            	</summary>
            <param name="childName">the node name to check</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Thrown if a node with the same name is existing.
            	</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNode.AssertQualifierNotExisting(System.String)">
            <summary>Checks that a qualifier name is not existing on the same level.</summary>
            <param name="qualifierName">the new qualifier name</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Thrown if a node with the same name is existing.
            	</exception>
        </member>
        <member name="T:iText.Kernel.XMP.Impl.XMPNodeUtils">
            <summary>Utilities for <code>XMPNode</code>.</summary>
            <since>Aug 28, 2006</since>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNodeUtils.#ctor">
            <summary>Private Constructor</summary>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNodeUtils.FindSchemaNode(iText.Kernel.XMP.Impl.XMPNode,System.String,System.Boolean)">
            <summary>Find or create a schema node if <code>createNodes</code> is false and</summary>
            <param name="tree">the root of the xmp tree.</param>
            <param name="namespaceURI">a namespace</param>
            <param name="createNodes">
            a flag indicating if the node shall be created if not found.
            <em>Note:</em> The namespace must be registered prior to this call.
            </param>
            <returns>
            Returns the schema node if found, <code>null</code> otherwise.
            Note: If <code>createNodes</code> is <code>true</code>, it is <b>always</b>
            returned a valid node.
            </returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">
            An exception is only thrown if an error occurred, not if a
            node was not found.
            </exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNodeUtils.FindSchemaNode(iText.Kernel.XMP.Impl.XMPNode,System.String,System.String,System.Boolean)">
            <summary>Find or create a schema node if <code>createNodes</code> is true.</summary>
            <param name="tree">the root of the xmp tree.</param>
            <param name="namespaceURI">a namespace</param>
            <param name="suggestedPrefix">If a prefix is suggested, the namespace is allowed to be registered.
            	</param>
            <param name="createNodes">
            a flag indicating if the node shall be created if not found.
            <em>Note:</em> The namespace must be registered prior to this call.
            </param>
            <returns>
            Returns the schema node if found, <code>null</code> otherwise.
            Note: If <code>createNodes</code> is <code>true</code>, it is <b>always</b>
            returned a valid node.
            </returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">
            An exception is only thrown if an error occurred, not if a
            node was not found.
            </exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNodeUtils.FindChildNode(iText.Kernel.XMP.Impl.XMPNode,System.String,System.Boolean)">
            <summary>Find or create a child node under a given parent node.</summary>
            <remarks>
            Find or create a child node under a given parent node. If the parent node is no
            Returns the found or created child node.
            </remarks>
            <param name="parent">the parent node</param>
            <param name="childName">the node name to find</param>
            <param name="createNodes">flag, if new nodes shall be created.</param>
            <returns>Returns the found or created node or <code>null</code>.</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">Thrown if</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNodeUtils.FindNode(iText.Kernel.XMP.Impl.XMPNode,iText.Kernel.XMP.Impl.XPath.XMPPath,System.Boolean,iText.Kernel.XMP.Options.PropertyOptions)">
            <summary>Follow an expanded path expression to find or create a node.</summary>
            <param name="xmpTree">the node to begin the search.</param>
            <param name="xpath">the complete xpath</param>
            <param name="createNodes">
            flag if nodes shall be created
            (when called by <code>setProperty()</code>)
            </param>
            <param name="leafOptions">
            the options for the created leaf nodes (only when
            <code>createNodes == true</code>).
            </param>
            <returns>Returns the node if found or created or <code>null</code>.</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">
            An exception is only thrown if an error occurred,
            not if a node was not found.
            </exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNodeUtils.DeleteNode(iText.Kernel.XMP.Impl.XMPNode)">
            <summary>Deletes the the given node and its children from its parent.</summary>
            <remarks>
            Deletes the the given node and its children from its parent.
            Takes care about adjusting the flags.
            </remarks>
            <param name="node">the top-most node to delete.</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNodeUtils.SetNodeValue(iText.Kernel.XMP.Impl.XMPNode,System.Object)">
            <summary>This is setting the value of a leaf node.</summary>
            <param name="node">an XMPNode</param>
            <param name="value">a value</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNodeUtils.VerifySetOptions(iText.Kernel.XMP.Options.PropertyOptions,System.Object)">
            <summary>Verifies the PropertyOptions for consistancy and updates them as needed.
            	</summary>
            <remarks>
            Verifies the PropertyOptions for consistancy and updates them as needed.
            If options are <code>null</code> they are created with default values.
            </remarks>
            <param name="options">the <code>PropertyOptions</code></param>
            <param name="itemValue">the node value to set</param>
            <returns>Returns the updated options.</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">If the options are not consistant.
            	</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNodeUtils.SerializeNodeValue(System.Object)">
            <summary>
            Converts the node value to String, apply special conversions for defined
            types in XMP.
            </summary>
            <param name="value">the node value to set</param>
            <returns>Returns the String representation of the node value.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.Impl.XMPNodeUtils.FollowXPathStep(iText.Kernel.XMP.Impl.XMPNode,iText.Kernel.XMP.Impl.XPath.XMPPathSegment,System.Boolean)" -->
        <member name="M:iText.Kernel.XMP.Impl.XMPNodeUtils.FindQualifierNode(iText.Kernel.XMP.Impl.XMPNode,System.String,System.Boolean)">
            <summary>Find or create a qualifier node under a given parent node.</summary>
            <remarks>
            Find or create a qualifier node under a given parent node. Returns a pointer to the
            qualifier node, and optionally an iterator for the node's position in
            the parent's vector of qualifiers. The iterator is unchanged if no qualifier node (null)
            is returned.
            <em>Note:</em> On entry, the qualName parameter must not have the leading '?' from the
            XMPPath step.
            </remarks>
            <param name="parent">the parent XMPNode</param>
            <param name="qualName">the qualifier name</param>
            <param name="createNodes">flag if nodes shall be created</param>
            <returns>Returns the qualifier node if found or created, <code>null</code> otherwise.
            	</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException"></exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNodeUtils.FindIndexedItem(iText.Kernel.XMP.Impl.XMPNode,System.String,System.Boolean)">
            <param name="arrayNode">an array node</param>
            <param name="segment">the segment containing the array index</param>
            <param name="createNodes">flag if new nodes are allowed to be created.</param>
            <returns>Returns the index or index = -1 if not found</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">Throws Exceptions</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNodeUtils.LookupFieldSelector(iText.Kernel.XMP.Impl.XMPNode,System.String,System.String)">
            <summary>
            Searches for a field selector in a node:
            [fieldName="value] - an element in an array of structs, chosen by a field value.
            </summary>
            <remarks>
            Searches for a field selector in a node:
            [fieldName="value] - an element in an array of structs, chosen by a field value.
            No implicit nodes are created by field selectors.
            </remarks>
            <param name="arrayNode"/>
            <param name="fieldName"/>
            <param name="fieldValue"/>
            <returns>Returns the index of the field if found, otherwise -1.</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException"></exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNodeUtils.LookupQualSelector(iText.Kernel.XMP.Impl.XMPNode,System.String,System.String,System.Int32)">
            <summary>
            Searches for a qualifier selector in a node:
            [?qualName="value"] - an element in an array, chosen by a qualifier value.
            </summary>
            <remarks>
            Searches for a qualifier selector in a node:
            [?qualName="value"] - an element in an array, chosen by a qualifier value.
            No implicit nodes are created for qualifier selectors,
            except for an alias to an x-default item.
            </remarks>
            <param name="arrayNode">an array node</param>
            <param name="qualName">the qualifier name</param>
            <param name="qualValue">the qualifier value</param>
            <param name="aliasForm">
            in case the qual selector results from an alias,
            an x-default node is created if there has not been one.
            </param>
            <returns>Returns the index of th</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException"></exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNodeUtils.NormalizeLangArray(iText.Kernel.XMP.Impl.XMPNode)">
            <summary>Make sure the x-default item is first.</summary>
            <remarks>
            Make sure the x-default item is first. Touch up &quot;single value&quot;
            arrays that have a default plus one real language. This case should have
            the same value for both items. Older Adobe apps were hardwired to only
            use the &quot;x-default&quot; item, so we copy that value to the other
            item.
            </remarks>
            <param name="arrayNode">an alt text array node</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNodeUtils.DetectAltText(iText.Kernel.XMP.Impl.XMPNode)">
            <summary>See if an array is an alt-text array.</summary>
            <remarks>
            See if an array is an alt-text array. If so, make sure the x-default item
            is first.
            </remarks>
            <param name="arrayNode">the array node to check if its an alt-text array</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNodeUtils.AppendLangItem(iText.Kernel.XMP.Impl.XMPNode,System.String,System.String)">
            <summary>Appends a language item to an alt text array.</summary>
            <param name="arrayNode">the language array</param>
            <param name="itemLang">the language of the item</param>
            <param name="itemValue">the content of the item</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Thrown if a duplicate property is added
            	</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.Impl.XMPNodeUtils.ChooseLocalizedText(iText.Kernel.XMP.Impl.XMPNode,System.String,System.String)" -->
        <member name="M:iText.Kernel.XMP.Impl.XMPNodeUtils.LookupLanguageItem(iText.Kernel.XMP.Impl.XMPNode,System.String)">
            <summary>Looks for the appropriate language item in a text alternative array.item
            	</summary>
            <param name="arrayNode">an array node</param>
            <param name="language">the requested language</param>
            <returns>Returns the index if the language has been found, -1 otherwise.</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="T:iText.Kernel.XMP.Impl.XMPNormalizer">
            <since>Aug 18, 2006</since>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPNormalizer.dcArrayForms">
            <summary>caches the correct dc-property array forms</summary>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNormalizer.#ctor">
            <summary>Hidden constructor</summary>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNormalizer.Process(iText.Kernel.XMP.Impl.XMPMetaImpl,iText.Kernel.XMP.Options.ParseOptions)">
            <summary>Normalizes a raw parsed XMPMeta-Object</summary>
            <param name="xmp">the raw metadata object</param>
            <param name="options">the parsing options</param>
            <returns>Returns the normalized metadata object</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">Collects all severe processing errors.
            	</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNormalizer.TweakOldXMP(iText.Kernel.XMP.Impl.XMPNode)">
            <summary>
            Tweak old XMP: Move an instance ID from rdf:about to the
            <em>xmpMM:InstanceID</em> property.
            </summary>
            <remarks>
            Tweak old XMP: Move an instance ID from rdf:about to the
            <em>xmpMM:InstanceID</em> property. An old instance ID usually looks
            like "uuid:bac965c4-9d87-11d9-9a30-000d936b79c4", plus InDesign
            3.0 wrote them like "bac965c4-9d87-11d9-9a30-000d936b79c4". If
            the name looks like a UUID simply move it to <em>xmpMM:InstanceID</em>,
            don't worry about any existing <em>xmpMM:InstanceID</em>. Both will
            only be present when a newer file with the <em>xmpMM:InstanceID</em>
            property is updated by an old app that uses <em>rdf:about</em>.
            </remarks>
            <param name="tree">the root of the metadata tree</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Thrown if tweaking fails.</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNormalizer.TouchUpDataModel(iText.Kernel.XMP.Impl.XMPMetaImpl)">
            <summary>Visit all schemas to do general fixes and handle special cases.</summary>
            <param name="xmp">the metadata object implementation</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Thrown if the normalisation fails.
            	</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNormalizer.NormalizeDCArrays(iText.Kernel.XMP.Impl.XMPNode)">
            <summary>
            Undo the denormalization performed by the XMP used in Acrobat 5.<br/>
            If a Dublin Core array had only one item, it was serialized as a simple
            property.
            </summary>
            <remarks>
            Undo the denormalization performed by the XMP used in Acrobat 5.<br/>
            If a Dublin Core array had only one item, it was serialized as a simple
            property. <br/>
            The <code>xml:lang</code> attribute was dropped from an
            <code>alt-text</code> item if the language was <code>x-default</code>.
            </remarks>
            <param name="dcSchema">the DC schema node</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Thrown if normalization fails
            	</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNormalizer.RepairAltText(iText.Kernel.XMP.Impl.XMPNode)">
            <summary>Make sure that the array is well-formed AltText.</summary>
            <remarks>
            Make sure that the array is well-formed AltText. Each item must be simple
            and have an "xml:lang" qualifier. If repairs are needed, keep simple
            non-empty items by adding the "xml:lang" with value "x-repair".
            </remarks>
            <param name="arrayNode">the property node of the array to repair.</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Forwards unexpected exceptions.
            	</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNormalizer.MoveExplicitAliases(iText.Kernel.XMP.Impl.XMPNode,iText.Kernel.XMP.Options.ParseOptions)">
            <summary>Visit all of the top level nodes looking for aliases.</summary>
            <remarks>
            Visit all of the top level nodes looking for aliases. If there is
            no base, transplant the alias subtree. If there is a base and strict
            aliasing is on, make sure the alias and base subtrees match.
            </remarks>
            <param name="tree">the root of the metadata tree</param>
            <param name="options">th parsing options</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Forwards XMP errors</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNormalizer.TransplantArrayItemAlias(iText.Kernel.XMP.Impl.XMPNode,iText.Kernel.XMP.Impl.XMPNode)">
            <summary>
            Moves an alias node of array form to another schema into an array </summary>
            <param name="childNode"> the node to be moved </param>
            <param name="baseArray"> the base array for the array item </param>
            <exception cref="T:iText.Kernel.XMP.XMPException"> Forwards XMP errors </exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNormalizer.FixGPSTimeStamp(iText.Kernel.XMP.Impl.XMPNode)">
            <summary>Fixes the GPS Timestamp in EXIF.</summary>
            <param name="exifSchema">the EXIF schema node</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Thrown if the date conversion fails.
            	</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNormalizer.DeleteEmptySchemas(iText.Kernel.XMP.Impl.XMPNode)">
            <summary>Remove all empty schemas from the metadata tree that were generated during the rdf parsing.
            	</summary>
            <param name="tree">the root of the metadata tree</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNormalizer.CompareAliasedSubtrees(iText.Kernel.XMP.Impl.XMPNode,iText.Kernel.XMP.Impl.XMPNode,System.Boolean)">
            <summary>The outermost call is special.</summary>
            <remarks>
            The outermost call is special. The names almost certainly differ. The
            qualifiers (and hence options) will differ for an alias to the x-default
            item of a langAlt array.
            </remarks>
            <param name="aliasNode">the alias node</param>
            <param name="baseNode">the base node of the alias</param>
            <param name="outerCall">marks the outer call of the recursion</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Forwards XMP errors</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNormalizer.MigrateAudioCopyright(iText.Kernel.XMP.XMPMeta,iText.Kernel.XMP.Impl.XMPNode)">
            <summary>
            The initial support for WAV files mapped a legacy ID3 audio copyright
            into a new xmpDM:copyright property.
            </summary>
            <remarks>
            The initial support for WAV files mapped a legacy ID3 audio copyright
            into a new xmpDM:copyright property. This is special case code to migrate
            that into dc:rights['x-default']. The rules:
            <pre>
            1. If there is no dc:rights array, or an empty array -
            Create one with dc:rights['x-default'] set from double linefeed and xmpDM:copyright.
            2. If there is a dc:rights array but it has no x-default item -
            Create an x-default item as a copy of the first item then apply rule #3.
            3. If there is a dc:rights array with an x-default item,
            Look for a double linefeed in the value.
            A. If no double linefeed, compare the x-default value to the xmpDM:copyright value.
            A1. If they match then leave the x-default value alone.
            A2. Otherwise, append a double linefeed and
            the xmpDM:copyright value to the x-default value.
            B. If there is a double linefeed, compare the trailing text to the xmpDM:copyright value.
            B1. If they match then leave the x-default value alone.
            B2. Otherwise, replace the trailing x-default text with the xmpDM:copyright value.
            4. In all cases, delete the xmpDM:copyright property.
            </pre>
            </remarks>
            <param name="xmp">the metadata object</param>
            <param name="dmCopyright">the "dm:copyright"-property</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPNormalizer.InitDCArrays">
            <summary>
            Initializes the map that contains the known arrays, that are fixed by
            <see cref="M:iText.Kernel.XMP.Impl.XMPNormalizer.NormalizeDCArrays(iText.Kernel.XMP.Impl.XMPNode)"/>
            .
            </summary>
        </member>
        <member name="T:iText.Kernel.XMP.Impl.XMPSchemaRegistryImpl">
            <summary>The schema registry handles the namespaces, aliases and global options for the XMP Toolkit.
            	</summary>
            <remarks>
            The schema registry handles the namespaces, aliases and global options for the XMP Toolkit. There
            is only one single instance used by the toolkit.
            </remarks>
            <since>27.01.2006</since>
        </member>
        <!-- Badly formed XML comment ignored for member "T:iText.Kernel.XMP.XMPSchemaRegistry" -->
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.XMPSchemaRegistry.RegisterNamespace(System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.XMPSchemaRegistry.GetNamespacePrefix(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.XMPSchemaRegistry.GetNamespaceURI(System.String)" -->
        <member name="M:iText.Kernel.XMP.XMPSchemaRegistry.GetNamespaces">
            <returns>
            Returns the registered prefix/namespace-pairs as map, where the keys are the
            namespaces and the values are the prefixes.
            </returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPSchemaRegistry.GetPrefixes">
            <returns>
            Returns the registered namespace/prefix-pairs as map, where the keys are the
            prefixes and the values are the namespaces.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.XMPSchemaRegistry.DeleteNamespace(System.String)" -->
        <member name="M:iText.Kernel.XMP.XMPSchemaRegistry.ResolveAlias(System.String,System.String)">
            <summary>Determines if a name is an alias, and what it is aliased to.</summary>
            <param name="aliasNS">
            The namespace URI of the alias. Must not be <code>null</code> or the empty
            string.
            </param>
            <param name="aliasProp">
            The name of the alias. May be an arbitrary path expression
            path, must not be <code>null</code> or the empty string.
            </param>
            <returns>
            Returns the <code>XMPAliasInfo</code> for the given alias namespace and property or
            <code>null</code> if there is no such alias.
            </returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPSchemaRegistry.FindAliases(System.String)">
            <summary>Collects all aliases that are contained in the provided namespace.</summary>
            <remarks>
            Collects all aliases that are contained in the provided namespace.
            If nothing is found, an empty array is returned.
            </remarks>
            <param name="aliasNS">a schema namespace URI</param>
            <returns>Returns all alias infos from aliases that are contained in the provided namespace.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPSchemaRegistry.FindAlias(System.String)">
            <summary>Searches for registered aliases.</summary>
            <param name="qname">an XML conform qname</param>
            <returns>
            Returns if an alias definition for the given qname to another
            schema and property is registered.
            </returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPSchemaRegistry.GetAliases">
            <returns>
            Returns the registered aliases as map, where the key is the "qname" (prefix and name)
            and the value an <code>XMPAliasInfo</code>-object.
            </returns>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPSchemaRegistryImpl.namespaceToPrefixMap">
            <summary>a map from a namespace URI to its registered prefix</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPSchemaRegistryImpl.prefixToNamespaceMap">
            <summary>a map from a prefix to the associated namespace URI</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPSchemaRegistryImpl.aliasMap">
            <summary>a map of all registered aliases.</summary>
            <remarks>
            a map of all registered aliases.
            The map is a relationship from a qname to an <code>XMPAliasInfo</code>-object.
            </remarks>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPSchemaRegistryImpl._regex">
            <summary>The pattern that must not be contained in simple properties</summary>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSchemaRegistryImpl.#ctor">
            <summary>
            Performs the initialisation of the registry with the default namespaces, aliases and global
            options.
            </summary>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSchemaRegistryImpl.RegisterNamespace(System.String,System.String)">
            <seealso cref="M:iText.Kernel.XMP.XMPSchemaRegistry.RegisterNamespace(System.String,System.String)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSchemaRegistryImpl.DeleteNamespace(System.String)">
            <seealso cref="M:iText.Kernel.XMP.XMPSchemaRegistry.DeleteNamespace(System.String)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSchemaRegistryImpl.GetNamespacePrefix(System.String)">
            <seealso cref="M:iText.Kernel.XMP.XMPSchemaRegistry.GetNamespacePrefix(System.String)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSchemaRegistryImpl.GetNamespaceURI(System.String)">
            <seealso cref="M:iText.Kernel.XMP.XMPSchemaRegistry.GetNamespaceURI(System.String)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSchemaRegistryImpl.GetNamespaces">
            <seealso cref="M:iText.Kernel.XMP.XMPSchemaRegistry.GetNamespaces"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSchemaRegistryImpl.GetPrefixes">
            <seealso cref="M:iText.Kernel.XMP.XMPSchemaRegistry.GetPrefixes"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSchemaRegistryImpl.RegisterStandardNamespaces">
            <summary>
            Register the standard namespaces of schemas and types that are included in the XMP
            Specification and some other Adobe private namespaces.
            </summary>
            <remarks>
            Register the standard namespaces of schemas and types that are included in the XMP
            Specification and some other Adobe private namespaces.
            Note: This method is not lock because only called by the constructor.
            </remarks>
            <exception cref="T:iText.Kernel.XMP.XMPException">Forwards processing exceptions
            	</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSchemaRegistryImpl.ResolveAlias(System.String,System.String)">
            <seealso cref="M:iText.Kernel.XMP.XMPSchemaRegistry.ResolveAlias(System.String,System.String)"/>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.Impl.XMPSchemaRegistryImpl.FindAlias(System.String)" -->
        <member name="M:iText.Kernel.XMP.Impl.XMPSchemaRegistryImpl.FindAliases(System.String)">
            <seealso cref="M:iText.Kernel.XMP.XMPSchemaRegistry.FindAliases(System.String)"/>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.Impl.XMPSchemaRegistryImpl.RegisterAlias(System.String,System.String,System.String,System.String,iText.Kernel.XMP.Options.AliasOptions)" -->
        <member name="M:iText.Kernel.XMP.Impl.XMPSchemaRegistryImpl.GetAliases">
            <seealso cref="M:iText.Kernel.XMP.XMPSchemaRegistry.GetAliases"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSchemaRegistryImpl.RegisterStandardAliases">
            <summary>Register the standard aliases.</summary>
            <remarks>
            Register the standard aliases.
            Note: This method is not lock because only called by the constructor.
            </remarks>
            <exception cref="T:iText.Kernel.XMP.XMPException">If the registrations of at least one alias fails.
            	</exception>
        </member>
        <member name="T:iText.Kernel.XMP.Properties.XMPAliasInfo">
            <summary>This interface is used to return info about an alias.</summary>
            <since>27.01.2006</since>
        </member>
        <member name="M:iText.Kernel.XMP.Properties.XMPAliasInfo.GetNamespace">
            <returns>Returns Returns the namespace URI for the base property.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Properties.XMPAliasInfo.GetPrefix">
            <returns>Returns the default prefix for the given base property.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Properties.XMPAliasInfo.GetPropName">
            <returns>Returns the path of the base property.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Properties.XMPAliasInfo.GetAliasForm">
            <returns>
            Returns the kind of the alias. This can be a direct alias
            (ARRAY), a simple property to an ordered array
            (ARRAY_ORDERED), to an alternate array
            (ARRAY_ALTERNATE) or to an alternate text array
            (ARRAY_ALT_TEXT).
            </returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSchemaRegistryImpl._XMPAliasInfo_409.GetNamespace">
            <seealso cref="M:iText.Kernel.XMP.Properties.XMPAliasInfo.GetNamespace"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSchemaRegistryImpl._XMPAliasInfo_409.GetPrefix">
            <seealso cref="M:iText.Kernel.XMP.Properties.XMPAliasInfo.GetPrefix"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSchemaRegistryImpl._XMPAliasInfo_409.GetPropName">
            <seealso cref="M:iText.Kernel.XMP.Properties.XMPAliasInfo.GetPropName"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSchemaRegistryImpl._XMPAliasInfo_409.GetAliasForm">
            <seealso cref="M:iText.Kernel.XMP.Properties.XMPAliasInfo.GetAliasForm"/>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.Impl.ReadOnlyDictionary.ReadOnly(System.Collections.IDictionary)" -->
        <member name="T:iText.Kernel.XMP.Impl.XMPSerializerHelper">
            <summary>
            Serializes the <code>XMPMeta</code>-object to an <code>OutputStream</code> according to the
            <code>SerializeOptions</code>.
            </summary>
            <since>11.07.2006</since>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSerializerHelper.Serialize(iText.Kernel.XMP.Impl.XMPMetaImpl,System.IO.Stream,iText.Kernel.XMP.Options.SerializeOptions)">
            <summary>Static method to serialize the metadata object.</summary>
            <remarks>
            Static method to serialize the metadata object. For each serialisation, a new XMPSerializer
            instance is created, either XMPSerializerRDF or XMPSerializerPlain so thats its possible to
            serialialize the same XMPMeta objects in two threads.
            </remarks>
            <param name="xmp">a metadata implementation object</param>
            <param name="out">the output stream to serialize to</param>
            <param name="options">serialization options, can be <code>null</code> for default.
            	</param>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSerializerHelper.SerializeToString(iText.Kernel.XMP.Impl.XMPMetaImpl,iText.Kernel.XMP.Options.SerializeOptions)">
            <summary>Serializes an <code>XMPMeta</code>-object as RDF into a string.</summary>
            <remarks>
            Serializes an <code>XMPMeta</code>-object as RDF into a string.
            <em>Note:</em> Encoding is forced to UTF-16 when serializing to a
            string to ensure the correctness of "exact packet size".
            </remarks>
            <param name="xmp">a metadata implementation object</param>
            <param name="options">
            Options to control the serialization (see
            <see cref="T:iText.Kernel.XMP.Options.SerializeOptions"/>
            ).
            </param>
            <returns>Returns a string containing the serialized RDF.</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">on serializsation errors.</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSerializerHelper.SerializeToBuffer(iText.Kernel.XMP.Impl.XMPMetaImpl,iText.Kernel.XMP.Options.SerializeOptions)">
            <summary>Serializes an <code>XMPMeta</code>-object as RDF into a byte buffer.</summary>
            <param name="xmp">a metadata implementation object</param>
            <param name="options">
            Options to control the serialization (see
            <see cref="T:iText.Kernel.XMP.Options.SerializeOptions"/>
            ).
            </param>
            <returns>Returns a byte buffer containing the serialized RDF.</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">on serializsation errors.</exception>
        </member>
        <member name="T:iText.Kernel.XMP.Impl.XMPSerializerRdf">
            <summary>Serializes the <code>XMPMeta</code>-object using the standard RDF serialization format.
            	</summary>
            <remarks>
            Serializes the <code>XMPMeta</code>-object using the standard RDF serialization format.
            The output is written to an <code>OutputStream</code>
            according to the <code>SerializeOptions</code>.
            </remarks>
            <since>11.07.2006</since>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPSerializerRdf.DEFAULT_PAD">
            <summary>default padding</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPSerializerRdf.PACKET_TRAILER">
            <summary>The w/r is missing inbetween</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPSerializerRdf.RDF_ATTR_QUALIFIER">
            <summary>a set of all rdf attribute qualifier</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPSerializerRdf.xmp">
            <summary>the metadata object to be serialized.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPSerializerRdf.outputStream">
            <summary>the output stream to serialize to</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPSerializerRdf.writer">
            <summary>this writer is used to do the actual serialization</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPSerializerRdf.options">
            <summary>the stored serialization options</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPSerializerRdf.unicodeSize">
            <summary>
            the size of one unicode char, for UTF-8 set to 1
            (Note: only valid for ASCII chars lower than 0x80),
            set to 2 in case of UTF-16
            </summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPSerializerRdf.padding">
            <summary>
            the padding in the XMP Packet, or the length of the complete packet in
            case of option <em>exactPacketLength</em>.
            </summary>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSerializerRdf.Serialize(iText.Kernel.XMP.XMPMeta,System.IO.Stream,iText.Kernel.XMP.Options.SerializeOptions)">
            <summary>The actual serialization.</summary>
            <param name="xmp">the metadata object to be serialized</param>
            <param name="output">outputStream the output stream to serialize to</param>
            <param name="options">the serialization options</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">If case of wrong options or any other serialization error.
            	</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSerializerRdf.AddPadding(System.Int32)">
            <summary>Calculates the padding according to the options and write it to the stream.
            	</summary>
            <param name="tailLength">the length of the tail string</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">thrown if packet size is to small to fit the padding
            	</exception>
            <exception cref="T:System.IO.IOException">forwards writer errors</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSerializerRdf.CheckOptionsConsistence">
            <summary>Checks if the supplied options are consistent.</summary>
            <exception cref="T:iText.Kernel.XMP.XMPException">Thrown if options are conflicting
            	</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSerializerRdf.SerializeAsRDF">
            <summary>Writes the (optional) packet header and the outer rdf-tags.</summary>
            <returns>Returns the packet end processing instraction to be written after the padding.
            	</returns>
            <exception cref="T:System.IO.IOException">Forwarded writer exceptions.</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSerializerRdf.SerializeCanonicalRDFSchemas(System.Int32)">
            <summary>Serializes the metadata in pretty-printed manner.</summary>
            <param name="level">indent level</param>
            <exception cref="T:System.IO.IOException">Forwarded writer exceptions</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSerializerRdf.WriteTreeName">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSerializerRdf.SerializeCompactRDFSchemas(System.Int32)">
            <summary>Serializes the metadata in compact manner.</summary>
            <param name="level">indent level to start with</param>
            <exception cref="T:System.IO.IOException">Forwarded writer exceptions</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSerializerRdf.SerializeCompactRDFAttrProps(iText.Kernel.XMP.Impl.XMPNode,System.Int32)">
            <summary>Write each of the parent's simple unqualified properties as an attribute.
            	</summary>
            <remarks>
            Write each of the parent's simple unqualified properties as an attribute. Returns true if all
            of the properties are written as attributes.
            </remarks>
            <param name="parentNode">the parent property node</param>
            <param name="indent">the current indent level</param>
            <returns>Returns true if all properties can be rendered as RDF attribute.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSerializerRdf.SerializeCompactRDFElementProps(iText.Kernel.XMP.Impl.XMPNode,System.Int32)">
            <summary>
            Recursively handles the "value" for a node that must be written as an RDF
            property element.
            </summary>
            <remarks>
            Recursively handles the "value" for a node that must be written as an RDF
            property element. It does not matter if it is a top level property, a
            field of a struct, or an item of an array. The indent is that for the
            property element. The patterns bwlow ignore attribute qualifiers such as
            xml:lang, they don't affect the output form.
            <blockquote>
            <pre>
            &lt;ns:UnqualifiedStructProperty-1
            ... The fields as attributes, if all are simple and unqualified
            /&gt;
            &lt;ns:UnqualifiedStructProperty-2 rdf:parseType="Resource"&gt;
            ... The fields as elements, if none are simple and unqualified
            &lt;/ns:UnqualifiedStructProperty-2&gt;
            &lt;ns:UnqualifiedStructProperty-3&gt;
            &lt;rdf:Description
            ... The simple and unqualified fields as attributes
            &gt;
            ... The compound or qualified fields as elements
            &lt;/rdf:Description&gt;
            &lt;/ns:UnqualifiedStructProperty-3&gt;
            &lt;ns:UnqualifiedArrayProperty&gt;
            &lt;rdf:Bag&gt; or Seq or Alt
            ... Array items as rdf:li elements, same forms as top level properties
            &lt;/rdf:Bag&gt;
            &lt;/ns:UnqualifiedArrayProperty&gt;
            &lt;ns:QualifiedProperty rdf:parseType="Resource"&gt;
            &lt;rdf:value&gt; ... Property "value"
            following the unqualified forms ... &lt;/rdf:value&gt;
            ... Qualifiers looking like named struct fields
            &lt;/ns:QualifiedProperty&gt;
            </pre>
            </blockquote>
            *** Consider numbered array items, but has compatibility problems.
            Consider qualified form with rdf:Description and attributes.
            </remarks>
            <param name="parentNode">the parent node</param>
            <param name="indent">the current indent level</param>
            <exception cref="T:System.IO.IOException">Forwards writer exceptions</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException">If qualifier and element fields are mixed.
            	</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSerializerRdf.SerializeCompactRDFSimpleProp(iText.Kernel.XMP.Impl.XMPNode)">
            <summary>Serializes a simple property.</summary>
            <param name="node">an XMPNode</param>
            <returns>Returns an array containing the flags emitEndTag and indentEndTag.</returns>
            <exception cref="T:System.IO.IOException">Forwards the writer exceptions.</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSerializerRdf.SerializeCompactRDFArrayProp(iText.Kernel.XMP.Impl.XMPNode,System.Int32)">
            <summary>Serializes an array property.</summary>
            <param name="node">an XMPNode</param>
            <param name="indent">the current indent level</param>
            <exception cref="T:System.IO.IOException">Forwards the writer exceptions.</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException">If qualifier and element fields are mixed.
            	</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSerializerRdf.SerializeCompactRDFStructProp(iText.Kernel.XMP.Impl.XMPNode,System.Int32,System.Boolean)">
            <summary>Serializes a struct property.</summary>
            <param name="node">an XMPNode</param>
            <param name="indent">the current indent level</param>
            <param name="hasRDFResourceQual">Flag if the element has resource qualifier</param>
            <returns>Returns true if an end flag shall be emitted.</returns>
            <exception cref="T:System.IO.IOException">Forwards the writer exceptions.</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException">If qualifier and element fields are mixed.
            	</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSerializerRdf.SerializeCompactRDFGeneralQualifier(System.Int32,iText.Kernel.XMP.Impl.XMPNode)">
            <summary>Serializes the general qualifier.</summary>
            <param name="node">the root node of the subtree</param>
            <param name="indent">the current indent level</param>
            <exception cref="T:System.IO.IOException">Forwards all writer exceptions.</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException">If qualifier and element fields are mixed.
            	</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSerializerRdf.SerializeCanonicalRDFSchema(iText.Kernel.XMP.Impl.XMPNode,System.Int32)">
            <summary>
            Serializes one schema with all contained properties in pretty-printed
            manner.<br/>
            Each schema's properties are written to a single
            rdf:Description element.
            </summary>
            <remarks>
            Serializes one schema with all contained properties in pretty-printed
            manner.<br/>
            Each schema's properties are written to a single
            rdf:Description element. All of the necessary namespaces are declared in
            the rdf:Description element. The baseIndent is the base level for the
            entire serialization, that of the x:xmpmeta element. An xml:lang
            qualifier is written as an attribute of the property start tag, not by
            itself forcing the qualified property form.
            <blockquote>
            <pre>
            &lt;rdf:Description rdf:about="TreeName" xmlns:ns="URI" ... &gt;
            ... The actual properties of the schema, see SerializePrettyRDFProperty
            &lt;!-- ns1:Alias is aliased to ns2:Actual --&gt;  ... If alias comments are wanted
            &lt;/rdf:Description&gt;
            </pre>
            </blockquote>
            </remarks>
            <param name="schemaNode">a schema node</param>
            <param name="level"/>
            <exception cref="T:System.IO.IOException">Forwarded writer exceptions</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSerializerRdf.DeclareUsedNamespaces(iText.Kernel.XMP.Impl.XMPNode,System.Collections.Generic.ICollection{System.String},System.Int32)">
            <summary>Writes all used namespaces of the subtree in node to the output.</summary>
            <remarks>
            Writes all used namespaces of the subtree in node to the output.
            The subtree is recursivly traversed.
            </remarks>
            <param name="node">the root node of the subtree</param>
            <param name="usedPrefixes">a set containing currently used prefixes</param>
            <param name="indent">the current indent level</param>
            <exception cref="T:System.IO.IOException">Forwards all writer exceptions.</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSerializerRdf.DeclareNamespace(System.String,System.String,System.Collections.Generic.ICollection{System.String},System.Int32)">
            <summary>Writes one namespace declaration to the output.</summary>
            <param name="prefix">a namespace prefix (without colon) or a complete qname (when namespace == null)
            	</param>
            <param name="namespace">the a namespace</param>
            <param name="usedPrefixes">a set containing currently used prefixes</param>
            <param name="indent">the current indent level</param>
            <exception cref="T:System.IO.IOException">Forwards all writer exceptions.</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSerializerRdf.StartOuterRDFDescription(iText.Kernel.XMP.Impl.XMPNode,System.Int32)">
            <summary>Start the outer rdf:Description element, including all needed xmlns attributes.
            	</summary>
            <remarks>
            Start the outer rdf:Description element, including all needed xmlns attributes.
            Leave the element open so that the compact form can add property attributes.
            </remarks>
            <exception cref="T:System.IO.IOException">If the writing to</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.Impl.XMPSerializerRdf.EndOuterRDFDescription(System.Int32)" -->
        <member name="M:iText.Kernel.XMP.Impl.XMPSerializerRdf.SerializeCanonicalRDFProperty(iText.Kernel.XMP.Impl.XMPNode,System.Boolean,System.Boolean,System.Int32)">
            <summary>Recursively handles the "value" for a node.</summary>
            <remarks>
            Recursively handles the "value" for a node. It does not matter if it is a
            top level property, a field of a struct, or an item of an array. The
            indent is that for the property element. An xml:lang qualifier is written
            as an attribute of the property start tag, not by itself forcing the
            qualified property form. The patterns below mostly ignore attribute
            qualifiers like xml:lang. Except for the one struct case, attribute
            qualifiers don't affect the output form.
            <blockquote>
            <pre>
            &lt;ns:UnqualifiedSimpleProperty&gt;value&lt;/ns:UnqualifiedSimpleProperty&gt;
            &lt;ns:UnqualifiedStructProperty&gt; (If no rdf:resource qualifier)
            &lt;rdf:Description&gt;
            ... Fields, same forms as top level properties
            &lt;/rdf:Description&gt;
            &lt;/ns:UnqualifiedStructProperty&gt;
            &lt;ns:ResourceStructProperty rdf:resource="URI"
            ... Fields as attributes
            &gt;
            &lt;ns:UnqualifiedArrayProperty&gt;
            &lt;rdf:Bag&gt; or Seq or Alt
            ... Array items as rdf:li elements, same forms as top level properties
            &lt;/rdf:Bag&gt;
            &lt;/ns:UnqualifiedArrayProperty&gt;
            &lt;ns:QualifiedProperty&gt;
            &lt;rdf:Description&gt;
            &lt;rdf:value&gt; ... Property "value" following the unqualified
            forms ... &lt;/rdf:value&gt;
            ... Qualifiers looking like named struct fields
            &lt;/rdf:Description&gt;
            &lt;/ns:QualifiedProperty&gt;
            </pre>
            </blockquote>
            </remarks>
            <param name="node">the property node</param>
            <param name="emitAsRDFValue">property shall be rendered as attribute rather than tag
            	</param>
            <param name="useCanonicalRDF">
            use canonical form with inner description tag or
            the compact form with rdf:ParseType="resource" attribute.
            </param>
            <param name="indent">the current indent level</param>
            <exception cref="T:System.IO.IOException">Forwards all writer exceptions.</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException">If "rdf:resource" and general qualifiers are mixed.
            	</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSerializerRdf.EmitRDFArrayTag(iText.Kernel.XMP.Impl.XMPNode,System.Boolean,System.Int32)">
            <summary>Writes the array start and end tags.</summary>
            <param name="arrayNode">an array node</param>
            <param name="isStartTag">flag if its the start or end tag</param>
            <param name="indent">the current indent level</param>
            <exception cref="T:System.IO.IOException">forwards writer exceptions</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSerializerRdf.AppendNodeValue(System.String,System.Boolean)">
            <summary>Serializes the node value in XML encoding.</summary>
            <remarks>
            Serializes the node value in XML encoding. Its used for tag bodies and
            attributes. <em>Note:</em> The attribute is always limited by quotes,
            thats why <code>&amp;apos;</code> is never serialized. <em>Note:</em>
            Control chars are written unescaped, but if the user uses others than tab, LF
            and CR the resulting XML will become invalid.
            </remarks>
            <param name="value">the value of the node</param>
            <param name="forAttribute">flag if value is an attribute value</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.Impl.XMPSerializerRdf.CanBeRDFAttrProp(iText.Kernel.XMP.Impl.XMPNode)" -->
        <member name="M:iText.Kernel.XMP.Impl.XMPSerializerRdf.WriteIndent(System.Int32)">
            <summary>Writes indents and automatically includes the baseindend from the options.
            	</summary>
            <param name="times">number of indents to write</param>
            <exception cref="T:System.IO.IOException">forwards exception</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSerializerRdf.Write(System.Char)">
            <summary>Writes a char to the output.</summary>
            <param name="c">a char</param>
            <exception cref="T:System.IO.IOException">forwards writer exceptions</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSerializerRdf.Write(System.String)">
            <summary>Writes a String to the output.</summary>
            <param name="str">a String</param>
            <exception cref="T:System.IO.IOException">forwards writer exceptions</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSerializerRdf.WriteChars(System.Int32,System.Char)">
            <summary>Writes an amount of chars, mostly spaces</summary>
            <param name="number">number of chars</param>
            <param name="c">a char</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPSerializerRdf.WriteNewline">
            <summary>Writes a newline according to the options.</summary>
            <exception cref="T:System.IO.IOException">Forwards exception</exception>
        </member>
        <member name="T:iText.Kernel.XMP.Impl.XMPUtilsImpl">
            <since>11.08.2006</since>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPUtilsImpl.SPACES">
            <summary>
            U+0022 ASCII space<br />
            U+3000, ideographic space<br />
            U+303F, ideographic half fill space<br />
            U+2000..U+200B, en quad through zero width space
            </summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPUtilsImpl.COMMAS">
            <summary>
            U+002C, ASCII comma<br />
            U+FF0C, full width comma<br />
            U+FF64, half width ideographic comma<br />
            U+FE50, small comma<br />
            U+FE51, small ideographic comma<br />
            U+3001, ideographic comma<br />
            U+060C, Arabic comma<br />
            U+055D, Armenian comma
            </summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPUtilsImpl.SEMICOLA">
            <summary>
            U+003B, ASCII semicolon<br />
            U+FF1B, full width semicolon<br />
            U+FE54, small semicolon<br />
            U+061B, Arabic semicolon<br />
            U+037E, Greek "semicolon" (really a question mark)
            </summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPUtilsImpl.QUOTES">
            <summary>
            U+0022 ASCII quote<br />
            The square brackets are not interpreted as quotes anymore (bug #2674672)
            (ASCII '[' (0x5B) and ']' (0x5D) are used as quotes in Chinese and
            Korean.)<br />
            U+00AB and U+00BB, guillemet quotes<br />
            U+3008..U+300F, various quotes.<br />
            U+301D..U+301F, double prime quotes.<br />
            U+2015, dash quote.<br />
            U+2018..U+201F, various quotes.<br />
            U+2039 and U+203A, guillemet quotes.
            </summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XMPUtilsImpl.CONTROLS">
            <summary>
            U+0000..U+001F ASCII controls<br />
            U+2028, line separator.<br />
            U+2029, paragraph separator.
            </summary>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPUtilsImpl.#ctor">
            <summary>Private constructor, as</summary>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPUtilsImpl.CatenateArrayItems(iText.Kernel.XMP.XMPMeta,System.String,System.String,System.String,System.String,System.Boolean)">
            <seealso cref="M:iText.Kernel.XMP.XMPUtils.CatenateArrayItems(iText.Kernel.XMP.XMPMeta,System.String,System.String,System.String,System.String,System.Boolean)"/>
            <param name="xmp">The XMP object containing the array to be catenated.</param>
            <param name="schemaNS">
            The schema namespace URI for the array. Must not be null or
            the empty string.
            </param>
            <param name="arrayName">
            The name of the array. May be a general path expression, must
            not be null or the empty string. Each item in the array must
            be a simple string value.
            </param>
            <param name="separator">
            The string to be used to separate the items in the catenated
            string. Defaults to "; ", ASCII semicolon and space
            (U+003B, U+0020).
            </param>
            <param name="quotes">
            The characters to be used as quotes around array items that
            contain a separator. Defaults to '"'
            </param>
            <param name="allowCommas">Option flag to control the catenation.</param>
            <returns>Returns the string containing the catenated array items.</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">Forwards the Exceptions from the metadata processing
            	</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPUtilsImpl.SeparateArrayItems(iText.Kernel.XMP.XMPMeta,System.String,System.String,System.String,iText.Kernel.XMP.Options.PropertyOptions,System.Boolean)">
            <summary>
            see
            <see cref="M:iText.Kernel.XMP.XMPUtils.SeparateArrayItems(iText.Kernel.XMP.XMPMeta,System.String,System.String,System.String,iText.Kernel.XMP.Options.PropertyOptions,System.Boolean)"/>
            </summary>
            <param name="xmp">The XMP object containing the array to be updated.</param>
            <param name="schemaNS">
            The schema namespace URI for the array. Must not be null or
            the empty string.
            </param>
            <param name="arrayName">
            The name of the array. May be a general path expression, must
            not be null or the empty string. Each item in the array must
            be a simple string value.
            </param>
            <param name="catedStr">The string to be separated into the array items.</param>
            <param name="arrayOptions">Option flags to control the separation.</param>
            <param name="preserveCommas">Flag if commas shall be preserved</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Forwards the Exceptions from the metadata processing
            	</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPUtilsImpl.SeparateFindCreateArray(System.String,System.String,iText.Kernel.XMP.Options.PropertyOptions,iText.Kernel.XMP.Impl.XMPMetaImpl)">
            <summary>Utility to find or create the array used by <code>separateArrayItems()</code>.
            	</summary>
            <param name="schemaNS">a the namespace fo the array</param>
            <param name="arrayName">the name of the array</param>
            <param name="arrayOptions">the options for the array if newly created</param>
            <param name="xmp">the xmp object</param>
            <returns>Returns the array node.</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">Forwards exceptions</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPUtilsImpl.RemoveProperties(iText.Kernel.XMP.XMPMeta,System.String,System.String,System.Boolean,System.Boolean)">
            <seealso cref="M:iText.Kernel.XMP.XMPUtils.RemoveProperties(iText.Kernel.XMP.XMPMeta,System.String,System.String,System.Boolean,System.Boolean)"/>
            <param name="xmp">The XMP object containing the properties to be removed.</param>
            <param name="schemaNS">
            Optional schema namespace URI for the properties to be
            removed.
            </param>
            <param name="propName">Optional path expression for the property to be removed.</param>
            <param name="doAllProperties">
            Option flag to control the deletion: do internal properties in
            addition to external properties.
            </param>
            <param name="includeAliases">
            Option flag to control the deletion: Include aliases in the
            "named schema" case above.
            </param>
            <exception cref="T:iText.Kernel.XMP.XMPException">If metadata processing fails
            	</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPUtilsImpl.AppendProperties(iText.Kernel.XMP.XMPMeta,iText.Kernel.XMP.XMPMeta,System.Boolean,System.Boolean,System.Boolean)">
            <seealso cref="M:iText.Kernel.XMP.XMPUtils.AppendProperties(iText.Kernel.XMP.XMPMeta,iText.Kernel.XMP.XMPMeta,System.Boolean,System.Boolean)"/>
            <param name="source">The source XMP object.</param>
            <param name="destination">The destination XMP object.</param>
            <param name="doAllProperties">Do internal properties in addition to external properties.
            	</param>
            <param name="replaceOldValues">Replace the values of existing properties.</param>
            <param name="deleteEmptyValues">Delete destination values if source property is empty.
            	</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Forwards the Exceptions from the metadata processing
            	</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPUtilsImpl.RemoveSchemaChildren(iText.Kernel.XMP.Impl.XMPNode,System.Boolean)">
            <summary>
            Remove all schema children according to the flag
            <code>doAllProperties</code>.
            </summary>
            <remarks>
            Remove all schema children according to the flag
            <code>doAllProperties</code>. Empty schemas are automatically remove
            by <code>XMPNode</code>
            </remarks>
            <param name="schemaNode">a schema node</param>
            <param name="doAllProperties">flag if all properties or only externals shall be removed.
            	</param>
            <returns>Returns true if the schema is empty after the operation.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPUtilsImpl.AppendSubtree(iText.Kernel.XMP.Impl.XMPMetaImpl,iText.Kernel.XMP.Impl.XMPNode,iText.Kernel.XMP.Impl.XMPNode,System.Boolean,System.Boolean)">
            <seealso cref="M:iText.Kernel.XMP.Impl.XMPUtilsImpl.AppendProperties(iText.Kernel.XMP.XMPMeta,iText.Kernel.XMP.XMPMeta,System.Boolean,System.Boolean,System.Boolean)"/>
            <param name="destXMP">The destination XMP object.</param>
            <param name="sourceNode">the source node</param>
            <param name="destParent">the parent of the destination node</param>
            <param name="replaceOldValues">Replace the values of existing properties.</param>
            <param name="deleteEmptyValues">
            flag if properties with empty values should be deleted
            in the destination object.
            </param>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPUtilsImpl.ItemValuesMatch(iText.Kernel.XMP.Impl.XMPNode,iText.Kernel.XMP.Impl.XMPNode)">
            <summary>Compares two nodes including its children and qualifier.</summary>
            <param name="leftNode">an <code>XMPNode</code></param>
            <param name="rightNode">an <code>XMPNode</code></param>
            <returns>Returns true if the nodes are equal, false otherwise.</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">Forwards exceptions to the calling method.
            	</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPUtilsImpl.CheckSeparator(System.String)">
            <summary>Make sure the separator is OK.</summary>
            <remarks>
            Make sure the separator is OK. It must be one semicolon surrounded by
            zero or more spaces. Any of the recognized semicolons or spaces are
            allowed.
            </remarks>
            <param name="separator"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPUtilsImpl.CheckQuotes(System.String,System.Char)">
            <summary>
            Make sure the open and close quotes are a legitimate pair and return the
            correct closing quote or an exception.
            </summary>
            <param name="quotes">opened and closing quote in a string</param>
            <param name="openQuote">the open quote</param>
            <returns>Returns a corresponding closing quote.</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPUtilsImpl.ClassifyCharacter(System.Char)">
            <summary>
            Classifies the character into normal chars, spaces, semicola, quotes,
            control chars.
            </summary>
            <param name="ch">a char</param>
            <returns>Return the character kind.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPUtilsImpl.GetClosingQuote(System.Char)">
            <param name="openQuote">the open quote char</param>
            <returns>Returns the matching closing quote for an open quote.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPUtilsImpl.ApplyQuotes(System.String,System.Char,System.Char,System.Boolean)">
            <summary>Add quotes to the item.</summary>
            <param name="item">the array item</param>
            <param name="openQuote">the open quote character</param>
            <param name="closeQuote">the closing quote character</param>
            <param name="allowCommas">flag if commas are allowed</param>
            <returns>Returns the value in quotes.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPUtilsImpl.IsSurroundingQuote(System.Char,System.Char,System.Char)">
            <param name="ch">a character</param>
            <param name="openQuote">the opening quote char</param>
            <param name="closeQuote">the closing quote char</param>
            <returns>Return it the character is a surrounding quote.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XMPUtilsImpl.IsClosingingQuote(System.Char,System.Char,System.Char)">
            <param name="ch">a character</param>
            <param name="openQuote">the opening quote char</param>
            <param name="closeQuote">the closing quote char</param>
            <returns>Returns true if the character is a closing quote.</returns>
        </member>
        <member name="T:iText.Kernel.XMP.Impl.XPath.XMPPath">
            <summary>Representates an XMP XMPPath with segment accessor methods.</summary>
            <since>28.02.2006</since>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XPath.XMPPath.STRUCT_FIELD_STEP">
            <summary>Marks a struct field step , also for top level nodes (schema "fields").</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XPath.XMPPath.QUALIFIER_STEP">
            <summary>Marks a qualifier step.</summary>
            <remarks>
            Marks a qualifier step.
            Note: Order is significant to separate struct/qual from array kinds!
            </remarks>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XPath.XMPPath.ARRAY_INDEX_STEP">
            <summary>Marks an array index step</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XPath.XMPPath.segments">
            <summary>stores the segments of an XMPPath</summary>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XPath.XMPPath.Add(iText.Kernel.XMP.Impl.XPath.XMPPathSegment)">
            <summary>Append a path segment</summary>
            <param name="segment">the segment to add</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XPath.XMPPath.GetSegment(System.Int32)">
            <param name="index">the index of the segment to return</param>
            <returns>Returns a path segment.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XPath.XMPPath.Size">
            <returns>Returns the size of the xmp path.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XPath.XMPPath.ToString">
            <summary>Return a single String explaining which certificate was verified, how and why.</summary>
            <seealso cref="M:System.Object.ToString"/>
        </member>
        <member name="T:iText.Kernel.XMP.Impl.XPath.XMPPathParser">
            <summary>Parser for XMP XPaths.</summary>
            <since>01.03.2006</since>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XPath.XMPPathParser.#ctor">
            <summary>Private constructor</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.Impl.XPath.XMPPathParser.ExpandXPath(System.String,System.String)" -->
        <member name="M:iText.Kernel.XMP.Impl.XPath.XMPPathParser.SkipPathDelimiter(System.String,iText.Kernel.XMP.Impl.XPath.PathPosition)">
            <param name="path"/>
            <param name="pos"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XPath.XMPPathParser.ParseStructSegment(iText.Kernel.XMP.Impl.XPath.PathPosition)">
            <summary>Parses a struct segment</summary>
            <param name="pos">the current position in the path</param>
            <returns>Retusn the segment or an errror</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">If the sement is empty</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XPath.XMPPathParser.ParseIndexSegment(iText.Kernel.XMP.Impl.XPath.PathPosition)">
            <summary>Parses an array index segment.</summary>
            <param name="pos">the xmp path</param>
            <returns>Returns the segment or an error</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">thrown on xmp path errors</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XPath.XMPPathParser.ParseRootNode(System.String,iText.Kernel.XMP.Impl.XPath.PathPosition,iText.Kernel.XMP.Impl.XPath.XMPPath)">
            <summary>
            Parses the root node of an XMP Path, checks if namespace and prefix fit together
            and resolve the property to the base property if it is an alias.
            </summary>
            <param name="schemaNS">the root namespace</param>
            <param name="pos">the parsing position helper</param>
            <param name="expandedXPath">the path to contribute to</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">If the path is not valid.</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XPath.XMPPathParser.VerifyQualName(System.String)">
            <summary>
            Verifies whether the qualifier name is not XML conformant or the
            namespace prefix has not been registered.
            </summary>
            <param name="qualName">a qualifier name</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">If the name is not conformant</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XPath.XMPPathParser.VerifySimpleXMLName(System.String)">
            <summary>Verify if an XML name is conformant.</summary>
            <param name="name">an XML name</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">When the name is not XML conformant</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.Impl.XPath.XMPPathParser.VerifyXPathRoot(System.String,System.String)" -->
        <member name="T:iText.Kernel.XMP.Impl.XPath.PathPosition">
            <summary>This objects contains all needed char positions to parse.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XPath.PathPosition.path">
            <summary>the complete path</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XPath.PathPosition.nameStart">
            <summary>the start of a segment name</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XPath.PathPosition.nameEnd">
            <summary>the end of a segment name</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XPath.PathPosition.stepBegin">
            <summary>the begin of a step</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XPath.PathPosition.stepEnd">
            <summary>the end of a step</summary>
        </member>
        <member name="T:iText.Kernel.XMP.Impl.XPath.XMPPathSegment">
            <summary>A segment of a parsed <code>XMPPath</code>.</summary>
            <since>23.06.2006</since>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XPath.XMPPathSegment.name">
            <summary>name of the path segment</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XPath.XMPPathSegment.kind">
            <summary>kind of the path segment</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XPath.XMPPathSegment.alias">
            <summary>flag if segment is an alias</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Impl.XPath.XMPPathSegment.aliasForm">
            <summary>alias form if applicable</summary>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XPath.XMPPathSegment.#ctor(System.String)">
            <summary>Constructor with initial values.</summary>
            <param name="name">the name of the segment</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XPath.XMPPathSegment.#ctor(System.String,System.Int32)">
            <summary>Constructor with initial values.</summary>
            <param name="name">the name of the segment</param>
            <param name="kind">the kind of the segment</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XPath.XMPPathSegment.GetKind">
            <returns>Returns the kind.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XPath.XMPPathSegment.SetKind(System.Int32)">
            <param name="kind">The kind to set.</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XPath.XMPPathSegment.GetName">
            <returns>Returns the name.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XPath.XMPPathSegment.SetName(System.String)">
            <param name="name">The name to set.</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XPath.XMPPathSegment.SetAlias(System.Boolean)">
            <param name="alias">the flag to set</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XPath.XMPPathSegment.IsAlias">
            <returns>Returns the alias.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XPath.XMPPathSegment.GetAliasForm">
            <returns>Returns the aliasForm if this segment has been created by an alias.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XPath.XMPPathSegment.SetAliasForm(System.Int32)">
            <param name="aliasForm">the aliasForm to set</param>
        </member>
        <member name="M:iText.Kernel.XMP.Impl.XPath.XMPPathSegment.ToString">
            <seealso cref="M:System.Object.ToString"/>
        </member>
        <member name="T:iText.Kernel.XMP.Options.AliasOptions">
            <summary>Options for XMPSchemaRegistryImpl#registerAlias.</summary>
            <since>20.02.2006</since>
        </member>
        <member name="T:iText.Kernel.XMP.Options.Options">
            <summary>The base class for a collection of 32 flag bits.</summary>
            <remarks>
            The base class for a collection of 32 flag bits. Individual flags are defined as enum value bit
            masks. Inheriting classes add convenience accessor methods.
            </remarks>
            <since>24.01.2006</since>
        </member>
        <member name="F:iText.Kernel.XMP.Options.Options.options">
            <summary>the internal int containing all options</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Options.Options.optionNames">
            <summary>a map containing the bit names</summary>
        </member>
        <member name="M:iText.Kernel.XMP.Options.Options.#ctor">
            <summary>The default constructor.</summary>
        </member>
        <member name="M:iText.Kernel.XMP.Options.Options.#ctor(System.Int32)">
            <summary>Constructor with the options bit mask.</summary>
            <param name="options">the options bit mask</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">If the options are not correct</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Options.Options.Clear">
            <summary>Resets the options.</summary>
        </member>
        <member name="M:iText.Kernel.XMP.Options.Options.IsExactly(System.Int32)">
            <param name="optionBits">an option bitmask</param>
            <returns>Returns true, if this object is equal to the given options.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.Options.ContainsAllOptions(System.Int32)">
            <param name="optionBits">an option bitmask</param>
            <returns>Returns true, if this object contains all given options.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.Options.ContainsOneOf(System.Int32)">
            <param name="optionBits">an option bitmask</param>
            <returns>Returns true, if this object contain at least one of the given options.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.Options.GetOption(System.Int32)">
            <param name="optionBit">the binary bit or bits that are requested</param>
            <returns>Returns if <emp>all</emp> of the requested bits are set or not.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.Options.SetOption(System.Int32,System.Boolean)">
            <param name="optionBits">the binary bit or bits that shall be set to the given value</param>
            <param name="value">the boolean value to set</param>
        </member>
        <member name="M:iText.Kernel.XMP.Options.Options.GetOptions">
            <summary>Is friendly to access it during the tests.</summary>
            <returns>Returns the options.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.Options.SetOptions(System.Int32)">
            <param name="options">The options to set.</param>
            <exception cref="T:iText.Kernel.XMP.XMPException"></exception>
        </member>
        <member name="M:iText.Kernel.XMP.Options.Options.Equals(System.Object)">
            <seealso cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Options.Options.GetHashCode">
            <seealso cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:iText.Kernel.XMP.Options.Options.GetOptionsString">
            <summary>Creates a human readable string from the set options.</summary>
            <remarks>
            Creates a human readable string from the set options. <em>Note:</em> This method is quite
            expensive and should only be used within tests or as
            </remarks>
            <returns>
            Returns a String listing all options that are set to <code>true</code> by their name,
            like &quot;option1 | option4&quot;.
            </returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.Options.ToString">
            <returns>Returns the options as hex bitmask.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.Options.GetValidOptions">
            <summary>To be implemeted by inheritants.</summary>
            <returns>Returns a bit mask where all valid option bits are set.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.Options.DefineOptionName(System.Int32)">
            <summary>To be implemeted by inheritants.</summary>
            <param name="option">a single, valid option bit.</param>
            <returns>Returns a human readable name for an option bit.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.Options.AssertConsistency(System.Int32)">
            <summary>The inheriting option class can do additional checks on the options.</summary>
            <remarks>
            The inheriting option class can do additional checks on the options.
            <em>Note:</em> For performance reasons this method is only called
            when setting bitmasks directly.
            When get- and set-methods are used, this method must be called manually,
            normally only when the Options-object has been created from a client
            (it has to be made public therefore).
            </remarks>
            <param name="options">the bitmask to check.</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Thrown if the options are not consistent.</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Options.Options.AssertOptionsValid(System.Int32)">
            <summary>Checks options before they are set.</summary>
            <remarks>
            Checks options before they are set.
            First it is checked if only defined options are used,
            second the additional
            <see cref="M:iText.Kernel.XMP.Options.Options.AssertConsistency(System.Int32)"/>
            -method is called.
            </remarks>
            <param name="options">the options to check</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Thrown if the options are invalid.</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Options.Options.GetOptionName(System.Int32)">
            <summary>Looks up or asks the inherited class for the name of an option bit.</summary>
            <remarks>
            Looks up or asks the inherited class for the name of an option bit.
            Its save that there is only one valid option handed into the method.
            </remarks>
            <param name="option">a single option bit</param>
            <returns>Returns the option name or undefined.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.Options.ProcureOptionNames">
            <returns>Returns the optionNames map and creates it if required.</returns>
        </member>
        <member name="F:iText.Kernel.XMP.Options.AliasOptions.PROP_DIRECT">
            <summary>This is a direct mapping.</summary>
            <remarks>This is a direct mapping. The actual data type does not matter.</remarks>
        </member>
        <member name="F:iText.Kernel.XMP.Options.AliasOptions.PROP_ARRAY">
            <summary>The actual is an unordered array, the alias is to the first element of the array.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Options.AliasOptions.PROP_ARRAY_ORDERED">
            <summary>The actual is an ordered array, the alias is to the first element of the array.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Options.AliasOptions.PROP_ARRAY_ALTERNATE">
            <summary>The actual is an alternate array, the alias is to the first element of the array.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Options.AliasOptions.PROP_ARRAY_ALT_TEXT">
            <summary>The actual is an alternate text array, the alias is to the 'x-default' element of the array.</summary>
        </member>
        <member name="M:iText.Kernel.XMP.Options.AliasOptions.#ctor">
            <seealso cref="M:iText.Kernel.XMP.Options.Options.#ctor"/>
        </member>
        <member name="M:iText.Kernel.XMP.Options.AliasOptions.#ctor(System.Int32)">
            <param name="options">the options to init with</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">If options are not consistant</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Options.AliasOptions.IsSimple">
            <returns>Returns if the alias is of the simple form.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.AliasOptions.IsArray">
            <returns>Returns the option.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.AliasOptions.SetArray(System.Boolean)">
            <param name="value">the value to set</param>
            <returns>Returns the instance to call more set-methods.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.AliasOptions.IsArrayOrdered">
            <returns>Returns the option.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.AliasOptions.SetArrayOrdered(System.Boolean)">
            <param name="value">the value to set</param>
            <returns>Returns the instance to call more set-methods.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.AliasOptions.IsArrayAlternate">
            <returns>Returns the option.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.AliasOptions.SetArrayAlternate(System.Boolean)">
            <param name="value">the value to set</param>
            <returns>Returns the instance to call more set-methods.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.AliasOptions.IsArrayAltText">
            <returns>Returns the option.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.AliasOptions.SetArrayAltText(System.Boolean)">
            <param name="value">the value to set</param>
            <returns>Returns the instance to call more set-methods.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.AliasOptions.ToPropertyOptions">
            <returns>
            returns a
            <see cref="T:iText.Kernel.XMP.Options.PropertyOptions"/>
            s object
            </returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">If the options are not consistant.</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Options.AliasOptions.DefineOptionName(System.Int32)">
            <seealso cref="M:iText.Kernel.XMP.Options.Options.DefineOptionName(System.Int32)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Options.AliasOptions.GetValidOptions">
            <seealso cref="M:iText.Kernel.XMP.Options.Options.GetValidOptions"/>
        </member>
        <member name="T:iText.Kernel.XMP.Options.IteratorOptions">
            <summary>Options for <code>XMPIterator</code> construction.</summary>
            <since>24.01.2006</since>
        </member>
        <member name="F:iText.Kernel.XMP.Options.IteratorOptions.JUST_CHILDREN">
            <summary>Just do the immediate children of the root, default is subtree.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Options.IteratorOptions.JUST_LEAFNODES">
            <summary>Just do the leaf nodes, default is all nodes in the subtree.</summary>
            <remarks>
            Just do the leaf nodes, default is all nodes in the subtree.
            Bugfix #2658965: If this option is set the Iterator returns the namespace
            of the leaf instead of the namespace of the base property.
            </remarks>
        </member>
        <member name="F:iText.Kernel.XMP.Options.IteratorOptions.JUST_LEAFNAME">
            <summary>Return just the leaf part of the path, default is the full path.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Options.IteratorOptions.OMIT_QUALIFIERS">
            <summary>Omit all qualifiers.</summary>
        </member>
        <member name="M:iText.Kernel.XMP.Options.IteratorOptions.IsJustChildren">
            <returns>Returns whether the option is set.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.IteratorOptions.IsJustLeafname">
            <returns>Returns whether the option is set.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.IteratorOptions.IsJustLeafnodes">
            <returns>Returns whether the option is set.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.IteratorOptions.IsOmitQualifiers">
            <returns>Returns whether the option is set.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.IteratorOptions.SetJustChildren(System.Boolean)">
            <summary>Sets the option and returns the instance.</summary>
            <param name="value">the value to set</param>
            <returns>Returns the instance to call more set-methods.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.IteratorOptions.SetJustLeafname(System.Boolean)">
            <summary>Sets the option and returns the instance.</summary>
            <param name="value">the value to set</param>
            <returns>Returns the instance to call more set-methods.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.IteratorOptions.SetJustLeafnodes(System.Boolean)">
            <summary>Sets the option and returns the instance.</summary>
            <param name="value">the value to set</param>
            <returns>Returns the instance to call more set-methods.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.IteratorOptions.SetOmitQualifiers(System.Boolean)">
            <summary>Sets the option and returns the instance.</summary>
            <param name="value">the value to set</param>
            <returns>Returns the instance to call more set-methods.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.IteratorOptions.DefineOptionName(System.Int32)">
            <seealso cref="M:iText.Kernel.XMP.Options.Options.DefineOptionName(System.Int32)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Options.IteratorOptions.GetValidOptions">
            <seealso cref="M:iText.Kernel.XMP.Options.Options.GetValidOptions"/>
        </member>
        <member name="T:iText.Kernel.XMP.Options.ParseOptions">
            <summary>
            Options for
            <see cref="M:iText.Kernel.XMP.XMPMetaFactory.Parse(System.IO.Stream,iText.Kernel.XMP.Options.ParseOptions)"/>
            .
            </summary>
            <since>24.01.2006</since>
        </member>
        <member name="F:iText.Kernel.XMP.Options.ParseOptions.REQUIRE_XMP_META">
            <summary>Require a surrounding &quot;x:xmpmeta&quot; element in the xml-document.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Options.ParseOptions.STRICT_ALIASING">
            <summary>Do not reconcile alias differences, throw an exception instead.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Options.ParseOptions.FIX_CONTROL_CHARS">
            <summary>Convert ASCII control characters 0x01 - 0x1F (except tab, cr, and lf) to spaces.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Options.ParseOptions.ACCEPT_LATIN_1">
            <summary>If the input is not unicode, try to parse it as ISO-8859-1.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Options.ParseOptions.OMIT_NORMALIZATION">
            <summary>Do not carry run the XMPNormalizer on a packet, leave it as it is.</summary>
        </member>
        <member name="M:iText.Kernel.XMP.Options.ParseOptions.#ctor">
            <summary>Sets the options to the default values.</summary>
        </member>
        <member name="M:iText.Kernel.XMP.Options.ParseOptions.GetRequireXMPMeta">
            <returns>Returns the requireXMPMeta.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.ParseOptions.SetRequireXMPMeta(System.Boolean)">
            <param name="value">the value to set</param>
            <returns>Returns the instance to call more set-methods.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.ParseOptions.GetStrictAliasing">
            <returns>Returns the strictAliasing.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.ParseOptions.SetStrictAliasing(System.Boolean)">
            <param name="value">the value to set</param>
            <returns>Returns the instance to call more set-methods.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.ParseOptions.GetFixControlChars">
            <returns>Returns the strictAliasing.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.ParseOptions.SetFixControlChars(System.Boolean)">
            <param name="value">the value to set</param>
            <returns>Returns the instance to call more set-methods.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.ParseOptions.GetAcceptLatin1">
            <returns>Returns the strictAliasing.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.ParseOptions.SetOmitNormalization(System.Boolean)">
            <param name="value">the value to set</param>
            <returns>Returns the instance to call more set-methods.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.ParseOptions.GetOmitNormalization">
            <returns>Returns the option "omit normalization".</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.ParseOptions.SetAcceptLatin1(System.Boolean)">
            <param name="value">the value to set</param>
            <returns>Returns the instance to call more set-methods.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.ParseOptions.DefineOptionName(System.Int32)">
            <seealso cref="M:iText.Kernel.XMP.Options.Options.DefineOptionName(System.Int32)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Options.ParseOptions.GetValidOptions">
            <seealso cref="M:iText.Kernel.XMP.Options.Options.GetValidOptions"/>
        </member>
        <member name="T:iText.Kernel.XMP.Options.PropertyOptions">
            <summary>
            The property flags are used when properties are fetched from the <code>XMPMeta</code>-object
            and provide more detailed information about the property.
            </summary>
            <since>03.07.2006</since>
        </member>
        <member name="F:iText.Kernel.XMP.Options.PropertyOptions.DELETE_EXISTING">
            <summary>may be used in the future</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Options.PropertyOptions.SEPARATE_NODE">
            <summary>Updated by iText.</summary>
            <remarks>Updated by iText. Indicates if the property should be writted as a separate node</remarks>
        </member>
        <member name="M:iText.Kernel.XMP.Options.PropertyOptions.#ctor">
            <summary>Default constructor</summary>
        </member>
        <member name="M:iText.Kernel.XMP.Options.PropertyOptions.#ctor(System.Int32)">
            <summary>Intialization constructor</summary>
            <param name="options">the initialization options</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">If the options are not valid</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Options.PropertyOptions.IsURI">
            <returns>
            Return whether the property value is a URI. It is serialized to RDF using the
            <tt>rdf:resource</tt> attribute. Not mandatory for URIs, but considered RDF-savvy.
            </returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.PropertyOptions.SetURI(System.Boolean)">
            <param name="value">the value to set</param>
            <returns>Returns this to enable cascaded options.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.PropertyOptions.GetHasQualifiers">
            <returns>
            Return whether the property has qualifiers. These could be an <tt>xml:lang</tt>
            attribute, an <tt>rdf:type</tt> property, or a general qualifier. See the
            introductory discussion of qualified properties for more information.
            </returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.PropertyOptions.SetHasQualifiers(System.Boolean)">
            <param name="value">the value to set</param>
            <returns>Returns this to enable cascaded options.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.PropertyOptions.IsQualifier">
            <returns>
            Return whether this property is a qualifier for some other property. Note that if the
            qualifier itself has a structured value, this flag is only set for the top node of
            the qualifier's subtree. Qualifiers may have arbitrary structure, and may even have
            qualifiers.
            </returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.PropertyOptions.SetQualifier(System.Boolean)">
            <param name="value">the value to set</param>
            <returns>Returns this to enable cascaded options.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.PropertyOptions.GetHasLanguage">
            <returns>Return whether this property has an <tt>xml:lang</tt> qualifier.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.PropertyOptions.SetHasLanguage(System.Boolean)">
            <param name="value">the value to set</param>
            <returns>Returns this to enable cascaded options.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.PropertyOptions.GetHasType">
            <returns>Return whether this property has an <tt>rdf:type</tt> qualifier.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.PropertyOptions.SetHasType(System.Boolean)">
            <param name="value">the value to set</param>
            <returns>Returns this to enable cascaded options.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.PropertyOptions.IsStruct">
            <returns>Return whether this property contains nested fields.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.PropertyOptions.SetStruct(System.Boolean)">
            <param name="value">the value to set</param>
            <returns>Returns this to enable cascaded options.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.PropertyOptions.IsArray">
            <returns>
            Return whether this property is an array. By itself this indicates a general
            unordered array. It is serialized using an <tt>rdf:Bag</tt> container.
            </returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.PropertyOptions.SetArray(System.Boolean)">
            <param name="value">the value to set</param>
            <returns>Returns this to enable cascaded options.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.PropertyOptions.IsArrayOrdered">
            <returns>
            Return whether this property is an ordered array. Appears in conjunction with
            getPropValueIsArray(). It is serialized using an <tt>rdf:Seq</tt> container.
            </returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.PropertyOptions.SetArrayOrdered(System.Boolean)">
            <param name="value">the value to set</param>
            <returns>Returns this to enable cascaded options.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.PropertyOptions.IsArrayAlternate">
            <returns>
            Return whether this property is an alternative array. Appears in conjunction with
            getPropValueIsArray(). It is serialized using an <tt>rdf:Alt</tt> container.
            </returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.PropertyOptions.SetArrayAlternate(System.Boolean)">
            <param name="value">the value to set</param>
            <returns>Returns this to enable cascaded options.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.PropertyOptions.IsArrayAltText">
            <returns>
            Return whether this property is an alt-text array. Appears in conjunction with
            getPropArrayIsAlternate(). It is serialized using an <tt>rdf:Alt</tt> container.
            Each array element is a simple property with an <tt>xml:lang</tt> attribute.
            </returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.PropertyOptions.SetArrayAltText(System.Boolean)">
            <param name="value">the value to set</param>
            <returns>Returns this to enable cascaded options.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.PropertyOptions.IsSchemaNode">
            <returns>Returns whether the SCHEMA_NODE option is set.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.PropertyOptions.SetSchemaNode(System.Boolean)">
            <param name="value">the option DELETE_EXISTING to set</param>
            <returns>Returns this to enable cascaded options.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.PropertyOptions.IsCompositeProperty">
            <returns>Returns whether the property is of composite type - an array or a struct.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.PropertyOptions.IsSimple">
            <returns>Returns whether the property is of composite type - an array or a struct.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.PropertyOptions.EqualArrayTypes(iText.Kernel.XMP.Options.PropertyOptions)">
            <summary>Compares two options set for array compatibility.</summary>
            <param name="options">other options</param>
            <returns>Returns true if the array options of the sets are equal.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.PropertyOptions.MergeWith(iText.Kernel.XMP.Options.PropertyOptions)">
            <summary>Merges the set options of a another options object with this.</summary>
            <remarks>
            Merges the set options of a another options object with this.
            If the other options set is null, this objects stays the same.
            </remarks>
            <param name="options">other options</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">If illegal options are provided</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Options.PropertyOptions.IsOnlyArrayOptions">
            <returns>Returns true if only array options are set.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.PropertyOptions.GetValidOptions">
            <seealso cref="M:iText.Kernel.XMP.Options.Options.GetValidOptions"/>
        </member>
        <member name="M:iText.Kernel.XMP.Options.PropertyOptions.DefineOptionName(System.Int32)">
            <seealso cref="M:iText.Kernel.XMP.Options.Options.DefineOptionName(System.Int32)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Options.PropertyOptions.AssertConsistency(System.Int32)">
            <summary>
            Checks that a node not a struct and array at the same time;
            and URI cannot be a struct.
            </summary>
            <param name="options">the bitmask to check.</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Thrown if the options are not consistent.</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:iText.Kernel.XMP.Options.SerializeOptions" -->
        <member name="F:iText.Kernel.XMP.Options.SerializeOptions.OMIT_PACKET_WRAPPER">
            <summary>Omit the XML packet wrapper.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Options.SerializeOptions.READONLY_PACKET">
            <summary>Mark packet as read-only.</summary>
            <remarks>Mark packet as read-only. Default is a writeable packet.</remarks>
        </member>
        <member name="F:iText.Kernel.XMP.Options.SerializeOptions.USE_COMPACT_FORMAT">
            <summary>Use a compact form of RDF.</summary>
            <remarks>
            Use a compact form of RDF.
            The compact form is the default serialization format (this flag is technically ignored).
            To serialize to the canonical form, set the flag USE_CANONICAL_FORMAT.
            If both flags &quot;compact&quot; and &quot;canonical&quot; are set, canonical is used.
            </remarks>
        </member>
        <member name="F:iText.Kernel.XMP.Options.SerializeOptions.USE_CANONICAL_FORMAT">
            <summary>Use the canonical form of RDF if set.</summary>
            <remarks>Use the canonical form of RDF if set. By default the compact form is used</remarks>
        </member>
        <member name="F:iText.Kernel.XMP.Options.SerializeOptions.INCLUDE_THUMBNAIL_PAD">
            <summary>Include a padding allowance for a thumbnail image.</summary>
            <remarks>
            Include a padding allowance for a thumbnail image. If no <tt>xmp:Thumbnails</tt> property
            is present, the typical space for a JPEG thumbnail is used.
            </remarks>
        </member>
        <member name="F:iText.Kernel.XMP.Options.SerializeOptions.EXACT_PACKET_LENGTH">
            <summary>The padding parameter provides the overall packet length.</summary>
            <remarks>
            The padding parameter provides the overall packet length. The actual amount of padding is
            computed. An exception is thrown if the packet exceeds this length with no padding.
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "F:iText.Kernel.XMP.Options.SerializeOptions.OMIT_XMPMETA_ELEMENT" -->
        <member name="F:iText.Kernel.XMP.Options.SerializeOptions.SORT">
            <summary>Sort the struct properties and qualifier before serializing</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Options.SerializeOptions.LITTLEENDIAN_BIT">
            <summary>Bit indicating little endian encoding, unset is big endian</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Options.SerializeOptions.UTF16_BIT">
            <summary>Bit indication UTF16 encoding.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Options.SerializeOptions.ENCODE_UTF8">
            <summary>UTF8 encoding; this is the default</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Options.SerializeOptions.ENCODE_UTF16BE">
            <summary>UTF16BE encoding</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Options.SerializeOptions.ENCODE_UTF16LE">
            <summary>UTF16LE encoding</summary>
        </member>
        <member name="F:iText.Kernel.XMP.Options.SerializeOptions.padding">
            <summary>The amount of padding to be added if a writeable XML packet is created.</summary>
            <remarks>
            The amount of padding to be added if a writeable XML packet is created. If zero is passed
            (the default) an appropriate amount of padding is computed.
            </remarks>
        </member>
        <member name="F:iText.Kernel.XMP.Options.SerializeOptions.newline">
            <summary>The string to be used as a line terminator.</summary>
            <remarks>
            The string to be used as a line terminator. If empty it defaults to; linefeed, U+000A, the
            standard XML newline.
            </remarks>
        </member>
        <member name="F:iText.Kernel.XMP.Options.SerializeOptions.indent">
            <summary>
            The string to be used for each level of indentation in the serialized
            RDF.
            </summary>
            <remarks>
            The string to be used for each level of indentation in the serialized
            RDF. If empty it defaults to two ASCII spaces, U+0020.
            </remarks>
        </member>
        <member name="F:iText.Kernel.XMP.Options.SerializeOptions.baseIndent">
            <summary>
            The number of levels of indentation to be used for the outermost XML element in the
            serialized RDF.
            </summary>
            <remarks>
            The number of levels of indentation to be used for the outermost XML element in the
            serialized RDF. This is convenient when embedding the RDF in other text, defaults to 0.
            </remarks>
        </member>
        <member name="F:iText.Kernel.XMP.Options.SerializeOptions.omitVersionAttribute">
            <summary>Omits the Toolkit version attribute, not published, only used for Unit tests.</summary>
        </member>
        <member name="M:iText.Kernel.XMP.Options.SerializeOptions.#ctor">
            <summary>Default constructor.</summary>
        </member>
        <member name="M:iText.Kernel.XMP.Options.SerializeOptions.#ctor(System.Int32)">
            <summary>Constructor using inital options</summary>
            <param name="options">the inital options</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Thrown if options are not consistant.</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Options.SerializeOptions.GetOmitPacketWrapper">
            <returns>Returns the option.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.SerializeOptions.SetOmitPacketWrapper(System.Boolean)">
            <param name="value">the value to set</param>
            <returns>Returns the instance to call more set-methods.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.SerializeOptions.GetOmitXmpMetaElement">
            <returns>Returns the option.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.SerializeOptions.SetOmitXmpMetaElement(System.Boolean)">
            <param name="value">the value to set</param>
            <returns>Returns the instance to call more set-methods.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.SerializeOptions.GetReadOnlyPacket">
            <returns>Returns the option.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.SerializeOptions.SetReadOnlyPacket(System.Boolean)">
            <param name="value">the value to set</param>
            <returns>Returns the instance to call more set-methods.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.SerializeOptions.GetUseCompactFormat">
            <returns>Returns the option.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.SerializeOptions.SetUseCompactFormat(System.Boolean)">
            <param name="value">the value to set</param>
            <returns>Returns the instance to call more set-methods.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.SerializeOptions.GetUseCanonicalFormat">
            <returns>Returns the option.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.SerializeOptions.SetUseCanonicalFormat(System.Boolean)">
            <param name="value">the value to set</param>
            <returns>Returns the instance to call more set-methods.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.SerializeOptions.GetIncludeThumbnailPad">
            <returns>Returns the option.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.SerializeOptions.SetIncludeThumbnailPad(System.Boolean)">
            <param name="value">the value to set</param>
            <returns>Returns the instance to call more set-methods.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.SerializeOptions.GetExactPacketLength">
            <returns>Returns the option.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.SerializeOptions.SetExactPacketLength(System.Boolean)">
            <param name="value">the value to set</param>
            <returns>Returns the instance to call more set-methods.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.SerializeOptions.GetSort">
            <returns>Returns the option.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.SerializeOptions.SetSort(System.Boolean)">
            <param name="value">the value to set</param>
            <returns>Returns the instance to call more set-methods.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.SerializeOptions.GetEncodeUTF16BE">
            <returns>Returns the option.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.SerializeOptions.SetEncodeUTF16BE(System.Boolean)">
            <param name="value">the value to set</param>
            <returns>Returns the instance to call more set-methods.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.SerializeOptions.GetEncodeUTF16LE">
            <returns>Returns the option.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.SerializeOptions.SetEncodeUTF16LE(System.Boolean)">
            <param name="value">the value to set</param>
            <returns>Returns the instance to call more set-methods.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.SerializeOptions.GetBaseIndent">
            <returns>Returns the baseIndent.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.SerializeOptions.SetBaseIndent(System.Int32)">
            <param name="baseIndent">The baseIndent to set.</param>
            <returns>Returns the instance to call more set-methods.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.SerializeOptions.GetIndent">
            <returns>Returns the indent.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.SerializeOptions.SetIndent(System.String)">
            <param name="indent">The indent to set.</param>
            <returns>Returns the instance to call more set-methods.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.SerializeOptions.GetNewline">
            <returns>Returns the newline.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.SerializeOptions.SetNewline(System.String)">
            <param name="newline">The newline to set.</param>
            <returns>Returns the instance to call more set-methods.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.SerializeOptions.GetPadding">
            <returns>Returns the padding.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.SerializeOptions.SetPadding(System.Int32)">
            <param name="padding">The padding to set.</param>
            <returns>Returns the instance to call more set-methods.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.SerializeOptions.GetOmitVersionAttribute">
            <returns>
            Returns whether the Toolkit version attribute shall be omitted.
            <em>Note:</em> This options can only be set by unit tests.
            </returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.SerializeOptions.GetEncoding">
            <returns>Returns the encoding as Java encoding String.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.Options.SerializeOptions.Clone">
            <returns>Returns clone of this SerializeOptions-object with the same options set.</returns>
            <exception cref="!:Java.Lang.CloneNotSupportedException">Cannot happen in this place.</exception>
        </member>
        <member name="M:iText.Kernel.XMP.Options.SerializeOptions.DefineOptionName(System.Int32)">
            <seealso cref="M:iText.Kernel.XMP.Options.Options.DefineOptionName(System.Int32)"/>
        </member>
        <member name="M:iText.Kernel.XMP.Options.SerializeOptions.GetValidOptions">
            <seealso cref="M:iText.Kernel.XMP.Options.Options.GetValidOptions"/>
        </member>
        <member name="T:iText.Kernel.XMP.PdfConst">
            <summary>Class that contains several constants.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.PdfConst.Contributor">
            <summary>External Contributors to the resource (other than the authors).</summary>
        </member>
        <member name="F:iText.Kernel.XMP.PdfConst.Coverage">
            <summary>The extent or scope of the resource.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.PdfConst.Creator">
            <summary>The authors of the resource (listed in order of precedence, if significant).</summary>
        </member>
        <member name="F:iText.Kernel.XMP.PdfConst.Date">
            <summary>Date(s) that something interesting happened to the resource.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.PdfConst.Description">
            <summary>A textual description of the content of the resource.</summary>
            <remarks>A textual description of the content of the resource. Multiple values may be present for different languages.
                </remarks>
        </member>
        <member name="F:iText.Kernel.XMP.PdfConst.Format">
            <summary>The file format used when saving the resource.</summary>
            <remarks>The file format used when saving the resource. Tools and applications should set this property to the save format of the data. It may include appropriate qualifiers.
                </remarks>
        </member>
        <member name="F:iText.Kernel.XMP.PdfConst.Identifier">
            <summary>An unordered array of text strings that unambiguously identify the resource within a given context.
                </summary>
        </member>
        <member name="F:iText.Kernel.XMP.PdfConst.Language">
            <summary>An unordered array specifying the languages used in the	resource.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.PdfConst.Publisher">
            <summary>Publishers.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.PdfConst.Relation">
            <summary>Relationships to other documents.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.PdfConst.Rights">
            <summary>Informal rights statement, selected by language.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.PdfConst.Source">
            <summary>Unique identifier of the work from which this resource was derived.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.PdfConst.Subject">
            <summary>An unordered array of descriptive phrases or keywords that specify the topic of the content of the resource.
                </summary>
        </member>
        <member name="F:iText.Kernel.XMP.PdfConst.Title">
            <summary>The title of the document, or the name given to the resource.</summary>
            <remarks>The title of the document, or the name given to the resource. Typically, it will be a name by which the resource is formally known.
                </remarks>
        </member>
        <member name="F:iText.Kernel.XMP.PdfConst.Type">
            <summary>A document type; for example, novel, poem, or working paper.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.PdfConst.Keywords">
            <summary>Keywords.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.PdfConst.Version">
            <summary>The PDF file version (for example: 1.0, 1.3, and so on).</summary>
        </member>
        <member name="F:iText.Kernel.XMP.PdfConst.Producer">
            <summary>The Producer.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.PdfConst.Part">
            <summary>The part</summary>
        </member>
        <member name="F:iText.Kernel.XMP.PdfConst.Advisory">
            <summary>An unordered array specifying properties that were edited outside the authoring application.</summary>
            <remarks>An unordered array specifying properties that were edited outside the authoring application. Each item should contain a single namespace and XPath separated by one ASCII space (U+0020).
                </remarks>
        </member>
        <member name="F:iText.Kernel.XMP.PdfConst.BaseURL">
            <summary>The base URL for relative URLs in the document content.</summary>
            <remarks>The base URL for relative URLs in the document content. If this document contains Internet links, and those links are relative, they are relative to this base URL. This property provides a standard way for embedded relative URLs to be interpreted by tools. Web authoring tools should set the value based on their notion of where URLs will be interpreted.
                </remarks>
        </member>
        <member name="F:iText.Kernel.XMP.PdfConst.CreateDate">
            <summary>The date and time the resource was originally created.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.PdfConst.CreatorTool">
            <summary>The name of the first known tool used to create the resource.</summary>
            <remarks>The name of the first known tool used to create the resource. If history is present in the metadata, this value should be equivalent to that of xmpMM:History's softwareAgent property.
                </remarks>
        </member>
        <member name="F:iText.Kernel.XMP.PdfConst.MetadataDate">
            <summary>The date and time that any metadata for this resource was last changed.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.PdfConst.ModifyDate">
            <summary>The date and time the resource was last modified.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.PdfConst.Nickname">
            <summary>A short informal name for the resource.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.PdfConst.Thumbnails">
            <summary>An alternative array of thumbnail images for a file, which can differ in characteristics such as size or image encoding.
                </summary>
        </member>
        <member name="T:iText.Kernel.XMP.XMPDateTimeFactory">
            <summary>
            A factory to create <code>XMPDateTime</code>-instances from a <code>Calendar</code> or an
            ISO 8601 string or for the current time.
            </summary>
            <since>16.02.2006</since>
        </member>
        <member name="M:iText.Kernel.XMP.XMPDateTimeFactory.#ctor">
            <summary>Private constructor</summary>
        </member>
        <member name="M:iText.Kernel.XMP.XMPDateTimeFactory.CreateFromCalendar(iText.Kernel.XMP.XMPCalendar)">
            <summary>Creates an <code>XMPDateTime</code> from a <code>Calendar</code>-object.
            	</summary>
            <param name="calendar">a <code>Calendar</code>-object.</param>
            <returns>An <code>XMPDateTime</code>-object.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPDateTimeFactory.Create">
            <summary>Creates an empty <code>XMPDateTime</code>-object.</summary>
            <returns>Returns an <code>XMPDateTime</code>-object.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPDateTimeFactory.Create(System.Int32,System.Int32,System.Int32)">
            <summary>Creates an <code>XMPDateTime</code>-object from initial values.</summary>
            <param name="year">years</param>
            <param name="month">
            months from 1 to 12<br/>
            <em>Note:</em> Remember that the month in
            <see cref="T:System.DateTime"/>
            is defined from 0 to 11.
            </param>
            <param name="day">days</param>
            <returns>Returns an <code>XMPDateTime</code>-object.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPDateTimeFactory.Create(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Creates an <code>XMPDateTime</code>-object from initial values.</summary>
            <param name="year">years</param>
            <param name="month">
            months from 1 to 12<br/>
            <em>Note:</em> Remember that the month in
            <see cref="T:System.DateTime"/>
            is defined from 0 to 11.
            </param>
            <param name="day">days</param>
            <param name="hour">hours</param>
            <param name="minute">minutes</param>
            <param name="second">seconds</param>
            <param name="nanoSecond">nanoseconds</param>
            <returns>Returns an <code>XMPDateTime</code>-object.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPDateTimeFactory.CreateFromISO8601(System.String)">
            <summary>Creates an <code>XMPDateTime</code> from an ISO 8601 string.</summary>
            <param name="strValue">The ISO 8601 string representation of the date/time.</param>
            <returns>An <code>XMPDateTime</code>-object.</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">When the ISO 8601 string is non-conform</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPDateTimeFactory.GetCurrentDateTime">
            <summary>Obtain the current date and time.</summary>
            <returns>
            Returns The returned time is UTC, properly adjusted for the local time zone. The
            resolution of the time is not guaranteed to be finer than seconds.
            </returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPDateTimeFactory.SetLocalTimeZone(iText.Kernel.XMP.XMPDateTime)">
            <summary>
            Sets the local time zone without touching any other Any existing time zone value is replaced,
            the other date/time fields are not adjusted in any way.
            </summary>
            <param name="dateTime">the <code>XMPDateTime</code> variable containing the value to be modified.
            	</param>
            <returns>Returns an updated <code>XMPDateTime</code>-object.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPDateTimeFactory.ConvertToUTCTime(iText.Kernel.XMP.XMPDateTime)">
            <summary>Make sure a time is UTC.</summary>
            <remarks>
            Make sure a time is UTC. If the time zone is not UTC, the time is
            adjusted and the time zone set to be UTC.
            </remarks>
            <param name="dateTime">
            the <code>XMPDateTime</code> variable containing the time to
            be modified.
            </param>
            <returns>Returns an updated <code>XMPDateTime</code>-object.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPDateTimeFactory.ConvertToLocalTime(iText.Kernel.XMP.XMPDateTime)">
            <summary>Make sure a time is local.</summary>
            <remarks>
            Make sure a time is local. If the time zone is not the local zone, the time is adjusted and
            the time zone set to be local.
            </remarks>
            <param name="dateTime">the <code>XMPDateTime</code> variable containing the time to be modified.
            	</param>
            <returns>Returns an updated <code>XMPDateTime</code>-object.</returns>
        </member>
        <member name="T:iText.Kernel.XMP.XMPError">
            <since>21.09.2006</since>
        </member>
        <member name="F:iText.Kernel.XMP.XMPError.BADSTREAM">
            <summary><em>Note:</em> This is an error code introduced by Java.</summary>
        </member>
        <member name="T:iText.Kernel.XMP.XMPException">
            <summary>This exception wraps all errors that occur in the XMP Toolkit.</summary>
            <since>16.02.2006</since>
        </member>
        <member name="F:iText.Kernel.XMP.XMPException.errorCode">
            <summary>the errorCode of the XMP toolkit</summary>
        </member>
        <member name="M:iText.Kernel.XMP.XMPException.#ctor(System.String,System.Int32)">
            <summary>Constructs an exception with a message and an error code.</summary>
            <param name="message">the message</param>
            <param name="errorCode">the error code</param>
        </member>
        <member name="M:iText.Kernel.XMP.XMPException.#ctor(System.String,System.Int32,System.Exception)">
            <summary>Constructs an exception with a message, an error code and a <code>Throwable</code></summary>
            <param name="message">the error message.</param>
            <param name="errorCode">the error code</param>
            <param name="t">the exception source</param>
        </member>
        <member name="M:iText.Kernel.XMP.XMPException.GetErrorCode">
            <returns>Returns the errorCode.</returns>
        </member>
        <member name="T:iText.Kernel.XMP.XMPMetaFactory">
            <summary>Creates <code>XMPMeta</code>-instances from an <code>InputStream</code></summary>
            <since>30.01.2006</since>
        </member>
        <member name="F:iText.Kernel.XMP.XMPMetaFactory.schema">
            <summary>The singleton instance of the <code>XMPSchemaRegistry</code>.</summary>
        </member>
        <member name="F:iText.Kernel.XMP.XMPMetaFactory.versionInfo">
            <summary>cache for version info</summary>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMetaFactory.#ctor">
            <summary>Hides public constructor</summary>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMetaFactory.GetSchemaRegistry">
            <returns>Returns the singleton instance of the <code>XMPSchemaRegistry</code>.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMetaFactory.Create">
            <returns>Returns an empty <code>XMPMeta</code>-object.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMetaFactory.Parse(System.IO.Stream)">
            <summary>Parsing with default options.</summary>
            <param name="in">an <code>InputStream</code></param>
            <returns>Returns the <code>XMPMeta</code>-object created from the input.</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">If the file is not well-formed XML or if the parsing fails.</exception>
            <seealso cref="M:iText.Kernel.XMP.XMPMetaFactory.Parse(System.IO.Stream,iText.Kernel.XMP.Options.ParseOptions)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.XMPMetaFactory.Parse(System.IO.Stream,iText.Kernel.XMP.Options.ParseOptions)" -->
        <member name="M:iText.Kernel.XMP.XMPMetaFactory.ParseFromString(System.String)">
            <summary>Parsing with default options.</summary>
            <param name="packet">a String contain an XMP-file.</param>
            <returns>Returns the <code>XMPMeta</code>-object created from the input.</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">If the file is not well-formed XML or if the parsing fails.</exception>
            <seealso cref="M:iText.Kernel.XMP.XMPMetaFactory.Parse(System.IO.Stream)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMetaFactory.ParseFromString(System.String,iText.Kernel.XMP.Options.ParseOptions)">
            <summary>Creates an <code>XMPMeta</code>-object from a string.</summary>
            <param name="packet">a String contain an XMP-file.</param>
            <param name="options">Options controlling the parsing.</param>
            <returns>Returns the <code>XMPMeta</code>-object created from the input.</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">If the file is not well-formed XML or if the parsing fails.</exception>
            <seealso cref="M:iText.Kernel.XMP.XMPMetaFactory.ParseFromString(System.String,iText.Kernel.XMP.Options.ParseOptions)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMetaFactory.ParseFromBuffer(System.Byte[])">
            <summary>Parsing with default options.</summary>
            <param name="buffer">a String contain an XMP-file.</param>
            <returns>Returns the <code>XMPMeta</code>-object created from the input.</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">If the file is not well-formed XML or if the parsing fails.</exception>
            <seealso cref="M:iText.Kernel.XMP.XMPMetaFactory.ParseFromBuffer(System.Byte[],iText.Kernel.XMP.Options.ParseOptions)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMetaFactory.ParseFromBuffer(System.Byte[],iText.Kernel.XMP.Options.ParseOptions)">
            <summary>Creates an <code>XMPMeta</code>-object from a byte-buffer.</summary>
            <param name="buffer">a String contain an XMP-file.</param>
            <param name="options">Options controlling the parsing.</param>
            <returns>Returns the <code>XMPMeta</code>-object created from the input.</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">If the file is not well-formed XML or if the parsing fails.</exception>
            <seealso cref="M:iText.Kernel.XMP.XMPMetaFactory.Parse(System.IO.Stream,iText.Kernel.XMP.Options.ParseOptions)"/>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMetaFactory.Serialize(iText.Kernel.XMP.XMPMeta,System.IO.Stream)">
            <summary>
            Serializes an <code>XMPMeta</code>-object as RDF into an <code>OutputStream</code>
            with default options.
            </summary>
            <param name="xmp">a metadata object</param>
            <param name="out">an <code>OutputStream</code> to write the serialized RDF to.</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">on serializsation errors.</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMetaFactory.Serialize(iText.Kernel.XMP.XMPMeta,System.IO.Stream,iText.Kernel.XMP.Options.SerializeOptions)">
            <summary>Serializes an <code>XMPMeta</code>-object as RDF into an <code>OutputStream</code>.</summary>
            <param name="xmp">a metadata object</param>
            <param name="options">
            Options to control the serialization (see
            <see cref="T:iText.Kernel.XMP.Options.SerializeOptions"/>
            ).
            </param>
            <param name="out">an <code>OutputStream</code> to write the serialized RDF to.</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">on serializsation errors.</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMetaFactory.SerializeToBuffer(iText.Kernel.XMP.XMPMeta,iText.Kernel.XMP.Options.SerializeOptions)">
            <summary>Serializes an <code>XMPMeta</code>-object as RDF into a byte buffer.</summary>
            <param name="xmp">a metadata object</param>
            <param name="options">
            Options to control the serialization (see
            <see cref="T:iText.Kernel.XMP.Options.SerializeOptions"/>
            ).
            </param>
            <returns>Returns a byte buffer containing the serialized RDF.</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">on serializsation errors.</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMetaFactory.SerializeToString(iText.Kernel.XMP.XMPMeta,iText.Kernel.XMP.Options.SerializeOptions)">
            <summary>Serializes an <code>XMPMeta</code>-object as RDF into a string.</summary>
            <remarks>
            Serializes an <code>XMPMeta</code>-object as RDF into a string. <em>Note:</em> Encoding
            is ignored when serializing to a string.
            </remarks>
            <param name="xmp">a metadata object</param>
            <param name="options">
            Options to control the serialization (see
            <see cref="T:iText.Kernel.XMP.Options.SerializeOptions"/>
            ).
            </param>
            <returns>Returns a string containing the serialized RDF.</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">on serializsation errors.</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMetaFactory.AssertImplementation(iText.Kernel.XMP.XMPMeta)">
            <param name="xmp">Asserts that xmp is compatible to <code>XMPMetaImpl</code>.s</param>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMetaFactory.Reset">
            <summary>Resets the schema registry to its original state (creates a new one).</summary>
            <remarks>
            Resets the schema registry to its original state (creates a new one).
            Be careful this might break all existing XMPMeta-objects and should be used
            only for testing purpurses.
            </remarks>
        </member>
        <member name="M:iText.Kernel.XMP.XMPMetaFactory.GetVersionInfo">
            <summary>Obtain version information.</summary>
            <remarks>
            Obtain version information. The XMPVersionInfo singleton is created the first time
            its requested.
            </remarks>
            <returns>Returns the version information.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:iText.Kernel.XMP.XMPVersionInfo" -->
        <member name="M:iText.Kernel.XMP.XMPVersionInfo.GetMajor">
            <returns>Returns the primary release number, the "1" in version "1.2.3".</returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPVersionInfo.GetMinor">
            <returns>Returns the secondary release number, the "2" in version "1.2.3".</returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPVersionInfo.GetMicro">
            <returns>Returns the tertiary release number, the "3" in version "1.2.3".</returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPVersionInfo.GetBuild">
            <returns>Returns a rolling build number, monotonically increasing in a release.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPVersionInfo.IsDebug">
            <returns>Returns true if this is a debug build.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPVersionInfo.GetMessage">
            <returns>Returns a comprehensive version information string.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:iText.Kernel.XMP.XMPPathFactory" -->
        <member name="M:iText.Kernel.XMP.XMPPathFactory.#ctor">
            <summary>Private constructor</summary>
        </member>
        <member name="M:iText.Kernel.XMP.XMPPathFactory.ComposeArrayItemPath(System.String,System.Int32)">
            <summary>Compose the path expression for an item in an array.</summary>
            <param name="arrayName">
            The name of the array. May be a general path expression, must not be
            <code>null</code> or the empty string.
            </param>
            <param name="itemIndex">
            The index of the desired item. Arrays in XMP are indexed from 1.
            0 and below means last array item and renders as <code>[last()]</code>.
            </param>
            <returns>
            Returns the composed path basing on fullPath. This will be of the form
            <tt>ns:arrayName[i]</tt>, where "ns" is the prefix for schemaNS and
            "i" is the decimal representation of itemIndex.
            </returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">Throws exeption if index zero is used.</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPPathFactory.ComposeStructFieldPath(System.String,System.String)">
            <summary>Compose the path expression for a field in a struct.</summary>
            <remarks>
            Compose the path expression for a field in a struct. The result can be added to the
            path of
            </remarks>
            <param name="fieldNS">
            The namespace URI for the field. Must not be <code>null</code> or the empty
            string.
            </param>
            <param name="fieldName">
            The name of the field. Must be a simple XML name, must not be
            <code>null</code> or the empty string.
            </param>
            <returns>
            Returns the composed path. This will be of the form
            <tt>ns:structName/fNS:fieldName</tt>, where "ns" is the prefix for
            schemaNS and "fNS" is the prefix for fieldNS.
            </returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">Thrown if the path to create is not valid.</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPPathFactory.ComposeQualifierPath(System.String,System.String)">
            <summary>Compose the path expression for a qualifier.</summary>
            <param name="qualNS">
            The namespace URI for the qualifier. May be <code>null</code> or the empty
            string if the qualifier is in the XML empty namespace.
            </param>
            <param name="qualName">
            The name of the qualifier. Must be a simple XML name, must not be
            <code>null</code> or the empty string.
            </param>
            <returns>
            Returns the composed path. This will be of the form
            <tt>ns:propName/?qNS:qualName</tt>, where "ns" is the prefix for
            schemaNS and "qNS" is the prefix for qualNS.
            </returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">Thrown if the path to create is not valid.</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPPathFactory.ComposeLangSelector(System.String,System.String)">
            <summary>Compose the path expression to select an alternate item by language.</summary>
            <remarks>
            Compose the path expression to select an alternate item by language. The
            path syntax allows two forms of &quot;content addressing&quot; that may
            be used to select an item in an array of alternatives. The form used in
            ComposeLangSelector lets you select an item in an alt-text array based on
            the value of its <tt>xml:lang</tt> qualifier. The other form of content
            addressing is shown in ComposeFieldSelector. \note ComposeLangSelector
            does not supplant SetLocalizedText or GetLocalizedText. They should
            generally be used, as they provide extra logic to choose the appropriate
            language and maintain consistency with the 'x-default' value.
            ComposeLangSelector gives you an path expression that is explicitly and
            only for the language given in the langName parameter.
            </remarks>
            <param name="arrayName">
            The name of the array. May be a general path expression, must
            not be <code>null</code> or the empty string.
            </param>
            <param name="langName">The RFC 3066 code for the desired language.</param>
            <returns>
            Returns the composed path. This will be of the form
            <tt>ns:arrayName[@xml:lang='langName']</tt>, where
            &quot;ns&quot; is the prefix for schemaNS.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.XMPPathFactory.ComposeFieldSelector(System.String,System.String,System.String,System.String)" -->
        <member name="M:iText.Kernel.XMP.XMPPathFactory.AssertQualNS(System.String)">
            <summary>ParameterAsserts that a qualifier namespace is set.</summary>
            <param name="qualNS">a qualifier namespace</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Qualifier schema is null or empty</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPPathFactory.AssertQualName(System.String)">
            <summary>ParameterAsserts that a qualifier name is set.</summary>
            <param name="qualName">a qualifier name or path</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Qualifier name is null or empty</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPPathFactory.AssertFieldNS(System.String)">
            <summary>ParameterAsserts that a struct field namespace is set.</summary>
            <param name="fieldNS">a struct field namespace</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Struct field schema is null or empty</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPPathFactory.AssertFieldName(System.String)">
            <summary>ParameterAsserts that a struct field name is set.</summary>
            <param name="fieldName">a struct field name or path</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Struct field name is null or empty</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="T:iText.Kernel.XMP.XMPUtils">
            <summary>Utility methods for XMP.</summary>
            <remarks>
            Utility methods for XMP. I included only those that are different from the
            Java default conversion utilities.
            </remarks>
            <since>21.02.2006</since>
        </member>
        <member name="M:iText.Kernel.XMP.XMPUtils.#ctor">
            <summary>Private constructor</summary>
        </member>
        <member name="M:iText.Kernel.XMP.XMPUtils.CatenateArrayItems(iText.Kernel.XMP.XMPMeta,System.String,System.String,System.String,System.String,System.Boolean)">
            <summary>Create a single edit string from an array of strings.</summary>
            <param name="xmp">The XMP object containing the array to be catenated.</param>
            <param name="schemaNS">
            The schema namespace URI for the array. Must not be null or
            the empty string.
            </param>
            <param name="arrayName">
            The name of the array. May be a general path expression, must
            not be null or the empty string. Each item in the array must
            be a simple string value.
            </param>
            <param name="separator">
            The string to be used to separate the items in the catenated
            string. Defaults to "; ", ASCII semicolon and space
            (U+003B, U+0020).
            </param>
            <param name="quotes">
            The characters to be used as quotes around array items that
            contain a separator. Defaults to '"'
            </param>
            <param name="allowCommas">Option flag to control the catenation.</param>
            <returns>Returns the string containing the catenated array items.</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">Forwards the Exceptions from the metadata processing</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPUtils.SeparateArrayItems(iText.Kernel.XMP.XMPMeta,System.String,System.String,System.String,iText.Kernel.XMP.Options.PropertyOptions,System.Boolean)">
            <summary>Separate a single edit string into an array of strings.</summary>
            <param name="xmp">The XMP object containing the array to be updated.</param>
            <param name="schemaNS">
            The schema namespace URI for the array. Must not be null or
            the empty string.
            </param>
            <param name="arrayName">
            The name of the array. May be a general path expression, must
            not be null or the empty string. Each item in the array must
            be a simple string value.
            </param>
            <param name="catedStr">The string to be separated into the array items.</param>
            <param name="arrayOptions">Option flags to control the separation.</param>
            <param name="preserveCommas">Flag if commas shall be preserved</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Forwards the Exceptions from the metadata processing</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.XMPUtils.RemoveProperties(iText.Kernel.XMP.XMPMeta,System.String,System.String,System.Boolean,System.Boolean)" -->
        <member name="M:iText.Kernel.XMP.XMPUtils.AppendProperties(iText.Kernel.XMP.XMPMeta,iText.Kernel.XMP.XMPMeta,System.Boolean,System.Boolean)">
            <summary>Alias without the new option <code>deleteEmptyValues</code>.</summary>
            <param name="source">The source XMP object.</param>
            <param name="dest">The destination XMP object.</param>
            <param name="doAllProperties">Do internal properties in addition to external properties.</param>
            <param name="replaceOldValues">Replace the values of existing properties.</param>
            <exception cref="T:iText.Kernel.XMP.XMPException">Forwards the Exceptions from the metadata processing</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.XMPUtils.AppendProperties(iText.Kernel.XMP.XMPMeta,iText.Kernel.XMP.XMPMeta,System.Boolean,System.Boolean,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:iText.Kernel.XMP.XMPUtils.ConvertToBoolean(System.String)" -->
        <member name="M:iText.Kernel.XMP.XMPUtils.ConvertFromBoolean(System.Boolean)">
            <summary>Convert from boolean to string.</summary>
            <param name="value">a boolean value</param>
            <returns>
            The XMP string representation of the boolean. The values used are
            given by the constnts
            <see cref="F:iText.Kernel.XMP.XMPConst.TRUESTR"/>
            and
            <see cref="F:iText.Kernel.XMP.XMPConst.FALSESTR"/>
            .
            </returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPUtils.ConvertToInteger(System.String)">
            <summary>Converts a string value to an <code>int</code>.</summary>
            <param name="rawValue">the string value</param>
            <returns>Returns an int.</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">
            If the <code>rawValue</code> is <code>null</code> or empty or the
            conversion fails.
            </exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPUtils.ConvertFromInteger(System.Int32)">
            <summary>Convert from int to string.</summary>
            <param name="value">an int value</param>
            <returns>The string representation of the int.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPUtils.ConvertToLong(System.String)">
            <summary>Converts a string value to a <code>long</code>.</summary>
            <param name="rawValue">the string value</param>
            <returns>Returns a long.</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">
            If the <code>rawValue</code> is <code>null</code> or empty or the
            conversion fails.
            </exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPUtils.ConvertFromLong(System.Int64)">
            <summary>Convert from long to string.</summary>
            <param name="value">a long value</param>
            <returns>The string representation of the long.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPUtils.ConvertToDouble(System.String)">
            <summary>Converts a string value to a <code>double</code>.</summary>
            <param name="rawValue">the string value</param>
            <returns>Returns a double.</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">
            If the <code>rawValue</code> is <code>null</code> or empty or the
            conversion fails.
            </exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPUtils.ConvertFromDouble(System.Double)">
            <summary>Convert from long to string.</summary>
            <param name="value">a long value</param>
            <returns>The string representation of the long.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPUtils.ConvertToDate(System.String)">
            <summary>Converts a string value to an <code>XMPDateTime</code>.</summary>
            <param name="rawValue">the string value</param>
            <returns>Returns an <code>XMPDateTime</code>-object.</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">
            If the <code>rawValue</code> is <code>null</code> or empty or the
            conversion fails.
            </exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:iText.Kernel.XMP.XMPUtils.ConvertFromDate(iText.Kernel.XMP.XMPDateTime)">
            <summary>Convert from <code>XMPDateTime</code> to string.</summary>
            <param name="value">an <code>XMPDateTime</code></param>
            <returns>The string representation of the long.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPUtils.EncodeBase64(System.Byte[])">
            <summary>Convert from a byte array to a base64 encoded string.</summary>
            <param name="buffer">the byte array to be converted</param>
            <returns>Returns the base64 string.</returns>
        </member>
        <member name="M:iText.Kernel.XMP.XMPUtils.DecodeBase64(System.String)">
            <summary>Decode from Base64 encoded string to raw data.</summary>
            <param name="base64String">a base64 encoded string</param>
            <returns>Returns a byte array containg the decoded string.</returns>
            <exception cref="T:iText.Kernel.XMP.XMPException">Thrown if the given string is not property base64 encoded</exception>
            <exception cref="T:iText.Kernel.XMP.XMPException"/>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Anssi.AnssiNamedCurves.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the X9ECParameters object for the named curve represented by
             the passed in object identifier. Null if the curve isn't present.
            
             @param oid an object identifier representing a named curve, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Anssi.AnssiNamedCurves.GetOid(System.String)">
             return the object identifier signified by the passed in name. Null
             if there is no object identifier associated with name.
            
             @return the object identifier associated with name, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Anssi.AnssiNamedCurves.GetName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            return the named curve name represented by the given object identifier.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Anssi.AnssiNamedCurves.Names">
            returns an enumeration containing the name strings for curves
            contained in this structure.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Encodable.GetDerEncoded">
             Return the DER encoding of the object, null if the DER encoding can not be made.
            
             @return a DER byte array, null otherwise.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Asn1InputStream">
            a general purpose ASN.1 decoder - note: this class differs from the
            others in that it returns null after it has read the last object in
            the stream. If an ASN.1 Null is encountered a Der/BER Null object is
            returned.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1InputStream.#ctor(System.IO.Stream,System.Int32)">
             Create an ASN1InputStream where no DER object will be longer than limit.
            
             @param input stream containing ASN.1 encoded data.
             @param limit maximum size of a DER encoded object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1InputStream.#ctor(System.Byte[])">
             Create an ASN1InputStream based on the input byte array. The length of DER objects in
             the stream is automatically limited to the length of the input array.
            
             @param input array containing ASN.1 encoded data.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1InputStream.BuildObject(System.Int32,System.Int32,System.Int32)">
            build an object given its tag and the number of bytes to construct it from.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Asn1Null">
            A Null object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Object.FromByteArray(System.Byte[])">
            <summary>Create a base ASN.1 object from a byte array.</summary>
            <param name="data">The byte array to parse.</param>
            <returns>The base ASN.1 object represented by the byte array.</returns>
            <exception cref="T:System.IO.IOException">If there is a problem parsing the data.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Object.FromStream(System.IO.Stream)">
            <summary>Read a base ASN.1 object from a stream.</summary>
            <param name="inStr">The stream to parse.</param>
            <returns>The base ASN.1 object represented by the byte array.</returns>
            <exception cref="T:System.IO.IOException">If there is a problem parsing the data.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1OctetString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an Octet string from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                          be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1OctetString.GetInstance(System.Object)">
             return an Octet string from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1OctetString.#ctor(System.Byte[])">
            @param string the octets making up the octet string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Sequence.GetInstance(System.Object)">
             return an Asn1Sequence from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Sequence.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             Return an ASN1 sequence from a tagged object. There is a special
             case here, if an object appears to have been explicitly tagged on
             reading but we were expecting it to be implicitly tagged in the
             normal course of events it indicates that we lost the surrounding
             sequence - so we need to add it back (this will happen if the tagged
             object is a sequence that contains other sequences). If you are
             dealing with implicitly tagged sequences you really <b>should</b>
             be using this method.
            
             @param obj the tagged object.
             @param explicitly true if the object is meant to be explicitly tagged,
                      false otherwise.
             @exception ArgumentException if the tagged object cannot
                      be converted.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Asn1Sequence.Item(System.Int32)">
             return the object at the sequence position indicated by index.
            
             @param index the sequence number (starting at zero) of the object
             @return the object at the sequence position indicated by index.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Set.GetInstance(System.Object)">
             return an ASN1Set from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Set.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             Return an ASN1 set from a tagged object. There is a special
             case here, if an object appears to have been explicitly tagged on
             reading but we were expecting it to be implicitly tagged in the
             normal course of events it indicates that we lost the surrounding
             set - so we need to add it back (this will happen if the tagged
             object is a sequence that contains other sequences). If you are
             dealing with implicitly tagged sets you really <b>should</b>
             be using this method.
            
             @param obj the tagged object.
             @param explicitly true if the object is meant to be explicitly tagged
                      false otherwise.
             @exception ArgumentException if the tagged object cannot
                      be converted.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Asn1Set.Item(System.Int32)">
             return the object at the set position indicated by index.
            
             @param index the set number (starting at zero) of the object
             @return the object at the set position indicated by index.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Asn1TaggedObject">
            ASN.1 TaggedObject - in ASN.1 notation this is any object preceded by
            a [n] where n is some number - these are assumed to follow the construction
            rules (as with sequences).
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1TaggedObject.#ctor(System.Int32,Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1TaggedObject.#ctor(System.Boolean,System.Int32,Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param explicitly true if the object is explicitly tagged.
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1TaggedObject.IsExplicit">
            return whether or not the object may be explicitly tagged.
            <p>
            Note: if the object has been read from an input stream, the only
            time you can be sure if isExplicit is returning the true state of
            affairs is if it returns false. An implicitly tagged object may appear
            to be explicitly tagged, so you need to understand the context under
            which the reading was done as well, see GetObject below.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1TaggedObject.GetObject">
            return whatever was following the tag.
            <p>
            Note: tagged objects are generally context dependent if you're
            trying to extract a tagged object you should be going via the
            appropriate GetInstance method.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1TaggedObject.GetObjectParser(System.Int32,System.Boolean)">
            Return the object held in this tagged object as a parser assuming it has
            the type of the passed in tag. If the object doesn't have a parser
            associated with it, the base object is returned.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerApplicationSpecific">
            Base class for an application specific object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerApplicationSpecific.GetObject">
             Return the enclosed object assuming explicit tagging.
            
             @return  the resulting object
             @throws IOException if reconstruction fails.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerApplicationSpecific.GetObject(System.Int32)">
             Return the enclosed object assuming implicit tagging.
            
             @param derTagNo the type tag that should be applied to the object's contents.
             @return  the resulting object
             @throws IOException if reconstruction fails.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IAsn1String">
            basic interface for Der string objects.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBitString.GetInstance(System.Object)">
             return a Bit string from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBitString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Bit string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBitString.#ctor(System.Byte[],System.Int32)">
            @param data the octets making up the bit string.
            @param padBits the number of extra bits at the end of the string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBitString.GetOctets">
             Return the octets contained in this BIT STRING, checking that this BIT STRING really
             does represent an octet aligned string. Only use this method when the standard you are
             following dictates that the BIT STRING will be octet aligned.
            
             @return a copy of the octet aligned data.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.DerBitString.IntValue">
            @return the value of the bit string as an int (truncating if necessary)
        </member>
        <member name="T:Org.BouncyCastle.Asn1.BerNull">
            A BER Null object.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerNull">
            A Null object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerOctetString.#ctor(System.Byte[])">
            <param name="str">The octets making up the octet string.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerOctetString.ToBytes(System.Collections.IEnumerable)">
            convert a vector of octet strings into a single byte string
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerOctetString.#ctor(System.Byte[])">
            <param name="str">The octets making up the octet string.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerOctetString.GetEnumerator">
            return the DER octets that make up this string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSequence.#ctor">
            create an empty sequence
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSequence.#ctor(Org.BouncyCastle.Asn1.Asn1Encodable)">
            create a sequence containing one object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSequence.#ctor(Org.BouncyCastle.Asn1.Asn1EncodableVector)">
            create a sequence containing a vector of objects.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerSequence.#ctor">
            create an empty sequence
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerSequence.#ctor(Org.BouncyCastle.Asn1.Asn1Encodable)">
            create a sequence containing one object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerSequence.#ctor(Org.BouncyCastle.Asn1.Asn1EncodableVector)">
            create a sequence containing a vector of objects.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerSet">
            A Der encoded set object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSet.#ctor">
            create an empty set
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSet.#ctor(Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param obj - a single object that makes up the set.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSet.#ctor(Org.BouncyCastle.Asn1.Asn1EncodableVector)">
            @param v - a vector of objects making up the set.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerSet.#ctor">
            create an empty sequence
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerSet.#ctor(Org.BouncyCastle.Asn1.Asn1Encodable)">
            create a set containing one object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerSet.#ctor(Org.BouncyCastle.Asn1.Asn1EncodableVector)">
            create a set containing a vector of objects.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.BerTaggedObject">
            BER TaggedObject - in ASN.1 notation this is any object preceded by
            a [n] where n is some number - these are assumed to follow the construction
            rules (as with sequences).
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerTaggedObject">
            DER TaggedObject - in ASN.1 notation this is any object preceded by
            a [n] where n is some number - these are assumed to follow the construction
            rules (as with sequences).
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerTaggedObject.#ctor(System.Int32,Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerTaggedObject.#ctor(System.Boolean,System.Int32,Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param explicitly true if an explicitly tagged object.
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerTaggedObject.#ctor(System.Int32)">
            create an implicitly tagged object that contains a zero
            length sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerTaggedObject.#ctor(System.Int32,Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerTaggedObject.#ctor(System.Boolean,System.Int32,Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param explicitly true if an explicitly tagged object.
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerTaggedObject.#ctor(System.Int32)">
            create an implicitly tagged object that contains a zero
            length sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.CAKeyUpdAnnContent.ToAsn1Object">
            <pre>
            CAKeyUpdAnnContent ::= SEQUENCE {
                                        oldWithNew   CmpCertificate, -- old pub signed with new priv
                                        newWithOld   CmpCertificate, -- new pub signed with old priv
                                        newWithNew   CmpCertificate  -- new pub signed with new priv
             }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.CertConfirmContent.ToAsn1Object">
            <pre>
            CertConfirmContent ::= SEQUENCE OF CertStatus
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.CertifiedKeyPair.ToAsn1Object">
            <pre>
            CertifiedKeyPair ::= SEQUENCE {
                                             certOrEncCert       CertOrEncCert,
                                             privateKey      [0] EncryptedValue      OPTIONAL,
                                             -- see [CRMF] for comment on encoding
                                             publicationInfo [1] PKIPublicationInfo  OPTIONAL
                  }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IAsn1Choice">
            Marker interface for CHOICE objects - if you implement this in a roll-your-own
            object, any attempt to tag the object implicitly will convert the tag to an
            explicit one as the encoding rules require.
            <p>
            If you use this interface your class should also implement the getInstance
            pattern which takes a tag object and the tagging mode used. 
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.CertOrEncCert.ToAsn1Object">
            <pre>
            CertOrEncCert ::= CHOICE {
                                 certificate     [0] CMPCertificate,
                                 encryptedCert   [1] EncryptedValue
                      }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.CertRepMessage.ToAsn1Object">
            <pre>
            CertRepMessage ::= SEQUENCE {
                                     caPubs       [1] SEQUENCE SIZE (1..MAX) OF CMPCertificate
                                                                                        OPTIONAL,
                                     response         SEQUENCE OF CertResponse
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.CertResponse.ToAsn1Object">
            <pre>
            CertResponse ::= SEQUENCE {
                                       certReqId           INTEGER,
                                       -- to match this response with corresponding request (a value
                                       -- of -1 is to be used if certReqId is not specified in the
                                       -- corresponding request)
                                       status              PKIStatusInfo,
                                       certifiedKeyPair    CertifiedKeyPair    OPTIONAL,
                                       rspInfo             OCTET STRING        OPTIONAL
                                       -- analogous to the id-regInfo-utf8Pairs string defined
                                       -- for regInfo in CertReqMsg [CRMF]
                        }
            </pre> 
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.CertStatus.ToAsn1Object">
            <pre>
            CertStatus ::= SEQUENCE {
                              certHash    OCTET STRING,
                              -- the hash of the certificate, using the same hash algorithm
                              -- as is used to create and verify the certificate signature
                              certReqId   INTEGER,
                              -- to match this confirmation with the corresponding req/rep
                              statusInfo  PKIStatusInfo OPTIONAL
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.Challenge.ToAsn1Object">
             <pre>
             Challenge ::= SEQUENCE {
                             owf                 AlgorithmIdentifier  OPTIONAL,
            
                             -- MUST be present in the first Challenge; MAY be omitted in
                             -- any subsequent Challenge in POPODecKeyChallContent (if
                             -- omitted, then the owf used in the immediately preceding
                             -- Challenge is to be used).
            
                             witness             OCTET STRING,
                             -- the result of applying the one-way function (owf) to a
                             -- randomly-generated INTEGER, A.  [Note that a different
                             -- INTEGER MUST be used for each Challenge.]
                             challenge           OCTET STRING
                             -- the encryption (under the public key for which the cert.
                             -- request is being made) of Rand, where Rand is specified as
                             --   Rand ::= SEQUENCE {
                             --      int      INTEGER,
                             --       - the randomly-generated INTEGER A (above)
                             --      sender   GeneralName
                             --       - the sender's name (as included in PKIHeader)
                             --   }
                  }
             </pre>
             @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.CmpCertificate.#ctor(Org.BouncyCastle.Asn1.X509.AttributeCertificate)">
            Note: the addition of attribute certificates is a BC extension.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.CmpCertificate.ToAsn1Object">
             <pre>
             CMPCertificate ::= CHOICE {
                        x509v3PKCert        Certificate
                        x509v2AttrCert      [1] AttributeCertificate
              }
             </pre>
             Note: the addition of attribute certificates is a BC extension.
            
             @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.CrlAnnContent.ToAsn1Object">
            <pre>
            CrlAnnContent ::= SEQUENCE OF CertificateList
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.ErrorMsgContent.ToAsn1Object">
            <pre>
            ErrorMsgContent ::= SEQUENCE {
                                   pKIStatusInfo          PKIStatusInfo,
                                   errorCode              INTEGER           OPTIONAL,
                                   -- implementation-specific error codes
                                   errorDetails           PKIFreeText       OPTIONAL
                                   -- implementation-specific error details
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.GenMsgContent.ToAsn1Object">
            <pre>
            GenMsgContent ::= SEQUENCE OF InfoTypeAndValue
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.GenRepContent.ToAsn1Object">
            <pre>
            GenRepContent ::= SEQUENCE OF InfoTypeAndValue
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Cmp.InfoTypeAndValue">
             Example InfoTypeAndValue contents include, but are not limited
             to, the following (un-comment in this ASN.1 module and use as
             appropriate for a given environment):
             <pre>
               id-it-caProtEncCert    OBJECT IDENTIFIER ::= {id-it 1}
                  CAProtEncCertValue      ::= CMPCertificate
               id-it-signKeyPairTypes OBJECT IDENTIFIER ::= {id-it 2}
                 SignKeyPairTypesValue   ::= SEQUENCE OF AlgorithmIdentifier
               id-it-encKeyPairTypes  OBJECT IDENTIFIER ::= {id-it 3}
                 EncKeyPairTypesValue    ::= SEQUENCE OF AlgorithmIdentifier
               id-it-preferredSymmAlg OBJECT IDENTIFIER ::= {id-it 4}
                  PreferredSymmAlgValue   ::= AlgorithmIdentifier
               id-it-caKeyUpdateInfo  OBJECT IDENTIFIER ::= {id-it 5}
                  CAKeyUpdateInfoValue    ::= CAKeyUpdAnnContent
               id-it-currentCRL       OBJECT IDENTIFIER ::= {id-it 6}
                  CurrentCRLValue         ::= CertificateList
               id-it-unsupportedOIDs  OBJECT IDENTIFIER ::= {id-it 7}
                  UnsupportedOIDsValue    ::= SEQUENCE OF OBJECT IDENTIFIER
               id-it-keyPairParamReq  OBJECT IDENTIFIER ::= {id-it 10}
                  KeyPairParamReqValue    ::= OBJECT IDENTIFIER
               id-it-keyPairParamRep  OBJECT IDENTIFIER ::= {id-it 11}
                  KeyPairParamRepValue    ::= AlgorithmIdentifer
               id-it-revPassphrase    OBJECT IDENTIFIER ::= {id-it 12}
                  RevPassphraseValue      ::= EncryptedValue
               id-it-implicitConfirm  OBJECT IDENTIFIER ::= {id-it 13}
                  ImplicitConfirmValue    ::= NULL
               id-it-confirmWaitTime  OBJECT IDENTIFIER ::= {id-it 14}
                  ConfirmWaitTimeValue    ::= GeneralizedTime
               id-it-origPKIMessage   OBJECT IDENTIFIER ::= {id-it 15}
                  OrigPKIMessageValue     ::= PKIMessages
               id-it-suppLangTags     OBJECT IDENTIFIER ::= {id-it 16}
                  SuppLangTagsValue       ::= SEQUENCE OF UTF8String
            
             where
            
               id-pkix OBJECT IDENTIFIER ::= {
                  iso(1) identified-organization(3)
                  dod(6) internet(1) security(5) mechanisms(5) pkix(7)}
             and
                  id-it   OBJECT IDENTIFIER ::= {id-pkix 4}
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.InfoTypeAndValue.ToAsn1Object">
            <pre>
            InfoTypeAndValue ::= SEQUENCE {
                                    infoType               OBJECT IDENTIFIER,
                                    infoValue              ANY DEFINED BY infoType  OPTIONAL
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.KeyRecRepContent.ToAsn1Object">
            <pre>
            KeyRecRepContent ::= SEQUENCE {
                                    status                  PKIStatusInfo,
                                    newSigCert          [0] CMPCertificate OPTIONAL,
                                    caCerts             [1] SEQUENCE SIZE (1..MAX) OF
                                                                      CMPCertificate OPTIONAL,
                                    keyPairHist         [2] SEQUENCE SIZE (1..MAX) OF
                                                                      CertifiedKeyPair OPTIONAL
                         }
            </pre> 
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.OobCertHash.ToAsn1Object">
            <pre>
            OobCertHash ::= SEQUENCE {
                                 hashAlg     [0] AlgorithmIdentifier     OPTIONAL,
                                 certId      [1] CertId                  OPTIONAL,
                                 hashVal         BIT STRING
                                 -- hashVal is calculated over the Der encoding of the
                                 -- self-signed certificate with the identifier certID.
                  }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PbmParameter.ToAsn1Object">
            <pre>
             PbmParameter ::= SEQUENCE {
                                   salt                OCTET STRING,
                                   -- note:  implementations MAY wish to limit acceptable sizes
                                   -- of this string to values appropriate for their environment
                                   -- in order to reduce the risk of denial-of-service attacks
                                   owf                 AlgorithmIdentifier,
                                   -- AlgId for a One-Way Function (SHA-1 recommended)
                                   iterationCount      INTEGER,
                                   -- number of times the OWF is applied
                                   -- note:  implementations MAY wish to limit acceptable sizes
                                   -- of this integer to values appropriate for their environment
                                   -- in order to reduce the risk of denial-of-service attacks
                                   mac                 AlgorithmIdentifier
                                   -- the MAC AlgId (e.g., DES-MAC, Triple-DES-MAC [PKCS11],
               }   -- or HMAC [RFC2104, RFC2202])
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiBody.#ctor(System.Int32,Org.BouncyCastle.Asn1.Asn1Encodable)">
            Creates a new PkiBody.
            @param type one of the TYPE_* constants
            @param content message content
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiBody.ToAsn1Object">
            <pre>
            PkiBody ::= CHOICE {       -- message-specific body elements
                   ir       [0]  CertReqMessages,        --Initialization Request
                   ip       [1]  CertRepMessage,         --Initialization Response
                   cr       [2]  CertReqMessages,        --Certification Request
                   cp       [3]  CertRepMessage,         --Certification Response
                   p10cr    [4]  CertificationRequest,   --imported from [PKCS10]
                   popdecc  [5]  POPODecKeyChallContent, --pop Challenge
                   popdecr  [6]  POPODecKeyRespContent,  --pop Response
                   kur      [7]  CertReqMessages,        --Key Update Request
                   kup      [8]  CertRepMessage,         --Key Update Response
                   krr      [9]  CertReqMessages,        --Key Recovery Request
                   krp      [10] KeyRecRepContent,       --Key Recovery Response
                   rr       [11] RevReqContent,          --Revocation Request
                   rp       [12] RevRepContent,          --Revocation Response
                   ccr      [13] CertReqMessages,        --Cross-Cert. Request
                   ccp      [14] CertRepMessage,         --Cross-Cert. Response
                   ckuann   [15] CAKeyUpdAnnContent,     --CA Key Update Ann.
                   cann     [16] CertAnnContent,         --Certificate Ann.
                   rann     [17] RevAnnContent,          --Revocation Ann.
                   crlann   [18] CRLAnnContent,          --CRL Announcement
                   pkiconf  [19] PKIConfirmContent,      --Confirmation
                   nested   [20] NestedMessageContent,   --Nested Message
                   genm     [21] GenMsgContent,          --General Message
                   genp     [22] GenRepContent,          --General Response
                   error    [23] ErrorMsgContent,        --Error Message
                   certConf [24] CertConfirmContent,     --Certificate confirm
                   pollReq  [25] PollReqContent,         --Polling request
                   pollRep  [26] PollRepContent          --Polling response
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiConfirmContent.ToAsn1Object">
            <pre>
            PkiConfirmContent ::= NULL
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Cmp.PkiFailureInfo">
            <pre>
            PKIFailureInfo ::= BIT STRING {
            badAlg               (0),
              -- unrecognized or unsupported Algorithm Identifier
            badMessageCheck      (1), -- integrity check failed (e.g., signature did not verify)
            badRequest           (2),
              -- transaction not permitted or supported
            badTime              (3), -- messageTime was not sufficiently close to the system time, as defined by local policy
            badCertId            (4), -- no certificate could be found matching the provided criteria
            badDataFormat        (5),
              -- the data submitted has the wrong format
            wrongAuthority       (6), -- the authority indicated in the request is different from the one creating the response token
            incorrectData        (7), -- the requester's data is incorrect (for notary services)
            missingTimeStamp     (8), -- when the timestamp is missing but should be there (by policy)
            badPOP               (9)  -- the proof-of-possession failed
            certRevoked         (10),
            certConfirmed       (11),
            wrongIntegrity      (12),
            badRecipientNonce   (13), 
            timeNotAvailable    (14),
              -- the TSA's time source is not available
            unacceptedPolicy    (15),
              -- the requested TSA policy is not supported by the TSA
            unacceptedExtension (16),
              -- the requested extension is not supported by the TSA
            addInfoNotAvailable (17)
              -- the additional information requested could not be understood
              -- or is not available
            badSenderNonce      (18),
            badCertTemplate     (19),
            signerNotTrusted    (20),
            transactionIdInUse  (21),
            unsupportedVersion  (22),
            notAuthorized       (23),
            systemUnavail       (24),    
            systemFailure       (25),
              -- the request cannot be handled due to system failure
            duplicateCertReq    (26) 
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiFailureInfo.#ctor(System.Int32)">
            Basic constructor.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiFreeText.ToAsn1Object">
            <pre>
            PkiFreeText ::= SEQUENCE SIZE (1..MAX) OF UTF8String
            </pre>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Cmp.PkiFreeText.Size">
             Return the number of string elements present.
            
             @return number of elements present.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Cmp.PkiFreeText.Item(System.Int32)">
             Return the UTF8STRING at index.
            
             @param index index of the string of interest
             @return the string at index.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Cmp.PkiHeader.NULL_NAME">
            Value for a "null" recipient or sender.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiHeader.ToAsn1Object">
            <pre>
             PkiHeader ::= SEQUENCE {
                       pvno                INTEGER     { cmp1999(1), cmp2000(2) },
                       sender              GeneralName,
                       -- identifies the sender
                       recipient           GeneralName,
                       -- identifies the intended recipient
                       messageTime     [0] GeneralizedTime         OPTIONAL,
                       -- time of production of this message (used when sender
                       -- believes that the transport will be "suitable"; i.e.,
                       -- that the time will still be meaningful upon receipt)
                       protectionAlg   [1] AlgorithmIdentifier     OPTIONAL,
                       -- algorithm used for calculation of protection bits
                       senderKID       [2] KeyIdentifier           OPTIONAL,
                       recipKID        [3] KeyIdentifier           OPTIONAL,
                       -- to identify specific keys used for protection
                       transactionID   [4] OCTET STRING            OPTIONAL,
                       -- identifies the transaction; i.e., this will be the same in
                       -- corresponding request, response, certConf, and PKIConf
                       -- messages
                       senderNonce     [5] OCTET STRING            OPTIONAL,
                       recipNonce      [6] OCTET STRING            OPTIONAL,
                       -- nonces used to provide replay protection, senderNonce
                       -- is inserted by the creator of this message; recipNonce
                       -- is a nonce previously inserted in a related message by
                       -- the intended recipient of this message
                       freeText        [7] PKIFreeText             OPTIONAL,
                       -- this may be used to indicate context-specific instructions
                       -- (this field is intended for human consumption)
                       generalInfo     [8] SEQUENCE SIZE (1..MAX) OF
                                            InfoTypeAndValue     OPTIONAL
                       -- this may be used to convey context-specific information
                       -- (this field not primarily intended for human consumption)
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiHeaderBuilder.Build">
            <pre>
             PKIHeader ::= SEQUENCE {
                       pvno                INTEGER     { cmp1999(1), cmp2000(2) },
                       sender              GeneralName,
                       -- identifies the sender
                       recipient           GeneralName,
                       -- identifies the intended recipient
                       messageTime     [0] GeneralizedTime         OPTIONAL,
                       -- time of production of this message (used when sender
                       -- believes that the transport will be "suitable"; i.e.,
                       -- that the time will still be meaningful upon receipt)
                       protectionAlg   [1] AlgorithmIdentifier     OPTIONAL,
                       -- algorithm used for calculation of protection bits
                       senderKID       [2] KeyIdentifier           OPTIONAL,
                       recipKID        [3] KeyIdentifier           OPTIONAL,
                       -- to identify specific keys used for protection
                       transactionID   [4] OCTET STRING            OPTIONAL,
                       -- identifies the transaction; i.e., this will be the same in
                       -- corresponding request, response, certConf, and PKIConf
                       -- messages
                       senderNonce     [5] OCTET STRING            OPTIONAL,
                       recipNonce      [6] OCTET STRING            OPTIONAL,
                       -- nonces used to provide replay protection, senderNonce
                       -- is inserted by the creator of this message; recipNonce
                       -- is a nonce previously inserted in a related message by
                       -- the intended recipient of this message
                       freeText        [7] PKIFreeText             OPTIONAL,
                       -- this may be used to indicate context-specific instructions
                       -- (this field is intended for human consumption)
                       generalInfo     [8] SEQUENCE SIZE (1..MAX) OF
                                            InfoTypeAndValue     OPTIONAL
                       -- this may be used to convey context-specific information
                       -- (this field not primarily intended for human consumption)
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiMessage.#ctor(Org.BouncyCastle.Asn1.Cmp.PkiHeader,Org.BouncyCastle.Asn1.Cmp.PkiBody,Org.BouncyCastle.Asn1.DerBitString,Org.BouncyCastle.Asn1.Cmp.CmpCertificate[])">
             Creates a new PkiMessage.
            
             @param header message header
             @param body message body
             @param protection message protection (may be null)
             @param extraCerts extra certificates (may be null)
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiMessage.ToAsn1Object">
            <pre>
            PkiMessage ::= SEQUENCE {
                             header           PKIHeader,
                             body             PKIBody,
                             protection   [0] PKIProtection OPTIONAL,
                             extraCerts   [1] SEQUENCE SIZE (1..MAX) OF CMPCertificate
                                                                                OPTIONAL
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiMessages.ToAsn1Object">
            <pre>
            PkiMessages ::= SEQUENCE SIZE (1..MAX) OF PkiMessage
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiStatusInfo.#ctor(System.Int32)">
            @param status
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiStatusInfo.#ctor(System.Int32,Org.BouncyCastle.Asn1.Cmp.PkiFreeText)">
            @param status
            @param statusString
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PkiStatusInfo.ToAsn1Object">
             <pre>
             PkiStatusInfo ::= SEQUENCE {
                 status        PKIStatus,                (INTEGER)
                 statusString  PkiFreeText     OPTIONAL,
                 failInfo      PkiFailureInfo  OPTIONAL  (BIT STRING)
             }
            
             PKIStatus:
               granted                (0), -- you got exactly what you asked for
               grantedWithMods        (1), -- you got something like what you asked for
               rejection              (2), -- you don't get it, more information elsewhere in the message
               waiting                (3), -- the request body part has not yet been processed, expect to hear more later
               revocationWarning      (4), -- this message contains a warning that a revocation is imminent
               revocationNotification (5), -- notification that a revocation has occurred
               keyUpdateWarning       (6)  -- update already done for the oldCertId specified in CertReqMsg
            
             PkiFailureInfo:
               badAlg           (0), -- unrecognized or unsupported Algorithm Identifier
               badMessageCheck  (1), -- integrity check failed (e.g., signature did not verify)
               badRequest       (2), -- transaction not permitted or supported
               badTime          (3), -- messageTime was not sufficiently close to the system time, as defined by local policy
               badCertId        (4), -- no certificate could be found matching the provided criteria
               badDataFormat    (5), -- the data submitted has the wrong format
               wrongAuthority   (6), -- the authority indicated in the request is different from the one creating the response token
               incorrectData    (7), -- the requester's data is incorrect (for notary services)
               missingTimeStamp (8), -- when the timestamp is missing but should be there (by policy)
               badPOP           (9)  -- the proof-of-possession failed
            
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PollRepContent.ToAsn1Object">
            <pre>
            PollRepContent ::= SEQUENCE OF SEQUENCE {
                    certReqId              INTEGER,
                    checkAfter             INTEGER,  -- time in seconds
                    reason                 PKIFreeText OPTIONAL
                }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PollReqContent.ToAsn1Object">
            <pre>
            PollReqContent ::= SEQUENCE OF SEQUENCE {
                                   certReqId              INTEGER
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PopoDecKeyChallContent.ToAsn1Object">
            <pre>
            PopoDecKeyChallContent ::= SEQUENCE OF Challenge
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.PopoDecKeyRespContent.ToAsn1Object">
            <pre>
            PopoDecKeyRespContent ::= SEQUENCE OF INTEGER
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.ProtectedPart.ToAsn1Object">
            <pre>
            ProtectedPart ::= SEQUENCE {
                               header    PKIHeader,
                               body      PKIBody
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.RevAnnContent.ToAsn1Object">
            <pre>
            RevAnnContent ::= SEQUENCE {
                  status              PKIStatus,
                  certId              CertId,
                  willBeRevokedAt     GeneralizedTime,
                  badSinceDate        GeneralizedTime,
                  crlDetails          Extensions  OPTIONAL
                   -- extra CRL details (e.g., crl number, reason, location, etc.)
            }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.RevDetails.ToAsn1Object">
            <pre>
            RevDetails ::= SEQUENCE {
                             certDetails         CertTemplate,
                              -- allows requester to specify as much as they can about
                              -- the cert. for which revocation is requested
                              -- (e.g., for cases in which serialNumber is not available)
                              crlEntryDetails     Extensions       OPTIONAL
                              -- requested crlEntryExtensions
                        }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.RevRepContent.ToAsn1Object">
            <pre>
            RevRepContent ::= SEQUENCE {
                   status       SEQUENCE SIZE (1..MAX) OF PKIStatusInfo,
                   -- in same order as was sent in RevReqContent
                   revCerts [0] SEQUENCE SIZE (1..MAX) OF CertId OPTIONAL,
                   -- IDs for which revocation was requested
                   -- (same order as status)
                   crls     [1] SEQUENCE SIZE (1..MAX) OF CertificateList OPTIONAL
                   -- the resulting CRLs (there may be more than one)
              }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.RevReqContent.ToAsn1Object">
            <pre>
            RevReqContent ::= SEQUENCE OF RevDetails
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.Attribute.GetInstance(System.Object)">
             return an Attribute object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.Attribute.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Attribute ::= SEQUENCE {
                attrType OBJECT IDENTIFIER,
                attrValues SET OF AttributeValue
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.Attributes.ToAsn1Object">
            <pre>
            Attributes ::=
              SET SIZE(1..MAX) OF Attribute -- according to RFC 5652
            </pre>
            @return
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.AttributeTable.GetAll(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             Return all the attributes matching the OBJECT IDENTIFIER oid. The vector will be
             empty if there are no attributes of the required type present.
            
             @param oid type of attribute required.
             @return a vector of all the attributes found of type oid.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.AttributeTable.Add(Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Asn1.Asn1Encodable)">
             Return a new table with the passed in attribute added.
            
             @param attrType
             @param attrValue
             @return
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Cms.AttributeTable.Item(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>Return the first attribute matching the given OBJECT IDENTIFIER</summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.AuthenticatedData.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an AuthenticatedData object from a tagged object.
            
             @param obj      the tagged object holding the object we want.
             @param isExplicit true if the object is meant to be explicitly
                             tagged false otherwise.
             @throws ArgumentException if the object held by the
                                              tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.AuthenticatedData.GetInstance(System.Object)">
             return an AuthenticatedData object from the given object.
            
             @param obj the object we want converted.
             @throws ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.AuthenticatedData.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
             AuthenticatedData ::= SEQUENCE {
                   version CMSVersion,
                   originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,
                   recipientInfos RecipientInfos,
                   macAlgorithm MessageAuthenticationCodeAlgorithm,
                   digestAlgorithm [1] DigestAlgorithmIdentifier OPTIONAL,
                   encapContentInfo EncapsulatedContentInfo,
                   authAttrs [2] IMPLICIT AuthAttributes OPTIONAL,
                   mac MessageAuthenticationCode,
                   unauthAttrs [3] IMPLICIT UnauthAttributes OPTIONAL }
            
             AuthAttributes ::= SET SIZE (1..MAX) OF Attribute
            
             UnauthAttributes ::= SET SIZE (1..MAX) OF Attribute
            
             MessageAuthenticationCode ::= OCTET STRING
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Cms.AuthenticatedDataParser">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
             AuthenticatedData ::= SEQUENCE {
                   version CMSVersion,
                   originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,
                   recipientInfos RecipientInfos,
                   macAlgorithm MessageAuthenticationCodeAlgorithm,
                   digestAlgorithm [1] DigestAlgorithmIdentifier OPTIONAL,
                   encapContentInfo EncapsulatedContentInfo,
                   authAttrs [2] IMPLICIT AuthAttributes OPTIONAL,
                   mac MessageAuthenticationCode,
                   unauthAttrs [3] IMPLICIT UnauthAttributes OPTIONAL }
            
             AuthAttributes ::= SET SIZE (1..MAX) OF Attribute
            
             UnauthAttributes ::= SET SIZE (1..MAX) OF Attribute
            
             MessageAuthenticationCode ::= OCTET STRING
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.AuthEnvelopedData.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an AuthEnvelopedData object from a tagged object.
            
             @param obj      the tagged object holding the object we want.
             @param isExplicit true if the object is meant to be explicitly
                             tagged false otherwise.
             @throws ArgumentException if the object held by the
                                              tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.AuthEnvelopedData.GetInstance(System.Object)">
             return an AuthEnvelopedData object from the given object.
            
             @param obj the object we want converted.
             @throws ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.AuthEnvelopedData.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            AuthEnvelopedData ::= SEQUENCE {
              version CMSVersion,
              originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,
              recipientInfos RecipientInfos,
              authEncryptedContentInfo EncryptedContentInfo,
              authAttrs [1] IMPLICIT AuthAttributes OPTIONAL,
              mac MessageAuthenticationCode,
              unauthAttrs [2] IMPLICIT UnauthAttributes OPTIONAL }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Cms.AuthEnvelopedDataParser">
            Produce an object suitable for an Asn1OutputStream.
            
            <pre>
            AuthEnvelopedData ::= SEQUENCE {
              version CMSVersion,
              originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,
              recipientInfos RecipientInfos,
              authEncryptedContentInfo EncryptedContentInfo,
              authAttrs [1] IMPLICIT AuthAttributes OPTIONAL,
              mac MessageAuthenticationCode,
              unauthAttrs [2] IMPLICIT UnauthAttributes OPTIONAL }
            </pre>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Cms.CmsObjectIdentifiers.id_ri">
            The other Revocation Info arc
            id-ri OBJECT IDENTIFIER ::= { iso(1) identified-organization(3)
                                              dod(6) internet(1) security(5) mechanisms(5) pkix(7) ri(16) }
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Cms.CompressedData">
            RFC 3274 - CMS Compressed Data.
            <pre>
            CompressedData ::= Sequence {
             version CMSVersion,
             compressionAlgorithm CompressionAlgorithmIdentifier,
             encapContentInfo EncapsulatedContentInfo
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.CompressedData.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a CompressedData object from a tagged object.
            
             @param ato the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.CompressedData.GetInstance(System.Object)">
             return a CompressedData object from the given object.
            
             @param _obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Cms.CompressedDataParser">
            RFC 3274 - CMS Compressed Data.
            <pre>
            CompressedData ::= SEQUENCE {
             version CMSVersion,
             compressionAlgorithm CompressionAlgorithmIdentifier,
             encapContentInfo EncapsulatedContentInfo
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.ContentInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            ContentInfo ::= Sequence {
                     contentType ContentType,
                     content
                     [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Cms.ContentInfoParser">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            ContentInfo ::= SEQUENCE {
                     contentType ContentType,
                     content
                     [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.Ecc.MQVuserKeyingMaterial.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an AuthEnvelopedData object from a tagged object.
            
             @param obj      the tagged object holding the object we want.
             @param isExplicit true if the object is meant to be explicitly
                             tagged false otherwise.
             @throws ArgumentException if the object held by the
                                              tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.Ecc.MQVuserKeyingMaterial.GetInstance(System.Object)">
             return an AuthEnvelopedData object from the given object.
            
             @param obj the object we want converted.
             @throws ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.Ecc.MQVuserKeyingMaterial.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            MQVuserKeyingMaterial ::= SEQUENCE {
              ephemeralPublicKey OriginatorPublicKey,
              addedukm [0] EXPLICIT UserKeyingMaterial OPTIONAL  }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.EncryptedContentInfo.GetInstance(System.Object)">
             return an EncryptedContentInfo object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.EncryptedContentInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            EncryptedContentInfo ::= Sequence {
                contentType ContentType,
                contentEncryptionAlgorithm ContentEncryptionAlgorithmIdentifier,
                encryptedContent [0] IMPLICIT EncryptedContent OPTIONAL
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Cms.EncryptedContentInfoParser">
            <pre>
            EncryptedContentInfo ::= SEQUENCE {
                contentType ContentType,
                contentEncryptionAlgorithm ContentEncryptionAlgorithmIdentifier,
                encryptedContent [0] IMPLICIT EncryptedContent OPTIONAL
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.EncryptedData.ToAsn1Object">
            <pre>
                  EncryptedData ::= SEQUENCE {
                                version CMSVersion,
                                encryptedContentInfo EncryptedContentInfo,
                                unprotectedAttrs [1] IMPLICIT UnprotectedAttributes OPTIONAL }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.EnvelopedData.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an EnvelopedData object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.EnvelopedData.GetInstance(System.Object)">
             return an EnvelopedData object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.EnvelopedData.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            EnvelopedData ::= Sequence {
                version CMSVersion,
                originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,
                recipientInfos RecipientInfos,
                encryptedContentInfo EncryptedContentInfo,
                unprotectedAttrs [1] IMPLICIT UnprotectedAttributes OPTIONAL
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Cms.EnvelopedDataParser">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            EnvelopedData ::= SEQUENCE {
                version CMSVersion,
                originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,
                recipientInfos RecipientInfos,
                encryptedContentInfo EncryptedContentInfo,
                unprotectedAttrs [1] IMPLICIT UnprotectedAttributes OPTIONAL
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KekIdentifier.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a KekIdentifier object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KekIdentifier.GetInstance(System.Object)">
             return a KekIdentifier object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KekIdentifier.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            KekIdentifier ::= Sequence {
                keyIdentifier OCTET STRING,
                date GeneralizedTime OPTIONAL,
                other OtherKeyAttribute OPTIONAL
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KekRecipientInfo.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a KekRecipientInfo object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KekRecipientInfo.GetInstance(System.Object)">
             return a KekRecipientInfo object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KekRecipientInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            KekRecipientInfo ::= Sequence {
                version CMSVersion,  -- always set to 4
                kekID KekIdentifier,
                keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
                encryptedKey EncryptedKey
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientIdentifier.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an KeyAgreeRecipientIdentifier object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param isExplicit true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientIdentifier.GetInstance(System.Object)">
             return an KeyAgreeRecipientIdentifier object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientIdentifier.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            KeyAgreeRecipientIdentifier ::= CHOICE {
                issuerAndSerialNumber IssuerAndSerialNumber,
                rKeyId [0] IMPLICIT RecipientKeyIdentifier
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientInfo.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a KeyAgreeRecipientInfo object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientInfo.GetInstance(System.Object)">
             return a KeyAgreeRecipientInfo object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KeyAgreeRecipientInfo.ToAsn1Object">
                     * Produce an object suitable for an Asn1OutputStream.
                     * <pre>
                     * KeyAgreeRecipientInfo ::= Sequence {
                     *     version CMSVersion,  -- always set to 3
                     *     originator [0] EXPLICIT OriginatorIdentifierOrKey,
                     *     ukm [1] EXPLICIT UserKeyingMaterial OPTIONAL,
                     *     keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
                     *     recipientEncryptedKeys RecipientEncryptedKeys
                     * }
            		 *
            		 * UserKeyingMaterial ::= OCTET STRING
                     * </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KeyTransRecipientInfo.GetInstance(System.Object)">
             return a KeyTransRecipientInfo object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.KeyTransRecipientInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            KeyTransRecipientInfo ::= Sequence {
                version CMSVersion,  -- always set to 0 or 2
                rid RecipientIdentifier,
                keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
                encryptedKey EncryptedKey
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.MetaData.ToAsn1Object">
            <pre>
            MetaData ::= SEQUENCE {
              hashProtected        BOOLEAN,
              fileName             UTF8String OPTIONAL,
              mediaType            IA5String OPTIONAL,
              otherMetaData        Attributes OPTIONAL
            }
            </pre>
            @return
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OriginatorIdentifierOrKey.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an OriginatorIdentifierOrKey object from a tagged object.
            
             @param o the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OriginatorIdentifierOrKey.GetInstance(System.Object)">
             return an OriginatorIdentifierOrKey object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OriginatorIdentifierOrKey.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
             OriginatorIdentifierOrKey ::= CHOICE {
                 issuerAndSerialNumber IssuerAndSerialNumber,
                 subjectKeyIdentifier [0] SubjectKeyIdentifier,
                 originatorKey [1] OriginatorPublicKey
             }
            
             SubjectKeyIdentifier ::= OCTET STRING
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OriginatorInfo.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an OriginatorInfo object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OriginatorInfo.GetInstance(System.Object)">
             return an OriginatorInfo object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OriginatorInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            OriginatorInfo ::= Sequence {
                certs [0] IMPLICIT CertificateSet OPTIONAL,
                crls [1] IMPLICIT CertificateRevocationLists OPTIONAL
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OriginatorPublicKey.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an OriginatorPublicKey object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OriginatorPublicKey.GetInstance(System.Object)">
             return an OriginatorPublicKey object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OriginatorPublicKey.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            OriginatorPublicKey ::= Sequence {
                algorithm AlgorithmIdentifier,
                publicKey BIT STRING
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OtherKeyAttribute.GetInstance(System.Object)">
             return an OtherKeyAttribute object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OtherKeyAttribute.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            OtherKeyAttribute ::= Sequence {
                keyAttrId OBJECT IDENTIFIER,
                keyAttr ANY DEFINED BY keyAttrId OPTIONAL
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OtherRecipientInfo.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a OtherRecipientInfo object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OtherRecipientInfo.GetInstance(System.Object)">
             return a OtherRecipientInfo object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OtherRecipientInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            OtherRecipientInfo ::= Sequence {
               oriType OBJECT IDENTIFIER,
               oriValue ANY DEFINED BY oriType }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OtherRevocationInfoFormat.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a OtherRevocationInfoFormat object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicit true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception IllegalArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OtherRevocationInfoFormat.GetInstance(System.Object)">
             return a OtherRevocationInfoFormat object from the given object.
            
             @param obj the object we want converted.
             @exception IllegalArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.OtherRevocationInfoFormat.ToAsn1Object">
            Produce an object suitable for an ASN1OutputStream.
            <pre>
            OtherRevocationInfoFormat ::= SEQUENCE {
                 otherRevInfoFormat OBJECT IDENTIFIER,
                 otherRevInfo ANY DEFINED BY otherRevInfoFormat }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.PasswordRecipientInfo.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a PasswordRecipientInfo object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.PasswordRecipientInfo.GetInstance(System.Object)">
             return a PasswordRecipientInfo object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.PasswordRecipientInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            PasswordRecipientInfo ::= Sequence {
              version CMSVersion,   -- Always set to 0
              keyDerivationAlgorithm [0] KeyDerivationAlgorithmIdentifier
                                        OPTIONAL,
             keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
             encryptedKey EncryptedKey }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientEncryptedKey.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an RecipientEncryptedKey object from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param isExplicit true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientEncryptedKey.GetInstance(System.Object)">
             return a RecipientEncryptedKey object from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientEncryptedKey.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            RecipientEncryptedKey ::= SEQUENCE {
                rid KeyAgreeRecipientIdentifier,
                encryptedKey EncryptedKey
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientIdentifier.GetInstance(System.Object)">
             return a RecipientIdentifier object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientIdentifier.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
             RecipientIdentifier ::= CHOICE {
                 issuerAndSerialNumber IssuerAndSerialNumber,
                 subjectKeyIdentifier [0] SubjectKeyIdentifier
             }
            
             SubjectKeyIdentifier ::= OCTET STRING
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            RecipientInfo ::= CHOICE {
                ktri KeyTransRecipientInfo,
                kari [1] KeyAgreeRecipientInfo,
                kekri [2] KekRecipientInfo,
                pwri [3] PasswordRecipientInfo,
                ori [4] OtherRecipientInfo }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientKeyIdentifier.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a RecipientKeyIdentifier object from a tagged object.
            
             @param _ato the tagged object holding the object we want.
             @param _explicit true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the object held by the
                      tagged object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientKeyIdentifier.GetInstance(System.Object)">
             return a RecipientKeyIdentifier object from the given object.
            
             @param _obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.RecipientKeyIdentifier.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
             RecipientKeyIdentifier ::= Sequence {
                 subjectKeyIdentifier SubjectKeyIdentifier,
                 date GeneralizedTime OPTIONAL,
                 other OtherKeyAttribute OPTIONAL
             }
            
             SubjectKeyIdentifier ::= OCTET STRING
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.ScvpReqRes.ToAsn1Object">
            <pre>
               ScvpReqRes ::= SEQUENCE {
               request  [0] EXPLICIT ContentInfo OPTIONAL,
               response     ContentInfo }
            </pre>
            @return  the ASN.1 primitive representation.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Cms.SignedData">
            a signed data object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.SignedData.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            SignedData ::= Sequence {
                version CMSVersion,
                digestAlgorithms DigestAlgorithmIdentifiers,
                encapContentInfo EncapsulatedContentInfo,
                certificates [0] IMPLICIT CertificateSet OPTIONAL,
                crls [1] IMPLICIT CertificateRevocationLists OPTIONAL,
                signerInfos SignerInfos
              }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Cms.SignedDataParser">
            <pre>
            SignedData ::= SEQUENCE {
                version CMSVersion,
                digestAlgorithms DigestAlgorithmIdentifiers,
                encapContentInfo EncapsulatedContentInfo,
                certificates [0] IMPLICIT CertificateSet OPTIONAL,
                crls [1] IMPLICIT CertificateRevocationLists OPTIONAL,
                signerInfos SignerInfos
              }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.SignerIdentifier.GetInstance(System.Object)">
             return a SignerIdentifier object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.SignerIdentifier.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
             SignerIdentifier ::= CHOICE {
                 issuerAndSerialNumber IssuerAndSerialNumber,
                 subjectKeyIdentifier [0] SubjectKeyIdentifier
             }
            
             SubjectKeyIdentifier ::= OCTET STRING
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.SignerInfo.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
              SignerInfo ::= Sequence {
                  version Version,
                  SignerIdentifier sid,
                  digestAlgorithm DigestAlgorithmIdentifier,
                  authenticatedAttributes [0] IMPLICIT Attributes OPTIONAL,
                  digestEncryptionAlgorithm DigestEncryptionAlgorithmIdentifier,
                  encryptedDigest EncryptedDigest,
                  unauthenticatedAttributes [1] IMPLICIT Attributes OPTIONAL
              }
            
              EncryptedDigest ::= OCTET STRING
            
              DigestAlgorithmIdentifier ::= AlgorithmIdentifier
            
              DigestEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.Time.#ctor(System.DateTime)">
            creates a time object from a given date - if the date is between 1950
            and 2049 a UTCTime object is Generated, otherwise a GeneralizedTime
            is used.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.Time.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Time ::= CHOICE {
                        utcTime        UTCTime,
                        generalTime    GeneralizedTime }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.TimeStampAndCrl.ToAsn1Object">
            <pre>
            TimeStampAndCRL ::= SEQUENCE {
                timeStamp   TimeStampToken,          -- according to RFC 3161
                crl         CertificateList OPTIONAL -- according to RFC 5280
             }
            </pre>
            @return
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.TimeStampedData.ToAsn1Object">
            <pre>
            TimeStampedData ::= SEQUENCE {
              version              INTEGER { v1(1) },
              dataUri              IA5String OPTIONAL,
              metaData             MetaData OPTIONAL,
              content              OCTET STRING OPTIONAL,
              temporalEvidence     Evidence
            }
            </pre>
            @return
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cms.TimeStampTokenEvidence.ToAsn1Object">
            <pre>
            TimeStampTokenEvidence ::=
               SEQUENCE SIZE(1..MAX) OF TimeStampAndCrl
            </pre>
            @return
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.AttributeTypeAndValue.ToAsn1Object">
            <pre>
            AttributeTypeAndValue ::= SEQUENCE {
                      type         OBJECT IDENTIFIER,
                      value        ANY DEFINED BY type }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.CertId.ToAsn1Object">
            <pre>
            CertId ::= SEQUENCE {
                            issuer           GeneralName,
                            serialNumber     INTEGER }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.CertReqMessages.ToAsn1Object">
            <pre>
            CertReqMessages ::= SEQUENCE SIZE (1..MAX) OF CertReqMsg
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.CertReqMsg.#ctor(Org.BouncyCastle.Asn1.Crmf.CertRequest,Org.BouncyCastle.Asn1.Crmf.ProofOfPossession,Org.BouncyCastle.Asn1.Crmf.AttributeTypeAndValue[])">
            Creates a new CertReqMsg.
            @param certReq CertRequest
            @param popo may be null
            @param regInfo may be null
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.CertReqMsg.ToAsn1Object">
            <pre>
            CertReqMsg ::= SEQUENCE {
                               certReq   CertRequest,
                               pop       ProofOfPossession  OPTIONAL,
                               -- content depends upon key type
                               regInfo   SEQUENCE SIZE(1..MAX) OF AttributeTypeAndValue OPTIONAL }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.CertRequest.ToAsn1Object">
            <pre>
            CertRequest ::= SEQUENCE {
                                 certReqId     INTEGER,          -- ID for matching request and reply
                                 certTemplate  CertTemplate,  -- Selected fields of cert to be issued
                                 controls      Controls OPTIONAL }   -- Attributes affecting issuance
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.CertTemplate.ToAsn1Object">
            <pre>
             CertTemplate ::= SEQUENCE {
                 version      [0] Version               OPTIONAL,
                 serialNumber [1] INTEGER               OPTIONAL,
                 signingAlg   [2] AlgorithmIdentifier   OPTIONAL,
                 issuer       [3] Name                  OPTIONAL,
                 validity     [4] OptionalValidity      OPTIONAL,
                 subject      [5] Name                  OPTIONAL,
                 publicKey    [6] SubjectPublicKeyInfo  OPTIONAL,
                 issuerUID    [7] UniqueIdentifier      OPTIONAL,
                 subjectUID   [8] UniqueIdentifier      OPTIONAL,
                 extensions   [9] Extensions            OPTIONAL }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.CertTemplateBuilder.SetVersion(System.Int32)">
            Sets the X.509 version. Note: for X509v3, use 2 here. 
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.CertTemplateBuilder.SetIssuerUID(Org.BouncyCastle.Asn1.DerBitString)">
            Sets the issuer unique ID (deprecated in X.509v3) 
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.CertTemplateBuilder.SetSubjectUID(Org.BouncyCastle.Asn1.DerBitString)">
            Sets the subject unique ID (deprecated in X.509v3) 
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.CertTemplateBuilder.Build">
            <pre>
             CertTemplate ::= SEQUENCE {
                 version      [0] Version               OPTIONAL,
                 serialNumber [1] INTEGER               OPTIONAL,
                 signingAlg   [2] AlgorithmIdentifier   OPTIONAL,
                 issuer       [3] Name                  OPTIONAL,
                 validity     [4] OptionalValidity      OPTIONAL,
                 subject      [5] Name                  OPTIONAL,
                 publicKey    [6] SubjectPublicKeyInfo  OPTIONAL,
                 issuerUID    [7] UniqueIdentifier      OPTIONAL,
                 subjectUID   [8] UniqueIdentifier      OPTIONAL,
                 extensions   [9] Extensions            OPTIONAL }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.Controls.ToAsn1Object">
            <pre>
            Controls  ::= SEQUENCE SIZE(1..MAX) OF AttributeTypeAndValue
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.EncKeyWithID.ToAsn1Object">
            <pre>
            EncKeyWithID ::= SEQUENCE {
                 privateKey           PrivateKeyInfo,
                 identifier CHOICE {
                    string               UTF8String,
                    generalName          GeneralName
                } OPTIONAL
            }
            </pre>
            @return
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.EncryptedKey.ToAsn1Object">
            <pre>
               EncryptedKey ::= CHOICE {
                   encryptedValue        EncryptedValue, -- deprecated
                   envelopedData     [0] EnvelopedData }
                   -- The encrypted private key MUST be placed in the envelopedData
                   -- encryptedContentInfo encryptedContent OCTET STRING.
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.EncryptedValue.ToAsn1Object">
            <pre>
            EncryptedValue ::= SEQUENCE {
                                intendedAlg   [0] AlgorithmIdentifier  OPTIONAL,
                                -- the intended algorithm for which the value will be used
                                symmAlg       [1] AlgorithmIdentifier  OPTIONAL,
                                -- the symmetric algorithm used to encrypt the value
                                encSymmKey    [2] BIT STRING           OPTIONAL,
                                -- the (encrypted) symmetric key used to encrypt the value
                                keyAlg        [3] AlgorithmIdentifier  OPTIONAL,
                                -- algorithm used to encrypt the symmetric key
                                valueHint     [4] OCTET STRING         OPTIONAL,
                                -- a brief description or identifier of the encValue content
                                -- (may be meaningful only to the sending entity, and used only
                                -- if EncryptedValue might be re-examined by the sending entity
                                -- in the future)
                                encValue       BIT STRING }
                                -- the encrypted value itself
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.OptionalValidity.ToAsn1Object">
            <pre>
            OptionalValidity ::= SEQUENCE {
                                   notBefore  [0] Time OPTIONAL,
                                   notAfter   [1] Time OPTIONAL } --at least one MUST be present
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.PkiArchiveOptions.ToAsn1Object">
            <pre>
             PkiArchiveOptions ::= CHOICE {
                 encryptedPrivKey     [0] EncryptedKey,
                 -- the actual value of the private key
                 keyGenParameters     [1] KeyGenParameters,
                 -- parameters which allow the private key to be re-generated
                 archiveRemGenPrivKey [2] BOOLEAN }
                 -- set to TRUE if sender wishes receiver to archive the private
                 -- key of a key pair that the receiver generates in response to
                 -- this request; set to FALSE if no archival is desired.
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.PkiPublicationInfo.ToAsn1Object">
            <pre>
            PkiPublicationInfo ::= SEQUENCE {
                             action     INTEGER {
                                            dontPublish (0),
                                            pleasePublish (1) },
                             pubInfos  SEQUENCE SIZE (1..MAX) OF SinglePubInfo OPTIONAL }
            -- pubInfos MUST NOT be present if action is "dontPublish"
            -- (if action is "pleasePublish" and pubInfos is omitted,
            -- "dontCare" is assumed)
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Crmf.PKMacValue">
            Password-based MAC value for use with POPOSigningKeyInput.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.PKMacValue.#ctor(Org.BouncyCastle.Asn1.Cmp.PbmParameter,Org.BouncyCastle.Asn1.DerBitString)">
            Creates a new PKMACValue.
            @param params parameters for password-based MAC
            @param value MAC of the DER-encoded SubjectPublicKeyInfo
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.PKMacValue.#ctor(Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier,Org.BouncyCastle.Asn1.DerBitString)">
            Creates a new PKMACValue.
            @param aid CMPObjectIdentifiers.passwordBasedMAC, with PBMParameter
            @param value MAC of the DER-encoded SubjectPublicKeyInfo
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.PKMacValue.ToAsn1Object">
            <pre>
            PKMACValue ::= SEQUENCE {
                 algId  AlgorithmIdentifier,
                 -- algorithm value shall be PasswordBasedMac 1.2.840.113533.7.66.13
                 -- parameter value is PBMParameter
                 value  BIT STRING }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.PopoPrivKey.ToAsn1Object">
            <pre>
            PopoPrivKey ::= CHOICE {
                   thisMessage       [0] BIT STRING,         -- Deprecated
                    -- possession is proven in this message (which contains the private
                    -- key itself (encrypted for the CA))
                   subsequentMessage [1] SubsequentMessage,
                    -- possession will be proven in a subsequent message
                   dhMAC             [2] BIT STRING,         -- Deprecated
                   agreeMAC          [3] PKMACValue,
                   encryptedKey      [4] EnvelopedData }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.PopoSigningKey.#ctor(Org.BouncyCastle.Asn1.Crmf.PopoSigningKeyInput,Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier,Org.BouncyCastle.Asn1.DerBitString)">
            Creates a new Proof of Possession object for a signing key.
            @param poposkIn the PopoSigningKeyInput structure, or null if the
                CertTemplate includes both subject and publicKey values.
            @param aid the AlgorithmIdentifier used to sign the proof of possession.
            @param signature a signature over the DER-encoded value of poposkIn,
                or the DER-encoded value of certReq if poposkIn is null.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.PopoSigningKey.ToAsn1Object">
            <pre>
            PopoSigningKey ::= SEQUENCE {
                                 poposkInput           [0] PopoSigningKeyInput OPTIONAL,
                                 algorithmIdentifier   AlgorithmIdentifier,
                                 signature             BIT STRING }
             -- The signature (using "algorithmIdentifier") is on the
             -- DER-encoded value of poposkInput.  NOTE: If the CertReqMsg
             -- certReq CertTemplate contains the subject and publicKey values,
             -- then poposkInput MUST be omitted and the signature MUST be
             -- computed on the DER-encoded value of CertReqMsg certReq.  If
             -- the CertReqMsg certReq CertTemplate does not contain the public
             -- key and subject values, then poposkInput MUST be present and
             -- MUST be signed.  This strategy ensures that the public key is
             -- not present in both the poposkInput and CertReqMsg certReq
             -- CertTemplate fields.
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.PopoSigningKeyInput.#ctor(Org.BouncyCastle.Asn1.X509.GeneralName,Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
            Creates a new PopoSigningKeyInput with sender name as authInfo. 
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.PopoSigningKeyInput.#ctor(Org.BouncyCastle.Asn1.Crmf.PKMacValue,Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
            Creates a new PopoSigningKeyInput using password-based MAC. 
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.PopoSigningKeyInput.ToAsn1Object">
            <pre>
            PopoSigningKeyInput ::= SEQUENCE {
                   authInfo             CHOICE {
                                            sender              [0] GeneralName,
                                            -- used only if an authenticated identity has been
                                            -- established for the sender (e.g., a DN from a
                                            -- previously-issued and currently-valid certificate
                                            publicKeyMac        PKMacValue },
                                            -- used if no authenticated GeneralName currently exists for
                                            -- the sender; publicKeyMac contains a password-based MAC
                                            -- on the DER-encoded value of publicKey
                   publicKey           SubjectPublicKeyInfo }  -- from CertTemplate
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Crmf.PopoSigningKeyInput.Sender">
            Returns the sender field, or null if authInfo is publicKeyMac 
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Crmf.PopoSigningKeyInput.PublicKeyMac">
            Returns the publicKeyMac field, or null if authInfo is sender 
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.ProofOfPossession.#ctor">
            Creates a ProofOfPossession with type raVerified. 
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.ProofOfPossession.#ctor(Org.BouncyCastle.Asn1.Crmf.PopoSigningKey)">
            Creates a ProofOfPossession for a signing key. 
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.ProofOfPossession.#ctor(System.Int32,Org.BouncyCastle.Asn1.Crmf.PopoPrivKey)">
            Creates a ProofOfPossession for key encipherment or agreement.
            @param type one of TYPE_KEY_ENCIPHERMENT or TYPE_KEY_AGREEMENT
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.ProofOfPossession.ToAsn1Object">
            <pre>
            ProofOfPossession ::= CHOICE {
                                      raVerified        [0] NULL,
                                      -- used if the RA has already verified that the requester is in
                                      -- possession of the private key
                                      signature         [1] PopoSigningKey,
                                      keyEncipherment   [2] PopoPrivKey,
                                      keyAgreement      [3] PopoPrivKey }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Crmf.SinglePubInfo.ToAsn1Object">
            <pre>
            SinglePubInfo ::= SEQUENCE {
                   pubMethod    INTEGER {
                      dontCare    (0),
                      x500        (1),
                      web         (2),
                      ldap        (3) },
                  pubLocation  GeneralName OPTIONAL }
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerInteger.GetInstance(System.Object)">
             return an integer from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerInteger.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an Integer from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param isExplicit true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.DerInteger.PositiveValue">
            in some cases positive values Get crammed into a space,
            that's not quite big enough...
        </member>
        <member name="T:Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves">
            table of the available named parameters for GOST 3410-2001.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the ECDomainParameters object for the given OID, null if it
             isn't present.
            
             @param oid an object identifier representing a named parameters, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves.GetName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            return the named curve name represented by the given object identifier.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves.Names">
            returns an enumeration containing the name strings for curves
            contained in this structure.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.CryptoPro.Gost28147Parameters.ToAsn1Object">
             <pre>
             Gost28147-89-Parameters ::=
                           SEQUENCE {
                                   iv                   Gost28147-89-IV,
                                   encryptionParamSet   OBJECT IDENTIFIER
                            }
            
               Gost28147-89-IV ::= OCTET STRING (SIZE (8))
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.CryptoPro.Gost3410NamedParameters">
            table of the available named parameters for GOST 3410-94.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.CryptoPro.Gost3410NamedParameters.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the GOST3410ParamSetParameters object for the given OID, null if it
             isn't present.
            
             @param oid an object identifier representing a named parameters, if present.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.CryptoPro.Gost3410NamedParameters.Names">
            returns an enumeration containing the name strings for parameters
            contained in this structure.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerBmpString">
            Der BMPString object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBmpString.GetInstance(System.Object)">
             return a BMP string from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBmpString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a BMP string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                          be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBmpString.#ctor(System.Byte[])">
            basic constructor - byte encoded string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBmpString.#ctor(System.String)">
            basic constructor
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBoolean.GetInstance(System.Object)">
             return a bool from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBoolean.GetInstance(System.Boolean)">
            return a DerBoolean from the passed in bool.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBoolean.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Boolean from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerEnumerated.GetInstance(System.Object)">
             return an integer from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerEnumerated.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an Enumerated from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerExternal">
            Class representing the DER-type External
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerExternal.#ctor(Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Asn1.DerInteger,Org.BouncyCastle.Asn1.Asn1Object,Org.BouncyCastle.Asn1.DerTaggedObject)">
            Creates a new instance of DerExternal
            See X.690 for more informations about the meaning of these parameters
            @param directReference The direct reference or <code>null</code> if not set.
            @param indirectReference The indirect reference or <code>null</code> if not set.
            @param dataValueDescriptor The data value descriptor or <code>null</code> if not set.
            @param externalData The external data in its encoded form.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerExternal.#ctor(Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Asn1.DerInteger,Org.BouncyCastle.Asn1.Asn1Object,System.Int32,Org.BouncyCastle.Asn1.Asn1Object)">
            Creates a new instance of DerExternal.
            See X.690 for more informations about the meaning of these parameters
            @param directReference The direct reference or <code>null</code> if not set.
            @param indirectReference The indirect reference or <code>null</code> if not set.
            @param dataValueDescriptor The data value descriptor or <code>null</code> if not set.
            @param encoding The encoding to be used for the external data
            @param externalData The external data
        </member>
        <member name="P:Org.BouncyCastle.Asn1.DerExternal.Encoding">
            The encoding of the content. Valid values are
            <ul>
            <li><code>0</code> single-ASN1-type</li>
            <li><code>1</code> OCTET STRING</li>
            <li><code>2</code> BIT STRING</li>
            </ul>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerGeneralizedTime">
            Generalized time object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerGeneralizedTime.GetInstance(System.Object)">
             return a generalized time from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerGeneralizedTime.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Generalized Time object from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerGeneralizedTime.#ctor(System.String)">
             The correct format for this is YYYYMMDDHHMMSS[.f]Z, or without the Z
             for local time, or Z+-HHMM on the end, for difference between local
             time and UTC time. The fractional second amount f must consist of at
             least one number with trailing zeroes removed.
            
             @param time the time string.
             @exception ArgumentException if string is an illegal format.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerGeneralizedTime.#ctor(System.DateTime)">
            base constructor from a local time object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerGeneralizedTime.GetTime">
            return the time - always in the form of
             YYYYMMDDhhmmssGMT(+hh:mm|-hh:mm).
            <p>
            Normally in a certificate we would expect "Z" rather than "GMT",
            however adding the "GMT" means we can just use:
            <pre>
                dateF = new SimpleDateFormat("yyyyMMddHHmmssz");
            </pre>
            To read in the time and Get a date which is compatible with our local
            time zone.</p>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.DerGeneralizedTime.TimeString">
            Return the time.
            @return The time string as it appeared in the encoded object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerGraphicString.GetInstance(System.Object)">
             return a Graphic String from the passed in object
            
             @param obj a DerGraphicString or an object that can be converted into one.
             @exception IllegalArgumentException if the object cannot be converted.
             @return a DerGraphicString instance, or null.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerGraphicString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Graphic String from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicit true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception IllegalArgumentException if the tagged object cannot
                           be converted.
             @return a DerGraphicString instance, or null.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerGraphicString.#ctor(System.Byte[])">
            basic constructor - with bytes.
            @param string the byte encoding of the characters making up the string.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerIA5String">
            Der IA5String object - this is an ascii string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerIA5String.GetInstance(System.Object)">
             return a IA5 string from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerIA5String.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an IA5 string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerIA5String.#ctor(System.Byte[])">
            basic constructor - with bytes.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerIA5String.#ctor(System.String)">
            basic constructor - without validation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerIA5String.#ctor(System.String,System.Boolean)">
             Constructor with optional validation.
            
             @param string the base string to wrap.
             @param validate whether or not to check the string.
             @throws ArgumentException if validate is true and the string
             contains characters that should not be in an IA5String.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerIA5String.IsIA5String(System.String)">
             return true if the passed in String can be represented without
             loss as an IA5String, false otherwise.
            
             @return true if in printable set, false otherwise.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerNumericString">
            Der NumericString object - this is an ascii string of characters {0,1,2,3,4,5,6,7,8,9, }.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerNumericString.GetInstance(System.Object)">
             return a Numeric string from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerNumericString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an Numeric string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerNumericString.#ctor(System.Byte[])">
            basic constructor - with bytes.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerNumericString.#ctor(System.String)">
            basic constructor -  without validation..
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerNumericString.#ctor(System.String,System.Boolean)">
             Constructor with optional validation.
            
             @param string the base string to wrap.
             @param validate whether or not to check the string.
             @throws ArgumentException if validate is true and the string
             contains characters that should not be in a NumericString.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerNumericString.IsNumericString(System.String)">
             Return true if the string can be represented as a NumericString ('0'..'9', ' ')
            
             @param str string to validate.
             @return true if numeric, fale otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerObjectIdentifier.GetInstance(System.Object)">
             return an Oid from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerObjectIdentifier.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an object Identifier from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerObjectIdentifier.On(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            Return  true if this oid is an extension of the passed in branch, stem.
            @param stem the arc or branch that is a possible parent.
            @return  true if the branch is on the passed in stem, false otherwise.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerPrintableString">
            Der PrintableString object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerPrintableString.GetInstance(System.Object)">
             return a printable string from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerPrintableString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Printable string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerPrintableString.#ctor(System.Byte[])">
            basic constructor - byte encoded string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerPrintableString.#ctor(System.String)">
            basic constructor - this does not validate the string
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerPrintableString.#ctor(System.String,System.Boolean)">
             Constructor with optional validation.
            
             @param string the base string to wrap.
             @param validate whether or not to check the string.
             @throws ArgumentException if validate is true and the string
             contains characters that should not be in a PrintableString.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerPrintableString.IsPrintableString(System.String)">
             return true if the passed in String can be represented without
             loss as a PrintableString, false otherwise.
            
             @return true if in printable set, false otherwise.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerT61String">
            Der T61String (also the teletex string) - 8-bit characters
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerT61String.GetInstance(System.Object)">
             return a T61 string from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerT61String.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an T61 string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerT61String.#ctor(System.Byte[])">
            basic constructor - with bytes.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerT61String.#ctor(System.String)">
            basic constructor - with string.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerUniversalString">
            Der UniversalString object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUniversalString.GetInstance(System.Object)">
             return a Universal string from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUniversalString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Universal string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUniversalString.#ctor(System.Byte[])">
            basic constructor - byte encoded string.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerUtcTime">
            UTC time object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtcTime.GetInstance(System.Object)">
             return an UTC Time from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtcTime.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an UTC Time from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtcTime.#ctor(System.String)">
            The correct format for this is YYMMDDHHMMSSZ (it used to be that seconds were
            never encoded. When you're creating one of these objects from scratch, that's
            what you want to use, otherwise we'll try to deal with whatever Gets read from
            the input stream... (this is why the input format is different from the GetTime()
            method output).
            <p>
            @param time the time string.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtcTime.#ctor(System.DateTime)">
            base constructor from a DateTime object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtcTime.ToDateTime">
             return the time as a date based on whatever a 2 digit year will return. For
             standardised processing use ToAdjustedDateTime().
            
             @return the resulting date
             @exception ParseException if the date string cannot be parsed.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtcTime.ToAdjustedDateTime">
             return the time as an adjusted date
             in the range of 1950 - 2049.
            
             @return a date in the range of 1950 to 2049.
             @exception ParseException if the date string cannot be parsed.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.DerUtcTime.TimeString">
            return the time - always in the form of
             YYMMDDhhmmssGMT(+hh:mm|-hh:mm).
            <p>
            Normally in a certificate we would expect "Z" rather than "GMT",
            however adding the "GMT" means we can just use:
            <pre>
                dateF = new SimpleDateFormat("yyMMddHHmmssz");
            </pre>
            To read in the time and Get a date which is compatible with our local
            time zone.</p>
            <p>
            <b>Note:</b> In some cases, due to the local date processing, this
            may lead to unexpected results. If you want to stick the normal
            convention of 1950 to 2049 use the GetAdjustedTime() method.</p>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.DerUtcTime.AdjustedTimeString">
            <summary>
            Return a time string as an adjusted date with a 4 digit year.
            This goes in the range of 1950 - 2049.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerUtf8String">
            Der UTF8String object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtf8String.GetInstance(System.Object)">
             return an UTF8 string from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtf8String.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an UTF8 string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtf8String.#ctor(System.Byte[])">
            basic constructor - byte encoded string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtf8String.#ctor(System.String)">
            basic constructor
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerVideotexString.GetInstance(System.Object)">
             return a Videotex String from the passed in object
            
             @param obj a DERVideotexString or an object that can be converted into one.
             @exception IllegalArgumentException if the object cannot be converted.
             @return a DERVideotexString instance, or null.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerVideotexString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Videotex String from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicit true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception IllegalArgumentException if the tagged object cannot
                           be converted.
             @return a DERVideotexString instance, or null.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerVideotexString.#ctor(System.Byte[])">
            basic constructor - with bytes.
            @param string the byte encoding of the characters making up the string.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerVisibleString">
            Der VisibleString object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerVisibleString.GetInstance(System.Object)">
             return a Visible string from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerVisibleString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Visible string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerVisibleString.#ctor(System.Byte[])">
            basic constructor - byte encoded string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerVisibleString.#ctor(System.String)">
            basic constructor
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.CertificateValues">
            <remarks>
            RFC 3126: 4.3.1 Certificate Values Attribute Definition
            <code>
            CertificateValues ::= SEQUENCE OF Certificate
            </code>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Esf.CommitmentTypeIndication.ToAsn1Object">
            <pre>
            CommitmentTypeIndication ::= SEQUENCE {
                 commitmentTypeId   CommitmentTypeIdentifier,
                 commitmentTypeQualifier   SEQUENCE SIZE (1..MAX) OF
                         CommitmentTypeQualifier OPTIONAL }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.CommitmentTypeQualifier">
             Commitment type qualifiers, used in the Commitment-Type-Indication attribute (RFC3126).
            
             <pre>
               CommitmentTypeQualifier ::= SEQUENCE {
                   commitmentTypeIdentifier  CommitmentTypeIdentifier,
                   qualifier          ANY DEFINED BY commitmentTypeIdentifier OPTIONAL }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Esf.CommitmentTypeQualifier.#ctor(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             Creates a new <code>CommitmentTypeQualifier</code> instance.
            
             @param commitmentTypeIdentifier a <code>CommitmentTypeIdentifier</code> value
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Esf.CommitmentTypeQualifier.#ctor(Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Asn1.Asn1Encodable)">
             Creates a new <code>CommitmentTypeQualifier</code> instance.
            
             @param commitmentTypeIdentifier a <code>CommitmentTypeIdentifier</code> value
             @param qualifier the qualifier, defined by the above field.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Esf.CommitmentTypeQualifier.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Creates a new <code>CommitmentTypeQualifier</code> instance.
            
             @param as <code>CommitmentTypeQualifier</code> structure
             encoded as an Asn1Sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Esf.CommitmentTypeQualifier.ToAsn1Object">
             Returns a DER-encodable representation of this instance.
            
             @return a <code>Asn1Object</code> value
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.CompleteCertificateRefs">
            <remarks>
            RFC 3126: 4.2.1 Complete Certificate Refs Attribute Definition
            <code>
            CompleteCertificateRefs ::= SEQUENCE OF OtherCertID
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.CompleteRevocationRefs">
            <remarks>
            RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
            <code>
            CompleteRevocationRefs ::= SEQUENCE OF CrlOcspRef
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.CrlIdentifier">
            <remarks>
            RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
            <code>
            CrlIdentifier ::= SEQUENCE 
            {
            	crlissuer		Name,
            	crlIssuedTime	UTCTime,
            	crlNumber		INTEGER OPTIONAL
            }
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.CrlListID">
            <remarks>
            RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
            <code>
            CRLListID ::= SEQUENCE 
            {
            	crls	SEQUENCE OF CrlValidatedID
            }
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.CrlOcspRef">
            <remarks>
            RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
            <code>
            CrlOcspRef ::= SEQUENCE {
            	crlids		[0] CRLListID		OPTIONAL,
            	ocspids		[1] OcspListID		OPTIONAL,
            	otherRev	[2] OtherRevRefs	OPTIONAL
            }
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.CrlValidatedID">
            <remarks>
            RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
            <code>
            CrlValidatedID ::= SEQUENCE {
            	crlHash			OtherHash,
            	crlIdentifier	CrlIdentifier OPTIONAL}
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.OcspIdentifier">
            <remarks>
            RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
            <code>
            OcspIdentifier ::= SEQUENCE {
            	ocspResponderID		ResponderID,
            		-- As in OCSP response data
            	producedAt			GeneralizedTime
            		-- As in OCSP response data
            }
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.OcspListID">
            <remarks>
            RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
            <code>
            OcspListID ::=  SEQUENCE {
            	ocspResponses	SEQUENCE OF OcspResponsesID
            }
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.OcspResponsesID">
            <remarks>
            RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
            <code>
            OcspResponsesID ::= SEQUENCE {
            	ocspIdentifier	OcspIdentifier,
            	ocspRepHash		OtherHash OPTIONAL
            }
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.OtherCertID">
            <remarks>
            <code>
            OtherCertID ::= SEQUENCE {
            	otherCertHash	OtherHash,
            	issuerSerial	IssuerSerial OPTIONAL
            }
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.OtherHash">
            <remarks>
            <code>
            OtherHash ::= CHOICE {
            	sha1Hash	OtherHashValue, -- This contains a SHA-1 hash
            	otherHash	OtherHashAlgAndValue
            }
            
            OtherHashValue ::= OCTET STRING
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.OtherHashAlgAndValue">
            <summary>
            Summary description for OtherHashAlgAndValue.
            </summary>
            <remarks>
            <code>
            OtherHashAlgAndValue ::= SEQUENCE {
            	hashAlgorithm	AlgorithmIdentifier,
            	hashValue		OtherHashValue
            }
            
            OtherHashValue ::= OCTET STRING
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.OtherRevRefs">
             <remarks>
             RFC 3126: 4.2.2 Complete Revocation Refs Attribute Definition
             <code>
             OtherRevRefs ::= SEQUENCE 
             {
            		otherRevRefType      OtherRevRefType,
            		otherRevRefs         ANY DEFINED BY otherRevRefType
             }
            
             OtherRevRefType ::= OBJECT IDENTIFIER
             </code>
             </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.OtherRevVals">
             <remarks>
             RFC 3126: 4.3.2 Revocation Values Attribute Definition
             <code>
             OtherRevVals ::= SEQUENCE 
             {
            		otherRevValType      OtherRevValType,
            		otherRevVals         ANY DEFINED BY otherRevValType
             }
            
             OtherRevValType ::= OBJECT IDENTIFIER
             </code>
             </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.OtherSigningCertificate">
            <remarks>
            <code>
            OtherSigningCertificate ::= SEQUENCE {
            	certs		SEQUENCE OF OtherCertID,
            	policies	SEQUENCE OF PolicyInformation OPTIONAL
            }
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.RevocationValues">
            <remarks>
            RFC 5126: 6.3.4.  revocation-values Attribute Definition
            <code>
            RevocationValues ::=  SEQUENCE {
            	crlVals			[0] SEQUENCE OF CertificateList     OPTIONAL,
            	ocspVals		[1] SEQUENCE OF BasicOCSPResponse   OPTIONAL,
            	otherRevVals	[2] OtherRevVals OPTIONAL
            }
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.SignaturePolicyId">
            <remarks>
            <code>
            SignaturePolicyId ::= SEQUENCE {
            	sigPolicyIdentifier		SigPolicyId,
            	sigPolicyHash			SigPolicyHash,
            	sigPolicyQualifiers		SEQUENCE SIZE (1..MAX) OF SigPolicyQualifierInfo OPTIONAL
            }
            
            SigPolicyId ::= OBJECT IDENTIFIER
            
            SigPolicyHash ::= OtherHashAlgAndValue
            </code>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.SignaturePolicyIdentifier">
            <remarks>
            <code>
            SignaturePolicyIdentifier ::= CHOICE {
            	SignaturePolicyId		SignaturePolicyId,
            	SignaturePolicyImplied	SignaturePolicyImplied
            }
            
            SignaturePolicyImplied ::= NULL
            </code>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Esf.SignerAttribute.ToAsn1Object">
            
             <pre>
              SignerAttribute ::= SEQUENCE OF CHOICE {
                  claimedAttributes   [0] ClaimedAttributes,
                  certifiedAttributes [1] CertifiedAttributes }
            
              ClaimedAttributes ::= SEQUENCE OF Attribute
              CertifiedAttributes ::= AttributeCertificate -- as defined in RFC 3281: see clause 4.1.
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.SignerLocation">
             Signer-Location attribute (RFC3126).
            
             <pre>
               SignerLocation ::= SEQUENCE {
                   countryName        [0] DirectoryString OPTIONAL,
                   localityName       [1] DirectoryString OPTIONAL,
                   postalAddress      [2] PostalAddress OPTIONAL }
            
               PostalAddress ::= SEQUENCE SIZE(1..6) OF DirectoryString
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Esf.SignerLocation.ToAsn1Object">
             <pre>
               SignerLocation ::= SEQUENCE {
                   countryName        [0] DirectoryString OPTIONAL,
                   localityName       [1] DirectoryString OPTIONAL,
                   postalAddress      [2] PostalAddress OPTIONAL }
            
               PostalAddress ::= SEQUENCE SIZE(1..6) OF DirectoryString
            
               DirectoryString ::= CHOICE {
                     teletexString           TeletexString (SIZE (1..MAX)),
                     printableString         PrintableString (SIZE (1..MAX)),
                     universalString         UniversalString (SIZE (1..MAX)),
                     utf8String              UTF8String (SIZE (1.. MAX)),
                     bmpString               BMPString (SIZE (1..MAX)) }
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Esf.SigPolicyQualifierInfo">
            <remarks>
            <code>
            SigPolicyQualifierInfo ::= SEQUENCE {
            	sigPolicyQualifierId  SigPolicyQualifierId,
            	sigQualifier          ANY DEFINED BY sigPolicyQualifierId
            }
            
            SigPolicyQualifierId ::= OBJECT IDENTIFIER
            </code>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.ContentHints.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
            constructor
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.ContentHints.ToAsn1Object">
            <pre>
            ContentHints ::= SEQUENCE {
              contentDescription UTF8String (SIZE (1..MAX)) OPTIONAL,
              contentType ContentType }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.ContentIdentifier.#ctor(Org.BouncyCastle.Asn1.Asn1OctetString)">
            Create from OCTET STRING whose octets represent the identifier.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.ContentIdentifier.#ctor(System.Byte[])">
            Create from byte array representing the identifier.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.ContentIdentifier.ToAsn1Object">
            The definition of ContentIdentifier is
            <pre>
            ContentIdentifier ::=  OCTET STRING
            </pre>
            id-aa-contentIdentifier OBJECT IDENTIFIER ::= { iso(1)
             member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs9(9)
             smime(16) id-aa(2) 7 }
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.EssCertID.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
            constructor
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.EssCertID.ToAsn1Object">
            <pre>
            EssCertID ::= SEQUENCE {
                certHash Hash,
                issuerSerial IssuerSerial OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.EssCertIDv2.ToAsn1Object">
             <pre>
             EssCertIDv2 ::=  SEQUENCE {
                 hashAlgorithm     AlgorithmIdentifier
                          DEFAULT {algorithm id-sha256},
                 certHash          Hash,
                 issuerSerial      IssuerSerial OPTIONAL
             }
            
             Hash ::= OCTET STRING
            
             IssuerSerial ::= SEQUENCE {
                 issuer         GeneralNames,
                 serialNumber   CertificateSerialNumber
             }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.OtherCertID.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
            constructor
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.OtherCertID.ToAsn1Object">
             <pre>
             OtherCertID ::= SEQUENCE {
                 otherCertHash    OtherHash,
                 issuerSerial     IssuerSerial OPTIONAL }
            
             OtherHash ::= CHOICE {
                 sha1Hash     OCTET STRING,
                 otherHash    OtherHashAlgAndValue }
            
             OtherHashAlgAndValue ::= SEQUENCE {
                 hashAlgorithm    AlgorithmIdentifier,
                 hashValue        OCTET STRING }
            
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.OtherSigningCertificate.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
            constructors
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.OtherSigningCertificate.ToAsn1Object">
            The definition of OtherSigningCertificate is
            <pre>
            OtherSigningCertificate ::=  SEQUENCE {
                 certs        SEQUENCE OF OtherCertID,
                 policies     SEQUENCE OF PolicyInformation OPTIONAL
            }
            </pre>
            id-aa-ets-otherSigCert OBJECT IDENTIFIER ::= { iso(1)
             member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs9(9)
             smime(16) id-aa(2) 19 }
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.SigningCertificate.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
            constructors
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.SigningCertificate.ToAsn1Object">
            The definition of SigningCertificate is
            <pre>
            SigningCertificate ::=  SEQUENCE {
                 certs        SEQUENCE OF EssCertID,
                 policies     SEQUENCE OF PolicyInformation OPTIONAL
            }
            </pre>
            id-aa-signingCertificate OBJECT IDENTIFIER ::= { iso(1)
             member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs9(9)
             smime(16) id-aa(2) 12 }
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ess.SigningCertificateV2.ToAsn1Object">
            The definition of SigningCertificateV2 is
            <pre>
            SigningCertificateV2 ::=  SEQUENCE {
                 certs        SEQUENCE OF EssCertIDv2,
                 policies     SEQUENCE OF PolicyInformation OPTIONAL
            }
            </pre>
            id-aa-signingCertificateV2 OBJECT IDENTIFIER ::= { iso(1)
               member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs9(9)
               smime(16) id-aa(2) 47 }
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Icao.CscaMasterList">
             The CscaMasterList object. This object can be wrapped in a
             CMSSignedData to be published in LDAP.
            
             <pre>
             CscaMasterList ::= SEQUENCE {
               version                CscaMasterListVersion,
               certList               SET OF Certificate }
               
             CscaMasterListVersion :: INTEGER {v0(0)}
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Icao.DataGroupHash">
             The DataGroupHash object.
             <pre>
             DataGroupHash  ::=  SEQUENCE {
                  dataGroupNumber         DataGroupNumber,
                  dataGroupHashValue     OCTET STRING }
            
             DataGroupNumber ::= INTEGER {
                     dataGroup1    (1),
                     dataGroup1    (2),
                     dataGroup1    (3),
                     dataGroup1    (4),
                     dataGroup1    (5),
                     dataGroup1    (6),
                     dataGroup1    (7),
                     dataGroup1    (8),
                     dataGroup1    (9),
                     dataGroup1    (10),
                     dataGroup1    (11),
                     dataGroup1    (12),
                     dataGroup1    (13),
                     dataGroup1    (14),
                     dataGroup1    (15),
                     dataGroup1    (16) }
            
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Icao.LdsSecurityObject">
             The LDSSecurityObject object (V1.8).
             <pre>
             LDSSecurityObject ::= SEQUENCE {
               version                LDSSecurityObjectVersion,
               hashAlgorithm          DigestAlgorithmIdentifier,
               dataGroupHashValues    SEQUENCE SIZE (2..ub-DataGroups) OF DataHashGroup,
               ldsVersionInfo         LDSVersionInfo OPTIONAL
                 -- if present, version MUST be v1 }
            
             DigestAlgorithmIdentifier ::= AlgorithmIdentifier,
            
             LDSSecurityObjectVersion :: INTEGER {V0(0)}
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Icao.LdsVersionInfo.ToAsn1Object">
            <pre>
            LDSVersionInfo ::= SEQUENCE {
               ldsVersion PRINTABLE STRING
               unicodeVersion PRINTABLE STRING
             }
            </pre>
            @return
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttCPAccredited">
            The id-isismtt-cp-accredited OID indicates that the certificate is a
            qualified certificate according to Directive 1999/93/EC of the European
            Parliament and of the Council of 13 December 1999 on a Community
            Framework for Electronic Signatures, which additionally conforms the
            special requirements of the SigG and has been issued by an accredited CA.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATDateOfCertGen">
             Certificate extensionDate of certificate generation
             
             <pre>
            		DateOfCertGenSyntax ::= GeneralizedTime
             </pre>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATProcuration">
            Attribute to indicate that the certificate holder may sign in the name of
            a third person. May also be used as extension in a certificate.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATAdmission">
            Attribute to indicate admissions to certain professions. May be used as
            attribute in attribute certificate or as extension in a certificate
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATMonetaryLimit">
            Monetary limit for transactions. The QcEuMonetaryLimit QC statement MUST
            be used in new certificates in place of the extension/attribute
            MonetaryLimit since January 1, 2004. For the sake of backward
            compatibility with certificates already in use, SigG conforming
            components MUST support MonetaryLimit (as well as QcEuLimitValue).
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATDeclarationOfMajority">
            A declaration of majority. May be used as attribute in attribute
            certificate or as extension in a certificate
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATIccsn">
             
             Serial number of the smart card containing the corresponding private key
             
             <pre>
            		ICCSNSyntax ::= OCTET STRING (SIZE(8..20))
             </pre>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATPKReference">
             
             Reference for a file of a smartcard that stores the public key of this
             certificate and that is used as �security anchor�.
             
             <pre>
            		PKReferenceSyntax ::= OCTET STRING (SIZE(20))
             </pre>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATRestriction">
             Some other restriction regarding the usage of this certificate. May be
             used as attribute in attribute certificate or as extension in a
             certificate.
             
             <pre>
            		RestrictionSyntax ::= DirectoryString (SIZE(1..1024))
             </pre>
             
             @see Org.BouncyCastle.Asn1.IsisMtt.X509.Restriction
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATRetrieveIfAllowed">
             
             (Single)Request extension: Clients may include this extension in a
             (single) Request to request the responder to send the certificate in the
             response message along with the status information. Besides the LDAP
             service, this extension provides another mechanism for the distribution
             of certificates, which MAY optionally be provided by certificate
             repositories.
             
             <pre>
            		RetrieveIfAllowed ::= BOOLEAN
             </pre>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATRequestedCertificate">
            SingleOCSPResponse extension: The certificate requested by the client by
            inserting the RetrieveIfAllowed extension in the request, will be
            returned in this extension.
            
            @see Org.BouncyCastle.Asn1.IsisMtt.Ocsp.RequestedCertificate
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATNamingAuthorities">
            Base ObjectIdentifier for naming authorities
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATCertInDirSince">
             SingleOCSPResponse extension: Date, when certificate has been published
             in the directory and status information has become available. Currently,
             accrediting authorities enforce that SigG-conforming OCSP servers include
             this extension in the responses.
             
             <pre>
            		CertInDirSince ::= GeneralizedTime
             </pre>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATCertHash">
             Hash of a certificate in OCSP.
            
             @see Org.BouncyCastle.Asn1.IsisMtt.Ocsp.CertHash
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATNameAtBirth">
             <pre>
            		NameAtBirth ::= DirectoryString(SIZE(1..64)
             </pre>
             
             Used in
             {@link Org.BouncyCastle.Asn1.X509.SubjectDirectoryAttributes SubjectDirectoryAttributes}
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATAdditionalInformation">
            Some other information of non-restrictive nature regarding the usage of
            this certificate. May be used as attribute in atribute certificate or as
            extension in a certificate.
            
            <pre>
                          AdditionalInformationSyntax ::= DirectoryString (SIZE(1..2048))
            </pre>
            
            @see Org.BouncyCastle.Asn1.IsisMtt.X509.AdditionalInformationSyntax
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.IsisMttObjectIdentifiers.IdIsisMttATLiabilityLimitationFlag">
             Indicates that an attribute certificate exists, which limits the
             usability of this public key certificate. Whenever verifying a signature
             with the help of this certificate, the content of the corresponding
             attribute certificate should be concerned. This extension MUST be
             included in a PKC, if a corresponding attribute certificate (having the
             PKC as base certificate) contains some attribute that restricts the
             usability of the PKC too. Attribute certificates with restricting content
             MUST always be included in the signed document.
             
             <pre>
            		LiabilityLimitationFlagSyntax ::= BOOLEAN
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IsisMtt.Ocsp.CertHash">
            ISIS-MTT PROFILE: The responder may include this extension in a response to
            send the hash of the requested certificate to the responder. This hash is
            cryptographically bound to the certificate and serves as evidence that the
            certificate is known to the responder (i.e. it has been issued and is present
            in the directory). Hence, this extension is a means to provide a positive
            statement of availability as described in T8.[8]. As explained in T13.[1],
            clients may rely on this information to be able to validate signatures after
            the expiry of the corresponding certificate. Hence, clients MUST support this
            extension. If a positive statement of availability is to be delivered, this
            extension syntax and OID MUST be used.
            <p/>
            <p/>
            <pre>
                CertHash ::= SEQUENCE {
                  hashAlgorithm AlgorithmIdentifier,
                  certificateHash OCTET STRING
                }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.Ocsp.CertHash.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             The sequence is of type CertHash:
             <p/>
             <pre>
                 CertHash ::= SEQUENCE {
                   hashAlgorithm AlgorithmIdentifier,
                   certificateHash OCTET STRING
                 }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.Ocsp.CertHash.#ctor(Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier,System.Byte[])">
             Constructor from a given details.
            
             @param hashAlgorithm   The hash algorithm identifier.
             @param certificateHash The hash of the whole DER encoding of the certificate.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.Ocsp.CertHash.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                 CertHash ::= SEQUENCE {
                   hashAlgorithm AlgorithmIdentifier,
                   certificateHash OCTET STRING
                 }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IsisMtt.Ocsp.RequestedCertificate">
            ISIS-MTT-Optional: The certificate requested by the client by inserting the
            RetrieveIfAllowed extension in the request, will be returned in this
            extension.
            <p/>
            ISIS-MTT-SigG: The signature act allows publishing certificates only then,
            when the certificate owner gives his isExplicit permission. Accordingly, there
            may be �nondownloadable� certificates, about which the responder must provide
            status information, but MUST NOT include them in the response. Clients may
            get therefore the following three kind of answers on a single request
            including the RetrieveIfAllowed extension:
            <ul>
            <li> a) the responder supports the extension and is allowed to publish the
            certificate: RequestedCertificate returned including the requested
            certificate</li>
            <li>b) the responder supports the extension but is NOT allowed to publish
            the certificate: RequestedCertificate returned including an empty OCTET
            STRING</li>
            <li>c) the responder does not support the extension: RequestedCertificate is
            not included in the response</li>
            </ul>
            Clients requesting RetrieveIfAllowed MUST be able to handle these cases. If
            any of the OCTET STRING options is used, it MUST contain the DER encoding of
            the requested certificate.
            <p/>
            <pre>
                       RequestedCertificate ::= CHOICE {
                         Certificate Certificate,
                         publicKeyCertificate [0] EXPLICIT OCTET STRING,
                         attributeCertificate [1] EXPLICIT OCTET STRING
                       }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.Ocsp.RequestedCertificate.#ctor(Org.BouncyCastle.Asn1.X509.X509CertificateStructure)">
             Constructor from a given details.
             <p/>
             Only one parameter can be given. All other must be <code>null</code>.
            
             @param certificate Given as Certificate
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.Ocsp.RequestedCertificate.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                        RequestedCertificate ::= CHOICE {
                          Certificate Certificate,
                          publicKeyCertificate [0] EXPLICIT OCTET STRING,
                          attributeCertificate [1] EXPLICIT OCTET STRING
                        }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IsisMtt.X509.AdditionalInformationSyntax">
            Some other information of non-restrictive nature regarding the usage of this
            certificate.
            
            <pre>
               AdditionalInformationSyntax ::= DirectoryString (SIZE(1..2048))
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.AdditionalInformationSyntax.#ctor(System.String)">
             Constructor from a given details.
            
             @param information The describtion of the information.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.AdditionalInformationSyntax.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
               AdditionalInformationSyntax ::= DirectoryString (SIZE(1..2048))
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IsisMtt.X509.Admissions">
             An Admissions structure.
             <p/>
             <pre>
                        Admissions ::= SEQUENCE
                        {
                          admissionAuthority [0] EXPLICIT GeneralName OPTIONAL
                          namingAuthority [1] EXPLICIT NamingAuthority OPTIONAL
                          professionInfos SEQUENCE OF ProfessionInfo
                        }
             <p/>
             </pre>
            
             @see Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax
             @see Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo
             @see Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.Admissions.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             The sequence is of type ProcurationSyntax:
             <p/>
             <pre>
                        Admissions ::= SEQUENCE
                        {
                          admissionAuthority [0] EXPLICIT GeneralName OPTIONAL
                          namingAuthority [1] EXPLICIT NamingAuthority OPTIONAL
                          professionInfos SEQUENCE OF ProfessionInfo
                        }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.Admissions.#ctor(Org.BouncyCastle.Asn1.X509.GeneralName,Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority,Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo[])">
             Constructor from a given details.
             <p/>
             Parameter <code>professionInfos</code> is mandatory.
            
             @param admissionAuthority The admission authority.
             @param namingAuthority    The naming authority.
             @param professionInfos    The profession infos.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.Admissions.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                   Admissions ::= SEQUENCE
                   {
                     admissionAuthority [0] EXPLICIT GeneralName OPTIONAL
                     namingAuthority [1] EXPLICIT NamingAuthority OPTIONAL
                     professionInfos SEQUENCE OF ProfessionInfo
                   }
             <p/>
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax">
             Attribute to indicate admissions to certain professions.
             <p/>
             <pre>
                 AdmissionSyntax ::= SEQUENCE
                 {
                   admissionAuthority GeneralName OPTIONAL,
                   contentsOfAdmissions SEQUENCE OF Admissions
                 }
             <p/>
                 Admissions ::= SEQUENCE
                 {
                   admissionAuthority [0] EXPLICIT GeneralName OPTIONAL
                   namingAuthority [1] EXPLICIT NamingAuthority OPTIONAL
                   professionInfos SEQUENCE OF ProfessionInfo
                 }
             <p/>
                 NamingAuthority ::= SEQUENCE
                 {
                   namingAuthorityId OBJECT IDENTIFIER OPTIONAL,
                   namingAuthorityUrl IA5String OPTIONAL,
                   namingAuthorityText DirectoryString(SIZE(1..128)) OPTIONAL
                 }
             <p/>
                 ProfessionInfo ::= SEQUENCE
                 {
                   namingAuthority [0] EXPLICIT NamingAuthority OPTIONAL,
                   professionItems SEQUENCE OF DirectoryString (SIZE(1..128)),
                   professionOIDs SEQUENCE OF OBJECT IDENTIFIER OPTIONAL,
                   registrationNumber PrintableString(SIZE(1..128)) OPTIONAL,
                   addProfessionInfo OCTET STRING OPTIONAL
                 }
             </pre>
             <p/>
             <p/>
             ISIS-MTT PROFILE: The relatively complex structure of AdmissionSyntax
             supports the following concepts and requirements:
             <ul>
             <li> External institutions (e.g. professional associations, chambers, unions,
             administrative bodies, companies, etc.), which are responsible for granting
             and verifying professional admissions, are indicated by means of the data
             field admissionAuthority. An admission authority is indicated by a
             GeneralName object. Here an X.501 directory name (distinguished name) can be
             indicated in the field directoryName, a URL address can be indicated in the
             field uniformResourceIdentifier, and an object identifier can be indicated in
             the field registeredId.</li>
             <li> The names of authorities which are responsible for the administration of
             title registers are indicated in the data field namingAuthority. The name of
             the authority can be identified by an object identifier in the field
             namingAuthorityId, by means of a text string in the field
             namingAuthorityText, by means of a URL address in the field
             namingAuthorityUrl, or by a combination of them. For example, the text string
             can contain the name of the authority, the country and the name of the title
             register. The URL-option refers to a web page which contains lists with
             officially registered professions (text and possibly OID) as well as
             further information on these professions. Object identifiers for the
             component namingAuthorityId are grouped under the OID-branch
             id-isis-at-namingAuthorities and must be applied for.</li>
             <li>See http://www.teletrust.de/anwend.asp?Id=30200&amp;Sprache=E_&amp;HomePG=0
             for an application form and http://www.teletrust.de/links.asp?id=30220,11
             for an overview of registered naming authorities.</li>
             <li> By means of the data type ProfessionInfo certain professions,
             specializations, disciplines, fields of activity, etc. are identified. A
             profession is represented by one or more text strings, resp. profession OIDs
             in the fields professionItems and professionOIDs and by a registration number
             in the field registrationNumber. An indication in text form must always be
             present, whereas the other indications are optional. The component
             addProfessionInfo may contain additional applicationspecific information in
             DER-encoded form.</li>
             </ul>
             <p/>
             By means of different namingAuthority-OIDs or profession OIDs hierarchies of
             professions, specializations, disciplines, fields of activity, etc. can be
             expressed. The issuing admission authority should always be indicated (field
             admissionAuthority), whenever a registration number is presented. Still,
             information on admissions can be given without indicating an admission or a
             naming authority by the exclusive use of the component professionItems. In
             this case the certification authority is responsible for the verification of
             the admission information.
             <p/>
             <p/>
             <p/>
             This attribute is single-valued. Still, several admissions can be captured in
             the sequence structure of the component contentsOfAdmissions of
             AdmissionSyntax or in the component professionInfos of Admissions. The
             component admissionAuthority of AdmissionSyntax serves as default value for
             the component admissionAuthority of Admissions. Within the latter component
             the default value can be overwritten, in case that another authority is
             responsible. The component namingAuthority of Admissions serves as a default
             value for the component namingAuthority of ProfessionInfo. Within the latter
             component the default value can be overwritten, in case that another naming
             authority needs to be recorded.
             <p/>
             The length of the string objects is limited to 128 characters. It is
             recommended to indicate a namingAuthorityURL in all issued attribute
             certificates. If a namingAuthorityURL is indicated, the field professionItems
             of ProfessionInfo should contain only registered titles. If the field
             professionOIDs exists, it has to contain the OIDs of the professions listed
             in professionItems in the same order. In general, the field professionInfos
             should contain only one entry, unless the admissions that are to be listed
             are logically connected (e.g. they have been issued under the same admission
             number).
            
             @see Org.BouncyCastle.Asn1.IsisMtt.X509.Admissions
             @see Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo
             @see Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             The sequence is of type ProcurationSyntax:
             <p/>
             <pre>
                 AdmissionSyntax ::= SEQUENCE
                 {
                   admissionAuthority GeneralName OPTIONAL,
                   contentsOfAdmissions SEQUENCE OF Admissions
                 }
             <p/>
                 Admissions ::= SEQUENCE
                 {
                   admissionAuthority [0] EXPLICIT GeneralName OPTIONAL
                   namingAuthority [1] EXPLICIT NamingAuthority OPTIONAL
                   professionInfos SEQUENCE OF ProfessionInfo
                 }
             <p/>
                 NamingAuthority ::= SEQUENCE
                 {
                   namingAuthorityId OBJECT IDENTIFIER OPTIONAL,
                   namingAuthorityUrl IA5String OPTIONAL,
                   namingAuthorityText DirectoryString(SIZE(1..128)) OPTIONAL
                 }
             <p/>
                 ProfessionInfo ::= SEQUENCE
                 {
                   namingAuthority [0] EXPLICIT NamingAuthority OPTIONAL,
                   professionItems SEQUENCE OF DirectoryString (SIZE(1..128)),
                   professionOIDs SEQUENCE OF OBJECT IDENTIFIER OPTIONAL,
                   registrationNumber PrintableString(SIZE(1..128)) OPTIONAL,
                   addProfessionInfo OCTET STRING OPTIONAL
                 }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax.#ctor(Org.BouncyCastle.Asn1.X509.GeneralName,Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from given details.
            
             @param admissionAuthority   The admission authority.
             @param contentsOfAdmissions The admissions.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                 AdmissionSyntax ::= SEQUENCE
                 {
                   admissionAuthority GeneralName OPTIONAL,
                   contentsOfAdmissions SEQUENCE OF Admissions
                 }
             <p/>
                 Admissions ::= SEQUENCE
                 {
                   admissionAuthority [0] EXPLICIT GeneralName OPTIONAL
                   namingAuthority [1] EXPLICIT NamingAuthority OPTIONAL
                   professionInfos SEQUENCE OF ProfessionInfo
                 }
             <p/>
                 NamingAuthority ::= SEQUENCE
                 {
                   namingAuthorityId OBJECT IDENTIFIER OPTIONAL,
                   namingAuthorityUrl IA5String OPTIONAL,
                   namingAuthorityText DirectoryString(SIZE(1..128)) OPTIONAL
                 }
             <p/>
                 ProfessionInfo ::= SEQUENCE
                 {
                   namingAuthority [0] EXPLICIT NamingAuthority OPTIONAL,
                   professionItems SEQUENCE OF DirectoryString (SIZE(1..128)),
                   professionOIDs SEQUENCE OF OBJECT IDENTIFIER OPTIONAL,
                   registrationNumber PrintableString(SIZE(1..128)) OPTIONAL,
                   addProfessionInfo OCTET STRING OPTIONAL
                 }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax.GetContentsOfAdmissions">
            @return Returns the contentsOfAdmissions.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax.AdmissionAuthority">
            @return Returns the admissionAuthority if present, null otherwise.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IsisMtt.X509.DeclarationOfMajority">
            A declaration of majority.
            <p/>
            <pre>
                      DeclarationOfMajoritySyntax ::= CHOICE
                      {
                        notYoungerThan [0] IMPLICIT INTEGER,
                        fullAgeAtCountry [1] IMPLICIT SEQUENCE
                        {
                          fullAge BOOLEAN DEFAULT TRUE,
                          country PrintableString (SIZE(2))
                        }
                        dateOfBirth [2] IMPLICIT GeneralizedTime
                      }
            </pre>
            <p/>
            fullAgeAtCountry indicates the majority of the owner with respect to the laws
            of a specific country.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.DeclarationOfMajority.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                       DeclarationOfMajoritySyntax ::= CHOICE
                       {
                         notYoungerThan [0] IMPLICIT INTEGER,
                         fullAgeAtCountry [1] IMPLICIT SEQUENCE
                         {
                           fullAge BOOLEAN DEFAULT TRUE,
                           country PrintableString (SIZE(2))
                         }
                         dateOfBirth [2] IMPLICIT GeneralizedTime
                       }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="P:Org.BouncyCastle.Asn1.IsisMtt.X509.DeclarationOfMajority.NotYoungerThan">
            @return notYoungerThan if that's what we are, -1 otherwise
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IsisMtt.X509.MonetaryLimit">
            Monetary limit for transactions. The QcEuMonetaryLimit QC statement MUST be
            used in new certificates in place of the extension/attribute MonetaryLimit
            since January 1, 2004. For the sake of backward compatibility with
            certificates already in use, components SHOULD support MonetaryLimit (as well
            as QcEuLimitValue).
            <p/>
            Indicates a monetary limit within which the certificate holder is authorized
            to act. (This value DOES NOT express a limit on the liability of the
            certification authority).
            <p/>
            <pre>
               MonetaryLimitSyntax ::= SEQUENCE
               {
                 currency PrintableString (SIZE(3)),
                 amount INTEGER,
                 exponent INTEGER
               }
            </pre>
            <p/>
            currency must be the ISO code.
            <p/>
            value = amount�10*exponent
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.MonetaryLimit.#ctor(System.String,System.Int32,System.Int32)">
             Constructor from a given details.
             <p/>
             <p/>
             value = amount�10^exponent
            
             @param currency The currency. Must be the ISO code.
             @param amount   The amount
             @param exponent The exponent
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.MonetaryLimit.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                MonetaryLimitSyntax ::= SEQUENCE
                {
                  currency PrintableString (SIZE(3)),
                  amount INTEGER,
                  exponent INTEGER
                }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority">
            Names of authorities which are responsible for the administration of title
            registers.
            
            <pre>
                        NamingAuthority ::= SEQUENCE 
                        {
                          namingAuthorityID OBJECT IDENTIFIER OPTIONAL,
                          namingAuthorityUrl IA5String OPTIONAL,
                          namingAuthorityText DirectoryString(SIZE(1..128)) OPTIONAL
                        }
            </pre>
            @see Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax
            
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority.IdIsisMttATNamingAuthoritiesRechtWirtschaftSteuern">
            Profession OIDs should always be defined under the OID branch of the
            responsible naming authority. At the time of this writing, the work group
            �Recht, Wirtschaft, Steuern� (�Law, Economy, Taxes�) is registered as the
            first naming authority under the OID id-isismtt-at-namingAuthorities.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             <p/>
             <pre>
                         NamingAuthority ::= SEQUENCE
                         {
                           namingAuthorityID OBJECT IDENTIFIER OPTIONAL,
                           namingAuthorityUrl IA5String OPTIONAL,
                           namingAuthorityText DirectoryString(SIZE(1..128)) OPTIONAL
                         }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority.#ctor(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.String,Org.BouncyCastle.Asn1.X500.DirectoryString)">
             Constructor from given details.
             <p/>
             All parameters can be combined.
            
             @param namingAuthorityID   ObjectIdentifier for naming authority.
             @param namingAuthorityUrl  URL for naming authority.
             @param namingAuthorityText Textual representation of naming authority.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                         NamingAuthority ::= SEQUENCE
                         {
                           namingAuthorityID OBJECT IDENTIFIER OPTIONAL,
                           namingAuthorityUrl IA5String OPTIONAL,
                           namingAuthorityText DirectoryString(SIZE(1..128)) OPTIONAL
                         }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="P:Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority.NamingAuthorityID">
            @return Returns the namingAuthorityID.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority.NamingAuthorityText">
            @return Returns the namingAuthorityText.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority.NamingAuthorityUrl">
            @return Returns the namingAuthorityUrl.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IsisMtt.X509.ProcurationSyntax">
            Attribute to indicate that the certificate holder may sign in the name of a
            third person.
            <p>
            ISIS-MTT PROFILE: The corresponding ProcurationSyntax contains either the
            name of the person who is represented (subcomponent thirdPerson) or a
            reference to his/her base certificate (in the component signingFor,
            subcomponent certRef), furthermore the optional components country and
            typeSubstitution to indicate the country whose laws apply, and respectively
            the type of procuration (e.g. manager, procuration, custody).
            </p>
            <p>
            ISIS-MTT PROFILE: The GeneralName MUST be of type directoryName and MAY only
            contain: - RFC3039 attributes, except pseudonym (countryName, commonName,
            surname, givenName, serialNumber, organizationName, organizationalUnitName,
            stateOrProvincename, localityName, postalAddress) and - SubjectDirectoryName
            attributes (title, dateOfBirth, placeOfBirth, gender, countryOfCitizenship,
            countryOfResidence and NameAtBirth).
            </p>
            <pre>
                          ProcurationSyntax ::= SEQUENCE {
                            country [1] EXPLICIT PrintableString(SIZE(2)) OPTIONAL,
                            typeOfSubstitution [2] EXPLICIT DirectoryString (SIZE(1..128)) OPTIONAL,
                            signingFor [3] EXPLICIT SigningFor 
                          }
                          
                          SigningFor ::= CHOICE 
                          { 
                            thirdPerson GeneralName,
                            certRef IssuerSerial 
                          }
            </pre>
            
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.ProcurationSyntax.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             The sequence is of type ProcurationSyntax:
             <p/>
             <pre>
                           ProcurationSyntax ::= SEQUENCE {
                             country [1] EXPLICIT PrintableString(SIZE(2)) OPTIONAL,
                             typeOfSubstitution [2] EXPLICIT DirectoryString (SIZE(1..128)) OPTIONAL,
                             signingFor [3] EXPLICIT SigningFor
                           }
             <p/>
                           SigningFor ::= CHOICE
                           {
                             thirdPerson GeneralName,
                             certRef IssuerSerial
                           }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.ProcurationSyntax.#ctor(System.String,Org.BouncyCastle.Asn1.X500.DirectoryString,Org.BouncyCastle.Asn1.X509.IssuerSerial)">
             Constructor from a given details.
             <p/>
             <p/>
             Either <code>generalName</code> or <code>certRef</code> MUST be
             <code>null</code>.
            
             @param country            The country code whose laws apply.
             @param typeOfSubstitution The type of procuration.
             @param certRef            Reference to certificate of the person who is represented.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.ProcurationSyntax.#ctor(System.String,Org.BouncyCastle.Asn1.X500.DirectoryString,Org.BouncyCastle.Asn1.X509.GeneralName)">
             Constructor from a given details.
             <p/>
             <p/>
             Either <code>generalName</code> or <code>certRef</code> MUST be
             <code>null</code>.
            
             @param country            The country code whose laws apply.
             @param typeOfSubstitution The type of procuration.
             @param thirdPerson        The GeneralName of the person who is represented.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.ProcurationSyntax.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                           ProcurationSyntax ::= SEQUENCE {
                             country [1] EXPLICIT PrintableString(SIZE(2)) OPTIONAL,
                             typeOfSubstitution [2] EXPLICIT DirectoryString (SIZE(1..128)) OPTIONAL,
                             signingFor [3] EXPLICIT SigningFor
                           }
             <p/>
                           SigningFor ::= CHOICE
                           {
                             thirdPerson GeneralName,
                             certRef IssuerSerial
                           }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo">
            Professions, specializations, disciplines, fields of activity, etc.
            
            <pre>
                          ProfessionInfo ::= SEQUENCE 
                          {
                            namingAuthority [0] EXPLICIT NamingAuthority OPTIONAL,
                            professionItems SEQUENCE OF DirectoryString (SIZE(1..128)),
                            professionOids SEQUENCE OF OBJECT IDENTIFIER OPTIONAL,
                            registrationNumber PrintableString(SIZE(1..128)) OPTIONAL,
                            addProfessionInfo OCTET STRING OPTIONAL 
                          }
            </pre>
            
            @see Org.BouncyCastle.Asn1.IsisMtt.X509.AdmissionSyntax
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Rechtsanwltin">
            Rechtsanw�ltin
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Rechtsanwalt">
            Rechtsanwalt
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Rechtsbeistand">
            Rechtsbeistand
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Steuerberaterin">
            Steuerberaterin
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Steuerberater">
            Steuerberater
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Steuerbevollmchtigte">
            Steuerbevollm�chtigte
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Steuerbevollmchtigter">
            Steuerbevollm�chtigter
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Notarin">
            Notarin
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Notar">
            Notar
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Notarvertreterin">
            Notarvertreterin
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Notarvertreter">
            Notarvertreter
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Notariatsverwalterin">
            Notariatsverwalterin
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Notariatsverwalter">
            Notariatsverwalter
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Wirtschaftsprferin">
            Wirtschaftspr�ferin
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Wirtschaftsprfer">
            Wirtschaftspr�fer
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.VereidigteBuchprferin">
            Vereidigte Buchpr�ferin
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.VereidigterBuchprfer">
            Vereidigter Buchpr�fer
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Patentanwltin">
            Patentanw�ltin
        </member>
        <member name="F:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.Patentanwalt">
            Patentanwalt
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             <p/>
             <pre>
                           ProfessionInfo ::= SEQUENCE
                           {
                             namingAuthority [0] EXPLICIT NamingAuthority OPTIONAL,
                             professionItems SEQUENCE OF DirectoryString (SIZE(1..128)),
                             professionOids SEQUENCE OF OBJECT IDENTIFIER OPTIONAL,
                             registrationNumber PrintableString(SIZE(1..128)) OPTIONAL,
                             addProfessionInfo OCTET STRING OPTIONAL
                           }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.#ctor(Org.BouncyCastle.Asn1.IsisMtt.X509.NamingAuthority,Org.BouncyCastle.Asn1.X500.DirectoryString[],Org.BouncyCastle.Asn1.DerObjectIdentifier[],System.String,Org.BouncyCastle.Asn1.Asn1OctetString)">
             Constructor from given details.
             <p/>
             <code>professionItems</code> is mandatory, all other parameters are
             optional.
            
             @param namingAuthority    The naming authority.
             @param professionItems    Directory strings of the profession.
             @param professionOids     DERObjectIdentfier objects for the
                                       profession.
             @param registrationNumber Registration number.
             @param addProfessionInfo  Additional infos in encoded form.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                           ProfessionInfo ::= SEQUENCE
                           {
                             namingAuthority [0] EXPLICIT NamingAuthority OPTIONAL,
                             professionItems SEQUENCE OF DirectoryString (SIZE(1..128)),
                             professionOids SEQUENCE OF OBJECT IDENTIFIER OPTIONAL,
                             registrationNumber PrintableString(SIZE(1..128)) OPTIONAL,
                             addProfessionInfo OCTET STRING OPTIONAL
                           }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.GetProfessionItems">
            @return Returns the professionItems.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.GetProfessionOids">
            @return Returns the professionOids.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.AddProfessionInfo">
            @return Returns the addProfessionInfo.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.NamingAuthority">
            @return Returns the namingAuthority.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.IsisMtt.X509.ProfessionInfo.RegistrationNumber">
            @return Returns the registrationNumber.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IsisMtt.X509.Restriction">
            Some other restriction regarding the usage of this certificate.
            <p/>
            <pre>
             RestrictionSyntax ::= DirectoryString (SIZE(1..1024))
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.Restriction.#ctor(Org.BouncyCastle.Asn1.X500.DirectoryString)">
             Constructor from DirectoryString.
             <p/>
             The DirectoryString is of type RestrictionSyntax:
             <p/>
             <pre>
                  RestrictionSyntax ::= DirectoryString (SIZE(1..1024))
             </pre>
            
             @param restriction A IAsn1String.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.Restriction.#ctor(System.String)">
             Constructor from a given details.
            
             @param restriction The description of the restriction.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.IsisMtt.X509.Restriction.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                  RestrictionSyntax ::= DirectoryString (SIZE(1..1024))
             <p/>
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Misc.Cast5CbcParameters.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            cast5CBCParameters ::= Sequence {
                                      iv         OCTET STRING DEFAULT 0,
                                             -- Initialization vector
                                      keyLength  Integer
                                             -- Key length, in bits
                                 }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Misc.IdeaCbcPar.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            IDEA-CBCPar ::= Sequence {
                                 iv    OCTET STRING OPTIONAL -- exactly 8 octets
                             }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Misc.NetscapeCertType">
            The NetscapeCertType object.
            <pre>
               NetscapeCertType ::= BIT STRING {
                    SSLClient               (0),
                    SSLServer               (1),
                    S/MIME                  (2),
                    Object Signing          (3),
                    Reserved                (4),
                    SSL CA                  (5),
                    S/MIME CA               (6),
                    Object Signing CA       (7) }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Misc.NetscapeCertType.#ctor(System.Int32)">
             Basic constructor.
            
             @param usage - the bitwise OR of the Key Usage flags giving the
             allowed uses for the key.
             e.g. (X509NetscapeCertType.sslCA | X509NetscapeCertType.smimeCA)
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Mozilla.PublicKeyAndChallenge">
             This is designed to parse
             the PublicKeyAndChallenge created by the KEYGEN tag included by
             Mozilla based browsers.
              <pre>
              PublicKeyAndChallenge ::= SEQUENCE {
                spki SubjectPublicKeyInfo,
                challenge IA5STRING
              }
            
              </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Nist.NistNamedCurves">
            Utility class for fetching curves using their NIST names as published in FIPS-PUB 186-3
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Nist.NistNamedCurves.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the X9ECParameters object for the named curve represented by
             the passed in object identifier. Null if the curve isn't present.
            
             @param oid an object identifier representing a named curve, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Nist.NistNamedCurves.GetOid(System.String)">
             return the object identifier signified by the passed in name. Null
             if there is no object identifier associated with name.
            
             @return the object identifier associated with name, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Nist.NistNamedCurves.GetName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            return the named curve name represented by the given object identifier.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Nist.NistNamedCurves.Names">
            returns an enumeration containing the name strings for curves
            contained in this structure.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Ntt.NttObjectIdentifiers">
            <summary>From RFC 3657</summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.BasicOcspResponse.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            BasicOcspResponse       ::= Sequence {
                 tbsResponseData      ResponseData,
                 signatureAlgorithm   AlgorithmIdentifier,
                 signature            BIT STRING,
                 certs                [0] EXPLICIT Sequence OF Certificate OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.CertID.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            CertID          ::=     Sequence {
                hashAlgorithm       AlgorithmIdentifier,
                issuerNameHash      OCTET STRING, -- Hash of Issuer's DN
                issuerKeyHash       OCTET STRING, -- Hash of Issuers public key
                serialNumber        CertificateSerialNumber }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.CertStatus.#ctor">
            create a CertStatus object with a tag of zero.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.CertStatus.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             CertStatus ::= CHOICE {
                             good        [0]     IMPLICIT Null,
                             revoked     [1]     IMPLICIT RevokedInfo,
                             unknown     [2]     IMPLICIT UnknownInfo }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.CrlID.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            CrlID ::= Sequence {
                crlUrl               [0]     EXPLICIT IA5String OPTIONAL,
                crlNum               [1]     EXPLICIT Integer OPTIONAL,
                crlTime              [2]     EXPLICIT GeneralizedTime OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.OcspRequest.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            OcspRequest     ::=     Sequence {
                tbsRequest                  TBSRequest,
                optionalSignature   [0]     EXPLICIT Signature OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.OcspResponse.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            OcspResponse ::= Sequence {
                responseStatus         OcspResponseStatus,
                responseBytes          [0] EXPLICIT ResponseBytes OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.OcspResponseStatus.#ctor(System.Int32)">
            The OcspResponseStatus enumeration.
            <pre>
            OcspResponseStatus ::= Enumerated {
                successful            (0),  --Response has valid confirmations
                malformedRequest      (1),  --Illegal confirmation request
                internalError         (2),  --Internal error in issuer
                tryLater              (3),  --Try again later
                                            --(4) is not used
                sigRequired           (5),  --Must sign the request
                unauthorized          (6)   --Request unauthorized
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.Request.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Request         ::=     Sequence {
                reqCert                     CertID,
                singleRequestExtensions     [0] EXPLICIT Extensions OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.ResponderID.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            ResponderID ::= CHOICE {
                 byName          [1] Name,
                 byKey           [2] KeyHash }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.ResponseBytes.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            ResponseBytes ::=       Sequence {
                responseType   OBJECT IDENTIFIER,
                response       OCTET STRING }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.ResponseData.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            ResponseData ::= Sequence {
                version              [0] EXPLICIT Version DEFAULT v1,
                responderID              ResponderID,
                producedAt               GeneralizedTime,
                responses                Sequence OF SingleResponse,
                responseExtensions   [1] EXPLICIT Extensions OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.RevokedInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            RevokedInfo ::= Sequence {
                 revocationTime              GeneralizedTime,
                 revocationReason    [0]     EXPLICIT CRLReason OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.ServiceLocator.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            ServiceLocator ::= Sequence {
                issuer    Name,
                locator   AuthorityInfoAccessSyntax OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.Signature.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Signature       ::=     Sequence {
                signatureAlgorithm      AlgorithmIdentifier,
                signature               BIT STRING,
                certs               [0] EXPLICIT Sequence OF Certificate OPTIONAL}
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.SingleResponse.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             SingleResponse ::= Sequence {
                     certID                       CertID,
                     certStatus                   CertStatus,
                     thisUpdate                   GeneralizedTime,
                     nextUpdate         [0]       EXPLICIT GeneralizedTime OPTIONAL,
                     singleExtensions   [1]       EXPLICIT Extensions OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.TbsRequest.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            TBSRequest      ::=     Sequence {
                version             [0]     EXPLICIT Version DEFAULT v1,
                requestorName       [1]     EXPLICIT GeneralName OPTIONAL,
                requestList                 Sequence OF Request,
                requestExtensions   [2]     EXPLICIT Extensions OPTIONAL }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.OidTokenizer">
            class for breaking up an Oid into it's component tokens, ala
            java.util.StringTokenizer. We need this class as some of the
            lightweight Java environment don't support classes like
            StringTokenizer.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.AttributePkcs.GetInstance(System.Object)">
             return an Attribute object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.AttributePkcs.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Attr ::= Sequence {
                attrType OBJECT IDENTIFIER,
                attrValues Set OF AttributeValue
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Pkcs.CertificationRequest">
            Pkcs10 Certfication request object.
            <pre>
            CertificationRequest ::= Sequence {
              certificationRequestInfo  CertificationRequestInfo,
              signatureAlgorithm        AlgorithmIdentifier{{ SignatureAlgorithms }},
              signature                 BIT STRING
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Pkcs.CertificationRequestInfo">
             Pkcs10 CertificationRequestInfo object.
             <pre>
              CertificationRequestInfo ::= Sequence {
               version             Integer { v1(0) } (v1,...),
               subject             Name,
               subjectPKInfo   SubjectPublicKeyInfo{{ PKInfoAlgorithms }},
               attributes          [0] Attributes{{ CRIAttributes }}
              }
            
              Attributes { ATTRIBUTE:IOSet } ::= Set OF Attr{{ IOSet }}
            
              Attr { ATTRIBUTE:IOSet } ::= Sequence {
                type    ATTRIBUTE.&amp;id({IOSet}),
                values  Set SIZE(1..MAX) OF ATTRIBUTE.&amp;Type({IOSet}{\@type})
              }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.ContentInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            ContentInfo ::= Sequence {
                     contentType ContentType,
                     content
                     [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Pkcs.EncryptedData">
             The EncryptedData object.
             <pre>
                  EncryptedData ::= Sequence {
                       version Version,
                       encryptedContentInfo EncryptedContentInfo
                  }
            
            
                  EncryptedContentInfo ::= Sequence {
                      contentType ContentType,
                      contentEncryptionAlgorithm  ContentEncryptionAlgorithmIdentifier,
                      encryptedContent [0] IMPLICIT EncryptedContent OPTIONAL
                }
            
                EncryptedContent ::= OCTET STRING
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.EncryptedPrivateKeyInfo.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
             EncryptedPrivateKeyInfo ::= Sequence {
                  encryptionAlgorithm AlgorithmIdentifier {{KeyEncryptionAlgorithms}},
                  encryptedData EncryptedData
             }
            
             EncryptedData ::= OCTET STRING
            
             KeyEncryptionAlgorithms ALGORITHM-IDENTIFIER ::= {
                      ... -- For local profiles
             }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
                 AlgorithmIdentifier ::= Sequence {
                                       algorithm OBJECT IDENTIFIER,
                                       parameters ANY DEFINED BY algorithm OPTIONAL }
            </pre>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier.Algorithm">
            <summary>
            Return the OID in the Algorithm entry of this identifier.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier.Parameters">
            <summary>
            Return the parameters structure in the Parameters entry of this identifier.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.MacData.ToAsn1Object">
            <pre>
            MacData ::= SEQUENCE {
                mac      DigestInfo,
                macSalt  OCTET STRING,
                iterations INTEGER DEFAULT 1
                -- Note: The default is for historic reasons and its use is deprecated. A
                -- higher value, like 1024 is recommended.
            </pre>
            @return the basic DERObject construction.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Pkcs.Pfx">
            the infamous Pfx from Pkcs12
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.PrivateKeyInfo.ToAsn1Object">
             write out an RSA private key with its associated information
             as described in Pkcs8.
             <pre>
                  PrivateKeyInfo ::= Sequence {
                                          version Version,
                                          privateKeyAlgorithm AlgorithmIdentifier {{PrivateKeyAlgorithms}},
                                          privateKey PrivateKey,
                                          attributes [0] IMPLICIT Attributes OPTIONAL
                                      }
                  Version ::= Integer {v1(0)} (v1,...)
            
                  PrivateKey ::= OCTET STRING
            
                  Attributes ::= Set OF Attr
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.RsaesOaepParameters.#ctor">
            The default version
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.RsaesOaepParameters.ToAsn1Object">
             <pre>
              RSAES-OAEP-params ::= SEQUENCE {
                 hashAlgorithm      [0] OAEP-PSSDigestAlgorithms     DEFAULT sha1,
                 maskGenAlgorithm   [1] PKCS1MGFAlgorithms  DEFAULT mgf1SHA1,
                 pSourceAlgorithm   [2] PKCS1PSourceAlgorithms  DEFAULT pSpecifiedEmpty
               }
            
               OAEP-PSSDigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
                 { OID id-sha1 PARAMETERS NULL   }|
                 { OID id-sha256 PARAMETERS NULL }|
                 { OID id-sha384 PARAMETERS NULL }|
                 { OID id-sha512 PARAMETERS NULL },
                 ...  -- Allows for future expansion --
               }
               PKCS1MGFAlgorithms    ALGORITHM-IDENTIFIER ::= {
                 { OID id-mgf1 PARAMETERS OAEP-PSSDigestAlgorithms },
                ...  -- Allows for future expansion --
               }
               PKCS1PSourceAlgorithms    ALGORITHM-IDENTIFIER ::= {
                 { OID id-pSpecified PARAMETERS OCTET STRING },
                 ...  -- Allows for future expansion --
              }
             </pre>
             @return the asn1 primitive representing the parameters.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.RsaPrivateKeyStructure.ToAsn1Object">
             This outputs the key in Pkcs1v2 format.
             <pre>
                  RsaPrivateKey ::= Sequence {
                                      version Version,
                                      modulus Integer, -- n
                                      publicExponent Integer, -- e
                                      privateExponent Integer, -- d
                                      prime1 Integer, -- p
                                      prime2 Integer, -- q
                                      exponent1 Integer, -- d mod (p-1)
                                      exponent2 Integer, -- d mod (q-1)
                                      coefficient Integer -- (inverse of q) mod p
                                  }
            
                  Version ::= Integer
             </pre>
             <p>This routine is written to output Pkcs1 version 0, private keys.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.RsassaPssParameters.#ctor">
            The default version
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.RsassaPssParameters.ToAsn1Object">
             <pre>
             RSASSA-PSS-params ::= SEQUENCE {
               hashAlgorithm      [0] OAEP-PSSDigestAlgorithms  DEFAULT sha1,
                maskGenAlgorithm   [1] PKCS1MGFAlgorithms  DEFAULT mgf1SHA1,
                saltLength         [2] INTEGER  DEFAULT 20,
                trailerField       [3] TrailerField  DEFAULT trailerFieldBC
              }
            
             OAEP-PSSDigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
                { OID id-sha1 PARAMETERS NULL   }|
                { OID id-sha256 PARAMETERS NULL }|
                { OID id-sha384 PARAMETERS NULL }|
                { OID id-sha512 PARAMETERS NULL },
                ...  -- Allows for future expansion --
             }
            
             PKCS1MGFAlgorithms    ALGORITHM-IDENTIFIER ::= {
               { OID id-mgf1 PARAMETERS OAEP-PSSDigestAlgorithms },
                ...  -- Allows for future expansion --
             }
            
             TrailerField ::= INTEGER { trailerFieldBC(1) }
             </pre>
             @return the asn1 primitive representing the parameters.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Pkcs.SignedData">
            a Pkcs#7 signed data object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.SignedData.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             SignedData ::= Sequence {
                 version Version,
                 digestAlgorithms DigestAlgorithmIdentifiers,
                 contentInfo ContentInfo,
                 certificates
                     [0] IMPLICIT ExtendedCertificatesAndCertificates
                              OPTIONAL,
                 crls
                     [1] IMPLICIT CertificateRevocationLists OPTIONAL,
                 signerInfos SignerInfos }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Pkcs.SignerInfo">
            a Pkcs#7 signer info object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.SignerInfo.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
              SignerInfo ::= Sequence {
                  version Version,
                  issuerAndSerialNumber IssuerAndSerialNumber,
                  digestAlgorithm DigestAlgorithmIdentifier,
                  authenticatedAttributes [0] IMPLICIT Attributes OPTIONAL,
                  digestEncryptionAlgorithm DigestEncryptionAlgorithmIdentifier,
                  encryptedDigest EncryptedDigest,
                  unauthenticatedAttributes [1] IMPLICIT Attributes OPTIONAL
              }
            
              EncryptedDigest ::= OCTET STRING
            
              DigestAlgorithmIdentifier ::= AlgorithmIdentifier
            
              DigestEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Sec.ECPrivateKeyStructure">
            the elliptic curve private key object from SEC 1
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Sec.ECPrivateKeyStructure.ToAsn1Object">
            ECPrivateKey ::= SEQUENCE {
                version INTEGER { ecPrivkeyVer1(1) } (ecPrivkeyVer1),
                privateKey OCTET STRING,
                parameters [0] Parameters OPTIONAL,
                publicKey [1] BIT STRING OPTIONAL }
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Sec.SecNamedCurves.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the X9ECParameters object for the named curve represented by
             the passed in object identifier. Null if the curve isn't present.
            
             @param oid an object identifier representing a named curve, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Sec.SecNamedCurves.GetOid(System.String)">
             return the object identifier signified by the passed in name. Null
             if there is no object identifier associated with name.
            
             @return the object identifier associated with name, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Sec.SecNamedCurves.GetName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            return the named curve name represented by the given object identifier.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Sec.SecNamedCurves.Names">
            returns an enumeration containing the name strings for curves
            contained in this structure.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Sec.SecObjectIdentifiers.EllipticCurve">
            EllipticCurve OBJECT IDENTIFIER ::= {
                  iso(1) identified-organization(3) certicom(132) curve(0)
            }
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Smime.SmimeCapabilities">
            Handler class for dealing with S/MIME Capabilities
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Smime.SmimeCapabilities.PreferSignedData">
            general preferences
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Smime.SmimeCapabilities.Aes256Cbc">
            encryption algorithms preferences
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Smime.SmimeCapabilities.GetInstance(System.Object)">
             return an Attr object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Smime.SmimeCapabilities.GetCapabilitiesForOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            returns an ArrayList with 0 or more objects of all the capabilities
            matching the passed in capability Oid. If the Oid passed is null the
            entire set is returned.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Smime.SmimeCapabilities.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            SMIMECapabilities ::= Sequence OF SMIMECapability
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AttributeX509.GetInstance(System.Object)">
             return an Attr object from the given object.
            
             @param o the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AttributeX509.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Attr ::= Sequence {
                attrType OBJECT IDENTIFIER,
                attrValues Set OF AttributeValue
            }
            </pre>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Smime.SmimeCapability.PreferSignedData">
            general preferences
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Smime.SmimeCapability.DesCbc">
            encryption algorithms preferences
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Smime.SmimeCapability.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            SMIMECapability ::= Sequence {
                capabilityID OBJECT IDENTIFIER,
                parameters ANY DEFINED BY capabilityID OPTIONAL
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Smime.SmimeCapabilityVector">
            Handler for creating a vector S/MIME Capabilities
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Smime.SmimeEncryptionKeyPreferenceAttribute">
            The SmimeEncryptionKeyPreference object.
            <pre>
            SmimeEncryptionKeyPreference ::= CHOICE {
                issuerAndSerialNumber   [0] IssuerAndSerialNumber,
                receipentKeyId          [1] RecipientKeyIdentifier,
                subjectAltKeyIdentifier [2] SubjectKeyIdentifier
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Smime.SmimeEncryptionKeyPreferenceAttribute.#ctor(Org.BouncyCastle.Asn1.Asn1OctetString)">
            @param sKeyId the subjectKeyIdentifier value (normally the X.509 one)
        </member>
        <member name="T:Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves">
            elliptic curves defined in "ECC Brainpool Standard Curves and Curve Generation"
            http://www.ecc-brainpool.org/download/draft_pkix_additional_ecc_dp.txt
        </member>
        <member name="M:Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the X9ECParameters object for the named curve represented by
             the passed in object identifier. Null if the curve isn't present.
            
             @param oid an object identifier representing a named curve, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves.GetOid(System.String)">
             return the object identifier signified by the passed in name. Null
             if there is no object identifier associated with name.
            
             @return the object identifier associated with name, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves.GetName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            return the named curve name represented by the given object identifier.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves.Names">
            returns an enumeration containing the name strings for curves
            contained in this structure.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Tsp.Accuracy.ToAsn1Object">
            <pre>
            Accuracy ::= SEQUENCE {
                        seconds        INTEGER              OPTIONAL,
                        millis     [0] INTEGER  (1..999)    OPTIONAL,
                        micros     [1] INTEGER  (1..999)    OPTIONAL
                        }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Tsp.MessageImprint.GetInstance(System.Object)">
            @param o
            @return a MessageImprint object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Tsp.MessageImprint.ToAsn1Object">
            <pre>
               MessageImprint ::= SEQUENCE  {
                  hashAlgorithm                AlgorithmIdentifier,
                  hashedMessage                OCTET STRING  }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Tsp.TimeStampReq.ToAsn1Object">
            <pre>
            TimeStampReq ::= SEQUENCE  {
             version                      INTEGER  { v1(1) },
             messageImprint               MessageImprint,
               --a hash algorithm OID and the hash value of the data to be
               --time-stamped
             reqPolicy             TSAPolicyId              OPTIONAL,
             nonce                 INTEGER                  OPTIONAL,
             certReq               BOOLEAN                  DEFAULT FALSE,
             extensions            [0] IMPLICIT Extensions  OPTIONAL
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Tsp.TimeStampResp.ToAsn1Object">
            <pre>
            TimeStampResp ::= SEQUENCE  {
              status                  PkiStatusInfo,
              timeStampToken          TimeStampToken     OPTIONAL  }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Tsp.TstInfo.ToAsn1Object">
             <pre>
            
                 TstInfo ::= SEQUENCE  {
                    version                      INTEGER  { v1(1) },
                    policy                       TSAPolicyId,
                    messageImprint               MessageImprint,
                      -- MUST have the same value as the similar field in
                      -- TimeStampReq
                    serialNumber                 INTEGER,
                     -- Time-Stamping users MUST be ready to accommodate integers
                     -- up to 160 bits.
                    genTime                      GeneralizedTime,
                    accuracy                     Accuracy                 OPTIONAL,
                    ordering                     BOOLEAN             DEFAULT FALSE,
                    nonce                        INTEGER                  OPTIONAL,
                      -- MUST be present if the similar field was present
                      -- in TimeStampReq.  In that case it MUST have the same value.
                    tsa                          [0] GeneralName          OPTIONAL,
                    extensions                   [1] IMPLICIT Extensions   OPTIONAL  }
            
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Utilities.Asn1Dump.AsString(System.String,System.Boolean,Org.BouncyCastle.Asn1.Asn1Object,System.Text.StringBuilder)">
             dump a Der object as a formatted string with indentation
            
             @param obj the Asn1Object to be dumped out.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Utilities.Asn1Dump.DumpAsString(Org.BouncyCastle.Asn1.Asn1Encodable)">
             dump out a DER object as a formatted string, in non-verbose mode
            
             @param obj the Asn1Encodable to be dumped out.
             @return  the resulting string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Utilities.Asn1Dump.DumpAsString(Org.BouncyCastle.Asn1.Asn1Encodable,System.Boolean)">
             Dump out the object as a string
            
             @param obj the Asn1Encodable to be dumped out.
             @param verbose  if true, dump out the contents of octet and bit strings.
             @return  the resulting string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X500.DirectoryString.ToAsn1Object">
            <pre>
             DirectoryString ::= CHOICE {
               teletexString               TeletexString (SIZE (1..MAX)),
               printableString             PrintableString (SIZE (1..MAX)),
               universalString             UniversalString (SIZE (1..MAX)),
               utf8String                  UTF8String (SIZE (1..MAX)),
               bmpString                   BMPString (SIZE (1..MAX))  }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.AccessDescription">
            The AccessDescription object.
            <pre>
            AccessDescription  ::=  SEQUENCE {
                  accessMethod          OBJECT IDENTIFIER,
                  accessLocation        GeneralName  }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AccessDescription.#ctor(Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Asn1.X509.GeneralName)">
            create an AccessDescription with the oid and location provided.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.AccessDescription.AccessMethod">
            
             @return the access method.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.AccessDescription.AccessLocation">
            
             @return the access location
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AttCertIssuer.#ctor(Org.BouncyCastle.Asn1.X509.GeneralNames)">
            <summary>
            Don't use this one if you are trying to be RFC 3281 compliant.
            Use it for v1 attribute certificates only.
            </summary>
            <param name="names">Our GeneralNames structure</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AttCertIssuer.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             AttCertIssuer ::= CHOICE {
                  v1Form   GeneralNames,  -- MUST NOT be used in this
                                          -- profile
                  v2Form   [0] V2Form     -- v2 only
             }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AttCertValidityPeriod.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             AttCertValidityPeriod  ::= Sequence {
                  notBeforeTime  GeneralizedTime,
                  notAfterTime   GeneralizedTime
             }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AttributeCertificate.GetInstance(System.Object)">
            @param obj
            @return
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AttributeCertificate.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             AttributeCertificate ::= Sequence {
                  acinfo               AttributeCertificateInfo,
                  signatureAlgorithm   AlgorithmIdentifier,
                  signatureValue       BIT STRING
             }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AttributeCertificateInfo.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <pre>
              AttributeCertificateInfo ::= Sequence {
                   version              AttCertVersion -- version is v2,
                   holder               Holder,
                   issuer               AttCertIssuer,
                   signature            AlgorithmIdentifier,
                   serialNumber         CertificateSerialNumber,
                   attrCertValidityPeriod   AttCertValidityPeriod,
                   attributes           Sequence OF Attr,
                   issuerUniqueID       UniqueIdentifier OPTIONAL,
                   extensions           Extensions OPTIONAL
              }
            
              AttCertVersion ::= Integer { v2(1) }
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.AuthorityInformationAccess">
             The AuthorityInformationAccess object.
             <pre>
             id-pe-authorityInfoAccess OBJECT IDENTIFIER ::= { id-pe 1 }
            
             AuthorityInfoAccessSyntax  ::=
                  Sequence SIZE (1..MAX) OF AccessDescription
             AccessDescription  ::=  Sequence {
                   accessMethod          OBJECT IDENTIFIER,
                   accessLocation        GeneralName  }
            
             id-ad OBJECT IDENTIFIER ::= { id-pkix 48 }
             id-ad-caIssuers OBJECT IDENTIFIER ::= { id-ad 2 }
             id-ad-ocsp OBJECT IDENTIFIER ::= { id-ad 1 }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AuthorityInformationAccess.#ctor(Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Asn1.X509.GeneralName)">
            create an AuthorityInformationAccess with the oid and location provided.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier">
             The AuthorityKeyIdentifier object.
             <pre>
             id-ce-authorityKeyIdentifier OBJECT IDENTIFIER ::=  { id-ce 35 }
            
               AuthorityKeyIdentifier ::= Sequence {
                  keyIdentifier             [0] IMPLICIT KeyIdentifier           OPTIONAL,
                  authorityCertIssuer       [1] IMPLICIT GeneralNames            OPTIONAL,
                  authorityCertSerialNumber [2] IMPLICIT CertificateSerialNumber OPTIONAL  }
            
               KeyIdentifier ::= OCTET STRING
             </pre>
            
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier.#ctor(Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
                     *
                     * Calulates the keyidentifier using a SHA1 hash over the BIT STRING
                     * from SubjectPublicKeyInfo as defined in RFC2459.
                     *
                     * Example of making a AuthorityKeyIdentifier:
                     * <pre>
            	     *   SubjectPublicKeyInfo apki = new SubjectPublicKeyInfo((ASN1Sequence)new ASN1InputStream(
            		 *       publicKey.getEncoded()).readObject());
                     *   AuthorityKeyIdentifier aki = new AuthorityKeyIdentifier(apki);
                     * </pre>
                     *
                     *
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier.#ctor(Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo,Org.BouncyCastle.Asn1.X509.GeneralNames,Org.BouncyCastle.Math.BigInteger)">
            create an AuthorityKeyIdentifier with the GeneralNames tag and
            the serial number provided as well.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier.#ctor(Org.BouncyCastle.Asn1.X509.GeneralNames,Org.BouncyCastle.Math.BigInteger)">
            create an AuthorityKeyIdentifier with the GeneralNames tag and
            the serial number provided.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier.#ctor(System.Byte[])">
            create an AuthorityKeyIdentifier with a precomputed key identifier
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier.#ctor(System.Byte[],Org.BouncyCastle.Asn1.X509.GeneralNames,Org.BouncyCastle.Math.BigInteger)">
            create an AuthorityKeyIdentifier with a precomupted key identifier
            and the GeneralNames tag and the serial number provided as well.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AuthorityKeyIdentifier.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.BasicConstraints.#ctor(System.Int32)">
             create a cA=true object for the given path length constraint.
            
             @param pathLenConstraint
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.BasicConstraints.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            BasicConstraints := Sequence {
               cA                  Boolean DEFAULT FALSE,
               pathLenConstraint   Integer (0..MAX) OPTIONAL
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.CertificateList">
             PKIX RFC-2459
            
             The X.509 v2 CRL syntax is as follows.  For signature calculation,
             the data that is to be signed is ASN.1 Der encoded.
            
             <pre>
             CertificateList  ::=  Sequence  {
                  tbsCertList          TbsCertList,
                  signatureAlgorithm   AlgorithmIdentifier,
                  signatureValue       BIT STRING  }
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.CertificatePair">
             This class helps to support crossCerfificatePairs in a LDAP directory
             according RFC 2587
            
             <pre>
                 crossCertificatePairATTRIBUTE::={
                   WITH SYNTAX   CertificatePair
                   EQUALITY MATCHING RULE certificatePairExactMatch
                   ID joint-iso-ccitt(2) ds(5) attributeType(4) crossCertificatePair(40)}
             </pre>
            
             <blockquote> The forward elements of the crossCertificatePair attribute of a
             CA's directory entry shall be used to store all, except self-issued
             certificates issued to this CA. Optionally, the reverse elements of the
             crossCertificatePair attribute, of a CA's directory entry may contain a
             subset of certificates issued by this CA to other CAs. When both the forward
             and the reverse elements are present in a single attribute value, issuer name
             in one certificate shall match the subject name in the other and vice versa,
             and the subject public key in one certificate shall be capable of verifying
             the digital signature on the other certificate and vice versa.
            
             When a reverse element is present, the forward element value and the reverse
             element value need not be stored in the same attribute value; in other words,
             they can be stored in either a single attribute value or two attribute
             values. </blockquote>
            
             <pre>
                   CertificatePair ::= SEQUENCE {
                     forward		[0]	Certificate OPTIONAL,
                     reverse		[1]	Certificate OPTIONAL,
                     -- at least one of the pair shall be present -- }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.CertificatePair.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             The sequence is of type CertificatePair:
             <p/>
             <pre>
                   CertificatePair ::= SEQUENCE {
                     forward		[0]	Certificate OPTIONAL,
                     reverse		[1]	Certificate OPTIONAL,
                     -- at least one of the pair shall be present -- }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.CertificatePair.#ctor(Org.BouncyCastle.Asn1.X509.X509CertificateStructure,Org.BouncyCastle.Asn1.X509.X509CertificateStructure)">
             Constructor from a given details.
            
             @param forward Certificates issued to this CA.
             @param reverse Certificates issued by this CA to other CAs.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.CertificatePair.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                   CertificatePair ::= SEQUENCE {
                     forward		[0]	Certificate OPTIONAL,
                     reverse		[1]	Certificate OPTIONAL,
                     -- at least one of the pair shall be present -- }
             </pre>
            
             @return a DERObject
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.CertificatePair.Forward">
            @return Returns the forward.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.CertificatePair.Reverse">
            @return Returns the reverse.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.CertificatePolicies.#ctor(Org.BouncyCastle.Asn1.X509.PolicyInformation)">
            Construct a CertificatePolicies object containing one PolicyInformation.
            
            @param name the name to be contained.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.CertificatePolicies.ToAsn1Object">
            Produce an object suitable for an ASN1OutputStream.
            <pre>
            CertificatePolicies ::= SEQUENCE SIZE {1..MAX} OF PolicyInformation
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.CertPolicyID">
             CertPolicyId, used in the CertificatePolicies and PolicyMappings
             X509V3 Extensions.
            
             <pre>
                 CertPolicyId ::= OBJECT IDENTIFIER
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.CrlDistPoint.GetDistributionPoints">
             Return the distribution points making up the sequence.
            
             @return DistributionPoint[]
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.CrlDistPoint.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            CrlDistPoint ::= Sequence SIZE {1..MAX} OF DistributionPoint
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.CrlNumber">
            The CRLNumber object.
            <pre>
            CRLNumber::= Integer(0..MAX)
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.CrlReason">
            The CRLReason enumeration.
            <pre>
            CRLReason ::= Enumerated {
             unspecified             (0),
             keyCompromise           (1),
             cACompromise            (2),
             affiliationChanged      (3),
             superseded              (4),
             cessationOfOperation    (5),
             certificateHold         (6),
             removeFromCRL           (8),
             privilegeWithdrawn      (9),
             aACompromise           (10)
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.DigestInfo">
            The DigestInfo object.
            <pre>
            DigestInfo::=Sequence{
                     digestAlgorithm  AlgorithmIdentifier,
                     digest OCTET STRING }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.DisplayText">
             <code>DisplayText</code> class, used in
             <code>CertificatePolicies</code> X509 V3 extensions (in policy qualifiers).
            
             <p>It stores a string in a chosen encoding.
             <pre>
             DisplayText ::= CHOICE {
                  ia5String        IA5String      (SIZE (1..200)),
                  visibleString    VisibleString  (SIZE (1..200)),
                  bmpString        BMPString      (SIZE (1..200)),
                  utf8String       UTF8String     (SIZE (1..200)) }
             </pre></p>
             @see PolicyQualifierInfo
             @see PolicyInformation
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.DisplayText.ContentTypeIA5String">
             Constant corresponding to ia5String encoding.
            
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.DisplayText.ContentTypeBmpString">
             Constant corresponding to bmpString encoding.
            
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.DisplayText.ContentTypeUtf8String">
             Constant corresponding to utf8String encoding.
            
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.DisplayText.ContentTypeVisibleString">
             Constant corresponding to visibleString encoding.
            
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.DisplayText.DisplayTextMaximumSize">
             Describe constant <code>DisplayTextMaximumSize</code> here.
            
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.DisplayText.#ctor(System.Int32,System.String)">
             Creates a new <code>DisplayText</code> instance.
            
             @param type the desired encoding type for the text.
             @param text the text to store. Strings longer than 200
             characters are truncated.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.DisplayText.#ctor(System.String)">
             Creates a new <code>DisplayText</code> instance.
            
             @param text the text to encapsulate. Strings longer than 200
             characters are truncated.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.DisplayText.#ctor(Org.BouncyCastle.Asn1.IAsn1String)">
             Creates a new <code>DisplayText</code> instance.
             <p>Useful when reading back a <code>DisplayText</code> class
             from it's Asn1Encodable form.</p>
            
             @param contents an <code>Asn1Encodable</code> instance.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.DisplayText.GetString">
             Returns the stored <code>string</code> object.
            
             @return the stored text as a <code>string</code>.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.DistributionPoint">
            The DistributionPoint object.
            <pre>
            DistributionPoint ::= Sequence {
                 distributionPoint [0] DistributionPointName OPTIONAL,
                 reasons           [1] ReasonFlags OPTIONAL,
                 cRLIssuer         [2] GeneralNames OPTIONAL
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.DistributionPointName">
            The DistributionPointName object.
            <pre>
            DistributionPointName ::= CHOICE {
                fullName                 [0] GeneralNames,
                nameRelativeToCRLIssuer  [1] RDN
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.ExtendedKeyUsage">
            The extendedKeyUsage object.
            <pre>
                 extendedKeyUsage ::= Sequence SIZE (1..MAX) OF KeyPurposeId
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.ExtendedKeyUsage.GetAllUsages">
            Returns all extended key usages.
            The returned ArrayList contains DerObjectIdentifier instances.
            @return An ArrayList with all key purposes.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.GeneralName">
             The GeneralName object.
             <pre>
             GeneralName ::= CHOICE {
                  otherName                       [0]     OtherName,
                  rfc822Name                      [1]     IA5String,
                  dNSName                         [2]     IA5String,
                  x400Address                     [3]     ORAddress,
                  directoryName                   [4]     Name,
                  ediPartyName                    [5]     EDIPartyName,
                  uniformResourceIdentifier       [6]     IA5String,
                  iPAddress                       [7]     OCTET STRING,
                  registeredID                    [8]     OBJECT IDENTIFIER}
            
             OtherName ::= Sequence {
                  type-id    OBJECT IDENTIFIER,
                  value      [0] EXPLICIT ANY DEFINED BY type-id }
            
             EDIPartyName ::= Sequence {
                  nameAssigner            [0]     DirectoryString OPTIONAL,
                  partyName               [1]     DirectoryString }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.GeneralName.#ctor(Org.BouncyCastle.Asn1.Asn1Object,System.Int32)">
             When the subjectAltName extension contains an Internet mail address,
             the address MUST be included as an rfc822Name. The format of an
             rfc822Name is an "addr-spec" as defined in RFC 822 [RFC 822].
            
             When the subjectAltName extension contains a domain name service
             label, the domain name MUST be stored in the dNSName (an IA5String).
             The name MUST be in the "preferred name syntax," as specified by RFC
             1034 [RFC 1034].
            
             When the subjectAltName extension contains a URI, the name MUST be
             stored in the uniformResourceIdentifier (an IA5String). The name MUST
             be a non-relative URL, and MUST follow the URL syntax and encoding
             rules specified in [RFC 1738].  The name must include both a scheme
             (e.g., "http" or "ftp") and a scheme-specific-part.  The scheme-
             specific-part must include a fully qualified domain name or IP
             address as the host.
            
             When the subjectAltName extension contains a iPAddress, the address
             MUST be stored in the octet string in "network byte order," as
             specified in RFC 791 [RFC 791]. The least significant bit (LSB) of
             each octet is the LSB of the corresponding byte in the network
             address. For IP Version 4, as specified in RFC 791, the octet string
             MUST contain exactly four octets.  For IP Version 6, as specified in
             RFC 1883, the octet string MUST contain exactly sixteen octets [RFC
             1883].
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.GeneralName.#ctor(System.Int32,System.String)">
             Create a GeneralName for the given tag from the passed in string.
             <p>
             This constructor can handle:
             <ul>
             <li>rfc822Name</li>
             <li>iPAddress</li>
             <li>directoryName</li>
             <li>dNSName</li>
             <li>uniformResourceIdentifier</li>
             <li>registeredID</li>
             </ul>
             For x400Address, otherName and ediPartyName there is no common string
             format defined.
             </p><p>
             Note: A directory name can be encoded in different ways into a byte
             representation. Be aware of this if the byte representation is used for
             comparing results.
             </p>
            
             @param tag tag number
             @param name string representation of name
             @throws ArgumentException if the string encoding is not correct or
                         not supported.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.GeneralNames.#ctor(Org.BouncyCastle.Asn1.X509.GeneralName)">
            <summary>Construct a GeneralNames object containing one GeneralName.</summary>
            <param name="name">The name to be contained.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.GeneralNames.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            GeneralNames ::= Sequence SIZE {1..MAX} OF GeneralName
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.GeneralSubtree">
             Class for containing a restriction object subtrees in NameConstraints. See
             RFC 3280.
            
             <pre>
            
                   GeneralSubtree ::= SEQUENCE
                   {
                     baseName                    GeneralName,
                     minimum         [0]     BaseDistance DEFAULT 0,
                     maximum         [1]     BaseDistance OPTIONAL
                   }
             </pre>
            
             @see org.bouncycastle.asn1.x509.NameConstraints
            
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.GeneralSubtree.#ctor(Org.BouncyCastle.Asn1.X509.GeneralName,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
             Constructor from a given details.
            
             According RFC 3280, the minimum and maximum fields are not used with any
             name forms, thus minimum MUST be zero, and maximum MUST be absent.
             <p>
             If minimum is <code>null</code>, zero is assumed, if
             maximum is <code>null</code>, maximum is absent.</p>
            
             @param baseName
                        A restriction.
             @param minimum
                        Minimum
            
             @param maximum
                        Maximum
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.GeneralSubtree.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
            
             Returns:
            
             <pre>
                   GeneralSubtree ::= SEQUENCE
                   {
                     baseName                    GeneralName,
                     minimum         [0]     BaseDistance DEFAULT 0,
                     maximum         [1]     BaseDistance OPTIONAL
                   }
             </pre>
            
             @return a DERObject
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.Holder">
            The Holder object.
            <p>
            For an v2 attribute certificate this is:
            
            <pre>
                       Holder ::= SEQUENCE {
                             baseCertificateID   [0] IssuerSerial OPTIONAL,
                                      -- the issuer and serial number of
                                      -- the holder's Public Key Certificate
                             entityName          [1] GeneralNames OPTIONAL,
                                      -- the name of the claimant or role
                             objectDigestInfo    [2] ObjectDigestInfo OPTIONAL
                                      -- used to directly authenticate the holder,
                                      -- for example, an executable
                       }
            </pre>
            </p>
            <p>
            For an v1 attribute certificate this is:
            
            <pre>
                    subject CHOICE {
                     baseCertificateID [0] IssuerSerial,
                     -- associated with a Public Key Certificate
                     subjectName [1] GeneralNames },
                     -- associated with a name
            </pre>
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Holder.#ctor(Org.BouncyCastle.Asn1.Asn1TaggedObject)">
            Constructor for a holder for an v1 attribute certificate.
            
            @param tagObj The ASN.1 tagged holder object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Holder.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
            Constructor for a holder for an v2 attribute certificate. *
            
            @param seq The ASN.1 sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Holder.#ctor(Org.BouncyCastle.Asn1.X509.IssuerSerial,System.Int32)">
            Constructs a holder from a IssuerSerial.
            @param baseCertificateID The IssuerSerial.
            @param version The version of the attribute certificate. 
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Holder.#ctor(Org.BouncyCastle.Asn1.X509.GeneralNames)">
            Constructs a holder with an entityName for v2 attribute certificates or
            with a subjectName for v1 attribute certificates.
            
            @param entityName The entity or subject name.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Holder.#ctor(Org.BouncyCastle.Asn1.X509.GeneralNames,System.Int32)">
            Constructs a holder with an entityName for v2 attribute certificates or
            with a subjectName for v1 attribute certificates.
            
            @param entityName The entity or subject name.
            @param version The version of the attribute certificate. 
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Holder.#ctor(Org.BouncyCastle.Asn1.X509.ObjectDigestInfo)">
            Constructs a holder from an object digest info.
            
            @param objectDigestInfo The object digest info object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Holder.ToAsn1Object">
            The Holder object.
            <pre>
             Holder ::= Sequence {
                   baseCertificateID   [0] IssuerSerial OPTIONAL,
                            -- the issuer and serial number of
                            -- the holder's Public Key Certificate
                   entityName          [1] GeneralNames OPTIONAL,
                            -- the name of the claimant or role
                   objectDigestInfo    [2] ObjectDigestInfo OPTIONAL
                            -- used to directly authenticate the holder,
                            -- for example, an executable
             }
            </pre>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.Holder.Version">
            Returns 1 for v2 attribute certificates or 0 for v1 attribute
            certificates. 
            @return The version of the attribute certificate.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.Holder.EntityName">
            Returns the entityName for an v2 attribute certificate or the subjectName
            for an v1 attribute certificate.
            
            @return The entityname or subjectname.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.IetfAttrSyntax">
            Implementation of <code>IetfAttrSyntax</code> as specified by RFC3281.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.IetfAttrSyntax.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
            
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.IetfAttrSyntax.ToAsn1Object">
            
             <pre>
            
              IetfAttrSyntax ::= Sequence {
                policyAuthority [0] GeneralNames OPTIONAL,
                values Sequence OF CHOICE {
                  octets OCTET STRING,
                  oid OBJECT IDENTIFIER,
                  string UTF8String
                }
              }
            
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.IssuerSerial.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             IssuerSerial  ::=  Sequence {
                  issuer         GeneralNames,
                  serial         CertificateSerialNumber,
                  issuerUid      UniqueIdentifier OPTIONAL
             }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.IssuingDistributionPoint">
            <pre>
            IssuingDistributionPoint ::= SEQUENCE { 
              distributionPoint          [0] DistributionPointName OPTIONAL, 
              onlyContainsUserCerts      [1] BOOLEAN DEFAULT FALSE, 
              onlyContainsCACerts        [2] BOOLEAN DEFAULT FALSE, 
              onlySomeReasons            [3] ReasonFlags OPTIONAL, 
              indirectCRL                [4] BOOLEAN DEFAULT FALSE,
              onlyContainsAttributeCerts [5] BOOLEAN DEFAULT FALSE }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.IssuingDistributionPoint.#ctor(Org.BouncyCastle.Asn1.X509.DistributionPointName,System.Boolean,System.Boolean,Org.BouncyCastle.Asn1.X509.ReasonFlags,System.Boolean,System.Boolean)">
            Constructor from given details.
            
            @param distributionPoint
                       May contain an URI as pointer to most current CRL.
            @param onlyContainsUserCerts Covers revocation information for end certificates.
            @param onlyContainsCACerts Covers revocation information for CA certificates.
            
            @param onlySomeReasons
                       Which revocation reasons does this point cover.
            @param indirectCRL
                       If <code>true</code> then the CRL contains revocation
                       information about certificates ssued by other CAs.
            @param onlyContainsAttributeCerts Covers revocation information for attribute certificates.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.IssuingDistributionPoint.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
            Constructor from Asn1Sequence
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.IssuingDistributionPoint.DistributionPoint">
            @return Returns the distributionPoint.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.IssuingDistributionPoint.OnlySomeReasons">
            @return Returns the onlySomeReasons.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.KeyPurposeID">
            The KeyPurposeID object.
            <pre>
                KeyPurposeID ::= OBJECT IDENTIFIER
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.KeyUsage">
             The KeyUsage object.
             <pre>
                id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 }
            
                KeyUsage ::= BIT STRING {
                     digitalSignature        (0),
                     nonRepudiation          (1),
                     keyEncipherment         (2),
                     dataEncipherment        (3),
                     keyAgreement            (4),
                     keyCertSign             (5),
                     cRLSign                 (6),
                     encipherOnly            (7),
                     decipherOnly            (8) }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.KeyUsage.#ctor(System.Int32)">
             Basic constructor.
            
             @param usage - the bitwise OR of the Key Usage flags giving the
             allowed uses for the key.
             e.g. (KeyUsage.keyEncipherment | KeyUsage.dataEncipherment)
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.NameConstraints.#ctor(System.Collections.IList,System.Collections.IList)">
             Constructor from a given details.
            
             <p>permitted and excluded are Vectors of GeneralSubtree objects.</p>
            
             @param permitted Permitted subtrees
             @param excluded Excluded subtrees
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.NoticeReference">
             <code>NoticeReference</code> class, used in
             <code>CertificatePolicies</code> X509 V3 extensions
             (in policy qualifiers).
            
             <pre>
              NoticeReference ::= Sequence {
                  organization     DisplayText,
                  noticeNumbers    Sequence OF Integer }
            
             </pre>
            
             @see PolicyQualifierInfo
             @see PolicyInformation
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.NoticeReference.#ctor(System.String,System.Collections.IList)">
             Creates a new <code>NoticeReference</code> instance.
            
             @param organization a <code>String</code> value
             @param numbers a <code>Vector</code> value
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.NoticeReference.#ctor(System.String,Org.BouncyCastle.Asn1.Asn1EncodableVector)">
             Creates a new <code>NoticeReference</code> instance.
            
             @param organization a <code>String</code> value
             @param noticeNumbers an <code>ASN1EncodableVector</code> value
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.NoticeReference.#ctor(Org.BouncyCastle.Asn1.X509.DisplayText,Org.BouncyCastle.Asn1.Asn1EncodableVector)">
             Creates a new <code>NoticeReference</code> instance.
            
             @param organization displayText
             @param noticeNumbers an <code>ASN1EncodableVector</code> value
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.NoticeReference.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Creates a new <code>NoticeReference</code> instance.
             <p>Useful for reconstructing a <code>NoticeReference</code>
             instance from its encodable/encoded form.</p>
            
             @param as an <code>Asn1Sequence</code> value obtained from either
             calling @{link ToAsn1Object()} for a <code>NoticeReference</code>
             instance or from parsing it from a Der-encoded stream.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.NoticeReference.ToAsn1Object">
             Describe <code>ToAsn1Object</code> method here.
            
             @return a <code>Asn1Object</code> value
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.ObjectDigestInfo">
            ObjectDigestInfo ASN.1 structure used in v2 attribute certificates.
            
            <pre>
             
               ObjectDigestInfo ::= SEQUENCE {
                    digestedObjectType  ENUMERATED {
                            publicKey            (0),
                            publicKeyCert        (1),
                            otherObjectTypes     (2) },
                                    -- otherObjectTypes MUST NOT
                                    -- be used in this profile
                    otherObjectTypeID   OBJECT IDENTIFIER OPTIONAL,
                    digestAlgorithm     AlgorithmIdentifier,
                    objectDigest        BIT STRING
               }
              
            </pre>
            
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.ObjectDigestInfo.PublicKey">
            The public key is hashed.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.ObjectDigestInfo.PublicKeyCert">
            The public key certificate is hashed.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.ObjectDigestInfo.OtherObjectDigest">
            An other object is hashed.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.ObjectDigestInfo.#ctor(System.Int32,System.String,Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier,System.Byte[])">
            Constructor from given details.
            <p>
            If <code>digestedObjectType</code> is not {@link #publicKeyCert} or
            {@link #publicKey} <code>otherObjectTypeID</code> must be given,
            otherwise it is ignored.</p>
            
            @param digestedObjectType The digest object type.
            @param otherObjectTypeID The object type ID for
                       <code>otherObjectDigest</code>.
            @param digestAlgorithm The algorithm identifier for the hash.
            @param objectDigest The hash value.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.ObjectDigestInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            
            <pre>
             
               ObjectDigestInfo ::= SEQUENCE {
                    digestedObjectType  ENUMERATED {
                            publicKey            (0),
                            publicKeyCert        (1),
                            otherObjectTypes     (2) },
                                    -- otherObjectTypes MUST NOT
                                    -- be used in this profile
                    otherObjectTypeID   OBJECT IDENTIFIER OPTIONAL,
                    digestAlgorithm     AlgorithmIdentifier,
                    objectDigest        BIT STRING
               }
              
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.PolicyMappings">
             PolicyMappings V3 extension, described in RFC3280.
             <pre>
                PolicyMappings ::= Sequence SIZE (1..MAX) OF Sequence {
                  issuerDomainPolicy      CertPolicyId,
                  subjectDomainPolicy     CertPolicyId }
             </pre>
            
             @see <a href="http://www.faqs.org/rfc/rfc3280.txt">RFC 3280, section 4.2.1.6</a>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.PolicyMappings.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Creates a new <code>PolicyMappings</code> instance.
            
             @param seq an <code>Asn1Sequence</code> constructed as specified
             in RFC 3280
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.PolicyMappings.#ctor(System.Collections.IDictionary)">
             Creates a new <code>PolicyMappings</code> instance.
            
             @param mappings a <code>HashMap</code> value that maps
             <code>string</code> oids
             to other <code>string</code> oids.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.PolicyQualifierID">
             PolicyQualifierId, used in the CertificatePolicies
             X509V3 extension.
            
             <pre>
                id-qt          OBJECT IDENTIFIER ::=  { id-pkix 2 }
                id-qt-cps      OBJECT IDENTIFIER ::=  { id-qt 1 }
                id-qt-unotice  OBJECT IDENTIFIER ::=  { id-qt 2 }
              PolicyQualifierId ::=
                   OBJECT IDENTIFIER ( id-qt-cps | id-qt-unotice )
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.PolicyQualifierInfo">
             Policy qualifiers, used in the X509V3 CertificatePolicies
             extension.
            
             <pre>
               PolicyQualifierInfo ::= Sequence {
                   policyQualifierId  PolicyQualifierId,
                   qualifier          ANY DEFINED BY policyQualifierId }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.PolicyQualifierInfo.#ctor(Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Asn1.Asn1Encodable)">
             Creates a new <code>PolicyQualifierInfo</code> instance.
            
             @param policyQualifierId a <code>PolicyQualifierId</code> value
             @param qualifier the qualifier, defined by the above field.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.PolicyQualifierInfo.#ctor(System.String)">
             Creates a new <code>PolicyQualifierInfo</code> containing a
             cPSuri qualifier.
            
             @param cps the CPS (certification practice statement) uri as a
             <code>string</code>.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.PolicyQualifierInfo.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Creates a new <code>PolicyQualifierInfo</code> instance.
            
             @param as <code>PolicyQualifierInfo</code> X509 structure
             encoded as an Asn1Sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.PolicyQualifierInfo.ToAsn1Object">
             Returns a Der-encodable representation of this instance.
            
             @return a <code>Asn1Object</code> value
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.PrivateKeyUsagePeriod">
            <remarks>
            <pre>
            PrivateKeyUsagePeriod ::= SEQUENCE
            {
            notBefore       [0]     GeneralizedTime OPTIONAL,
            notAfter        [1]     GeneralizedTime OPTIONAL }
            </pre>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.Qualified.BiometricData">
            The BiometricData object.
            <pre>
            BiometricData  ::=  SEQUENCE {
                  typeOfBiometricData  TypeOfBiometricData,
                  hashAlgorithm        AlgorithmIdentifier,
                  biometricDataHash    OCTET STRING,
                  sourceDataUri        IA5String OPTIONAL  }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.Qualified.Iso4217CurrencyCode">
            The Iso4217CurrencyCode object.
            <pre>
            Iso4217CurrencyCode  ::=  CHOICE {
                  alphabetic              PrintableString (SIZE 3), --Recommended
                  numeric              INTEGER (1..999) }
            -- Alphabetic or numeric currency code as defined in ISO 4217
            -- It is recommended that the Alphabetic form is used
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.Qualified.MonetaryValue">
            The MonetaryValue object.
            <pre>
            MonetaryValue  ::=  SEQUENCE {
                  currency              Iso4217CurrencyCode,
                  amount               INTEGER,
                  exponent             INTEGER }
            -- value = amount * 10^exponent
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.Qualified.QCStatement">
            The QCStatement object.
            <pre>
            QCStatement ::= SEQUENCE {
              statementId        OBJECT IDENTIFIER,
              statementInfo      ANY DEFINED BY statementId OPTIONAL}
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.Qualified.SemanticsInformation">
             The SemanticsInformation object.
             <pre>
                   SemanticsInformation ::= SEQUENCE {
                     semanticsIdentifier        OBJECT IDENTIFIER   OPTIONAL,
                     nameRegistrationAuthorities NameRegistrationAuthorities
                                                                     OPTIONAL }
                     (WITH COMPONENTS {..., semanticsIdentifier PRESENT}|
                      WITH COMPONENTS {..., nameRegistrationAuthorities PRESENT})
            
                 NameRegistrationAuthorities ::=  SEQUENCE SIZE (1..MAX) OF
                     GeneralName
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.Qualified.TypeOfBiometricData">
             The TypeOfBiometricData object.
             <pre>
             TypeOfBiometricData ::= CHOICE {
               predefinedBiometricType   PredefinedBiometricType,
               biometricDataOid          OBJECT IDENTIFIER }
            
             PredefinedBiometricType ::= INTEGER {
               picture(0),handwritten-signature(1)}
               (picture|handwritten-signature)
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.ReasonFlags">
            The ReasonFlags object.
            <pre>
            ReasonFlags ::= BIT STRING {
               unused(0),
               keyCompromise(1),
               cACompromise(2),
               affiliationChanged(3),
               superseded(4),
               cessationOfOperation(5),
               certficateHold(6)
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.ReasonFlags.#ctor(System.Int32)">
            @param reasons - the bitwise OR of the Key Reason flags giving the
            allowed uses for the key.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.RoleSyntax">
             Implementation of the RoleSyntax object as specified by the RFC3281.
            
             <pre>
             RoleSyntax ::= SEQUENCE {
                             roleAuthority  [0] GeneralNames OPTIONAL,
                             roleName       [1] GeneralName
                       }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.RoleSyntax.GetInstance(System.Object)">
            RoleSyntax factory method.
            @param obj the object used to construct an instance of <code>
            RoleSyntax</code>. It must be an instance of <code>RoleSyntax
            </code> or <code>Asn1Sequence</code>.
            @return the instance of <code>RoleSyntax</code> built from the
            supplied object.
            @throws java.lang.ArgumentException if the object passed
            to the factory is not an instance of <code>RoleSyntax</code> or
            <code>Asn1Sequence</code>.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.RoleSyntax.#ctor(Org.BouncyCastle.Asn1.X509.GeneralNames,Org.BouncyCastle.Asn1.X509.GeneralName)">
            Constructor.
            @param roleAuthority the role authority of this RoleSyntax.
            @param roleName    the role name of this RoleSyntax.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.RoleSyntax.#ctor(Org.BouncyCastle.Asn1.X509.GeneralName)">
            Constructor. Invoking this constructor is the same as invoking
            <code>new RoleSyntax(null, roleName)</code>.
            @param roleName    the role name of this RoleSyntax.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.RoleSyntax.#ctor(System.String)">
            Utility constructor. Takes a <code>string</code> argument representing
            the role name, builds a <code>GeneralName</code> to hold the role name
            and calls the constructor that takes a <code>GeneralName</code>.
            @param roleName
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.RoleSyntax.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
            Constructor that builds an instance of <code>RoleSyntax</code> by
            extracting the encoded elements from the <code>Asn1Sequence</code>
            object supplied.
            @param seq    an instance of <code>Asn1Sequence</code> that holds
            the encoded elements used to build this <code>RoleSyntax</code>.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.RoleSyntax.GetRoleNameAsString">
            Gets the role name as a <code>java.lang.string</code> object.
            @return    the role name of this RoleSyntax represented as a
            <code>string</code> object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.RoleSyntax.GetRoleAuthorityAsString">
            Gets the role authority as a <code>string[]</code> object.
            @return the role authority of this RoleSyntax represented as a
            <code>string[]</code> array.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.RoleSyntax.ToAsn1Object">
             Implementation of the method <code>ToAsn1Object</code> as
             required by the superclass <code>ASN1Encodable</code>.
            
             <pre>
             RoleSyntax ::= SEQUENCE {
                             roleAuthority  [0] GeneralNames OPTIONAL,
                             roleName       [1] GeneralName
                       }
             </pre>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.RoleSyntax.RoleAuthority">
            Gets the role authority of this RoleSyntax.
            @return    an instance of <code>GeneralNames</code> holding the
            role authority of this RoleSyntax.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.RoleSyntax.RoleName">
            Gets the role name of this RoleSyntax.
            @return    an instance of <code>GeneralName</code> holding the
            role name of this RoleSyntax.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.RsaPublicKeyStructure.ToAsn1Object">
            This outputs the key in Pkcs1v2 format.
            <pre>
                 RSAPublicKey ::= Sequence {
                                     modulus Integer, -- n
                                     publicExponent Integer, -- e
                                 }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.SigI.NameOrPseudonym">
            Structure for a name or pseudonym.
            
            <pre>
                  NameOrPseudonym ::= CHOICE {
                	   surAndGivenName SEQUENCE {
                	     surName DirectoryString,
                	     givenName SEQUENCE OF DirectoryString 
                    },
                	   pseudonym DirectoryString 
                  }
            </pre>
            
            @see org.bouncycastle.asn1.x509.sigi.PersonalData
            
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SigI.NameOrPseudonym.#ctor(Org.BouncyCastle.Asn1.X500.DirectoryString)">
            Constructor from DERString.
            <p/>
            The sequence is of type NameOrPseudonym:
            <p/>
            <pre>
                  NameOrPseudonym ::= CHOICE {
                	   surAndGivenName SEQUENCE {
                	     surName DirectoryString,
                	     givenName SEQUENCE OF DirectoryString
                    },
                	   pseudonym DirectoryString
                  }
            </pre>
            @param pseudonym pseudonym value to use.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SigI.NameOrPseudonym.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             The sequence is of type NameOrPseudonym:
             <p/>
             <pre>
                   NameOrPseudonym ::= CHOICE {
                 	   surAndGivenName SEQUENCE {
                 	     surName DirectoryString,
                 	     givenName SEQUENCE OF DirectoryString
                     },
                 	   pseudonym DirectoryString
                   }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SigI.NameOrPseudonym.#ctor(System.String)">
             Constructor from a given details.
            
             @param pseudonym The pseudonym.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SigI.NameOrPseudonym.#ctor(Org.BouncyCastle.Asn1.X500.DirectoryString,Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from a given details.
            
             @param surname   The surname.
             @param givenName A sequence of directory strings making up the givenName
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SigI.NameOrPseudonym.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                   NameOrPseudonym ::= CHOICE {
                 	   surAndGivenName SEQUENCE {
                 	     surName DirectoryString,
                 	     givenName SEQUENCE OF DirectoryString
                     },
                 	   pseudonym DirectoryString
                   }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.SigI.PersonalData">
             Contains personal data for the otherName field in the subjectAltNames
             extension.
             <p/>
             <pre>
                 PersonalData ::= SEQUENCE {
                   nameOrPseudonym NameOrPseudonym,
                   nameDistinguisher [0] INTEGER OPTIONAL,
                   dateOfBirth [1] GeneralizedTime OPTIONAL,
                   placeOfBirth [2] DirectoryString OPTIONAL,
                   gender [3] PrintableString OPTIONAL,
                   postalAddress [4] DirectoryString OPTIONAL
                   }
             </pre>
            
             @see org.bouncycastle.asn1.x509.sigi.NameOrPseudonym
             @see org.bouncycastle.asn1.x509.sigi.SigIObjectIdentifiers
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SigI.PersonalData.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
             <p/>
             The sequence is of type NameOrPseudonym:
             <p/>
             <pre>
                 PersonalData ::= SEQUENCE {
                   nameOrPseudonym NameOrPseudonym,
                   nameDistinguisher [0] INTEGER OPTIONAL,
                   dateOfBirth [1] GeneralizedTime OPTIONAL,
                   placeOfBirth [2] DirectoryString OPTIONAL,
                   gender [3] PrintableString OPTIONAL,
                   postalAddress [4] DirectoryString OPTIONAL
                   }
             </pre>
            
             @param seq The ASN.1 sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SigI.PersonalData.#ctor(Org.BouncyCastle.Asn1.X509.SigI.NameOrPseudonym,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Asn1.DerGeneralizedTime,Org.BouncyCastle.Asn1.X500.DirectoryString,System.String,Org.BouncyCastle.Asn1.X500.DirectoryString)">
             Constructor from a given details.
            
             @param nameOrPseudonym  Name or pseudonym.
             @param nameDistinguisher Name distinguisher.
             @param dateOfBirth      Date of birth.
             @param placeOfBirth     Place of birth.
             @param gender           Gender.
             @param postalAddress    Postal Address.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SigI.PersonalData.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
             <p/>
             Returns:
             <p/>
             <pre>
                 PersonalData ::= SEQUENCE {
                   nameOrPseudonym NameOrPseudonym,
                   nameDistinguisher [0] INTEGER OPTIONAL,
                   dateOfBirth [1] GeneralizedTime OPTIONAL,
                   placeOfBirth [2] DirectoryString OPTIONAL,
                   gender [3] PrintableString OPTIONAL,
                   postalAddress [4] DirectoryString OPTIONAL
                   }
             </pre>
            
             @return an Asn1Object
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.SigI.SigIObjectIdentifiers">
            Object Identifiers of SigI specifciation (German Signature Law
            Interoperability specification).
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.SigI.SigIObjectIdentifiers.IdSigIKP">
            Key purpose IDs for German SigI (Signature Interoperability
            Specification)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.SigI.SigIObjectIdentifiers.IdSigICP">
            Certificate policy IDs for German SigI (Signature Interoperability
            Specification)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.SigI.SigIObjectIdentifiers.IdSigION">
            Other Name IDs for German SigI (Signature Interoperability Specification)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.SigI.SigIObjectIdentifiers.IdSigIKPDirectoryService">
            To be used for for the generation of directory service certificates.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.SigI.SigIObjectIdentifiers.IdSigIONPersonalData">
            ID for PersonalData
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.SigI.SigIObjectIdentifiers.IdSigICPSigConform">
            Certificate is conform to german signature law.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.SubjectDirectoryAttributes">
             This extension may contain further X.500 attributes of the subject. See also
             RFC 3039.
            
             <pre>
                 SubjectDirectoryAttributes ::= Attributes
                 Attributes ::= SEQUENCE SIZE (1..MAX) OF Attribute
                 Attribute ::= SEQUENCE
                 {
                   type AttributeType
                   values SET OF AttributeValue
                 }
            
                 AttributeType ::= OBJECT IDENTIFIER
                 AttributeValue ::= ANY DEFINED BY AttributeType
             </pre>
            
             @see org.bouncycastle.asn1.x509.X509Name for AttributeType ObjectIdentifiers.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SubjectDirectoryAttributes.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
            
             The sequence is of type SubjectDirectoryAttributes:
            
             <pre>
                  SubjectDirectoryAttributes ::= Attributes
                  Attributes ::= SEQUENCE SIZE (1..MAX) OF Attribute
                  Attribute ::= SEQUENCE
                  {
                    type AttributeType
                    values SET OF AttributeValue
                  }
            
                  AttributeType ::= OBJECT IDENTIFIER
                  AttributeValue ::= ANY DEFINED BY AttributeType
             </pre>
            
             @param seq
                        The ASN.1 sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SubjectDirectoryAttributes.#ctor(System.Collections.IList)">
             Constructor from an ArrayList of attributes.
            
             The ArrayList consists of attributes of type {@link Attribute Attribute}
            
             @param attributes The attributes.
            
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SubjectDirectoryAttributes.ToAsn1Object">
             Produce an object suitable for an Asn1OutputStream.
            
             Returns:
            
             <pre>
                  SubjectDirectoryAttributes ::= Attributes
                  Attributes ::= SEQUENCE SIZE (1..MAX) OF Attribute
                  Attribute ::= SEQUENCE
                  {
                    type AttributeType
                    values SET OF AttributeValue
                  }
            
                  AttributeType ::= OBJECT IDENTIFIER
                  AttributeValue ::= ANY DEFINED BY AttributeType
             </pre>
            
             @return a DERObject
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.SubjectDirectoryAttributes.Attributes">
            @return Returns the attributes.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.SubjectKeyIdentifier">
            The SubjectKeyIdentifier object.
            <pre>
            SubjectKeyIdentifier::= OCTET STRING
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SubjectKeyIdentifier.#ctor(Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
             Calculates the keyIdentifier using a SHA1 hash over the BIT STRING
             from SubjectPublicKeyInfo as defined in RFC3280.
            
             @param spki the subject public key info.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SubjectKeyIdentifier.CreateSha1KeyIdentifier(Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
            Return a RFC 3280 type 1 key identifier. As in:
            <pre>
            (1) The keyIdentifier is composed of the 160-bit SHA-1 hash of the
            value of the BIT STRING subjectPublicKey (excluding the tag,
            length, and number of unused bits).
            </pre>
            @param keyInfo the key info object containing the subjectPublicKey field.
            @return the key identifier.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SubjectKeyIdentifier.CreateTruncatedSha1KeyIdentifier(Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
            Return a RFC 3280 type 2 key identifier. As in:
            <pre>
            (2) The keyIdentifier is composed of a four bit type field with
            the value 0100 followed by the least significant 60 bits of the
            SHA-1 hash of the value of the BIT STRING subjectPublicKey.
            </pre>
            @param keyInfo the key info object containing the subjectPublicKey field.
            @return the key identifier.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo">
            The object that contains the public key stored in a certficate.
            <p>
            The GetEncoded() method in the public keys in the JCE produces a DER
            encoded one of these.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo.GetPublicKey">
             for when the public key is an encoded object - if the bitstring
             can't be decoded this routine raises an IOException.
            
             @exception IOException - if the bit string doesn't represent a Der
             encoded object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            SubjectPublicKeyInfo ::= Sequence {
                                     algorithm AlgorithmIdentifier,
                                     publicKey BIT STRING }
            </pre>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo.PublicKeyData">
            for when the public key is raw bits...
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.Target">
            Target structure used in target information extension for attribute
            certificates from RFC 3281.
            
            <pre>
                Target  ::= CHOICE {
                  targetName          [0] GeneralName,
                  targetGroup         [1] GeneralName,
                  targetCert          [2] TargetCert
                }
            </pre>
            
            <p>
            The targetCert field is currently not supported and must not be used
            according to RFC 3281.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Target.GetInstance(System.Object)">
            Creates an instance of a Target from the given object.
            <p>
            <code>obj</code> can be a Target or a {@link Asn1TaggedObject}</p>
            
            @param obj The object.
            @return A Target instance.
            @throws ArgumentException if the given object cannot be
                        interpreted as Target.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Target.#ctor(Org.BouncyCastle.Asn1.Asn1TaggedObject)">
            Constructor from Asn1TaggedObject.
            
            @param tagObj The tagged object.
            @throws ArgumentException if the encoding is wrong.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Target.#ctor(Org.BouncyCastle.Asn1.X509.Target.Choice,Org.BouncyCastle.Asn1.X509.GeneralName)">
             Constructor from given details.
             <p>
             Exactly one of the parameters must be not <code>null</code>.</p>
            
             @param type the choice type to apply to the name.
             @param name the general name.
             @throws ArgumentException if type is invalid.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Target.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            
            Returns:
            
            <pre>
                Target  ::= CHOICE {
                  targetName          [0] GeneralName,
                  targetGroup         [1] GeneralName,
                  targetCert          [2] TargetCert
                }
            </pre>
            
            @return an Asn1Object
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.Target.TargetGroup">
            @return Returns the targetGroup.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.Target.TargetName">
            @return Returns the targetName.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.TargetInformation">
            Target information extension for attributes certificates according to RFC
            3281.
            
            <pre>
                      SEQUENCE OF Targets
            </pre>
            
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.TargetInformation.GetInstance(System.Object)">
            Creates an instance of a TargetInformation from the given object.
            <p>
            <code>obj</code> can be a TargetInformation or a {@link Asn1Sequence}</p>
            
            @param obj The object.
            @return A TargetInformation instance.
            @throws ArgumentException if the given object cannot be interpreted as TargetInformation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.TargetInformation.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
            Constructor from a Asn1Sequence.
            
            @param seq The Asn1Sequence.
            @throws ArgumentException if the sequence does not contain
                        correctly encoded Targets elements.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.TargetInformation.GetTargetsObjects">
            Returns the targets in this target information extension.
            <p>
            The ArrayList is cloned before it is returned.</p>
            
            @return Returns the targets.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.TargetInformation.#ctor(Org.BouncyCastle.Asn1.X509.Targets)">
            Constructs a target information from a single targets element. 
            According to RFC 3281 only one targets element must be produced.
            
            @param targets A Targets instance.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.TargetInformation.#ctor(Org.BouncyCastle.Asn1.X509.Target[])">
             According to RFC 3281 only one targets element must be produced. If
             multiple targets are given they must be merged in
             into one targets element.
            
             @param targets An array with {@link Targets}.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.TargetInformation.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            
            Returns:
            
            <pre>
                     SEQUENCE OF Targets
            </pre>
            
            <p>
            According to RFC 3281 only one targets element must be produced. If
            multiple targets are given in the constructor they are merged into one
            targets element. If this was produced from a
            {@link Org.BouncyCastle.Asn1.Asn1Sequence} the encoding is kept.</p>
            
            @return an Asn1Object
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.Targets">
            Targets structure used in target information extension for attribute
            certificates from RFC 3281.
            
            <pre>
                       Targets ::= SEQUENCE OF Target
                      
                       Target  ::= CHOICE {
                         targetName          [0] GeneralName,
                         targetGroup         [1] GeneralName,
                         targetCert          [2] TargetCert
                       }
                      
                       TargetCert  ::= SEQUENCE {
                         targetCertificate    IssuerSerial,
                         targetName           GeneralName OPTIONAL,
                         certDigestInfo       ObjectDigestInfo OPTIONAL
                       }
            </pre>
            
            @see org.bouncycastle.asn1.x509.Target
            @see org.bouncycastle.asn1.x509.TargetInformation
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Targets.GetInstance(System.Object)">
            Creates an instance of a Targets from the given object.
            <p>
            <code>obj</code> can be a Targets or a {@link Asn1Sequence}</p>
            
            @param obj The object.
            @return A Targets instance.
            @throws ArgumentException if the given object cannot be interpreted as Target.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Targets.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
            Constructor from Asn1Sequence.
            
            @param targets The ASN.1 SEQUENCE.
            @throws ArgumentException if the contents of the sequence are
                        invalid.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Targets.#ctor(Org.BouncyCastle.Asn1.X509.Target[])">
            Constructor from given targets.
            <p>
            The ArrayList is copied.</p>
            
            @param targets An <code>ArrayList</code> of {@link Target}s.
            @see Target
            @throws ArgumentException if the ArrayList contains not only Targets.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Targets.GetTargets">
            Returns the targets in an <code>ArrayList</code>.
            <p>
            The ArrayList is cloned before it is returned.</p>
            
            @return Returns the targets.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Targets.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            
            Returns:
            
            <pre>
                       Targets ::= SEQUENCE OF Target
            </pre>
            
            @return an Asn1Object
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.TbsCertificateStructure">
            The TbsCertificate object.
            <pre>
            TbsCertificate ::= Sequence {
                 version          [ 0 ]  Version DEFAULT v1(0),
                 serialNumber            CertificateSerialNumber,
                 signature               AlgorithmIdentifier,
                 issuer                  Name,
                 validity                Validity,
                 subject                 Name,
                 subjectPublicKeyInfo    SubjectPublicKeyInfo,
                 issuerUniqueID    [ 1 ] IMPLICIT UniqueIdentifier OPTIONAL,
                 subjectUniqueID   [ 2 ] IMPLICIT UniqueIdentifier OPTIONAL,
                 extensions        [ 3 ] Extensions OPTIONAL
                 }
            </pre>
            <p>
            Note: issuerUniqueID and subjectUniqueID are both deprecated by the IETF. This class
            will parse them, but you really shouldn't be creating new ones.</p>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.TbsCertificateList">
            PKIX RFC-2459 - TbsCertList object.
            <pre>
            TbsCertList  ::=  Sequence  {
                 version                 Version OPTIONAL,
                                              -- if present, shall be v2
                 signature               AlgorithmIdentifier,
                 issuer                  Name,
                 thisUpdate              Time,
                 nextUpdate              Time OPTIONAL,
                 revokedCertificates     Sequence OF Sequence  {
                      userCertificate         CertificateSerialNumber,
                      revocationDate          Time,
                      crlEntryExtensions      Extensions OPTIONAL
                                                    -- if present, shall be v2
                                           }  OPTIONAL,
                 crlExtensions           [0]  EXPLICIT Extensions OPTIONAL
                                                    -- if present, shall be v2
                                           }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Time.#ctor(System.DateTime)">
            creates a time object from a given date - if the date is between 1950
            and 2049 a UTCTime object is Generated, otherwise a GeneralizedTime
            is used.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Time.ToDateTime">
            <summary>
            Return our time as DateTime.
            </summary>
            <returns>A date time.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Time.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Time ::= CHOICE {
                        utcTime        UTCTime,
                        generalTime    GeneralizedTime }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.UserNotice">
             <code>UserNotice</code> class, used in
             <code>CertificatePolicies</code> X509 extensions (in policy
             qualifiers).
             <pre>
             UserNotice ::= Sequence {
                  noticeRef        NoticeReference OPTIONAL,
                  explicitText     DisplayText OPTIONAL}
            
             </pre>
            
             @see PolicyQualifierId
             @see PolicyInformation
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.UserNotice.#ctor(Org.BouncyCastle.Asn1.X509.NoticeReference,Org.BouncyCastle.Asn1.X509.DisplayText)">
             Creates a new <code>UserNotice</code> instance.
            
             @param noticeRef a <code>NoticeReference</code> value
             @param explicitText a <code>DisplayText</code> value
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.UserNotice.#ctor(Org.BouncyCastle.Asn1.X509.NoticeReference,System.String)">
             Creates a new <code>UserNotice</code> instance.
            
             @param noticeRef a <code>NoticeReference</code> value
             @param str the explicitText field as a string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.UserNotice.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Creates a new <code>UserNotice</code> instance.
             <p>Useful from reconstructing a <code>UserNotice</code> instance
             from its encodable/encoded form.
            
             @param as an <code>ASN1Sequence</code> value obtained from either
             calling @{link toASN1Object()} for a <code>UserNotice</code>
             instance or from parsing it from a DER-encoded stream.</p>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.V1TbsCertificateGenerator">
             Generator for Version 1 TbsCertificateStructures.
             <pre>
             TbsCertificate ::= Sequence {
                  version          [ 0 ]  Version DEFAULT v1(0),
                  serialNumber            CertificateSerialNumber,
                  signature               AlgorithmIdentifier,
                  issuer                  Name,
                  validity                Validity,
                  subject                 Name,
                  subjectPublicKeyInfo    SubjectPublicKeyInfo,
                  }
             </pre>
            
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.V2AttributeCertificateInfoGenerator">
             Generator for Version 2 AttributeCertificateInfo
             <pre>
             AttributeCertificateInfo ::= Sequence {
                   version              AttCertVersion -- version is v2,
                   holder               Holder,
                   issuer               AttCertIssuer,
                   signature            AlgorithmIdentifier,
                   serialNumber         CertificateSerialNumber,
                   attrCertValidityPeriod   AttCertValidityPeriod,
                   attributes           Sequence OF Attr,
                   issuerUniqueID       UniqueIdentifier OPTIONAL,
                   extensions           Extensions OPTIONAL
             }
             </pre>
            
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.V2AttributeCertificateInfoGenerator.AddAttribute(Org.BouncyCastle.Asn1.X509.AttributeX509)">
            @param attribute
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.V2Form.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             V2Form ::= Sequence {
                  issuerName            GeneralNames  OPTIONAL,
                  baseCertificateID     [0] IssuerSerial  OPTIONAL,
                  objectDigestInfo      [1] ObjectDigestInfo  OPTIONAL
                    -- issuerName MUST be present in this profile
                    -- baseCertificateID and objectDigestInfo MUST NOT
                    -- be present in this profile
             }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.V2TbsCertListGenerator">
             Generator for Version 2 TbsCertList structures.
             <pre>
              TbsCertList  ::=  Sequence  {
                   version                 Version OPTIONAL,
                                                -- if present, shall be v2
                   signature               AlgorithmIdentifier,
                   issuer                  Name,
                   thisUpdate              Time,
                   nextUpdate              Time OPTIONAL,
                   revokedCertificates     Sequence OF Sequence  {
                        userCertificate         CertificateSerialNumber,
                        revocationDate          Time,
                        crlEntryExtensions      Extensions OPTIONAL
                                                      -- if present, shall be v2
                                             }  OPTIONAL,
                   crlExtensions           [0]  EXPLICIT Extensions OPTIONAL
                                                      -- if present, shall be v2
                                             }
             </pre>
            
             <b>Note: This class may be subject to change</b>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.V3TbsCertificateGenerator">
             Generator for Version 3 TbsCertificateStructures.
             <pre>
             TbsCertificate ::= Sequence {
                  version          [ 0 ]  Version DEFAULT v1(0),
                  serialNumber            CertificateSerialNumber,
                  signature               AlgorithmIdentifier,
                  issuer                  Name,
                  validity                Validity,
                  subject                 Name,
                  subjectPublicKeyInfo    SubjectPublicKeyInfo,
                  issuerUniqueID    [ 1 ] IMPLICIT UniqueIdentifier OPTIONAL,
                  subjectUniqueID   [ 2 ] IMPLICIT UniqueIdentifier OPTIONAL,
                  extensions        [ 3 ] Extensions OPTIONAL
                  }
             </pre>
            
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509CertificateStructure">
            an X509Certificate structure.
            <pre>
             Certificate ::= Sequence {
                 tbsCertificate          TbsCertificate,
                 signatureAlgorithm      AlgorithmIdentifier,
                 signature               BIT STRING
             }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509DefaultEntryConverter">
            The default converter for X509 DN entries when going from their
            string value to ASN.1 strings.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509NameEntryConverter">
                 * It turns out that the number of standard ways the fields in a DN should be
                 * encoded into their ASN.1 counterparts is rapidly approaching the
                 * number of machines on the internet. By default the X509Name class
                 * will produce UTF8Strings in line with the current recommendations (RFC 3280).
                 * <p>
                 * An example of an encoder look like below:
                 * <pre>
                 * public class X509DirEntryConverter
                 *     : X509NameEntryConverter
                 * {
                 *     public Asn1Object GetConvertedValue(
                 *         DerObjectIdentifier  oid,
                 *         string               value)
                 *     {
                 *         if (str.Length() != 0 &amp;&amp; str.charAt(0) == '#')
                 *         {
                 *             return ConvertHexEncoded(str, 1);
                 *         }
                 *         if (oid.Equals(EmailAddress))
                 *         {
                 *             return new DerIA5String(str);
                 *         }
                 *         else if (CanBePrintable(str))
                 *         {
                 *             return new DerPrintableString(str);
                 *         }
                 *         else if (CanBeUTF8(str))
                 *         {
                 *             return new DerUtf8String(str);
                 *         }
                 *         else
                 *         {
                 *             return new DerBmpString(str);
                 *         }
                 *     }
                 * }
            	 * </pre>
            	 * </p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509NameEntryConverter.ConvertHexEncoded(System.String,System.Int32)">
             Convert an inline encoded hex string rendition of an ASN.1
             object back into its corresponding ASN.1 object.
            
             @param str the hex encoded object
             @param off the index at which the encoding starts
             @return the decoded object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509NameEntryConverter.CanBePrintable(System.String)">
            return true if the passed in string can be represented without
            loss as a PrintableString, false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509NameEntryConverter.GetConvertedValue(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.String)">
             Convert the passed in string value into the appropriate ASN.1
             encoded object.
            
             @param oid the oid associated with the value in the DN.
             @param value the value of the particular DN component.
             @return the ASN.1 equivalent for the value.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509DefaultEntryConverter.GetConvertedValue(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.String)">
             Apply default conversion for the given value depending on the oid
             and the character range of the value.
            
             @param oid the object identifier for the DN entry
             @param value the value associated with it
             @return the ASN.1 equivalent for the string value.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509Extension">
            an object for the elements in the X.509 V3 extension block.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extension.ConvertValueToObject(Org.BouncyCastle.Asn1.X509.X509Extension)">
            <sumary>Convert the value of the passed in extension to an object.</sumary>
            <param name="ext">The extension to parse.</param>
            <returns>The object the value string contains.</returns>
            <exception cref="T:System.ArgumentException">If conversion is not possible.</exception>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.SubjectDirectoryAttributes">
            Subject Directory Attributes
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.SubjectKeyIdentifier">
            Subject Key Identifier
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.KeyUsage">
            Key Usage
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.PrivateKeyUsagePeriod">
            Private Key Usage Period
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.SubjectAlternativeName">
            Subject Alternative Name
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.IssuerAlternativeName">
            Issuer Alternative Name
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.BasicConstraints">
            Basic Constraints
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.CrlNumber">
            CRL Number
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.ReasonCode">
            Reason code
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.InstructionCode">
            Hold Instruction Code
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.InvalidityDate">
            Invalidity Date
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.DeltaCrlIndicator">
            Delta CRL indicator
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.IssuingDistributionPoint">
            Issuing Distribution Point
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.CertificateIssuer">
            Certificate Issuer
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.NameConstraints">
            Name Constraints
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.CrlDistributionPoints">
            CRL Distribution Points
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.CertificatePolicies">
            Certificate Policies
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.PolicyMappings">
            Policy Mappings
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.AuthorityKeyIdentifier">
            Authority Key Identifier
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.PolicyConstraints">
            Policy Constraints
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.ExtendedKeyUsage">
            Extended Key Usage
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.FreshestCrl">
            Freshest CRL
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.InhibitAnyPolicy">
            Inhibit Any Policy
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.AuthorityInfoAccess">
            Authority Info Access
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.SubjectInfoAccess">
            Subject Info Access
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.LogoType">
            Logo Type
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.BiometricInfo">
            BiometricInfo
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.QCStatements">
            QCStatements
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.AuditIdentity">
            Audit identity extension in attribute certificates.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.NoRevAvail">
            NoRevAvail extension in attribute certificates.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.TargetInformation">
            TargetInformation extension in attribute certificates.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
            
             the extensions are a list of constructed sequences, either with (Oid, OctetString) or (Oid, Boolean, OctetString)
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.#ctor(System.Collections.IDictionary)">
            constructor from a table of extensions.
            <p>
            it's is assumed the table contains Oid/string pairs.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.#ctor(System.Collections.IList,System.Collections.IDictionary)">
            Constructor from a table of extensions with ordering.
            <p>
            It's is assumed the table contains Oid/string pairs.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.#ctor(System.Collections.IList,System.Collections.IList)">
             Constructor from two vectors
            
             @param objectIDs an ArrayList of the object identifiers.
             @param values an ArrayList of the extension values.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.#ctor(System.Collections.Hashtable)">
            constructor from a table of extensions.
            <p>
            it's is assumed the table contains Oid/string pairs.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.#ctor(System.Collections.ArrayList,System.Collections.Hashtable)">
            Constructor from a table of extensions with ordering.
            <p>
            It's is assumed the table contains Oid/string pairs.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.#ctor(System.Collections.ArrayList,System.Collections.ArrayList)">
             Constructor from two vectors
            
             @param objectIDs an ArrayList of the object identifiers.
             @param values an ArrayList of the extension values.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.GetExtension(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the extension represented by the object identifier
             passed in.
            
             @return the extension if it's present, null otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.ToAsn1Object">
             <pre>
                 Extensions        ::=   SEQUENCE SIZE (1..MAX) OF Extension
            
                 Extension         ::=   SEQUENCE {
                    extnId            EXTENSION.&amp;id ({ExtensionSet}),
                    critical          BOOLEAN DEFAULT FALSE,
                    extnValue         OCTET STRING }
             </pre>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.X509Extensions.ExtensionOids">
            return an Enumeration of the extension field's object ids.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509ExtensionsGenerator">
            <remarks>Generator for X.509 extensions</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509ExtensionsGenerator.Reset">
            <summary>Reset the generator</summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509ExtensionsGenerator.AddExtension(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,Org.BouncyCastle.Asn1.Asn1Encodable)">
            <summary>
            Add an extension with the given oid and the passed in value to be included
            in the OCTET STRING associated with the extension.
            </summary>
            <param name="oid">OID for the extension.</param>
            <param name="critical">True if critical, false otherwise.</param>
            <param name="extValue">The ASN.1 object to be included in the extension.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509ExtensionsGenerator.AddExtension(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,System.Byte[])">
            <summary>
            Add an extension with the given oid and the passed in byte array to be wrapped
            in the OCTET STRING associated with the extension.
            </summary>
            <param name="oid">OID for the extension.</param>
            <param name="critical">True if critical, false otherwise.</param>
            <param name="extValue">The byte array to be wrapped.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509ExtensionsGenerator.Generate">
            <summary>Generate an X509Extensions object based on the current state of the generator.</summary>
            <returns>An <c>X509Extensions</c> object</returns>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.X509ExtensionsGenerator.IsEmpty">
            <summary>Return true if there are no extension present in this generator.</summary>
            <returns>True if empty, false otherwise</returns>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509Name">
             <pre>
                 RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
            
                 RelativeDistinguishedName ::= SET SIZE (1..MAX) OF AttributeTypeAndValue
            
                 AttributeTypeAndValue ::= SEQUENCE {
                                               type  OBJECT IDENTIFIER,
                                               value ANY }
             </pre>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.C">
            country code - StringType(SIZE(2))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.O">
            organization - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.OU">
            organizational unit name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.T">
            Title
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.CN">
            common name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.Street">
            street - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.SerialNumber">
            device serial number name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.L">
            locality name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.ST">
            state, or province name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.Surname">
            Naming attributes of type X520name
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.BusinessCategory">
            businessCategory - DirectoryString(SIZE(1..128)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.PostalCode">
            postalCode - DirectoryString(SIZE(1..40)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.DnQualifier">
            dnQualifier - DirectoryString(SIZE(1..64)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.Pseudonym">
            RFC 3039 Pseudonym - DirectoryString(SIZE(1..64)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.DateOfBirth">
            RFC 3039 DateOfBirth - GeneralizedTime - YYYYMMDD000000Z
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.PlaceOfBirth">
            RFC 3039 PlaceOfBirth - DirectoryString(SIZE(1..128)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.Gender">
            RFC 3039 DateOfBirth - PrintableString (SIZE(1)) -- "M", "F", "m" or "f"
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.CountryOfCitizenship">
            RFC 3039 CountryOfCitizenship - PrintableString (SIZE (2)) -- ISO 3166
            codes only
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.CountryOfResidence">
            RFC 3039 CountryOfCitizenship - PrintableString (SIZE (2)) -- ISO 3166
            codes only
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.NameAtBirth">
            ISIS-MTT NameAtBirth - DirectoryString(SIZE(1..64)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.PostalAddress">
            RFC 3039 PostalAddress - SEQUENCE SIZE (1..6) OF
            DirectoryString(SIZE(1..30))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.DmdName">
            RFC 2256 dmdName
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.TelephoneNumber">
            id-at-telephoneNumber
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.Name">
            id-at-name
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.EmailAddress">
            Email address (RSA PKCS#9 extension) - IA5String.
            <p>Note: if you're trying to be ultra orthodox, don't use this! It shouldn't be in here.</p>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.UnstructuredName">
            more from PKCS#9
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.E">
            email address in Verisign certificates
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.UID">
            LDAP User id.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.DefaultSymbols">
            default look up table translating OID values into their common symbols following
            the convention in RFC 2253 with a few extras
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.RFC2253Symbols">
            look up table translating OID values into their common symbols following the convention in RFC 2253
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.RFC1779Symbols">
             look up table translating OID values into their common symbols following the convention in RFC 1779
            
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.DefaultLookup">
            look up table translating common symbols into their OIDS.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             Return a X509Name based on the passed in tagged object.
            
             @param obj tag object holding name.
             @param explicitly true if explicitly tagged false otherwise.
             @return the X509Name
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence
            
             the principal will be a list of constructed sets, each containing an (OID, string) pair.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Collections.IList,System.Collections.IDictionary)">
            Constructor from a table of attributes with ordering.
            <p>
            it's is assumed the table contains OID/string pairs, and the contents
            of the table are copied into an internal table as part of the
            construction process. The ordering ArrayList should contain the OIDs
            in the order they are meant to be encoded or printed in ToString.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Collections.IList,System.Collections.IDictionary,Org.BouncyCastle.Asn1.X509.X509NameEntryConverter)">
            Constructor from a table of attributes with ordering.
            <p>
            it's is assumed the table contains OID/string pairs, and the contents
            of the table are copied into an internal table as part of the
            construction process. The ordering ArrayList should contain the OIDs
            in the order they are meant to be encoded or printed in ToString.</p>
            <p>
            The passed in converter will be used to convert the strings into their
            ASN.1 counterparts.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Collections.IList,System.Collections.IList)">
            Takes two vectors one of the oids and the other of the values.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Collections.IList,System.Collections.IList,Org.BouncyCastle.Asn1.X509.X509NameEntryConverter)">
            Takes two vectors one of the oids and the other of the values.
            <p>
            The passed in converter will be used to convert the strings into their
            ASN.1 counterparts.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.String)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.String,Org.BouncyCastle.Asn1.X509.X509NameEntryConverter)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes with each
            string value being converted to its associated ASN.1 type using the passed
            in converter.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Boolean,System.String)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes. If reverse
            is true, create the encoded version of the sequence starting from the
            last element in the string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Boolean,System.String,Org.BouncyCastle.Asn1.X509.X509NameEntryConverter)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes with each
            string value being converted to its associated ASN.1 type using the passed
            in converter. If reverse is true the ASN.1 sequence representing the DN will
            be built by starting at the end of the string, rather than the start.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Boolean,System.Collections.IDictionary,System.String)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes. lookUp
            should provide a table of lookups, indexed by lowercase only strings and
            yielding a DerObjectIdentifier, other than that OID. and numeric oids
            will be processed automatically.
            <br/>
            If reverse is true, create the encoded version of the sequence
            starting from the last element in the string.
            @param reverse true if we should start scanning from the end (RFC 2553).
            @param lookUp table of names and their oids.
            @param dirName the X.500 string to be parsed.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Boolean,System.Collections.IDictionary,System.String,Org.BouncyCastle.Asn1.X509.X509NameEntryConverter)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes. lookUp
            should provide a table of lookups, indexed by lowercase only strings and
            yielding a DerObjectIdentifier, other than that OID. and numeric oids
            will be processed automatically. The passed in converter is used to convert the
            string values to the right of each equals sign to their ASN.1 counterparts.
            <br/>
            @param reverse true if we should start scanning from the end, false otherwise.
            @param lookUp table of names and oids.
            @param dirName the string dirName
            @param converter the converter to convert string values into their ASN.1 equivalents
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.GetOidList">
            return an IList of the oids in the name, in the order they were found.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.GetValueList">
            return an IList of the values found in the name, in the order they
            were found.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.GetValueList(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            return an IList of the values found in the name, in the order they
            were found, with the DN label corresponding to passed in oid.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.Equivalent(Org.BouncyCastle.Asn1.X509.X509Name,System.Boolean)">
            <param name="other">The X509Name object to test equivalency against.</param>
            <param name="inOrder">If true, the order of elements must be the same,
            as well as the values associated with each element.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.Equivalent(Org.BouncyCastle.Asn1.X509.X509Name)">
            test for equivalence - note: case is ignored.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.ToString(System.Boolean,System.Collections.IDictionary)">
             convert the structure to a string - if reverse is true the
             oids and values are listed out starting with the last element
             in the sequence (ala RFC 2253), otherwise the string will begin
             with the first element of the structure. If no string definition
             for the oid is found in oidSymbols the string value of the oid is
             added. Two standard symbol tables are provided DefaultSymbols, and
             RFC2253Symbols as part of this class.
            
             @param reverse if true start at the end of the sequence and work back.
             @param oidSymbols look up table strings for oids.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.X509Name.DefaultReverse">
            determines whether or not strings should be processed and printed
            from back to front.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509NameTokenizer">
            class for breaking up an X500 Name into it's component tokens, ala
            java.util.StringTokenizer. We need this class as some of the
            lightweight Java environment don't support classes like
            StringTokenizer.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.ECNamedCurveTable">
            A general class that reads all X9.62 style EC curve tables.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.ECNamedCurveTable.GetByName(System.String)">
             return a X9ECParameters object representing the passed in named
             curve. The routine returns null if the curve is not present.
            
             @param name the name of the curve requested
             @return an X9ECParameters object or null if the curve is not available.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.ECNamedCurveTable.GetOid(System.String)">
             return the object identifier signified by the passed in name. Null
             if there is no object identifier associated with name.
            
             @return the object identifier associated with name, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.ECNamedCurveTable.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return a X9ECParameters object representing the passed in named
             curve.
            
             @param oid the object id of the curve requested
             @return an X9ECParameters object or null if the curve is not available.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X9.ECNamedCurveTable.Names">
             return an enumeration of the names of the available curves.
            
             @return an enumeration of the names of the available curves.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.KeySpecificInfo">
            ASN.1 def for Diffie-Hellman key exchange KeySpecificInfo structure. See
            RFC 2631, or X9.42, for further details.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.KeySpecificInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             KeySpecificInfo ::= Sequence {
                 algorithm OBJECT IDENTIFIER,
                 counter OCTET STRING SIZE (4..4)
             }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.OtherInfo">
            ANS.1 def for Diffie-Hellman key exchange OtherInfo structure. See
            RFC 2631, or X9.42, for further details.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.OtherInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             OtherInfo ::= Sequence {
                 keyInfo KeySpecificInfo,
                 partyAInfo [0] OCTET STRING OPTIONAL,
                 suppPubInfo [2] OCTET STRING
             }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.X962NamedCurves">
            table of the current named curves defined in X.962 EC-DSA.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X962NamedCurves.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the X9ECParameters object for the named curve represented by
             the passed in object identifier. Null if the curve isn't present.
            
             @param oid an object identifier representing a named curve, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X962NamedCurves.GetOid(System.String)">
             return the object identifier signified by the passed in name. Null
             if there is no object identifier associated with name.
            
             @return the object identifier associated with name, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X962NamedCurves.GetName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            return the named curve name represented by the given object identifier.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X9.X962NamedCurves.Names">
            returns an enumeration containing the name strings for curves
            contained in this structure.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X962Parameters.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Parameters ::= CHOICE {
               ecParameters ECParameters,
               namedCurve   CURVES.&amp;id({CurveNames}),
               implicitlyCA Null
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.X9Curve">
            ASN.1 def for Elliptic-Curve Curve structure. See
            X9.62, for further details.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9Curve.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             Curve ::= Sequence {
                 a               FieldElement,
                 b               FieldElement,
                 seed            BIT STRING      OPTIONAL
             }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.X9ECParameters">
            ASN.1 def for Elliptic-Curve ECParameters structure. See
            X9.62, for further details.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9ECParameters.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             ECParameters ::= Sequence {
                 version         Integer { ecpVer1(1) } (ecpVer1),
                 fieldID         FieldID {{FieldTypes}},
                 curve           X9Curve,
                 base            X9ECPoint,
                 order           Integer,
                 cofactor        Integer OPTIONAL
             }
            </pre>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X9.X9ECParameters.CurveEntry">
             Return the ASN.1 entry representing the Curve.
            
             @return the X9Curve for the curve in these parameters.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X9.X9ECParameters.FieldIDEntry">
             Return the ASN.1 entry representing the FieldID.
            
             @return the X9FieldID for the FieldID in these parameters.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X9.X9ECParameters.BaseEntry">
             Return the ASN.1 entry representing the base point G.
            
             @return the X9ECPoint for the base point in these parameters.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.X9ECPoint">
            class for describing an ECPoint as a Der object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9ECPoint.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             ECPoint ::= OCTET STRING
            </pre>
            <p>
            Octet string produced using ECPoint.GetEncoded().</p>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.X9FieldElement">
            Class for processing an ECFieldElement as a DER object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9FieldElement.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             FieldElement ::= OCTET STRING
            </pre>
            <p>
            <ol>
            <li> if <i>q</i> is an odd prime then the field element is
            processed as an Integer and converted to an octet string
            according to x 9.62 4.3.1.</li>
            <li> if <i>q</i> is 2<sup>m</sup> then the bit string
            contained in the field element is converted into an octet
            string with the same ordering padded at the front if necessary.
            </li>
            </ol>
            </p>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.X9FieldID">
            ASN.1 def for Elliptic-Curve Field ID structure. See
            X9.62, for further details.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9FieldID.#ctor(Org.BouncyCastle.Math.BigInteger)">
            Constructor for elliptic curves over prime fields
            <code>F<sub>2</sub></code>.
            @param primeP The prime <code>p</code> defining the prime field.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9FieldID.#ctor(System.Int32,System.Int32)">
            Constructor for elliptic curves over binary fields
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9FieldID.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            Constructor for elliptic curves over binary fields
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>..
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9FieldID.ToAsn1Object">
            Produce a Der encoding of the following structure.
            <pre>
             FieldID ::= Sequence {
                 fieldType       FIELD-ID.&amp;id({IOSet}),
                 parameters      FIELD-ID.&amp;Type({IOSet}{&#64;fieldType})
             }
            </pre>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X9.X9ObjectIdentifiers.IdDsaWithSha1">
            id-dsa-with-sha1 OBJECT IDENTIFIER ::=  { iso(1) member-body(2)
                  us(840) x9-57 (10040) x9cm(4) 3 }
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X9.X9ObjectIdentifiers.X9x63Scheme">
            X9.63
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X9.X9ObjectIdentifiers.ansi_x9_42">
            X9.42
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.ArmoredInputStream">
            reader for Base64 armored objects - read the headers and then start returning
            bytes when the data is reached. An IOException is thrown if the CRC check
            fails.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredInputStream.Decode(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32[])">
             decode the base 64 encoded input data.
            
             @return the offset the data starts in out.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredInputStream.#ctor(System.IO.Stream)">
             Create a stream for reading a PGP armoured message, parsing up to a header
             and then reading the data that follows.
            
             @param input
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredInputStream.#ctor(System.IO.Stream,System.Boolean)">
             Create an armoured input stream which will assume the data starts
             straight away, or parse for headers first depending on the value of
             hasHeaders.
            
             @param input
             @param hasHeaders true if headers are to be looked for, false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredInputStream.IsClearText">
            @return true if we are inside the clear text section of a PGP
            signed message.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredInputStream.IsEndOfStream">
            @return true if the stream is actually at end of file.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredInputStream.GetArmorHeaderLine">
            Return the armor header line (if there is one)
            @return the armor header line, null if none present.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredInputStream.GetArmorHeaders">
            Return the armor headers (the lines after the armor header line),
            @return an array of armor headers, null if there aren't any.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.ArmoredOutputStream">
            Basic output stream.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredOutputStream.Encode(System.IO.Stream,System.Int32[],System.Int32)">
            encode the input data producing a base 64 encoded byte array.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredOutputStream.SetHeader(System.String,System.String)">
             Set an additional header entry.
            
             @param name the name of the header entry.
             @param v the value of the header entry.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredOutputStream.ResetHeaders">
            Reset the headers to only contain a Version string.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredOutputStream.BeginClearText(Org.BouncyCastle.Bcpg.HashAlgorithmTag)">
            Start a clear text signed message.
            @param hashAlgorithm
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ArmoredOutputStream.Close">
            <b>Note</b>: Close() does not close the underlying stream. So it is possible to write
            multiple objects using armoring to a single stream.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Attr.ImageAttrib">
            <remarks>Basic type for a image attribute packet.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.UserAttributeSubpacket">
            Basic type for a user attribute sub-packet.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.UserAttributeSubpacket.GetData">
            return the generic data making up the packet.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.BcpgInputStream">
            <remarks>Reader for PGP objects.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.BcpgInputStream.NextPacketTag">
            <summary>Returns the next packet tag in the stream.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.BcpgInputStream.PartialInputStream">
            <summary>
            A stream that overlays our input stream, allowing the user to only read a segment of it.
            NB: dataLength will be negative if the segment length is in the upper range above 2**31.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.BcpgObject">
            <remarks>Base class for a PGP object.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.BcpgOutputStream">
            <remarks>Basic output stream.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.BcpgOutputStream.#ctor(System.IO.Stream)">
            <summary>Create a stream representing a general packet.</summary>
            <param name="outStr">Output stream to write to.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.BcpgOutputStream.#ctor(System.IO.Stream,Org.BouncyCastle.Bcpg.PacketTag)">
            <summary>Create a stream representing an old style partial object.</summary>
            <param name="outStr">Output stream to write to.</param>
            <param name="tag">The packet tag for the object.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.BcpgOutputStream.#ctor(System.IO.Stream,Org.BouncyCastle.Bcpg.PacketTag,System.Int64,System.Boolean)">
            <summary>Create a stream representing a general packet.</summary>
            <param name="outStr">Output stream to write to.</param>
            <param name="tag">Packet tag.</param>
            <param name="length">Size of chunks making up the packet.</param>
            <param name="oldFormat">If true, the header is written out in old format.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.BcpgOutputStream.#ctor(System.IO.Stream,Org.BouncyCastle.Bcpg.PacketTag,System.Int64)">
            <summary>Create a new style partial input stream buffered into chunks.</summary>
            <param name="outStr">Output stream to write to.</param>
            <param name="tag">Packet tag.</param>
            <param name="length">Size of chunks making up the packet.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.BcpgOutputStream.#ctor(System.IO.Stream,Org.BouncyCastle.Bcpg.PacketTag,System.Byte[])">
            <summary>Create a new style partial input stream buffered into chunks.</summary>
            <param name="outStr">Output stream to write to.</param>
            <param name="tag">Packet tag.</param>
            <param name="buffer">Buffer to use for collecting chunks.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.BcpgOutputStream.Flush">
            <summary>Flush the underlying stream.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.BcpgOutputStream.Finish">
            <summary>Finish writing out the current packet without closing the underlying stream.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.CompressedDataPacket">
            <remarks>Generic compressed data object.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.InputStreamPacket.GetInputStream">
            <summary>Note: you can only read from this once...</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.CompressedDataPacket.Algorithm">
            <summary>The algorithm tag value.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.CompressionAlgorithmTag">
            <remarks>Basic tags for compression algorithms.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.ContainedPacket">
            <remarks>Basic type for a PGP packet.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.DsaPublicBcpgKey">
            <remarks>Base class for a DSA public key.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.IBcpgKey">
            <remarks>Base interface for a PGP key.</remarks>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.IBcpgKey.Format">
            <summary>
            The base format for this key - in the case of the symmetric keys it will generally
            be raw indicating that the key is just a straight byte representation, for an asymmetric
            key the format will be PGP, indicating the key is a string of MPIs encoded in PGP format.
            </summary>
            <returns>"RAW" or "PGP".</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.DsaPublicBcpgKey.#ctor(Org.BouncyCastle.Bcpg.BcpgInputStream)">
            <param name="bcpgIn">The stream to read the packet from.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.DsaPublicBcpgKey.GetEncoded">
            <summary>Return the standard PGP encoding of the key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.DsaPublicBcpgKey.Format">
            <summary>The format, as a string, always "PGP".</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.DsaSecretBcpgKey">
            <remarks>Base class for a DSA secret key.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.DsaSecretBcpgKey.#ctor(Org.BouncyCastle.Bcpg.BcpgInputStream)">
            @param in
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.DsaSecretBcpgKey.GetEncoded">
            <summary>Return the standard PGP encoding of the key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.DsaSecretBcpgKey.Format">
            <summary>The format, as a string, always "PGP".</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.DsaSecretBcpgKey.X">
            @return x
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.ECDHPublicBcpgKey">
            <remarks>Base class for an ECDH Public Key.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.ECPublicBcpgKey">
            <remarks>Base class for an EC Public Key.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ECPublicBcpgKey.#ctor(Org.BouncyCastle.Bcpg.BcpgInputStream)">
            <param name="bcpgIn">The stream to read the packet from.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ECPublicBcpgKey.GetEncoded">
            <summary>Return the standard PGP encoding of the key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.ECPublicBcpgKey.Format">
            <summary>The format, as a string, always "PGP".</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ECDHPublicBcpgKey.#ctor(Org.BouncyCastle.Bcpg.BcpgInputStream)">
            <param name="bcpgIn">The stream to read the packet from.</param>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.ECDsaPublicBcpgKey">
            <remarks>Base class for an ECDSA Public Key.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ECDsaPublicBcpgKey.#ctor(Org.BouncyCastle.Bcpg.BcpgInputStream)">
            <param name="bcpgIn">The stream to read the packet from.</param>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.ECSecretBcpgKey">
            <remarks>Base class for an EC Secret Key.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ECSecretBcpgKey.GetEncoded">
            <summary>Return the standard PGP encoding of the key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.ECSecretBcpgKey.Format">
            <summary>The format, as a string, always "PGP".</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.ElGamalPublicBcpgKey">
            <remarks>Base class for an ElGamal public key.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ElGamalPublicBcpgKey.GetEncoded">
            <summary>Return the standard PGP encoding of the key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.ElGamalPublicBcpgKey.Format">
            <summary>The format, as a string, always "PGP".</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.ElGamalSecretBcpgKey">
            <remarks>Base class for an ElGamal secret key.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ElGamalSecretBcpgKey.#ctor(Org.BouncyCastle.Bcpg.BcpgInputStream)">
            @param in
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ElGamalSecretBcpgKey.#ctor(Org.BouncyCastle.Math.BigInteger)">
            @param x
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.ElGamalSecretBcpgKey.GetEncoded">
            <summary>Return the standard PGP encoding of the key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.ElGamalSecretBcpgKey.Format">
            <summary>The format, as a string, always "PGP".</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.ExperimentalPacket">
            <remarks>Basic packet for an experimental packet.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.HashAlgorithmTag">
            <remarks>Basic tags for hash algorithms.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.LiteralDataPacket">
            <remarks>Generic literal data packet.</remarks>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.LiteralDataPacket.Format">
            <summary>The format tag value.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.LiteralDataPacket.ModificationTime">
            <summary>The modification time of the file in milli-seconds (since Jan 1, 1970 UTC)</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.MarkerPacket">
            <remarks>Basic type for a marker packet.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.ModDetectionCodePacket">
            <remarks>Basic packet for a modification detection code packet.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.MPInteger">
            <remarks>A multiple precision integer</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OnePassSignaturePacket">
            <remarks>Generic signature object</remarks>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OnePassSignaturePacket.KeyAlgorithm">
            <summary>The encryption algorithm tag.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OnePassSignaturePacket.HashAlgorithm">
            <summary>The hash algorithm tag.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.PacketTag">
            <remarks>Basic PGP packet tag types.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag">
            <remarks>Public Key Algorithm tag numbers.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.PublicKeyEncSessionPacket">
            <remarks>Basic packet for a PGP public key.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.PublicKeyPacket">
            <remarks>Basic packet for a PGP public key.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.PublicKeyPacket.#ctor(Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag,System.DateTime,Org.BouncyCastle.Bcpg.IBcpgKey)">
            <summary>Construct a version 4 public key packet.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.PublicSubkeyPacket">
            <remarks>Basic packet for a PGP public subkey</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.PublicSubkeyPacket.#ctor(Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag,System.DateTime,Org.BouncyCastle.Bcpg.IBcpgKey)">
            <summary>Construct a version 4 public subkey packet.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.RsaPublicBcpgKey">
            <remarks>Base class for an RSA public key.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.RsaPublicBcpgKey.#ctor(Org.BouncyCastle.Bcpg.BcpgInputStream)">
            <summary>Construct an RSA public key from the passed in stream.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.RsaPublicBcpgKey.#ctor(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            <param name="n">The modulus.</param>
            <param name="e">The public exponent.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.RsaPublicBcpgKey.GetEncoded">
            <summary>Return the standard PGP encoding of the key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.RsaPublicBcpgKey.Format">
            <summary>The format, as a string, always "PGP".</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.RsaSecretBcpgKey">
            <remarks>Base class for an RSA secret (or priate) key.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.RsaSecretBcpgKey.GetEncoded">
            <summary>Return the standard PGP encoding of the key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.RsaSecretBcpgKey.Format">
            <summary>The format, as a string, always "PGP".</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.S2k">
            <remarks>The string to key specifier class.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.S2k.GetIV">
            <summary>The IV for the key generation algorithm.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.S2k.HashAlgorithm">
            <summary>The hash algorithm.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.S2k.IterationCount">
            <summary>The iteration count</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.S2k.ProtectionMode">
            <summary>The protection mode - only if GnuDummyS2K</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.SecretKeyPacket">
            <remarks>Basic packet for a PGP secret key.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.SecretSubkeyPacket">
            <remarks>Basic packet for a PGP secret key.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.SignaturePacket">
            <remarks>Generic signature packet.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.SignaturePacket.#ctor(System.Int32,System.Int64,Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag,Org.BouncyCastle.Bcpg.HashAlgorithmTag,Org.BouncyCastle.Bcpg.SignatureSubpacket[],Org.BouncyCastle.Bcpg.SignatureSubpacket[],System.Byte[],Org.BouncyCastle.Bcpg.MPInteger[])">
             Generate a version 4 signature packet.
            
             @param signatureType
             @param keyAlgorithm
             @param hashAlgorithm
             @param hashedData
             @param unhashedData
             @param fingerprint
             @param signature
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.SignaturePacket.#ctor(System.Int32,System.Int32,System.Int64,Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag,Org.BouncyCastle.Bcpg.HashAlgorithmTag,System.Int64,System.Byte[],Org.BouncyCastle.Bcpg.MPInteger[])">
             Generate a version 2/3 signature packet.
            
             @param signatureType
             @param keyAlgorithm
             @param hashAlgorithm
             @param fingerprint
             @param signature
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.SignaturePacket.GetSignatureTrailer">
             return the signature trailer that must be included with the data
             to reconstruct the signature
            
             @return byte[]
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.SignaturePacket.GetSignature">
            		* return the signature as a set of integers - note this is normalised to be the
                    * ASN.1 encoding of what appears in the signature packet.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.SignaturePacket.GetSignatureBytes">
            Return the byte encoding of the signature section.
            @return uninterpreted signature bytes.
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.SignaturePacket.KeyId">
            return the keyId
            @return the keyId that created the signature.
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.SignaturePacket.CreationTime">
            <summary>Return the creation time in milliseconds since 1 Jan., 1970 UTC.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.SignatureSubpacket">
            <remarks>Basic type for a PGP Signature sub-packet.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.SignatureSubpacket.GetData">
            <summary>Return the generic data making up the packet.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.SignatureSubpacketsParser">
            reader for signature sub-packets
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.SignatureSubpacketTag">
            Basic PGP signature sub-packet tag types.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.EmbeddedSignature">
            Packet embedded signature
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.Exportable">
            packet giving signature creation time.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.Features">
            packet giving signature expiration time.
        </member>
        <member name="F:Org.BouncyCastle.Bcpg.Sig.Features.FEATURE_MODIFICATION_DETECTION">
            Identifier for the modification detection feature 
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.Sig.Features.SupportsFeature(System.Byte)">
            Returns if a particular feature is supported.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.Sig.Features.SetSupportsFeature(System.Byte,System.Boolean)">
            Sets support for a particular feature.
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.Sig.Features.SupportsModificationDetection">
            Returns if modification detection is supported.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.IssuerKeyId">
            packet giving signature creation time.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.KeyExpirationTime">
            packet giving time after creation at which the key expires.
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.Sig.KeyExpirationTime.Time">
             Return the number of seconds after creation time a key is valid for.
            
             @return second count for key validity.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.KeyFlags">
            Packet holding the key flag values.
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.Sig.KeyFlags.Flags">
            <summary>
            Return the flag values contained in the first 4 octets (note: at the moment
            the standard only uses the first one).
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.NotationData">
            Class provided a NotationData object according to
            RFC2440, Chapter 5.2.3.15. Notation Data
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.PreferredAlgorithms">
            packet giving signature creation time.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.PrimaryUserId">
            packet giving whether or not the signature is signed using the primary user ID for the key.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.Revocable">
            packet giving whether or not is revocable.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.RevocationKey">
            <summary>
            Represents revocation key OpenPGP signature sub packet.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.RevocationReason">
            <summary>
            Represents revocation reason OpenPGP signature sub packet.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.SignatureCreationTime">
            packet giving signature creation time.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.SignatureExpirationTime">
            packet giving signature expiration time.
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.Sig.SignatureExpirationTime.Time">
            return time in seconds before signature expires after creation time.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.SignerUserId">
            packet giving the User ID of the signer.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.Sig.TrustSignature">
            packet giving trust.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.SymmetricEncDataPacket">
            <remarks>Basic type for a symmetric key encrypted packet.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag">
            Basic tags for symmetric key algorithms
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.SymmetricKeyEncSessionPacket">
            Basic type for a symmetric encrypted session key packet
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.SymmetricKeyEncSessionPacket.GetSecKeyData">
            @return byte[]
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.SymmetricKeyEncSessionPacket.EncAlgorithm">
            @return int
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.SymmetricKeyEncSessionPacket.S2k">
            @return S2k
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.SymmetricKeyEncSessionPacket.Version">
            @return int
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.TrustPacket">
            <summary>Basic type for a trust packet.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.UserAttributePacket">
            Basic type for a user attribute packet.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.UserAttributeSubpacketsParser">
            reader for user attribute sub-packets
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.UserAttributeSubpacketTag">
            Basic PGP user attribute sub-packet tag types.
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.UserIdPacket">
            Basic type for a user ID packet.
        </member>
        <member name="T:Org.BouncyCastle.Apache.Bzip2.BZip2Constants">
             Base class for both the compress and decompress classes.
             Holds common arrays, and static data.
            
             @author <a href="mailto:keiron@aftexsw.com">Keiron Liddle</a>
        </member>
        <member name="T:Org.BouncyCastle.Apache.Bzip2.CBZip2InputStream">
             An input stream that decompresses from the BZip2 format (with the file
             header chars) to be read as any other stream.
            
             @author <a href="mailto:keiron@aftexsw.com">Keiron Liddle</a>
            
             <b>NB:</b> note this class has been modified to read the leading BZ from the
             start of the BZIP2 stream to make it compatible with other PGP programs.
        </member>
        <member name="T:Org.BouncyCastle.Apache.Bzip2.CBZip2OutputStream">
             An output stream that compresses into the BZip2 format (with the file
             header chars) into another stream.
            
             @author <a href="mailto:keiron@aftexsw.com">Keiron Liddle</a>
            
             TODO:    Update to BZip2 1.0.1
             <b>NB:</b> note this class has been modified to add a leading BZ to the
             start of the BZIP2 stream to make it compatible with other PGP programs.
        </member>
        <member name="M:Org.BouncyCastle.Apache.Bzip2.CBZip2OutputStream.WriteByte(System.Byte)">
            
             modified by Oliver Merkel, 010128
            
        </member>
        <member name="T:Org.BouncyCastle.Apache.Bzip2.CRC">
             A simple class the hold and calculate the CRC for sanity checking
             of the data.
            
             @author <a href="mailto:keiron@aftexsw.com">Keiron Liddle</a>
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsAttributeTableParameter">
            <remarks>
            The 'Signature' parameter is only available when generating unsigned attributes.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsAuthenticatedData">
            containing class for an CMS Authenticated Data object
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedData.GetRecipientInfos">
            return a store of the intended recipients for this message
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedData.GetAuthAttrs">
            return a table of the digested attributes indexed by
            the OID of the attribute.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedData.GetUnauthAttrs">
            return a table of the undigested attributes indexed by
            the OID of the attribute.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedData.GetEncoded">
            return the ASN.1 encoded representation of this object.
        </member>
        <member name="P:Org.BouncyCastle.Cms.CmsAuthenticatedData.MacAlgOid">
            return the object identifier for the content MAC algorithm.
        </member>
        <member name="P:Org.BouncyCastle.Cms.CmsAuthenticatedData.ContentInfo">
            return the ContentInfo 
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsAuthenticatedDataGenerator">
             General class for generating a CMS authenticated-data message.
            
             A simple example of usage.
            
             <pre>
                  CMSAuthenticatedDataGenerator  fact = new CMSAuthenticatedDataGenerator();
            
                  fact.addKeyTransRecipient(cert);
            
                  CMSAuthenticatedData         data = fact.generate(content, algorithm, "BC");
             </pre>
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsEnvelopedGenerator">
             General class for generating a CMS enveloped-data message.
            
             A simple example of usage.
            
             <pre>
                  CMSEnvelopedDataGenerator  fact = new CMSEnvelopedDataGenerator();
            
                  fact.addKeyTransRecipient(cert);
            
                  CMSEnvelopedData         data = fact.generate(content, algorithm, "BC");
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedGenerator.#ctor(Org.BouncyCastle.Security.SecureRandom)">
            <summary>Constructor allowing specific source of randomness</summary>
            <param name="rand">Instance of <c>SecureRandom</c> to use.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedGenerator.AddKeyTransRecipient(Org.BouncyCastle.X509.X509Certificate)">
             add a recipient.
            
             @param cert recipient's public key certificate
             @exception ArgumentException if there is a problem with the certificate
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedGenerator.AddKeyTransRecipient(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[])">
             add a recipient
            
             @param key the public key used by the recipient
             @param subKeyId the identifier for the recipient's public key
             @exception ArgumentException if there is a problem with the key
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedGenerator.AddKekRecipient(System.String,Org.BouncyCastle.Crypto.Parameters.KeyParameter,System.Byte[])">
            add a KEK recipient.
            @param key the secret key to use for wrapping
            @param keyIdentifier the byte string that identifies the key
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedGenerator.AddKekRecipient(System.String,Org.BouncyCastle.Crypto.Parameters.KeyParameter,Org.BouncyCastle.Asn1.Cms.KekIdentifier)">
            add a KEK recipient.
            @param key the secret key to use for wrapping
            @param keyIdentifier the byte string that identifies the key
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedGenerator.AddKeyAgreementRecipient(System.String,Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.X509.X509Certificate,System.String)">
             Add a key agreement based recipient.
            
             @param agreementAlgorithm key agreement algorithm to use.
             @param senderPrivateKey private key to initialise sender side of agreement with.
             @param senderPublicKey sender public key to include with message.
             @param recipientCert recipient's public key certificate.
             @param cekWrapAlgorithm OID for key wrapping algorithm to use.
             @exception SecurityUtilityException if the algorithm requested cannot be found
             @exception InvalidKeyException if the keys are inappropriate for the algorithm specified
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedGenerator.AddKeyAgreementRecipients(System.String,Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Collections.ICollection,System.String)">
             Add multiple key agreement based recipients (sharing a single KeyAgreeRecipientInfo structure).
            
             @param agreementAlgorithm key agreement algorithm to use.
             @param senderPrivateKey private key to initialise sender side of agreement with.
             @param senderPublicKey sender public key to include with message.
             @param recipientCerts recipients' public key certificates.
             @param cekWrapAlgorithm OID for key wrapping algorithm to use.
             @exception SecurityUtilityException if the algorithm requested cannot be found
             @exception InvalidKeyException if the keys are inappropriate for the algorithm specified
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedGenerator.#ctor">
            base constructor
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedGenerator.#ctor(Org.BouncyCastle.Security.SecureRandom)">
             constructor allowing specific source of randomness
            
             @param rand instance of SecureRandom to use
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedDataGenerator.#ctor">
            base constructor
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedDataGenerator.#ctor(Org.BouncyCastle.Security.SecureRandom)">
            constructor allowing specific source of randomness
            @param rand instance of SecureRandom to use
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedDataGenerator.Generate(Org.BouncyCastle.Cms.CmsProcessable,System.String,Org.BouncyCastle.Crypto.CipherKeyGenerator)">
            generate an enveloped object that contains an CMS Enveloped Data
            object using the given provider and the passed in key generator.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedDataGenerator.Generate(Org.BouncyCastle.Cms.CmsProcessable,System.String)">
            generate an authenticated object that contains an CMS Authenticated Data object
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsAuthenticatedDataParser">
             Parsing class for an CMS Authenticated Data object from an input stream.
             <p>
             Note: that because we are in a streaming mode only one recipient can be tried and it is important
             that the methods on the parser are called in the appropriate order.
             </p>
             <p>
             Example of use - assuming the first recipient matches the private key we have.
             <pre>
                  CMSAuthenticatedDataParser     ad = new CMSAuthenticatedDataParser(inputStream);
            
                  RecipientInformationStore  recipients = ad.getRecipientInfos();
            
                  Collection  c = recipients.getRecipients();
                  Iterator    it = c.iterator();
            
                  if (it.hasNext())
                  {
                      RecipientInformation   recipient = (RecipientInformation)it.next();
            
                      CMSTypedStream recData = recipient.getContentStream(privateKey, "BC");
            
                      processDataStream(recData.getContentStream());
            
                      if (!Arrays.equals(ad.getMac(), recipient.getMac())
                      {
                          System.err.println("Data corrupted!!!!");
                      }
                  }
              </pre>
              Note: this class does not introduce buffering - if you are processing large files you should create
              the parser with:
              <pre>
                      CMSAuthenticatedDataParser     ep = new CMSAuthenticatedDataParser(new BufferedInputStream(inputStream, bufSize));
              </pre>
              where bufSize is a suitably large buffer size.
             </p>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsContentInfoParser.Close">
            Close the underlying data stream.
            @throws IOException if the close fails.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedDataParser.GetRecipientInfos">
            return a store of the intended recipients for this message
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedDataParser.GetAuthAttrs">
            return a table of the unauthenticated attributes indexed by
            the OID of the attribute.
            @exception java.io.IOException
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedDataParser.GetUnauthAttrs">
            return a table of the unauthenticated attributes indexed by
            the OID of the attribute.
            @exception java.io.IOException
        </member>
        <member name="P:Org.BouncyCastle.Cms.CmsAuthenticatedDataParser.MacAlgOid">
            return the object identifier for the mac algorithm.
        </member>
        <member name="P:Org.BouncyCastle.Cms.CmsAuthenticatedDataParser.MacAlgParams">
            return the ASN.1 encoded encryption algorithm parameters, or null if
            there aren't any.
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsAuthenticatedDataStreamGenerator">
             General class for generating a CMS authenticated-data message stream.
             <p>
             A simple example of usage.
             <pre>
                  CMSAuthenticatedDataStreamGenerator edGen = new CMSAuthenticatedDataStreamGenerator();
            
                  edGen.addKeyTransRecipient(cert);
            
                  ByteArrayOutputStream  bOut = new ByteArrayOutputStream();
            
                  OutputStream out = edGen.open(
                                          bOut, CMSAuthenticatedDataGenerator.AES128_CBC, "BC");*
                  out.write(data);
            
                  out.close();
             </pre>
             </p>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedDataStreamGenerator.#ctor">
            base constructor
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedDataStreamGenerator.#ctor(Org.BouncyCastle.Security.SecureRandom)">
            constructor allowing specific source of randomness
            @param rand instance of SecureRandom to use
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedDataStreamGenerator.SetBufferSize(System.Int32)">
             Set the underlying string size for encapsulated data
            
             @param bufferSize length of octet strings to buffer the data.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedDataStreamGenerator.SetBerEncodeRecipients(System.Boolean)">
            Use a BER Set to store the recipient information
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedDataStreamGenerator.Open(System.IO.Stream,System.String,Org.BouncyCastle.Crypto.CipherKeyGenerator)">
            generate an enveloped object that contains an CMS Enveloped Data
            object using the given provider and the passed in key generator.
            @throws java.io.IOException
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedDataStreamGenerator.Open(System.IO.Stream,System.String)">
            generate an enveloped object that contains an CMS Enveloped Data object
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsAuthenticatedDataStreamGenerator.Open(System.IO.Stream,System.String,System.Int32)">
            generate an enveloped object that contains an CMS Enveloped Data object
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsAuthEnvelopedData">
            containing class for an CMS AuthEnveloped Data object
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsCompressedData">
            containing class for an CMS Compressed Data object
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsCompressedData.GetContent">
             Return the uncompressed content.
            
             @return the uncompressed content
             @throws CmsException if there is an exception uncompressing the data.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsCompressedData.GetContent(System.Int32)">
             Return the uncompressed content, throwing an exception if the data size
             is greater than the passed in limit. If the content is exceeded getCause()
             on the CMSException will contain a StreamOverflowException
            
             @param limit maximum number of bytes to read
             @return the content read
             @throws CMSException if there is an exception uncompressing the data.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsCompressedData.GetEncoded">
            return the ASN.1 encoded representation of this object.
        </member>
        <member name="P:Org.BouncyCastle.Cms.CmsCompressedData.ContentInfo">
            return the ContentInfo 
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsCompressedDataGenerator">
                * General class for generating a compressed CMS message.
                * <p>
                * A simple example of usage.</p>
                * <p>
                * <pre>
                *      CMSCompressedDataGenerator fact = new CMSCompressedDataGenerator();
                *      CMSCompressedData data = fact.Generate(content, algorithm);
                * </pre>
            	* </p>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsCompressedDataGenerator.Generate(Org.BouncyCastle.Cms.CmsProcessable,System.String)">
            Generate an object that contains an CMS Compressed Data
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsCompressedDataParser">
             Class for reading a CMS Compressed Data stream.
             <pre>
                 CMSCompressedDataParser cp = new CMSCompressedDataParser(inputStream);
            
                 process(cp.GetContent().GetContentStream());
             </pre>
              Note: this class does not introduce buffering - if you are processing large files you should create
              the parser with:
              <pre>
                  CMSCompressedDataParser     ep = new CMSCompressedDataParser(new BufferedInputStream(inputStream, bufSize));
              </pre>
              where bufSize is a suitably large buffer size.
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsCompressedDataStreamGenerator">
             General class for generating a compressed CMS message stream.
             <p>
             A simple example of usage.
             </p>
             <pre>
                  CMSCompressedDataStreamGenerator gen = new CMSCompressedDataStreamGenerator();
            
                  Stream cOut = gen.Open(outputStream, CMSCompressedDataStreamGenerator.ZLIB);
            
                  cOut.Write(data);
            
                  cOut.Close();
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsCompressedDataStreamGenerator.#ctor">
            base constructor
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsCompressedDataStreamGenerator.SetBufferSize(System.Int32)">
             Set the underlying string size for encapsulated data
            
             @param bufferSize length of octet strings to buffer the data.
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsEnvelopedData">
            containing class for an CMS Enveloped Data object
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedData.GetRecipientInfos">
            return a store of the intended recipients for this message
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedData.GetUnprotectedAttributes">
            return a table of the unprotected attributes indexed by
            the OID of the attribute.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedData.GetEncoded">
            return the ASN.1 encoded representation of this object.
        </member>
        <member name="P:Org.BouncyCastle.Cms.CmsEnvelopedData.EncryptionAlgOid">
            return the object identifier for the content encryption algorithm.
        </member>
        <member name="P:Org.BouncyCastle.Cms.CmsEnvelopedData.ContentInfo">
            return the ContentInfo 
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsEnvelopedDataGenerator">
             <remarks>
             General class for generating a CMS enveloped-data message.
            
             A simple example of usage.
            
             <pre>
                  CmsEnvelopedDataGenerator  fact = new CmsEnvelopedDataGenerator();
            
                  fact.AddKeyTransRecipient(cert);
            
                  CmsEnvelopedData         data = fact.Generate(content, algorithm);
             </pre>
             </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedDataGenerator.#ctor(Org.BouncyCastle.Security.SecureRandom)">
            <summary>Constructor allowing specific source of randomness</summary>
            <param name="rand">Instance of <c>SecureRandom</c> to use.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedDataGenerator.Generate(Org.BouncyCastle.Cms.CmsProcessable,System.String,Org.BouncyCastle.Crypto.CipherKeyGenerator)">
            <summary>
            Generate an enveloped object that contains a CMS Enveloped Data
            object using the passed in key generator.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedDataGenerator.Generate(Org.BouncyCastle.Cms.CmsProcessable,System.String)">
            <summary>Generate an enveloped object that contains an CMS Enveloped Data object.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedDataGenerator.Generate(Org.BouncyCastle.Cms.CmsProcessable,System.String,System.Int32)">
            <summary>Generate an enveloped object that contains an CMS Enveloped Data object.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsEnvelopedDataParser">
             Parsing class for an CMS Enveloped Data object from an input stream.
             <p>
             Note: that because we are in a streaming mode only one recipient can be tried and it is important
             that the methods on the parser are called in the appropriate order.
             </p>
             <p>
             Example of use - assuming the first recipient matches the private key we have.
             <pre>
                  CmsEnvelopedDataParser     ep = new CmsEnvelopedDataParser(inputStream);
            
                  RecipientInformationStore  recipients = ep.GetRecipientInfos();
            
                  Collection  c = recipients.getRecipients();
                  Iterator    it = c.iterator();
            
                  if (it.hasNext())
                  {
                      RecipientInformation   recipient = (RecipientInformation)it.next();
            
                      CMSTypedStream recData = recipient.getContentStream(privateKey);
            
                      processDataStream(recData.getContentStream());
                  }
              </pre>
              Note: this class does not introduce buffering - if you are processing large files you should create
              the parser with:
              <pre>
                      CmsEnvelopedDataParser     ep = new CmsEnvelopedDataParser(new BufferedInputStream(inputStream, bufSize));
              </pre>
              where bufSize is a suitably large buffer size.
             </p>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedDataParser.GetRecipientInfos">
            return a store of the intended recipients for this message
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedDataParser.GetUnprotectedAttributes">
            return a table of the unprotected attributes indexed by
            the OID of the attribute.
            @throws IOException
        </member>
        <member name="P:Org.BouncyCastle.Cms.CmsEnvelopedDataParser.EncryptionAlgOid">
            return the object identifier for the content encryption algorithm.
        </member>
        <member name="P:Org.BouncyCastle.Cms.CmsEnvelopedDataParser.EncryptionAlgParams">
            return the ASN.1 encoded encryption algorithm parameters, or null if
            there aren't any.
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsEnvelopedDataStreamGenerator">
             General class for generating a CMS enveloped-data message stream.
             <p>
             A simple example of usage.
             <pre>
                  CmsEnvelopedDataStreamGenerator edGen = new CmsEnvelopedDataStreamGenerator();
            
                  edGen.AddKeyTransRecipient(cert);
            
                  MemoryStream  bOut = new MemoryStream();
            
                  Stream out = edGen.Open(
                                          bOut, CMSEnvelopedDataGenerator.AES128_CBC);*
                  out.Write(data);
            
                  out.Close();
             </pre>
             </p>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedDataStreamGenerator.#ctor(Org.BouncyCastle.Security.SecureRandom)">
            <summary>Constructor allowing specific source of randomness</summary>
            <param name="rand">Instance of <c>SecureRandom</c> to use.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedDataStreamGenerator.SetBufferSize(System.Int32)">
            <summary>Set the underlying string size for encapsulated data.</summary>
            <param name="bufferSize">Length of octet strings to buffer the data.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedDataStreamGenerator.SetBerEncodeRecipients(System.Boolean)">
            <summary>Use a BER Set to store the recipient information.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedDataStreamGenerator.Open(System.IO.Stream,System.String,Org.BouncyCastle.Crypto.CipherKeyGenerator)">
            <summary>
            Generate an enveloped object that contains an CMS Enveloped Data
            object using the passed in key generator.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedDataStreamGenerator.Open(System.IO.Stream,System.String)">
            generate an enveloped object that contains an CMS Enveloped Data object
            @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedDataStreamGenerator.Open(System.IO.Stream,System.String,System.Int32)">
            generate an enveloped object that contains an CMS Enveloped Data object
            @throws IOException
        </member>
        <member name="T:Org.BouncyCastle.Crypto.ICipherParameters">
            all parameter classes implement this.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsProcessable.Write(System.IO.Stream)">
            <summary>
            Generic routine to copy out the data we want processed.
            </summary>
            <remarks>
            This routine may be called multiple times.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsProcessableByteArray">
            a holding class for a byte array of data to be processed.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsProcessableByteArray.GetContent">
            <returns>A clone of the byte array</returns>
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsProcessableFile">
            a holding class for a file of data to be processed.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsProcessableFile.GetContent">
            <returns>The file handle</returns>
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsSignedData">
             general class for handling a pkcs7-signature message.
            
             A simple example of usage - note, in the example below the validity of
             the certificate isn't verified, just the fact that one of the certs
             matches the given signer...
            
             <pre>
              IX509Store              certs = s.GetCertificates();
              SignerInformationStore  signers = s.GetSignerInfos();
            
              foreach (SignerInformation signer in signers.GetSigners())
              {
                  ArrayList       certList = new ArrayList(certs.GetMatches(signer.SignerID));
                  X509Certificate cert = (X509Certificate) certList[0];
            
                  if (signer.Verify(cert.GetPublicKey()))
                  {
                      verified++;
                  }
              }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.#ctor(System.Collections.IDictionary,System.Byte[])">
             Content with detached signature, digests precomputed
            
             @param hashes a map of precomputed digests for content indexed by name of hash.
             @param sigBlock the signature object.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.#ctor(Org.BouncyCastle.Cms.CmsProcessable,System.IO.Stream)">
             base constructor - content with detached signature.
            
             @param signedContent the content that was signed.
             @param sigData the signature object.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.#ctor(System.IO.Stream)">
            base constructor - with encapsulated content
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.GetSignerInfos">
            return the collection of signers that are associated with the
            signatures for the message.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.GetAttributeCertificates(System.String)">
             return a X509Store containing the attribute certificates, if any, contained
             in this message.
            
             @param type type of store to create
             @return a store of attribute certificates
             @exception NoSuchStoreException if the store type isn't available.
             @exception CmsException if a general exception prevents creation of the X509Store
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.GetCertificates(System.String)">
             return a X509Store containing the public key certificates, if any, contained
             in this message.
            
             @param type type of store to create
             @return a store of public key certificates
             @exception NoSuchStoreException if the store type isn't available.
             @exception CmsException if a general exception prevents creation of the X509Store
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.GetCrls(System.String)">
             return a X509Store containing CRLs, if any, contained
             in this message.
            
             @param type type of store to create
             @return a store of CRLs
             @exception NoSuchStoreException if the store type isn't available.
             @exception CmsException if a general exception prevents creation of the X509Store
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.GetEncoded">
            return the ASN.1 encoded representation of this object.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.ReplaceSigners(Org.BouncyCastle.Cms.CmsSignedData,Org.BouncyCastle.Cms.SignerInformationStore)">
             Replace the signerinformation store associated with this
             CmsSignedData object with the new one passed in. You would
             probably only want to do this if you wanted to change the unsigned
             attributes associated with a signer, or perhaps delete one.
            
             @param signedData the signed data object to be used as a base.
             @param signerInformationStore the new signer information store to use.
             @return a new signed data object.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.ReplaceCertificatesAndCrls(Org.BouncyCastle.Cms.CmsSignedData,Org.BouncyCastle.X509.Store.IX509Store,Org.BouncyCastle.X509.Store.IX509Store,Org.BouncyCastle.X509.Store.IX509Store)">
             Replace the certificate and CRL information associated with this
             CmsSignedData object with the new one passed in.
            
             @param signedData the signed data object to be used as a base.
             @param x509Certs the new certificates to be used.
             @param x509Crls the new CRLs to be used.
             @return a new signed data object.
             @exception CmsException if there is an error processing the stores
        </member>
        <member name="P:Org.BouncyCastle.Cms.CmsSignedData.Version">
            <summary>Return the version number for this object.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Cms.CmsSignedData.SignedContentType">
            <summary>
            Return the <c>DerObjectIdentifier</c> associated with the encapsulated
            content info structure carried in the signed data.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Cms.CmsSignedData.ContentInfo">
            return the ContentInfo
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsSignedDataGenerator">
                 * general class for generating a pkcs7-signature message.
                 * <p>
                 * A simple example of usage.
                 *
                 * <pre>
                 *      IX509Store certs...
                 *      IX509Store crls...
                 *      CmsSignedDataGenerator gen = new CmsSignedDataGenerator();
                 *
                 *      gen.AddSigner(privKey, cert, CmsSignedGenerator.DigestSha1);
                 *      gen.AddCertificates(certs);
                 *      gen.AddCrls(crls);
                 *
                 *      CmsSignedData data = gen.Generate(content);
                 * </pre>
            	 * </p>
        </member>
        <member name="F:Org.BouncyCastle.Cms.CmsSignedGenerator.Data">
            Default type for the signed data.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedGenerator.#ctor(Org.BouncyCastle.Security.SecureRandom)">
            <summary>Constructor allowing specific source of randomness</summary>
            <param name="rand">Instance of <c>SecureRandom</c> to use.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedGenerator.AddAttributeCertificates(Org.BouncyCastle.X509.Store.IX509Store)">
             Add the attribute certificates contained in the passed in store to the
             generator.
            
             @param store a store of Version 2 attribute certificates
             @throws CmsException if an error occurse processing the store.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedGenerator.AddSigners(Org.BouncyCastle.Cms.SignerInformationStore)">
             Add a store of precalculated signers to the generator.
            
             @param signerStore store of signers
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedGenerator.GetGeneratedDigests">
             Return a map of oids and byte arrays representing the digests calculated on the content during
             the last generate.
            
             @return a map of oids (as String objects) and byte[] representing digests.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.#ctor(Org.BouncyCastle.Security.SecureRandom)">
            <summary>Constructor allowing specific source of randomness</summary>
            <param name="rand">Instance of <c>SecureRandom</c> to use.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.X509.X509Certificate,System.String)">
                    * add a signer - no attributes other than the default ones will be
                    * provided here.
            		*
            		* @param key signing key to use
            		* @param cert certificate containing corresponding public key
            		* @param digestOID digest algorithm OID
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.X509.X509Certificate,System.String,System.String)">
             add a signer, specifying the digest encryption algorithm to use - no attributes other than the default ones will be
             provided here.
            
             @param key signing key to use
             @param cert certificate containing corresponding public key
             @param encryptionOID digest encryption algorithm OID
             @param digestOID digest algorithm OID
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[],System.String)">
            add a signer - no attributes other than the default ones will be
            provided here.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[],System.String,System.String)">
            add a signer, specifying the digest encryption algorithm to use - no attributes other than the default ones will be
            provided here.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.X509.X509Certificate,System.String,Org.BouncyCastle.Asn1.Cms.AttributeTable,Org.BouncyCastle.Asn1.Cms.AttributeTable)">
                    * add a signer with extra signed/unsigned attributes.
            		*
            		* @param key signing key to use
            		* @param cert certificate containing corresponding public key
            		* @param digestOID digest algorithm OID
            		* @param signedAttr table of attributes to be included in signature
            		* @param unsignedAttr table of attributes to be included as unsigned
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.X509.X509Certificate,System.String,System.String,Org.BouncyCastle.Asn1.Cms.AttributeTable,Org.BouncyCastle.Asn1.Cms.AttributeTable)">
             add a signer, specifying the digest encryption algorithm, with extra signed/unsigned attributes.
            
             @param key signing key to use
             @param cert certificate containing corresponding public key
             @param encryptionOID digest encryption algorithm OID
             @param digestOID digest algorithm OID
             @param signedAttr table of attributes to be included in signature
             @param unsignedAttr table of attributes to be included as unsigned
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[],System.String,Org.BouncyCastle.Asn1.Cms.AttributeTable,Org.BouncyCastle.Asn1.Cms.AttributeTable)">
            	     * add a signer with extra signed/unsigned attributes.
            		 *
            		 * @param key signing key to use
            		 * @param subjectKeyID subjectKeyID of corresponding public key
            		 * @param digestOID digest algorithm OID
            		 * @param signedAttr table of attributes to be included in signature
            		 * @param unsignedAttr table of attributes to be included as unsigned
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[],System.String,System.String,Org.BouncyCastle.Asn1.Cms.AttributeTable,Org.BouncyCastle.Asn1.Cms.AttributeTable)">
             add a signer, specifying the digest encryption algorithm, with extra signed/unsigned attributes.
            
             @param key signing key to use
             @param subjectKeyID subjectKeyID of corresponding public key
             @param encryptionOID digest encryption algorithm OID
             @param digestOID digest algorithm OID
             @param signedAttr table of attributes to be included in signature
             @param unsignedAttr table of attributes to be included as unsigned
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.X509.X509Certificate,System.String,Org.BouncyCastle.Cms.CmsAttributeTableGenerator,Org.BouncyCastle.Cms.CmsAttributeTableGenerator)">
            add a signer with extra signed/unsigned attributes based on generators.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.X509.X509Certificate,System.String,System.String,Org.BouncyCastle.Cms.CmsAttributeTableGenerator,Org.BouncyCastle.Cms.CmsAttributeTableGenerator)">
            add a signer, specifying the digest encryption algorithm, with extra signed/unsigned attributes based on generators.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[],System.String,Org.BouncyCastle.Cms.CmsAttributeTableGenerator,Org.BouncyCastle.Cms.CmsAttributeTableGenerator)">
            add a signer with extra signed/unsigned attributes based on generators.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[],System.String,System.String,Org.BouncyCastle.Cms.CmsAttributeTableGenerator,Org.BouncyCastle.Cms.CmsAttributeTableGenerator)">
            add a signer, including digest encryption algorithm, with extra signed/unsigned attributes based on generators.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.Generate(Org.BouncyCastle.Cms.CmsProcessable)">
            generate a signed object that for a CMS Signed Data object
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.Generate(System.String,Org.BouncyCastle.Cms.CmsProcessable,System.Boolean)">
            generate a signed object that for a CMS Signed Data
            object  - if encapsulate is true a copy
            of the message will be included in the signature. The content type
            is set according to the OID represented by the string signedContentType.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.Generate(Org.BouncyCastle.Cms.CmsProcessable,System.Boolean)">
            generate a signed object that for a CMS Signed Data
            object - if encapsulate is true a copy
            of the message will be included in the signature with the
            default content type "data".
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.GenerateCounterSigners(Org.BouncyCastle.Cms.SignerInformation)">
             generate a set of one or more SignerInformation objects representing counter signatures on
             the passed in SignerInformation object.
            
             @param signer the signer to be countersigned
             @param sigProvider the provider to be used for counter signing.
             @return a store containing the signers.
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsSignedDataParser">
             Parsing class for an CMS Signed Data object from an input stream.
             <p>
             Note: that because we are in a streaming mode only one signer can be tried and it is important
             that the methods on the parser are called in the appropriate order.
             </p>
             <p>
             A simple example of usage for an encapsulated signature.
             </p>
             <p>
             Two notes: first, in the example below the validity of
             the certificate isn't verified, just the fact that one of the certs
             matches the given signer, and, second, because we are in a streaming
             mode the order of the operations is important.
             </p>
             <pre>
                  CmsSignedDataParser     sp = new CmsSignedDataParser(encapSigData);
            
                  sp.GetSignedContent().Drain();
            
                  IX509Store              certs = sp.GetCertificates();
                  SignerInformationStore  signers = sp.GetSignerInfos();
            
                  foreach (SignerInformation signer in signers.GetSigners())
                  {
                      ArrayList       certList = new ArrayList(certs.GetMatches(signer.SignerID));
                      X509Certificate cert = (X509Certificate) certList[0];
            
                      Console.WriteLine("verify returns: " + signer.Verify(cert));
                  }
             </pre>
              Note also: this class does not introduce buffering - if you are processing large files you should create
              the parser with:
              <pre>
                      CmsSignedDataParser     ep = new CmsSignedDataParser(new BufferedInputStream(encapSigData, bufSize));
              </pre>
              where bufSize is a suitably large buffer size.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataParser.#ctor(System.IO.Stream)">
            base constructor - with encapsulated content
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataParser.#ctor(Org.BouncyCastle.Cms.CmsTypedStream,System.IO.Stream)">
             base constructor
            
             @param signedContent the content that was signed.
             @param sigData the signature object.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataParser.GetSignerInfos">
            return the collection of signers that are associated with the
            signatures for the message.
            @throws CmsException
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataParser.GetAttributeCertificates(System.String)">
             return a X509Store containing the attribute certificates, if any, contained
             in this message.
            
             @param type type of store to create
             @return a store of attribute certificates
             @exception org.bouncycastle.x509.NoSuchStoreException if the store type isn't available.
             @exception CmsException if a general exception prevents creation of the X509Store
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataParser.GetCertificates(System.String)">
             return a X509Store containing the public key certificates, if any, contained
             in this message.
            
             @param type type of store to create
             @return a store of public key certificates
             @exception NoSuchStoreException if the store type isn't available.
             @exception CmsException if a general exception prevents creation of the X509Store
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataParser.GetCrls(System.String)">
             return a X509Store containing CRLs, if any, contained
             in this message.
            
             @param type type of store to create
             @return a store of CRLs
             @exception NoSuchStoreException if the store type isn't available.
             @exception CmsException if a general exception prevents creation of the X509Store
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataParser.ReplaceSigners(System.IO.Stream,Org.BouncyCastle.Cms.SignerInformationStore,System.IO.Stream)">
            Replace the signerinformation store associated with the passed
            in message contained in the stream original with the new one passed in.
            You would probably only want to do this if you wanted to change the unsigned
            attributes associated with a signer, or perhaps delete one.
            <p>
            The output stream is returned unclosed.
            </p>
            @param original the signed data stream to be used as a base.
            @param signerInformationStore the new signer information store to use.
            @param out the stream to Write the new signed data object to.
            @return out.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataParser.ReplaceCertificatesAndCrls(System.IO.Stream,Org.BouncyCastle.X509.Store.IX509Store,Org.BouncyCastle.X509.Store.IX509Store,Org.BouncyCastle.X509.Store.IX509Store,System.IO.Stream)">
            Replace the certificate and CRL information associated with this
            CMSSignedData object with the new one passed in.
            <p>
            The output stream is returned unclosed.
            </p>
            @param original the signed data stream to be used as a base.
            @param certsAndCrls the new certificates and CRLs to be used.
            @param out the stream to Write the new signed data object to.
            @return out.
            @exception CmsException if there is an error processing the CertStore
        </member>
        <member name="P:Org.BouncyCastle.Cms.CmsSignedDataParser.Version">
             Return the version number for the SignedData object
            
             @return the version number
        </member>
        <member name="P:Org.BouncyCastle.Cms.CmsSignedDataParser.SignedContentType">
            <summary>
            Return the <c>DerObjectIdentifier</c> associated with the encapsulated
            content info structure carried in the signed data.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator">
             General class for generating a pkcs7-signature message stream.
             <p>
             A simple example of usage.
             </p>
             <pre>
                  IX509Store                   certs...
                  CmsSignedDataStreamGenerator gen = new CmsSignedDataStreamGenerator();
            
                  gen.AddSigner(privateKey, cert, CmsSignedDataStreamGenerator.DIGEST_SHA1);
            
                  gen.AddCertificates(certs);
            
                  Stream sigOut = gen.Open(bOut);
            
                  sigOut.Write(Encoding.UTF8.GetBytes("Hello World!"));
            
                  sigOut.Close();
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.#ctor(Org.BouncyCastle.Security.SecureRandom)">
            <summary>Constructor allowing specific source of randomness</summary>
            <param name="rand">Instance of <c>SecureRandom</c> to use.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.SetBufferSize(System.Int32)">
             Set the underlying string size for encapsulated data
            
             @param bufferSize length of octet strings to buffer the data.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.X509.X509Certificate,System.String)">
            add a signer - no attributes other than the default ones will be
            provided here.
            @throws NoSuchAlgorithmException
            @throws InvalidKeyException
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.X509.X509Certificate,System.String,System.String)">
            add a signer, specifying the digest encryption algorithm - no attributes other than the default ones will be
            provided here.
            @throws NoSuchProviderException
            @throws NoSuchAlgorithmException
            @throws InvalidKeyException
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.X509.X509Certificate,System.String,Org.BouncyCastle.Asn1.Cms.AttributeTable,Org.BouncyCastle.Asn1.Cms.AttributeTable)">
            add a signer with extra signed/unsigned attributes.
            @throws NoSuchAlgorithmException
            @throws InvalidKeyException
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.X509.X509Certificate,System.String,System.String,Org.BouncyCastle.Asn1.Cms.AttributeTable,Org.BouncyCastle.Asn1.Cms.AttributeTable)">
            add a signer with extra signed/unsigned attributes - specifying digest
            encryption algorithm.
            @throws NoSuchProviderException
            @throws NoSuchAlgorithmException
            @throws InvalidKeyException
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[],System.String)">
            add a signer - no attributes other than the default ones will be
            provided here.
            @throws NoSuchAlgorithmException
            @throws InvalidKeyException
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[],System.String,System.String)">
            add a signer - no attributes other than the default ones will be
            provided here.
            @throws NoSuchProviderException
            @throws NoSuchAlgorithmException
            @throws InvalidKeyException
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.AddSigner(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[],System.String,Org.BouncyCastle.Asn1.Cms.AttributeTable,Org.BouncyCastle.Asn1.Cms.AttributeTable)">
            add a signer with extra signed/unsigned attributes.
            @throws NoSuchAlgorithmException
            @throws InvalidKeyException
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.Open(System.IO.Stream)">
            generate a signed object that for a CMS Signed Data object
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.Open(System.IO.Stream,System.Boolean)">
            generate a signed object that for a CMS Signed Data
            object - if encapsulate is true a copy
            of the message will be included in the signature with the
            default content type "data".
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.Open(System.IO.Stream,System.Boolean,System.IO.Stream)">
            generate a signed object that for a CMS Signed Data
            object using the given provider - if encapsulate is true a copy
            of the message will be included in the signature with the
            default content type "data". If dataOutputStream is non null the data
            being signed will be written to the stream as it is processed.
            @param out stream the CMS object is to be written to.
            @param encapsulate true if data should be encapsulated.
            @param dataOutputStream output stream to copy the data being signed to.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.Open(System.IO.Stream,System.String,System.Boolean)">
            generate a signed object that for a CMS Signed Data
            object - if encapsulate is true a copy
            of the message will be included in the signature. The content type
            is set according to the OID represented by the string signedContentType.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataStreamGenerator.Open(System.IO.Stream,System.String,System.Boolean,System.IO.Stream)">
            generate a signed object that for a CMS Signed Data
            object using the given provider - if encapsulate is true a copy
            of the message will be included in the signature. The content type
            is set according to the OID represented by the string signedContentType.
            @param out stream the CMS object is to be written to.
            @param signedContentType OID for data to be signed.
            @param encapsulate true if data should be encapsulated.
            @param dataOutputStream output stream to copy the data being signed to.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedHelper.GetDigestAlgName(System.String)">
            Return the digest algorithm using one of the standard JCA string
            representations rather than the algorithm identifier (if possible).
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedHelper.GetEncryptionAlgName(System.String)">
            Return the digest encryption algorithm using one of the standard
            JCA string representations rather than the algorithm identifier (if
            possible).
        </member>
        <member name="T:Org.BouncyCastle.Cms.DefaultAuthenticatedAttributeTableGenerator">
            Default authenticated attributes generator.
        </member>
        <member name="M:Org.BouncyCastle.Cms.DefaultAuthenticatedAttributeTableGenerator.#ctor">
            Initialise to use all defaults
        </member>
        <member name="M:Org.BouncyCastle.Cms.DefaultAuthenticatedAttributeTableGenerator.#ctor(Org.BouncyCastle.Asn1.Cms.AttributeTable)">
             Initialise with some extra attributes or overrides.
            
             @param attributeTable initial attribute table to use.
        </member>
        <member name="M:Org.BouncyCastle.Cms.DefaultAuthenticatedAttributeTableGenerator.CreateStandardAttributeTable(System.Collections.IDictionary)">
             Create a standard attribute table from the passed in parameters - this will
             normally include contentType and messageDigest. If the constructor
             using an AttributeTable was used, entries in it for contentType and
             messageDigest will override the generated ones.
            
             @param parameters source parameters for table generation.
            
             @return a filled in IDictionary of attributes.
        </member>
        <member name="M:Org.BouncyCastle.Cms.DefaultAuthenticatedAttributeTableGenerator.GetAttributes(System.Collections.IDictionary)">
            @param parameters source parameters
            @return the populated attribute table
        </member>
        <member name="T:Org.BouncyCastle.Cms.DefaultSignedAttributeTableGenerator">
            Default signed attributes generator.
        </member>
        <member name="M:Org.BouncyCastle.Cms.DefaultSignedAttributeTableGenerator.#ctor">
            Initialise to use all defaults
        </member>
        <member name="M:Org.BouncyCastle.Cms.DefaultSignedAttributeTableGenerator.#ctor(Org.BouncyCastle.Asn1.Cms.AttributeTable)">
             Initialise with some extra attributes or overrides.
            
             @param attributeTable initial attribute table to use.
        </member>
        <member name="M:Org.BouncyCastle.Cms.DefaultSignedAttributeTableGenerator.createStandardAttributeTable(System.Collections.IDictionary)">
             Create a standard attribute table from the passed in parameters - this will
             normally include contentType, signingTime, and messageDigest. If the constructor
             using an AttributeTable was used, entries in it for contentType, signingTime, and
             messageDigest will override the generated ones.
            
             @param parameters source parameters for table generation.
            
             @return a filled in Hashtable of attributes.
        </member>
        <member name="M:Org.BouncyCastle.Cms.DefaultSignedAttributeTableGenerator.GetAttributes(System.Collections.IDictionary)">
            @param parameters source parameters
            @return the populated attribute table
        </member>
        <member name="M:Org.BouncyCastle.Cms.RecipientInfoGenerator.Generate(Org.BouncyCastle.Crypto.Parameters.KeyParameter,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Generate a RecipientInfo object for the given key.
            </summary>
            <param name="contentEncryptionKey">
            A <see cref="T:Org.BouncyCastle.Crypto.Parameters.KeyParameter"/>
            </param>
            <param name="random">
            A <see cref="T:Org.BouncyCastle.Security.SecureRandom"/>
            </param>
            <returns>
            A <see cref="T:Org.BouncyCastle.Asn1.Cms.RecipientInfo"/>
            </returns>
            <exception cref="T:Org.BouncyCastle.Security.GeneralSecurityException"></exception>
        </member>
        <member name="T:Org.BouncyCastle.Cms.KekRecipientInformation">
            the RecipientInfo class for a recipient who has been sent a message
            encrypted using a secret key known to the other side.
        </member>
        <member name="M:Org.BouncyCastle.Cms.RecipientInformation.GetMac">
             Return the MAC calculated for the content stream. Note: this call is only meaningful once all
             the content has been read.
            
             @return  byte array containing the mac.
        </member>
        <member name="P:Org.BouncyCastle.Cms.RecipientInformation.KeyEncryptionAlgOid">
                    * return the object identifier for the key encryption algorithm.
                    * 
            		* @return OID for key encryption algorithm.
        </member>
        <member name="P:Org.BouncyCastle.Cms.RecipientInformation.KeyEncryptionAlgParams">
                    * return the ASN.1 encoded key encryption algorithm parameters, or null if
                    * there aren't any.
                    * 
            		* @return ASN.1 encoding of key encryption algorithm parameters.
        </member>
        <member name="M:Org.BouncyCastle.Cms.KekRecipientInformation.GetContentStream(Org.BouncyCastle.Crypto.ICipherParameters)">
            decrypt the content and return an input stream.
        </member>
        <member name="T:Org.BouncyCastle.Cms.KeyAgreeRecipientInformation">
            the RecipientInfo class for a recipient who has been sent a message
            encrypted using key agreement.
        </member>
        <member name="M:Org.BouncyCastle.Cms.KeyAgreeRecipientInformation.GetContentStream(Org.BouncyCastle.Crypto.ICipherParameters)">
            decrypt the content and return an input stream.
        </member>
        <member name="T:Org.BouncyCastle.Cms.KeyTransRecipientInformation">
            the KeyTransRecipientInformation class for a recipient who has been sent a secret
            key encrypted using their public key that needs to be used to
            extract the message.
        </member>
        <member name="M:Org.BouncyCastle.Cms.KeyTransRecipientInformation.GetContentStream(Org.BouncyCastle.Crypto.ICipherParameters)">
            decrypt the content and return it as a byte array.
        </member>
        <member name="T:Org.BouncyCastle.Cms.OriginatorID">
            a basic index for an originator.
        </member>
        <member name="P:Org.BouncyCastle.X509.Store.X509CertStoreSelector.Policy">
            <summary>
            An <code>ISet</code> of <code>DerObjectIdentifier</code> objects.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Cms.OriginatorInformation.GetCertificates">
             Return the certificates stored in the underlying OriginatorInfo object.
            
             @return a Store of X509CertificateHolder objects.
        </member>
        <member name="M:Org.BouncyCastle.Cms.OriginatorInformation.GetCrls">
             Return the CRLs stored in the underlying OriginatorInfo object.
            
             @return a Store of X509CRLHolder objects.
        </member>
        <member name="M:Org.BouncyCastle.Cms.OriginatorInformation.ToAsn1Structure">
             Return the underlying ASN.1 object defining this SignerInformation object.
            
             @return a OriginatorInfo.
        </member>
        <member name="T:Org.BouncyCastle.Cms.PasswordRecipientInformation">
            the RecipientInfo class for a recipient who has been sent a message
            encrypted using a password.
        </member>
        <member name="M:Org.BouncyCastle.Cms.PasswordRecipientInformation.GetContentStream(Org.BouncyCastle.Crypto.ICipherParameters)">
            decrypt the content and return an input stream.
        </member>
        <member name="P:Org.BouncyCastle.Cms.PasswordRecipientInformation.KeyDerivationAlgorithm">
             return the object identifier for the key derivation algorithm, or null
             if there is none present.
            
             @return OID for key derivation algorithm, if present.
        </member>
        <member name="T:Org.BouncyCastle.Cms.Pkcs5Scheme2PbeKey">
            <summary>
            PKCS5 scheme-2 - password converted to bytes assuming ASCII.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Cms.Pkcs5Scheme2Utf8PbeKey">
            PKCS5 scheme-2 - password converted to bytes using UTF-8.
        </member>
        <member name="M:Org.BouncyCastle.Cms.RecipientInformationStore.GetFirstRecipient(Org.BouncyCastle.Cms.RecipientID)">
             Return the first RecipientInformation object that matches the
             passed in selector. Null if there are no matches.
            
             @param selector to identify a recipient
             @return a single RecipientInformation object. Null if none matches.
        </member>
        <member name="M:Org.BouncyCastle.Cms.RecipientInformationStore.GetRecipients">
             Return all recipients in the collection
            
             @return a collection of recipients.
        </member>
        <member name="M:Org.BouncyCastle.Cms.RecipientInformationStore.GetRecipients(Org.BouncyCastle.Cms.RecipientID)">
             Return possible empty collection with recipients matching the passed in RecipientID
            
             @param selector a recipient id to select against.
             @return a collection of RecipientInformation objects.
        </member>
        <member name="P:Org.BouncyCastle.Cms.RecipientInformationStore.Count">
             Return the number of recipients in the collection.
            
             @return number of recipients identified.
        </member>
        <member name="T:Org.BouncyCastle.Cms.SignerID">
            a basic index for a signer.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInfoGeneratorBuilder.SetDirectSignature(System.Boolean)">
             If the passed in flag is true, the signer signature will be based on the data, not
             a collection of signed attributes, and no signed attributes will be included.
            
             @return the builder object
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInfoGeneratorBuilder.WithSignedAttributeGenerator(Org.BouncyCastle.Cms.CmsAttributeTableGenerator)">
              Provide a custom signed attribute generator.
            
             @param signedGen a generator of signed attributes.
             @return the builder object
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInfoGeneratorBuilder.WithUnsignedAttributeGenerator(Org.BouncyCastle.Cms.CmsAttributeTableGenerator)">
             Provide a generator of unsigned attributes.
            
             @param unsignedGen  a generator for signed attributes.
             @return the builder object
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInfoGeneratorBuilder.Build(Org.BouncyCastle.Crypto.ISignatureFactory,Org.BouncyCastle.X509.X509Certificate)">
             Build a generator with the passed in certHolder issuer and serial number as the signerIdentifier.
            
             @param contentSigner  operator for generating the final signature in the SignerInfo with.
             @param certHolder  carrier for the X.509 certificate related to the contentSigner.
             @return  a SignerInfoGenerator
             @throws OperatorCreationException   if the generator cannot be built.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInfoGeneratorBuilder.Build(Org.BouncyCastle.Crypto.ISignatureFactory,System.Byte[])">
             Build a generator with the passed in subjectKeyIdentifier as the signerIdentifier. If used  you should
             try to follow the calculation described in RFC 5280 section 4.2.1.2.
            
             @param signerFactory  operator factory for generating the final signature in the SignerInfo with.
             @param subjectKeyIdentifier    key identifier to identify the public key for verifying the signature.
             @return  a SignerInfoGenerator
        </member>
        <member name="T:Org.BouncyCastle.Cms.SignerInformation">
            an expanded SignerInfo block from a CMS Signed message
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformation.GetContentDigest">
            return the content digest that was calculated during verification.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformation.GetSignature">
            return the encoded signature
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformation.GetCounterSignatures">
            Return a SignerInformationStore containing the counter signatures attached to this
            signer. If no counter signatures are present an empty store is returned.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformation.GetEncodedSignedAttributes">
            return the DER encoding of the signed attributes.
            @throws IOException if an encoding error occurs.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformation.Verify(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            verify that the given public key successfully handles and confirms the
            signature associated with this signer.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformation.Verify(Org.BouncyCastle.X509.X509Certificate)">
            verify that the given certificate successfully handles and confirms
            the signature associated with this signer and, if a signingTime
            attribute is available, that the certificate was valid at the time the
            signature was generated.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformation.ToSignerInfo">
             Return the base ASN.1 CMS structure that this object contains.
            
             @return an object containing a CMS SignerInfo structure.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformation.ReplaceUnsignedAttributes(Org.BouncyCastle.Cms.SignerInformation,Org.BouncyCastle.Asn1.Cms.AttributeTable)">
             Return a signer information object with the passed in unsigned
             attributes replacing the ones that are current associated with
             the object passed in.
            
             @param signerInformation the signerInfo to be used as the basis.
             @param unsignedAttributes the unsigned attributes to add.
             @return a copy of the original SignerInformationObject with the changed attributes.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformation.AddCounterSigners(Org.BouncyCastle.Cms.SignerInformation,Org.BouncyCastle.Cms.SignerInformationStore)">
             Return a signer information object with passed in SignerInformationStore representing counter
             signatures attached as an unsigned attribute.
            
             @param signerInformation the signerInfo to be used as the basis.
             @param counterSigners signer info objects carrying counter signature.
             @return a copy of the original SignerInformationObject with the changed attributes.
        </member>
        <member name="P:Org.BouncyCastle.Cms.SignerInformation.Version">
            return the version number for this objects underlying SignerInfo structure.
        </member>
        <member name="P:Org.BouncyCastle.Cms.SignerInformation.DigestAlgOid">
            return the object identifier for the signature.
        </member>
        <member name="P:Org.BouncyCastle.Cms.SignerInformation.DigestAlgParams">
            return the signature parameters, or null if there aren't any.
        </member>
        <member name="P:Org.BouncyCastle.Cms.SignerInformation.EncryptionAlgOid">
            return the object identifier for the signature.
        </member>
        <member name="P:Org.BouncyCastle.Cms.SignerInformation.EncryptionAlgParams">
            return the signature/encryption algorithm parameters, or null if
            there aren't any.
        </member>
        <member name="P:Org.BouncyCastle.Cms.SignerInformation.SignedAttributes">
            return a table of the signed attributes - indexed by
            the OID of the attribute.
        </member>
        <member name="P:Org.BouncyCastle.Cms.SignerInformation.UnsignedAttributes">
            return a table of the unsigned attributes indexed by
            the OID of the attribute.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformationStore.#ctor(Org.BouncyCastle.Cms.SignerInformation)">
             Create a store containing a single SignerInformation object.
            
             @param signerInfo the signer information to contain.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformationStore.#ctor(System.Collections.ICollection)">
             Create a store containing a collection of SignerInformation objects.
            
             @param signerInfos a collection signer information objects to contain.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformationStore.GetFirstSigner(Org.BouncyCastle.Cms.SignerID)">
             Return the first SignerInformation object that matches the
             passed in selector. Null if there are no matches.
            
             @param selector to identify a signer
             @return a single SignerInformation object. Null if none matches.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformationStore.GetSigners">
            <returns>An ICollection of all signers in the collection</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformationStore.GetSigners(Org.BouncyCastle.Cms.SignerID)">
             Return possible empty collection with signers matching the passed in SignerID
            
             @param selector a signer id to select against.
             @return a collection of SignerInformation objects.
        </member>
        <member name="P:Org.BouncyCastle.Cms.SignerInformationStore.Count">
            <summary>The number of signers in the collection.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Cms.SimpleAttributeTableGenerator">
            Basic generator that just returns a preconstructed attribute table
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Agreement.DHAgreement">
            a Diffie-Hellman key exchange engine.
            <p>
            note: This uses MTI/A0 key agreement in order to make the key agreement
            secure against passive attacks. If you're doing Diffie-Hellman and both
            parties have long term public keys you should look at using this. For
            further information have a look at RFC 2631.</p>
            <p>
            It's possible to extend this to more than two parties as well, for the moment
            that is left as an exercise for the reader.</p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.DHAgreement.CalculateMessage">
            calculate our initial message.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.DHAgreement.CalculateAgreement(Org.BouncyCastle.Crypto.Parameters.DHPublicKeyParameters,Org.BouncyCastle.Math.BigInteger)">
            given a message from a given party and the corresponding public key
            calculate the next message in the agreement sequence. In this case
            this will represent the shared secret.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Agreement.DHBasicAgreement">
            a Diffie-Hellman key agreement class.
            <p>
            note: This is only the basic algorithm, it doesn't take advantage of
            long term public keys if they are available. See the DHAgreement class
            for a "better" implementation.</p>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IBasicAgreement">
            The basic interface that basic Diffie-Hellman implementations
            conforms to.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBasicAgreement.Init(Org.BouncyCastle.Crypto.ICipherParameters)">
            initialise the agreement engine.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBasicAgreement.GetFieldSize">
            return the field size for the agreement algorithm in bytes.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBasicAgreement.CalculateAgreement(Org.BouncyCastle.Crypto.ICipherParameters)">
            given a public key from a given party calculate the next
            message in the agreement sequence.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.DHBasicAgreement.CalculateAgreement(Org.BouncyCastle.Crypto.ICipherParameters)">
            given a short term public key from a given party calculate the next
            message in the agreement sequence.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Agreement.DHStandardGroups">
            <summary>Standard Diffie-Hellman groups from various IETF specifications.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Agreement.ECDHBasicAgreement">
             P1363 7.2.1 ECSVDP-DH
            
             ECSVDP-DH is Elliptic Curve Secret Value Derivation Primitive,
             Diffie-Hellman version. It is based on the work of [DH76], [Mil86],
             and [Kob87]. This primitive derives a shared secret value from one
             party's private key and another party's public key, where both have
             the same set of EC domain parameters. If two parties correctly
             execute this primitive, they will produce the same output. This
             primitive can be invoked by a scheme to derive a shared secret key;
             specifically, it may be used with the schemes ECKAS-DH1 and
             DL/ECKAS-DH2. It assumes that the input keys are valid (see also
             Section 7.2.2).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Agreement.ECDHCBasicAgreement">
             P1363 7.2.2 ECSVDP-DHC
            
             ECSVDP-DHC is Elliptic Curve Secret Value Derivation Primitive,
             Diffie-Hellman version with cofactor multiplication. It is based on
             the work of [DH76], [Mil86], [Kob87], [LMQ98] and [Kal98a]. This
             primitive derives a shared secret value from one party's private key
             and another party's public key, where both have the same set of EC
             domain parameters. If two parties correctly execute this primitive,
             they will produce the same output. This primitive can be invoked by a
             scheme to derive a shared secret key; specifically, it may be used
             with the schemes ECKAS-DH1 and DL/ECKAS-DH2. It does not assume the
             validity of the input public key (see also Section 7.2.1).
             <p>
             Note: As stated P1363 compatibility mode with ECDH can be preset, and
             in this case the implementation doesn't have a ECDH compatibility mode
             (if you want that just use ECDHBasicAgreement and note they both implement
             BasicAgreement!).</p>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant">
             <summary>
             A participant in a Password Authenticated Key Exchange by Juggling (J-PAKE) exchange.
            
             The J-PAKE exchange is defined by Feng Hao and Peter Ryan in the paper
             <a href="http://grouper.ieee.org/groups/1363/Research/contributions/hao-ryan-2008.pdf">
             "Password Authenticated Key Exchange by Juggling, 2008."</a>
            
             The J-PAKE protocol is symmetric.
             There is no notion of a <i>client</i> or <i>server</i>, but rather just two <i>participants</i>.
             An instance of JPakeParticipant represents one participant, and
             is the primary interface for executing the exchange.
            
             To execute an exchange, construct a JPakeParticipant on each end,
             and call the following 7 methods
             (once and only once, in the given order, for each participant, sending messages between them as described):
            
             CreateRound1PayloadToSend() - and send the payload to the other participant
             ValidateRound1PayloadReceived(JPakeRound1Payload) - use the payload received from the other participant
             CreateRound2PayloadToSend() - and send the payload to the other participant
             ValidateRound2PayloadReceived(JPakeRound2Payload) - use the payload received from the other participant
             CalculateKeyingMaterial()
             CreateRound3PayloadToSend(BigInteger) - and send the payload to the other participant
             ValidateRound3PayloadReceived(JPakeRound3Payload, BigInteger) - use the payload received from the other participant
            
             Each side should derive a session key from the keying material returned by CalculateKeyingMaterial().
             The caller is responsible for deriving the session key using a secure key derivation function (KDF).
            
             Round 3 is an optional key confirmation process.
             If you do not execute round 3, then there is no assurance that both participants are using the same key.
             (i.e. if the participants used different passwords, then their session keys will differ.)
            
             If the round 3 validation succeeds, then the keys are guaranteed to be the same on both sides.
            
             The symmetric design can easily support the asymmetric cases when one party initiates the communication.
             e.g. Sometimes the round1 payload and round2 payload may be sent in one pass.
             Also, in some cases, the key confirmation payload can be sent together with the round2 payload.
             These are the trivial techniques to optimize the communication.
            
             The key confirmation process is implemented as specified in
             <a href="http://csrc.nist.gov/publications/nistpubs/800-56A/SP800-56A_Revision1_Mar08-2007.pdf">NIST SP 800-56A Revision 1</a>,
             Section 8.2 Unilateral Key Confirmation for Key Agreement Schemes.
            
             This class is stateful and NOT threadsafe.
             Each instance should only be used for ONE complete J-PAKE exchange
             (i.e. a new JPakeParticipant should be constructed for each new J-PAKE exchange).
             </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.#ctor(System.String,System.Char[])">
             <summary>
             Convenience constructor for a new JPakeParticipant that uses
             the JPakePrimeOrderGroups#NIST_3072 prime order group,
             a SHA-256 digest, and a default SecureRandom implementation.
            
             After construction, the State state will be STATE_INITIALIZED.
             
             Throws NullReferenceException if any argument is null. Throws
             ArgumentException if password is empty.
             </summary>
             <param name="participantId">Unique identifier of this participant.
                  The two participants in the exchange must NOT share the same id.</param>
             <param name="password">Shared secret.
                  A defensive copy of this array is made (and cleared once CalculateKeyingMaterial() is called).
                  Caller should clear the input password as soon as possible.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.#ctor(System.String,System.Char[],Org.BouncyCastle.Crypto.Agreement.JPake.JPakePrimeOrderGroup)">
             <summary>
             Convenience constructor for a new JPakeParticipant that uses
             a SHA-256 digest, and a default SecureRandom implementation.
            
             After construction, the State state will be STATE_INITIALIZED.
             
             Throws NullReferenceException if any argument is null. Throws
             ArgumentException if password is empty.
             </summary>
             <param name="participantId">Unique identifier of this participant.
                  The two participants in the exchange must NOT share the same id.</param>
             <param name="password">Shared secret.
                  A defensive copy of this array is made (and cleared once CalculateKeyingMaterial() is called).
                  Caller should clear the input password as soon as possible.</param>
             <param name="group">Prime order group. See JPakePrimeOrderGroups for standard groups.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.#ctor(System.String,System.Char[],Org.BouncyCastle.Crypto.Agreement.JPake.JPakePrimeOrderGroup,Org.BouncyCastle.Crypto.IDigest,Org.BouncyCastle.Security.SecureRandom)">
             <summary>
             Constructor for a new JPakeParticipant.
            
             After construction, the State state will be STATE_INITIALIZED.
             
             Throws NullReferenceException if any argument is null. Throws
             ArgumentException if password is empty.
             </summary>
             <param name="participantId">Unique identifier of this participant.
                  The two participants in the exchange must NOT share the same id.</param>
             <param name="password">Shared secret.
                  A defensive copy of this array is made (and cleared once CalculateKeyingMaterial() is called).
                  Caller should clear the input password as soon as possible.</param>
             <param name="group">Prime order group. See JPakePrimeOrderGroups for standard groups.</param>
             <param name="digest">Digest to use during zero knowledge proofs and key confirmation
                 (SHA-256 or stronger preferred).</param>
             <param name="random">Source of secure random data for x1 and x2, and for the zero knowledge proofs.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.CreateRound1PayloadToSend">
             <summary>
             Creates and returns the payload to send to the other participant during round 1.
            
             After execution, the State state} will be STATE_ROUND_1_CREATED}.
             </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.ValidateRound1PayloadReceived(Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound1Payload)">
             <summary>
             Validates the payload received from the other participant during round 1.
            
             Must be called prior to CreateRound2PayloadToSend().
            
             After execution, the State state will be  STATE_ROUND_1_VALIDATED.
             
             Throws CryptoException if validation fails. Throws InvalidOperationException
             if called multiple times.
             </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.CreateRound2PayloadToSend">
             <summary>
             Creates and returns the payload to send to the other participant during round 2.
            
             ValidateRound1PayloadReceived(JPakeRound1Payload) must be called prior to this method.
            
             After execution, the State state will be  STATE_ROUND_2_CREATED.
            
             Throws InvalidOperationException if called prior to ValidateRound1PayloadReceived(JPakeRound1Payload), or multiple times
             </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.ValidateRound2PayloadReceived(Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound2Payload)">
             <summary>
             Validates the payload received from the other participant during round 2.
             Note that this DOES NOT detect a non-common password.
             The only indication of a non-common password is through derivation
             of different keys (which can be detected explicitly by executing round 3 and round 4)
            
             Must be called prior to CalculateKeyingMaterial().
            
             After execution, the State state will be STATE_ROUND_2_VALIDATED.
            
             Throws CryptoException if validation fails. Throws
             InvalidOperationException if called prior to ValidateRound1PayloadReceived(JPakeRound1Payload), or multiple times
             </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.CalculateKeyingMaterial">
             <summary>
             Calculates and returns the key material.
             A session key must be derived from this key material using a secure key derivation function (KDF).
             The KDF used to derive the key is handled externally (i.e. not by JPakeParticipant).
            
             The keying material will be identical for each participant if and only if
             each participant's password is the same.  i.e. If the participants do not
             share the same password, then each participant will derive a different key.
             Therefore, if you immediately start using a key derived from
             the keying material, then you must handle detection of incorrect keys.
             If you want to handle this detection explicitly, you can optionally perform
             rounds 3 and 4.  See JPakeParticipant for details on how to execute
             rounds 3 and 4.
            
             The keying material will be in the range <tt>[0, p-1]</tt>.
            
             ValidateRound2PayloadReceived(JPakeRound2Payload) must be called prior to this method.
             
             As a side effect, the internal password array is cleared, since it is no longer needed.
            
             After execution, the State state will be STATE_KEY_CALCULATED.
            
             Throws InvalidOperationException if called prior to ValidateRound2PayloadReceived(JPakeRound2Payload),
             or if called multiple times.
             </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.CreateRound3PayloadToSend(Org.BouncyCastle.Math.BigInteger)">
             <summary>
             Creates and returns the payload to send to the other participant during round 3.
            
             See JPakeParticipant for more details on round 3.
            
             After execution, the State state} will be  STATE_ROUND_3_CREATED.
             Throws InvalidOperationException if called prior to CalculateKeyingMaterial, or multiple
             times.
             </summary>
             <param name="keyingMaterial">The keying material as returned from CalculateKeyingMaterial().</param> 
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.ValidateRound3PayloadReceived(Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound3Payload,Org.BouncyCastle.Math.BigInteger)">
             <summary>
             Validates the payload received from the other participant during round 3.
            
             See JPakeParticipant for more details on round 3.
            
             After execution, the State state will be STATE_ROUND_3_VALIDATED.
             
             Throws CryptoException if validation fails. Throws InvalidOperationException if called prior to
             CalculateKeyingMaterial or multiple times
             </summary>
             <param name="round3PayloadReceived">The round 3 payload received from the other participant.</param> 
             <param name="keyingMaterial">The keying material as returned from CalculateKeyingMaterial().</param> 
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeParticipant.State">
            <summary>
            Gets the current state of this participant.
            See the <tt>STATE_*</tt> constants for possible values.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Agreement.JPake.JPakePrimeOrderGroup">
             <summary>
             A pre-computed prime order group for use during a J-PAKE exchange.
            
             Typically a Schnorr group is used.  In general, J-PAKE can use any prime order group
             that is suitable for public key cryptography, including elliptic curve cryptography.
            
             See JPakePrimeOrderGroups for convenient standard groups.
            
             NIST <a href="http://csrc.nist.gov/groups/ST/toolkit/documents/Examples/DSA2_All.pdf">publishes</a>
             many groups that can be used for the desired level of security.
             </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.JPake.JPakePrimeOrderGroup.#ctor(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
             <summary>
             Constructs a new JPakePrimeOrderGroup.
            
             In general, you should use one of the pre-approved groups from
             JPakePrimeOrderGroups, rather than manually constructing one.
            
             The following basic checks are performed:
            
             p-1 must be evenly divisible by q
             g must be in [2, p-1]
             g^q mod p must equal 1
             p must be prime (within reasonably certainty)
             q must be prime (within reasonably certainty)
            
             The prime checks are performed using BigInteger#isProbablePrime(int),
             and are therefore subject to the same probability guarantees.
            
             These checks prevent trivial mistakes.
             However, due to the small uncertainties if p and q are not prime,
             advanced attacks are not prevented.
             Use it at your own risk.
             
             Throws NullReferenceException if any argument is null. Throws
             InvalidOperationException is any of the above validations fail.
             </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.JPake.JPakePrimeOrderGroup.#ctor(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,System.Boolean)">
            <summary>
            Constructor used by the pre-approved groups in JPakePrimeOrderGroups.
            These pre-approved groups can avoid the expensive checks.
            User-specified groups should not use this constructor.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Agreement.JPake.JPakePrimeOrderGroups">
            <summary>
            Standard pre-computed prime order groups for use by J-PAKE.
            (J-PAKE can use pre-computed prime order groups, same as DSA and Diffie-Hellman.)
            <p/>
            This class contains some convenient constants for use as input for
            constructing {@link JPAKEParticipant}s.
            <p/>
            The prime order groups below are taken from Sun's JDK JavaDoc (docs/guide/security/CryptoSpec.html#AppB),
            and from the prime order groups
            <a href="http://csrc.nist.gov/groups/ST/toolkit/documents/Examples/DSA2_All.pdf">published by NIST</a>.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Agreement.JPake.JPakePrimeOrderGroups.SUN_JCE_1024">
            <summary>
            From Sun's JDK JavaDoc (docs/guide/security/CryptoSpec.html#AppB)
            1024-bit p, 160-bit q and 1024-bit g for 80-bit security.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Agreement.JPake.JPakePrimeOrderGroups.NIST_2048">
            <summary>
            From NIST.
            2048-bit p, 224-bit q and 2048-bit g for 112-bit security.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Agreement.JPake.JPakePrimeOrderGroups.NIST_3072">
            <summary>
            From NIST.
            3072-bit p, 256-bit q and 3072-bit g for 128-bit security.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound1Payload">
            <summary>
            The payload sent/received during the first round of a J-PAKE exchange.
            
            Each JPAKEParticipant creates and sends an instance of this payload to
            the other. The payload to send should be created via 
            JPAKEParticipant.CreateRound1PayloadToSend().
            
            Each participant must also validate the payload received from the other.
            The received payload should be validated via 
            JPAKEParticipant.ValidateRound1PayloadReceived(JPakeRound1Payload).
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound1Payload.participantId">
            <summary>
            The id of the JPAKEParticipant who created/sent this payload.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound1Payload.gx1">
            <summary>
            The value of g^x1
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound1Payload.gx2">
            <summary>
            The value of g^x2
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound1Payload.knowledgeProofForX1">
            <summary>
            The zero knowledge proof for x1.
            
            This is a two element array, containing {g^v, r} for x1.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound1Payload.knowledgeProofForX2">
            <summary>
            The zero knowledge proof for x2.
            
            This is a two element array, containing {g^v, r} for x2.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound2Payload">
            <summary>
            The payload sent/received during the second round of a J-PAKE exchange.
            
            Each JPAKEParticipant creates and sends an instance
            of this payload to the other JPAKEParticipant.
            The payload to send should be created via
            JPAKEParticipant#createRound2PayloadToSend()
            
            Each JPAKEParticipant must also validate the payload
            received from the other JPAKEParticipant.
            The received payload should be validated via
            JPAKEParticipant#validateRound2PayloadReceived(JPakeRound2Payload)
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound2Payload.participantId">
            <summary>
            The id of the JPAKEParticipant who created/sent this payload.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound2Payload.a">
            <summary>
            The value of A, as computed during round 2.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound2Payload.knowledgeProofForX2s">
            <summary>
            The zero knowledge proof for x2 * s.
            
            This is a two element array, containing {g^v, r} for x2 * s.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound3Payload">
             <summary>
             The payload sent/received during the optional third round of a J-PAKE exchange,
             which is for explicit key confirmation.
            
             Each JPAKEParticipant creates and sends an instance
             of this payload to the other JPAKEParticipant.
             The payload to send should be created via
             JPAKEParticipant#createRound3PayloadToSend(BigInteger)
            
             Eeach JPAKEParticipant must also validate the payload
             received from the other JPAKEParticipant.
             The received payload should be validated via
             JPAKEParticipant#validateRound3PayloadReceived(JPakeRound3Payload, BigInteger)
             </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound3Payload.participantId">
            <summary>
            The id of the {@link JPAKEParticipant} who created/sent this payload.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeRound3Payload.macTag">
            <summary>
            The value of MacTag, as computed by round 3.
            
            See JPAKEUtil#calculateMacTag(string, string, BigInteger, BigInteger, BigInteger, BigInteger, BigInteger, org.bouncycastle.crypto.Digest)
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities">
            <summary>
            Primitives needed for a J-PAKE exchange.
            
            The recommended way to perform a J-PAKE exchange is by using
            two JPAKEParticipants.  Internally, those participants
            call these primitive operations in JPakeUtilities.
            
            The primitives, however, can be used without a JPAKEParticipant if needed.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.GenerateX1(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Return a value that can be used as x1 or x3 during round 1.
            The returned value is a random value in the range [0, q-1].
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.GenerateX2(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Return a value that can be used as x2 or x4 during round 1.
            The returned value is a random value in the range [1, q-1].
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.CalculateS(System.Char[])">
            <summary>
            Converts the given password to a BigInteger
            for use in arithmetic calculations.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.CalculateGx(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Calculate g^x mod p as done in round 1.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.CalculateGA(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Calculate ga as done in round 2.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.CalculateX2s(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Calculate x2 * s as done in round 2.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.CalculateA(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Calculate A as done in round 2. 
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.CalculateZeroKnowledgeProof(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,System.String,Org.BouncyCastle.Crypto.IDigest,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Calculate a zero knowledge proof of x using Schnorr's signature.
            The returned array has two elements {g^v, r = v-x*h} for x.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.ValidateGx4(Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Validates that g^x4 is not 1.
            throws CryptoException if g^x4 is 1
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.ValidateGa(Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Validates that ga is not 1.
            
            As described by Feng Hao...
            Alice could simply check ga != 1 to ensure it is a generator.
            In fact, as we will explain in Section 3, (x1 + x3 + x4 ) is random over Zq even in the face of active attacks.
            Hence, the probability for ga = 1 is extremely small - on the order of 2^160 for 160-bit q.
            
            throws CryptoException if ga is 1
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.ValidateZeroKnowledgeProof(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger[],System.String,Org.BouncyCastle.Crypto.IDigest)">
            <summary>
            Validates the zero knowledge proof (generated by
            calculateZeroKnowledgeProof(BigInteger, BigInteger, BigInteger, BigInteger, BigInteger, string, Digest, SecureRandom)
            is correct.
            
            throws CryptoException if the zero knowledge proof is not correct
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.CalculateKeyingMaterial(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Calculates the keying material, which can be done after round 2 has completed.
            A session key must be derived from this key material using a secure key derivation function (KDF).
            The KDF used to derive the key is handled externally (i.e. not by JPAKEParticipant).
            
            KeyingMaterial = (B/g^{x2*x4*s})^x2
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.ValidateParticipantIdsDiffer(System.String,System.String)">
             <summary>
             Validates that the given participant ids are not equal.
             (For the J-PAKE exchange, each participant must use a unique id.)
            
             Throws CryptoException if the participantId strings are equal.
             </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.ValidateParticipantIdsEqual(System.String,System.String)">
            <summary>
            Validates that the given participant ids are equal.
            This is used to ensure that the payloads received from
            each round all come from the same participant.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.ValidateNotNull(System.Object,System.String)">
            <summary>
            Validates that the given object is not null.
            throws NullReferenceException if the object is null.
            </summary>
            <param name="obj">object in question</param>
            <param name="description">name of the object (to be used in exception message)</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.CalculateMacTag(System.String,System.String,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Crypto.IDigest)">
             <summary>
             Calculates the MacTag (to be used for key confirmation), as defined by
             <a href="http://csrc.nist.gov/publications/nistpubs/800-56A/SP800-56A_Revision1_Mar08-2007.pdf">NIST SP 800-56A Revision 1</a>,
             Section 8.2 Unilateral Key Confirmation for Key Agreement Schemes.
            
             MacTag = HMAC(MacKey, MacLen, MacData)
             MacKey = H(K || "JPAKE_KC")
             MacData = "KC_1_U" || participantId || partnerParticipantId || gx1 || gx2 || gx3 || gx4
            
             Note that both participants use "KC_1_U" because the sender of the round 3 message
             is always the initiator for key confirmation.
            
             HMAC = {@link HMac} used with the given {@link Digest}
             H = The given {@link Digest}
             MacLen = length of MacTag
             </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.CalculateMacKey(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Crypto.IDigest)">
            <summary>
            Calculates the MacKey (i.e. the key to use when calculating the MagTag for key confirmation).
            
            MacKey = H(K || "JPAKE_KC")
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.JPake.JPakeUtilities.ValidateMacTag(System.String,System.String,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Crypto.IDigest,Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Validates the MacTag received from the partner participant.
            
            throws CryptoException if the participantId strings are equal.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IDerivationParameters">
            Parameters for key/byte stream derivation classes
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Agreement.Kdf.DHKekGenerator">
            RFC 2631 Diffie-hellman KEK derivation function.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IDerivationFunction">
            base interface for general purpose byte derivation functions.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IDerivationFunction.Digest">
            return the message digest used as the basis for the function
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Agreement.Kdf.ECDHKekGenerator">
            X9.63 based key derivation function for ECDH CMS.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Client">
            Implements the client side SRP-6a protocol. Note that this class is stateful, and therefore NOT threadsafe.
            This implementation of SRP is based on the optimized message sequence put forth by Thomas Wu in the paper
            "SRP-6: Improvements and Refinements to the Secure Remote Password Protocol, 2002"
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Client.Init(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Crypto.IDigest,Org.BouncyCastle.Security.SecureRandom)">
            Initialises the client to begin new authentication attempt
            @param N The safe prime associated with the client's verifier
            @param g The group parameter associated with the client's verifier
            @param digest The digest algorithm associated with the client's verifier
            @param random For key generation
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Client.GenerateClientCredentials(System.Byte[],System.Byte[],System.Byte[])">
            Generates client's credentials given the client's salt, identity and password
            @param salt The salt used in the client's verifier.
            @param identity The user's identity (eg. username)
            @param password The user's password
            @return Client's public value to send to server
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Client.CalculateSecret(Org.BouncyCastle.Math.BigInteger)">
            Generates client's verification message given the server's credentials
            @param serverB The server's credentials
            @return Client's verification message for the server
            @throws CryptoException If server's credentials are invalid
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Client.CalculateClientEvidenceMessage">
            Computes the client evidence message M1 using the previously received values.
            To be called after calculating the secret S.
            @return M1: the client side generated evidence message
            @throws CryptoException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Client.VerifyServerEvidenceMessage(Org.BouncyCastle.Math.BigInteger)">
            Authenticates the server evidence message M2 received and saves it only if correct.
            @param M2: the server side generated evidence message
            @return A boolean indicating if the server message M2 was the expected one.
            @throws CryptoException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Client.CalculateSessionKey">
            Computes the final session key as a result of the SRP successful mutual authentication
            To be called after verifying the server evidence message M2.
            @return Key: the mutually authenticated symmetric session key
            @throws CryptoException
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Server">
            Implements the server side SRP-6a protocol. Note that this class is stateful, and therefore NOT threadsafe.
            This implementation of SRP is based on the optimized message sequence put forth by Thomas Wu in the paper
            "SRP-6: Improvements and Refinements to the Secure Remote Password Protocol, 2002"
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Server.Init(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Crypto.IDigest,Org.BouncyCastle.Security.SecureRandom)">
            Initialises the server to accept a new client authentication attempt
            @param N The safe prime associated with the client's verifier
            @param g The group parameter associated with the client's verifier
            @param v The client's verifier
            @param digest The digest algorithm associated with the client's verifier
            @param random For key generation
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Server.GenerateServerCredentials">
            Generates the server's credentials that are to be sent to the client.
            @return The server's public value to the client
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Server.CalculateSecret(Org.BouncyCastle.Math.BigInteger)">
            Processes the client's credentials. If valid the shared secret is generated and returned.
            @param clientA The client's credentials
            @return A shared secret BigInteger
            @throws CryptoException If client's credentials are invalid
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Server.VerifyClientEvidenceMessage(Org.BouncyCastle.Math.BigInteger)">
            Authenticates the received client evidence message M1 and saves it only if correct.
            To be called after calculating the secret S.
            @param M1: the client side generated evidence message
            @return A boolean indicating if the client message M1 was the expected one.
            @throws CryptoException 
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Server.CalculateServerEvidenceMessage">
            Computes the server evidence message M2 using the previously verified values.
            To be called after successfully verifying the client evidence message M1.
            @return M2: the server side generated evidence message
            @throws CryptoException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Server.CalculateSessionKey">
            Computes the final session key as a result of the SRP successful mutual authentication
            To be called after calculating the server evidence message M2.
            @return Key: the mutual authenticated symmetric session key
            @throws CryptoException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Utilities.CalculateM1(Org.BouncyCastle.Crypto.IDigest,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            Computes the client evidence message (M1) according to the standard routine:
            M1 = H( A | B | S )
            @param digest The Digest used as the hashing function H
            @param N Modulus used to get the pad length
            @param A The public client value
            @param B The public server value
            @param S The secret calculated by both sides
            @return M1 The calculated client evidence message
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Utilities.CalculateM2(Org.BouncyCastle.Crypto.IDigest,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            Computes the server evidence message (M2) according to the standard routine:
            M2 = H( A | M1 | S )
            @param digest The Digest used as the hashing function H
            @param N Modulus used to get the pad length
            @param A The public client value
            @param M1 The client evidence message
            @param S The secret calculated by both sides
            @return M2 The calculated server evidence message
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6Utilities.CalculateKey(Org.BouncyCastle.Crypto.IDigest,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            Computes the final Key according to the standard routine: Key = H(S)
            @param digest The Digest used as the hashing function H
            @param N Modulus used to get the pad length
            @param S The secret calculated by both sides
            @return
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6VerifierGenerator">
            Generates new SRP verifier for user
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6VerifierGenerator.Init(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Crypto.IDigest)">
            Initialises generator to create new verifiers
            @param N The safe prime to use (see DHParametersGenerator)
            @param g The group parameter to use (see DHParametersGenerator)
            @param digest The digest to use. The same digest type will need to be used later for the actual authentication
            attempt. Also note that the final session key size is dependent on the chosen digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.Srp.Srp6VerifierGenerator.GenerateVerifier(System.Byte[],System.Byte[],System.Byte[])">
            Creates a new SRP verifier
            @param salt The salt to use, generally should be large and random
            @param identity The user's identifying information (eg. username)
            @param password The user's password
            @return A new verifier for use in future SRP authentication
        </member>
        <member name="T:Org.BouncyCastle.Crypto.AsymmetricCipherKeyPair">
            a holding class for public/private parameter pairs.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.AsymmetricCipherKeyPair.#ctor(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
             basic constructor.
            
             @param publicParam a public key parameters object.
             @param privateParam the corresponding private key parameters.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.AsymmetricCipherKeyPair.Public">
             return the public key parameters.
            
             @return the public key parameters.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.AsymmetricCipherKeyPair.Private">
             return the private key parameters.
            
             @return the private key parameters.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher">
            The AEAD block ciphers already handle buffering internally, so this class
            just takes care of implementing IBufferedCipher methods.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IBufferedCipher">
            <remarks>Block cipher engines are expected to conform to this interface.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBufferedCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">If true the cipher is initialised for encryption,
            if false for decryption.</param>
            <param name="parameters">The key and other data required by the cipher.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBufferedCipher.Reset">
            <summary>
            Reset the cipher. After resetting the cipher is in the same state
            as it was after the last init (if there was one).
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IBufferedCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the cipher.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.GetBlockSize">
             return the blocksize for the underlying cipher.
            
             @return the blocksize for the underlying cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.GetUpdateOutputSize(System.Int32)">
             return the size of the output buffer required for an update
             an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.GetOutputSize(System.Int32)">
             return the size of the output buffer required for an update plus a
             doFinal with an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update and doFinal
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             process a single byte, producing an output block if necessary.
            
             @param in the input byte.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process an array of bytes, producing output if necessary.
            
             @param in the input byte array.
             @param inOff the offset at which the input data starts.
             @param len the number of bytes to be copied out of the input array.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Process the last block in the buffer.
            
             @param out the array the block currently being held is copied into.
             @param outOff the offset at which the copying starts.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there is insufficient space in out for
             the output, or the input is not block size aligned and should be.
             @exception InvalidOperationException if the underlying cipher is not
             initialised.
             @exception InvalidCipherTextException if padding is expected and not found.
             @exception DataLengthException if the input is not block size
             aligned.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.Reset">
            Reset the buffer and cipher. After resetting the object is in the same
            state as it was after the last init (if there was one).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.BufferedAsymmetricBlockCipher">
            a buffer wrapper for an asymmetric block cipher, allowing input
            to be accumulated in a piecemeal fashion until final processing.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAsymmetricBlockCipher.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher)">
             base constructor.
            
             @param cipher the cipher this buffering object wraps.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAsymmetricBlockCipher.GetBufferPosition">
             return the amount of data sitting in the buffer.
            
             @return the amount of data sitting in the buffer.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAsymmetricBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the buffer and the underlying cipher.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAsymmetricBlockCipher.DoFinal">
             process the contents of the buffer using the underlying
             cipher.
            
             @return the result of the encryption/decryption process on the
             buffer.
             @exception InvalidCipherTextException if we are given a garbage block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAsymmetricBlockCipher.Reset">
            <summary>Reset the buffer</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.BufferedBlockCipher">
            A wrapper class that allows block ciphers to be used to process data in
            a piecemeal fashion. The BufferedBlockCipher outputs a block only when the
            buffer is full and more data is being added, or on a doFinal.
            <p>
            Note: in the case where the underlying cipher is either a CFB cipher or an
            OFB one the last block may not be a multiple of the block size.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.#ctor">
            constructor for subclasses
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Create a buffered block cipher without padding.
            
             @param cipher the underlying block cipher this buffering object wraps.
             false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the cipher.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.GetBlockSize">
             return the blocksize for the underlying cipher.
            
             @return the blocksize for the underlying cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.GetUpdateOutputSize(System.Int32)">
             return the size of the output buffer required for an update
             an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.GetOutputSize(System.Int32)">
             return the size of the output buffer required for an update plus a
             doFinal with an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update and doFinal
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             process a single byte, producing an output block if necessary.
            
             @param in the input byte.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process an array of bytes, producing output if necessary.
            
             @param in the input byte array.
             @param inOff the offset at which the input data starts.
             @param len the number of bytes to be copied out of the input array.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Process the last block in the buffer.
            
             @param out the array the block currently being held is copied into.
             @param outOff the offset at which the copying starts.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there is insufficient space in out for
             the output, or the input is not block size aligned and should be.
             @exception InvalidOperationException if the underlying cipher is not
             initialised.
             @exception InvalidCipherTextException if padding is expected and not found.
             @exception DataLengthException if the input is not block size
             aligned.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.Reset">
            Reset the buffer and cipher. After resetting the object is in the same
            state as it was after the last init (if there was one).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.CipherKeyGenerator">
            The base class for symmetric, or secret, cipher key generators.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.CipherKeyGenerator.Init(Org.BouncyCastle.Crypto.KeyGenerationParameters)">
             initialise the key generator.
            
             @param param the parameters to be used for key generation
        </member>
        <member name="M:Org.BouncyCastle.Crypto.CipherKeyGenerator.GenerateKey">
             Generate a secret key.
            
             @return a byte array containing the key value.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.DataLengthException">
            this exception is thrown if a buffer that is meant to have output
            copied into it turns out to be too short, or if we've been given
            insufficient input. In general this exception will Get thrown rather
            than an ArrayOutOfBounds exception.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.DataLengthException.#ctor">
            base constructor.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.DataLengthException.#ctor(System.String)">
             create a DataLengthException with the given message.
            
             @param message the message to be carried with the exception.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.GeneralDigest">
            base implementation of MD4 family style digest as outlined in
            "Handbook of Applied Cryptography", pages 344 - 347.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IDigest">
            interface that a message digest conforms to.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDigest.GetDigestSize">
             return the size, in bytes, of the digest produced by this message digest.
            
             @return the size, in bytes, of the digest produced by this message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDigest.GetByteLength">
             return the size, in bytes, of the internal buffer used by this digest.
            
             @return the size, in bytes, of the internal buffer used by this digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDigest.Update(System.Byte)">
             update the message digest with a single byte.
            
             @param inByte the input byte to be entered.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDigest.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
             update the message digest with a block of bytes.
            
             @param input the byte array containing the data.
             @param inOff the offset into the byte array where the data starts.
             @param len the length of the data.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDigest.DoFinal(System.Byte[],System.Int32)">
             Close the digest, producing the final digest value. The doFinal
             call leaves the digest reset.
            
             @param output the array the digest is to be copied into.
             @param outOff the offset into the out array the digest is to start at.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDigest.Reset">
            reset the digest back to it's initial state.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IDigest.AlgorithmName">
             return the algorithm name
            
             @return the algorithm name
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IMemoable.Copy">
            <summary>
            Produce a copy of this object with its configuration and in its current state.
            </summary>
            <remarks>
            The returned object may be used simply to store the state, or may be used as a similar object
            starting from the copied state.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IMemoable.Reset(Org.BouncyCastle.Utilities.IMemoable)">
            <summary>
            Restore a copied object state into this object.
            </summary>
            <remarks>
            Implementations of this method <em>should</em> try to avoid or minimise memory allocation to perform the reset.
            </remarks>
            <param name="other">an object originally {@link #copy() copied} from an object of the same type as this instance.</param>
            <exception cref="T:System.InvalidCastException">if the provided object is not of the correct type.</exception>
            <exception cref="T:Org.BouncyCastle.Utilities.MemoableResetException">if the <b>other</b> parameter is in some other way invalid.</exception>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Gost3411Digest">
            implementation of GOST R 34.11-94
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Gost3411Digest.#ctor">
            Standard constructor
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Gost3411Digest.#ctor(System.Byte[])">
            Constructor to allow use of a particular sbox with GOST28147
            @see GOST28147Engine#getSBox(String)
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Gost3411Digest.#ctor(Org.BouncyCastle.Crypto.Digests.Gost3411Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Gost3411Digest.C2">
            reset the chaining variables to the IV values.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.KeccakDigest">
            <summary>
            Implementation of Keccak based on following KeccakNISTInterface.c from http://keccak.noekeon.org/
            </summary>
            <remarks>
            Following the naming conventions used in the C source code to enable easy review of the implementation.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.KeccakDigest.GetByteLength">
             Return the size of block that the compression function is applied to in bytes.
            
             @return internal byte length of a block.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.LongDigest">
            Base class for SHA-384 and SHA-512.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.LongDigest.#ctor">
            Constructor for variable length word
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.LongDigest.#ctor(Org.BouncyCastle.Crypto.Digests.LongDigest)">
            Copy constructor.  We are using copy constructors in place
            of the object.Clone() interface as this interface is not
            supported by J2ME.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.LongDigest.AdjustByteCounts">
            adjust the byte counts so that byteCount2 represents the
            upper long (less 3 bits) word of the byte count.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.MD2Digest">
            implementation of MD2
            as outlined in RFC1319 by B.Kaliski from RSA Laboratories April 1992
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD2Digest.DoFinal(System.Byte[],System.Int32)">
             Close the digest, producing the final digest value. The doFinal
             call leaves the digest reset.
            
             @param out the array the digest is to be copied into.
             @param outOff the offset into the out array the digest is to start at.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD2Digest.Reset">
            reset the digest back to it's initial state.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD2Digest.Update(System.Byte)">
             update the message digest with a single byte.
            
             @param in the input byte to be entered.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD2Digest.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
             update the message digest with a block of bytes.
            
             @param in the byte array containing the data.
             @param inOff the offset into the byte array where the data starts.
             @param len the length of the data.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Digests.MD2Digest.AlgorithmName">
             return the algorithm name
            
             @return the algorithm name
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.MD4Digest">
            implementation of MD4 as RFC 1320 by R. Rivest, MIT Laboratory for
            Computer Science and RSA Data Security, Inc.
            <p>
            <b>NOTE</b>: This algorithm is only included for backwards compatibility
            with legacy applications, it's not secure, don't use it for anything new!</p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD4Digest.#ctor">
            Standard constructor
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD4Digest.#ctor(Org.BouncyCastle.Crypto.Digests.MD4Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD4Digest.Reset">
            reset the chaining variables to the IV values.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.MD5Digest">
            implementation of MD5 as outlined in "Handbook of Applied Cryptography", pages 346 - 347.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD5Digest.#ctor(Org.BouncyCastle.Crypto.Digests.MD5Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD5Digest.Reset">
            reset the chaining variables to the IV values.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.NonMemoableDigest">
            Wrapper removes exposure to the IMemoable interface on an IDigest implementation.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.NonMemoableDigest.#ctor(Org.BouncyCastle.Crypto.IDigest)">
             Base constructor.
            
             @param baseDigest underlying digest to use.
             @exception IllegalArgumentException if baseDigest is null
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.RipeMD128Digest">
            implementation of RipeMD128
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD128Digest.#ctor">
            Standard constructor
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD128Digest.#ctor(Org.BouncyCastle.Crypto.Digests.RipeMD128Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD128Digest.Reset">
            reset the chaining variables to the IV values.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.RipeMD160Digest">
            implementation of RipeMD see,
            http://www.esat.kuleuven.ac.be/~bosselae/ripemd160.html
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD160Digest.#ctor">
            Standard constructor
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD160Digest.#ctor(Org.BouncyCastle.Crypto.Digests.RipeMD160Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD160Digest.Reset">
            reset the chaining variables to the IV values.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.RipeMD256Digest">
            <remarks>
            <p>Implementation of RipeMD256.</p>
            <p><b>Note:</b> this algorithm offers the same level of security as RipeMD128.</p>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD256Digest.#ctor">
            <summary> Standard constructor</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD256Digest.#ctor(Org.BouncyCastle.Crypto.Digests.RipeMD256Digest)">
            <summary> Copy constructor.  This will copy the state of the provided
            message digest.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD256Digest.Reset">
            <summary> reset the chaining variables to the IV values.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.RipeMD320Digest">
            <remarks>
            <p>Implementation of RipeMD 320.</p>
            <p><b>Note:</b> this algorithm offers the same level of security as RipeMD160.</p>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD320Digest.#ctor">
            <summary> Standard constructor</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD320Digest.#ctor(Org.BouncyCastle.Crypto.Digests.RipeMD320Digest)">
            <summary> Copy constructor.  This will copy the state of the provided
            message digest.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD320Digest.Reset">
            <summary> reset the chaining variables to the IV values.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Sha1Digest">
             implementation of SHA-1 as outlined in "Handbook of Applied Cryptography", pages 346 - 349.
            
             It is interesting to ponder why the, apart from the extra IV, the other difference here from MD5
             is the "endianness" of the word processing!
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha1Digest.#ctor(Org.BouncyCastle.Crypto.Digests.Sha1Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha1Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Sha224Digest">
            SHA-224 as described in RFC 3874
            <pre>
                    block  word  digest
            SHA-1   512    32    160
            SHA-224 512    32    224
            SHA-256 512    32    256
            SHA-384 1024   64    384
            SHA-512 1024   64    512
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha224Digest.#ctor">
            Standard constructor
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha224Digest.#ctor(Org.BouncyCastle.Crypto.Digests.Sha224Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha224Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Sha256Digest">
             Draft FIPS 180-2 implementation of SHA-256. <b>Note:</b> As this is
             based on a draft this implementation is subject to change.
            
             <pre>
                     block  word  digest
             SHA-1   512    32    160
             SHA-256 512    32    256
             SHA-384 1024   64    384
             SHA-512 1024   64    512
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha256Digest.#ctor(Org.BouncyCastle.Crypto.Digests.Sha256Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha256Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Sha384Digest">
             Draft FIPS 180-2 implementation of SHA-384. <b>Note:</b> As this is
             based on a draft this implementation is subject to change.
            
             <pre>
                     block  word  digest
             SHA-1   512    32    160
             SHA-256 512    32    256
             SHA-384 1024   64    384
             SHA-512 1024   64    512
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha384Digest.#ctor(Org.BouncyCastle.Crypto.Digests.Sha384Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha384Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Sha3Digest">
            <summary>
            Implementation of SHA-3 based on following KeccakNISTInterface.c from http://keccak.noekeon.org/
            </summary>
            <remarks>
            Following the naming conventions used in the C source code to enable easy review of the implementation.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Sha512Digest">
             Draft FIPS 180-2 implementation of SHA-512. <b>Note:</b> As this is
             based on a draft this implementation is subject to change.
            
             <pre>
                     block  word  digest
             SHA-1   512    32    160
             SHA-256 512    32    256
             SHA-384 1024   64    384
             SHA-512 1024   64    512
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha512Digest.#ctor(Org.BouncyCastle.Crypto.Digests.Sha512Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha512Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Sha512tDigest">
            FIPS 180-4 implementation of SHA-512/t
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha512tDigest.#ctor(System.Int32)">
            Standard constructor
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha512tDigest.#ctor(Org.BouncyCastle.Crypto.Digests.Sha512tDigest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha512tDigest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.ShakeDigest">
            <summary>
            Implementation of SHAKE based on following KeccakNISTInterface.c from http://keccak.noekeon.org/
            </summary>
            <remarks>
            Following the naming conventions used in the C source code to enable easy review of the implementation.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IXof">
            <remarks>
            With FIPS PUB 202 a new kind of message digest was announced which supported extendable output, or variable digest sizes.
            This interface provides the extra method required to support variable output on a digest implementation.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IXof.DoFinal(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Output the results of the final calculation for this digest to outLen number of bytes.
            </summary>
            <param name="output">output array to write the output bytes to.</param>
            <param name="outOff">offset to start writing the bytes at.</param>
            <param name="outLen">the number of output bytes requested.</param>
            <returns>the number of bytes written</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IXof.DoOutput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Start outputting the results of the final calculation for this digest. Unlike DoFinal, this method
            will continue producing output until the Xof is explicitly reset, or signals otherwise.
            </summary>
            <param name="output">output array to write the output bytes to.</param>
            <param name="outOff">offset to start writing the bytes at.</param>
            <param name="outLen">the number of output bytes requested.</param>
            <returns>the number of bytes written</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.ShortenedDigest">
            Wrapper class that reduces the output length of a particular digest to
            only the first n bytes of the digest function.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.ShortenedDigest.#ctor(Org.BouncyCastle.Crypto.IDigest,System.Int32)">
             Base constructor.
            
             @param baseDigest underlying digest to use.
             @param length length in bytes of the output of doFinal.
             @exception ArgumentException if baseDigest is null, or length is greater than baseDigest.GetDigestSize().
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.SkeinDigest">
            <summary>
            Implementation of the Skein parameterised hash function in 256, 512 and 1024 bit block sizes,
            based on the <see cref="T:Org.BouncyCastle.Crypto.Engines.ThreefishEngine">Threefish</see> tweakable block cipher.
            </summary>
            <remarks>
            This is the 1.3 version of Skein defined in the Skein hash function submission to the NIST SHA-3
            competition in October 2010.
            <p/>
            Skein was designed by Niels Ferguson - Stefan Lucks - Bruce Schneier - Doug Whiting - Mihir
            Bellare - Tadayoshi Kohno - Jon Callas - Jesse Walker.
            </remarks>
            <seealso cref="T:Org.BouncyCastle.Crypto.Digests.SkeinEngine"/>
            <seealso cref="T:Org.BouncyCastle.Crypto.Parameters.SkeinParameters"/>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.SkeinDigest.SKEIN_256">
            <summary>
            256 bit block size - Skein-256
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.SkeinDigest.SKEIN_512">
            <summary>
            512 bit block size - Skein-512
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.SkeinDigest.SKEIN_1024">
            <summary>
            1024 bit block size - Skein-1024
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.SkeinDigest.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a Skein digest with an internal state size and output size.
            </summary>
            <param name="stateSizeBits">the internal state size in bits - one of <see cref="F:Org.BouncyCastle.Crypto.Digests.SkeinDigest.SKEIN_256"/> <see cref="F:Org.BouncyCastle.Crypto.Digests.SkeinDigest.SKEIN_512"/> or
                                  <see cref="F:Org.BouncyCastle.Crypto.Digests.SkeinDigest.SKEIN_1024"/>.</param>
            <param name="digestSizeBits">the output/digest size to produce in bits, which must be an integral number of
                                 bytes.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.SkeinDigest.Init(Org.BouncyCastle.Crypto.Parameters.SkeinParameters)">
            <summary>
            Optionally initialises the Skein digest with the provided parameters.
            </summary>
            See <see cref="T:Org.BouncyCastle.Crypto.Parameters.SkeinParameters"></see> for details on the parameterisation of the Skein hash function.
            <param name="parameters">the parameters to apply to this engine, or <code>null</code> to use no parameters.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.SkeinEngine">
            <summary>
            Implementation of the Skein family of parameterised hash functions in 256, 512 and 1024 bit block
            sizes, based on the <see cref="T:Org.BouncyCastle.Crypto.Engines.ThreefishEngine">Threefish</see> tweakable block cipher.
            </summary>
            <remarks>
            This is the 1.3 version of Skein defined in the Skein hash function submission to the NIST SHA-3
            competition in October 2010.
            <p/>
            Skein was designed by Niels Ferguson - Stefan Lucks - Bruce Schneier - Doug Whiting - Mihir
            Bellare - Tadayoshi Kohno - Jon Callas - Jesse Walker.
            <p/>
            This implementation is the basis for <see cref="T:Org.BouncyCastle.Crypto.Digests.SkeinDigest"/> and <see cref="T:Org.BouncyCastle.Crypto.Macs.SkeinMac"/>, implementing the
            parameter based configuration system that allows Skein to be adapted to multiple applications. <br/>
            Initialising the engine with <see cref="T:Org.BouncyCastle.Crypto.Parameters.SkeinParameters"/> allows standard and arbitrary parameters to
            be applied during the Skein hash function.
            <p/>
            Implemented:
            <ul>
            <li>256, 512 and 1024 bit internal states.</li>
            <li>Full 96 bit input length.</li>
            <li>Parameters defined in the Skein specification, and arbitrary other pre and post message
            parameters.</li>
            <li>Arbitrary output size in 1 byte intervals.</li>
            </ul>
            <p/>
            Not implemented:
            <ul>
            <li>Sub-byte length input (bit padding).</li>
            <li>Tree hashing.</li>
            </ul>
            </remarks>
            <seealso cref="T:Org.BouncyCastle.Crypto.Parameters.SkeinParameters"/>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.SkeinEngine.SKEIN_256">
            <summary>
            256 bit block size - Skein-256
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.SkeinEngine.SKEIN_512">
            <summary>
            512 bit block size - Skein-512
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.SkeinEngine.SKEIN_1024">
            <summary>
            1024 bit block size - Skein-1024
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.SkeinEngine.PARAM_TYPE_KEY">
            The parameter type for the Skein key.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.SkeinEngine.PARAM_TYPE_CONFIG">
            The parameter type for the Skein configuration block.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.SkeinEngine.PARAM_TYPE_MESSAGE">
            The parameter type for the message.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.SkeinEngine.PARAM_TYPE_OUTPUT">
            The parameter type for the output transformation.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.SkeinEngine.INITIAL_STATES">
            Precalculated UBI(CFG) states for common state/output combinations without key or other
            pre-message params.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.SkeinEngine.threefish">
            Underlying Threefish tweakable block cipher
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.SkeinEngine.outputSizeBytes">
            Size of the digest output, in bytes
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.SkeinEngine.chain">
            The current chaining/state value
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.SkeinEngine.initialState">
            The initial state value
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.SkeinEngine.key">
            The (optional) key parameter
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.SkeinEngine.preMessageParameters">
            Parameters to apply prior to the message
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.SkeinEngine.postMessageParameters">
            Parameters to apply after the message, but prior to output
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.SkeinEngine.ubi">
            The current UBI operation
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.SkeinEngine.singleByte">
            Buffer for single byte update method
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.SkeinEngine.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a Skein digest with an internal state size and output size.
            </summary>
            <param name="blockSizeBits">the internal state size in bits - one of <see cref="F:Org.BouncyCastle.Crypto.Digests.SkeinEngine.SKEIN_256"/> <see cref="F:Org.BouncyCastle.Crypto.Digests.SkeinEngine.SKEIN_512"/> or
                                  <see cref="F:Org.BouncyCastle.Crypto.Digests.SkeinEngine.SKEIN_1024"/>.</param>
            <param name="outputSizeBits">the output/digest size to produce in bits, which must be an integral number of
                                 bytes.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.SkeinEngine.#ctor(Org.BouncyCastle.Crypto.Digests.SkeinEngine)">
            <summary>
            Creates a SkeinEngine as an exact copy of an existing instance.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.SkeinEngine.Init(Org.BouncyCastle.Crypto.Parameters.SkeinParameters)">
            <summary>
            Initialises the Skein engine with the provided parameters. See <see cref="T:Org.BouncyCastle.Crypto.Parameters.SkeinParameters"/> for
            details on the parameterisation of the Skein hash function.
            </summary>
            <param name="parameters">the parameters to apply to this engine, or <code>null</code> to use no parameters.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.SkeinEngine.CreateInitialState">
            Calculate the initial (pre message block) chaining state.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.SkeinEngine.Reset">
            <summary>
            Reset the engine to the initial state (with the key and any pre-message parameters , ready to
            accept message input.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.SkeinEngine.UbiTweak.LOW_RANGE">
            Point at which position might overflow long, so switch to add with carry logic
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.SkeinEngine.UbiTweak.T1_FINAL">
            Bit 127 = final
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.SkeinEngine.UbiTweak.T1_FIRST">
            Bit 126 = first
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.SkeinEngine.UbiTweak.tweak">
            UBI uses a 128 bit tweak
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.SkeinEngine.UbiTweak.extendedPosition">
            Whether 64 bit position exceeded
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.SkeinEngine.UbiTweak.AdvancePosition(System.Int32)">
            Advances the position in the tweak by the specified value.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.SkeinEngine.UBI">
            The Unique Block Iteration chaining mode.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.SkeinEngine.UBI.currentBlock">
            Buffer for the current block of message data
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.SkeinEngine.UBI.currentOffset">
            Offset into the current message block
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.SkeinEngine.UBI.message">
            Buffer for message words for feedback into encrypted block
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.SM3Digest">
            <summary>
            Implementation of Chinese SM3 digest as described at
            http://tools.ietf.org/html/draft-shen-sm3-hash-00
            and at .... ( Chinese PDF )
            </summary>
            <remarks>
            The specification says "process a bit stream",
            but this is written to process bytes in blocks of 4,
            meaning this will process 32-bit word groups.
            But so do also most other digest specifications,
            including the SHA-256 which was a origin for
            this specification.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.SM3Digest.#ctor">
            <summary>
            Standard constructor
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.SM3Digest.#ctor(Org.BouncyCastle.Crypto.Digests.SM3Digest)">
            <summary>
            Copy constructor.  This will copy the state of the provided
            message digest.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.SM3Digest.Reset">
            <summary>
            reset the chaining variables
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.TigerDigest">
            implementation of Tiger based on:
            <a href="http://www.cs.technion.ac.il/~biham/Reports/Tiger">
             http://www.cs.technion.ac.il/~biham/Reports/Tiger</a>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.TigerDigest.#ctor">
            Standard constructor
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.TigerDigest.#ctor(Org.BouncyCastle.Crypto.Digests.TigerDigest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.TigerDigest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.WhirlpoolDigest">
             Implementation of WhirlpoolDigest, based on Java source published by Barreto
             and Rijmen.
            
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.WhirlpoolDigest.#ctor(Org.BouncyCastle.Crypto.Digests.WhirlpoolDigest)">
            Copy constructor. This will copy the state of the provided message
            digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.WhirlpoolDigest.Reset">
            Reset the chaining variables
        </member>
        <member name="M:Org.BouncyCastle.Crypto.EC.CustomNamedCurves.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the X9ECParameters object for the named curve represented by
             the passed in object identifier. Null if the curve isn't present.
            
             @param oid an object identifier representing a named curve, if present.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.EC.CustomNamedCurves.GetOid(System.String)">
             return the object identifier signified by the passed in name. Null
             if there is no object identifier associated with name.
            
             @return the object identifier associated with name, if present.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.EC.CustomNamedCurves.GetName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            return the named curve name represented by the given object identifier.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.EC.CustomNamedCurves.Names">
            returns an enumeration containing the name strings for curves
            contained in this structure.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Encodings.ISO9796d1Encoding">
            ISO 9796-1 padding. Note in the light of recent results you should
            only use this with RSA (rather than the "simpler" Rabin keys) and you
            should never use it with anything other than a hash (ie. even if the
            message is small don't sign the message, sign it's hash) or some "random"
            value. See your favorite search engine for details.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IAsymmetricBlockCipher">
            <remarks>Base interface for a public/private key block cipher.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAsymmetricBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">Initialise for encryption if true, for decryption if false.</param>
            <param name="parameters">The key or other data required by the cipher.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAsymmetricBlockCipher.GetInputBlockSize">
            <returns>The maximum size, in bytes, an input block may be.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAsymmetricBlockCipher.GetOutputBlockSize">
            <returns>The maximum size, in bytes, an output block will be.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAsymmetricBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>Process a block.</summary>
            <param name="inBuf">The input buffer.</param>
            <param name="inOff">The offset into <paramref>inBuf</paramref> that the input block begins.</param>
            <param name="inLen">The length of the input block.</param>
            <exception cref="T:Org.BouncyCastle.Crypto.InvalidCipherTextException">Input decrypts improperly.</exception>
            <exception cref="T:Org.BouncyCastle.Crypto.DataLengthException">Input is too large for the cipher.</exception>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IAsymmetricBlockCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.ISO9796d1Encoding.GetInputBlockSize">
            return the input block size. The largest message we can process
            is (key_size_in_bits + 3)/16, which in our world comes to
            key_size_in_bytes / 2.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.ISO9796d1Encoding.GetOutputBlockSize">
            return the maximum possible size for the output.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.ISO9796d1Encoding.SetPadBits(System.Int32)">
            set the number of bits in the next message to be treated as
            pad bits.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.ISO9796d1Encoding.GetPadBits">
            retrieve the number of pad bits in the last decoded message.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.ISO9796d1Encoding.DecodeBlock(System.Byte[],System.Int32,System.Int32)">
            @exception InvalidCipherTextException if the decrypted block is not a valid ISO 9796 bit string
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Encodings.OaepEncoding">
            Optimal Asymmetric Encryption Padding (OAEP) - see PKCS 1 V 2.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.OaepEncoding.DecodeBlock(System.Byte[],System.Int32,System.Int32)">
            @exception InvalidCipherTextException if the decrypted block turns out to
            be badly formatted.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.OaepEncoding.ItoOSP(System.Int32,System.Byte[])">
            int to octet string.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.OaepEncoding.maskGeneratorFunction1(System.Byte[],System.Int32,System.Int32,System.Int32)">
            mask generator function, as described in PKCS1v2.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding">
            this does your basic Pkcs 1 v1.5 padding - whether or not you should be using this
            depends on your application - see Pkcs1 Version 2 for details.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.StrictLengthEnabledProperty">
            some providers fail to include the leading zero in PKCS1 encoded blocks. If you need to
            work with one of these set the system property Org.BouncyCastle.Pkcs1.Strict to false.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher)">
            Basic constructor.
            @param cipher
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,System.Int32)">
            Constructor for decryption with a fixed plaintext length.
            
            @param cipher The cipher to use for cryptographic operation.
            @param pLen Length of the expected plaintext.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,System.Byte[])">
            Constructor for decryption with a fixed plaintext length and a fallback
            value that is returned, if the padding is incorrect.
            
            @param cipher
                       The cipher to use for cryptographic operation.
            @param fallback
                       The fallback value, we don't to a arraycopy here.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.CheckPkcs1Encoding(System.Byte[],System.Int32)">
            Checks if the argument is a correctly PKCS#1.5 encoded Plaintext
            for encryption.
            
            @param encoded The Plaintext.
            @param pLen Expected length of the plaintext.
            @return Either 0, if the encoding is correct, or -1, if it is incorrect.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.DecodeBlockOrRandom(System.Byte[],System.Int32,System.Int32)">
            Decode PKCS#1.5 encoding, and return a random value if the padding is not correct.
            
            @param in The encrypted block.
            @param inOff Offset in the encrypted block.
            @param inLen Length of the encrypted block.
            @param pLen Length of the desired output.
            @return The plaintext without padding, or a random value if the padding was incorrect.
            
            @throws InvalidCipherTextException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.DecodeBlock(System.Byte[],System.Int32,System.Int32)">
            @exception InvalidCipherTextException if the decrypted block is not in Pkcs1 format.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.StrictLengthEnabled">
            The same effect can be achieved by setting the static property directly
            <p>
            The static property is checked during construction of the encoding object, it is set to
            true by default.
            </p>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.AesEngine">
             an implementation of the AES (Rijndael), from FIPS-197.
             <p>
             For further details see: <a href="http://csrc.nist.gov/encryption/aes/">http://csrc.nist.gov/encryption/aes/</a>.
            
             This implementation is based on optimizations from Dr. Brian Gladman's paper and C code at
             <a href="http://fp.gladman.plus.com/cryptography_technology/rijndael/">http://fp.gladman.plus.com/cryptography_technology/rijndael/</a>
            
             There are three levels of tradeoff of speed vs memory
             Because java has no preprocessor, they are written as three separate classes from which to choose
            
             The fastest uses 8Kbytes of static tables to precompute round calculations, 4 256 word tables for encryption
             and 4 for decryption.
            
             The middle performance version uses only one 256 word table for each, for a total of 2Kbytes,
             adding 12 rotate operations per round to compute the values contained in the other tables from
             the contents of the first.
            
             The slowest version uses no static tables at all and computes the values in each round.
             </p>
             <p>
             This file contains the middle performance version with 2Kbytes of static tables for round precomputation.
             </p>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IBlockCipher">
            <remarks>Base interface for a symmetric key block cipher.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">Initialise for encryption if true, for decryption if false.</param>
            <param name="parameters">The key or other data required by the cipher.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockCipher.GetBlockSize">
            <returns>The block size for this cipher, in bytes.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>Process a block.</summary>
            <param name="inBuf">The input buffer.</param>
            <param name="inOff">The offset into <paramref>inBuf</paramref> that the input block begins.</param>
            <param name="outBuf">The output buffer.</param>
            <param name="outOff">The offset into <paramref>outBuf</paramref> to write the output block.</param>
            <exception cref="T:Org.BouncyCastle.Crypto.DataLengthException">If input block is wrong size, or outBuf too small.</exception>
            <returns>The number of bytes processed and produced.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockCipher.Reset">
            <summary>
            Reset the cipher to the same state as it was after the last init (if there was one).
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IBlockCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IBlockCipher.IsPartialBlockOkay">
            <summary>Indicates whether this cipher can handle partial blocks.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.AesEngine.GenerateWorkingKey(System.Byte[],System.Boolean)">
            Calculate the necessary round keys
            The number of calculations depends on key size and block size
            AES specified a fixed block size of 128 bits and key sizes 128/192/256 bits
            This code is written assuming those are the only possible values
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.AesEngine.#ctor">
            default constructor - 128 bit block size.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.AesEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise an AES cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.AesFastEngine">
             an implementation of the AES (Rijndael)), from FIPS-197.
             <p>
             For further details see: <a href="http://csrc.nist.gov/encryption/aes/">http://csrc.nist.gov/encryption/aes/</a>.
            
             This implementation is based on optimizations from Dr. Brian Gladman's paper and C code at
             <a href="http://fp.gladman.plus.com/cryptography_technology/rijndael/">http://fp.gladman.plus.com/cryptography_technology/rijndael/</a>
            
             There are three levels of tradeoff of speed vs memory
             Because java has no preprocessor), they are written as three separate classes from which to choose
            
             The fastest uses 8Kbytes of static tables to precompute round calculations), 4 256 word tables for encryption
             and 4 for decryption.
            
             The middle performance version uses only one 256 word table for each), for a total of 2Kbytes),
             adding 12 rotate operations per round to compute the values contained in the other tables from
             the contents of the first
            
             The slowest version uses no static tables at all and computes the values in each round
             </p>
             <p>
             This file contains the fast version with 8Kbytes of static tables for round precomputation
             </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.AesFastEngine.GenerateWorkingKey(System.Byte[],System.Boolean)">
            Calculate the necessary round keys
            The number of calculations depends on key size and block size
            AES specified a fixed block size of 128 bits and key sizes 128/192/256 bits
            This code is written assuming those are the only possible values
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.AesFastEngine.#ctor">
            default constructor - 128 bit block size.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.AesFastEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise an AES cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.AesLightEngine">
             an implementation of the AES (Rijndael), from FIPS-197.
             <p>
             For further details see: <a href="http://csrc.nist.gov/encryption/aes/">http://csrc.nist.gov/encryption/aes/</a>.
            
             This implementation is based on optimizations from Dr. Brian Gladman's paper and C code at
             <a href="http://fp.gladman.plus.com/cryptography_technology/rijndael/">http://fp.gladman.plus.com/cryptography_technology/rijndael/</a>
            
             There are three levels of tradeoff of speed vs memory
             Because java has no preprocessor, they are written as three separate classes from which to choose
            
             The fastest uses 8Kbytes of static tables to precompute round calculations, 4 256 word tables for encryption
             and 4 for decryption.
            
             The middle performance version uses only one 256 word table for each, for a total of 2Kbytes,
             adding 12 rotate operations per round to compute the values contained in the other tables from
             the contents of the first
            
             The slowest version uses no static tables at all and computes the values
             in each round.
             </p>
             <p>
             This file contains the slowest performance version with no static tables
             for round precomputation, but it has the smallest foot print.
             </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.AesLightEngine.GenerateWorkingKey(System.Byte[],System.Boolean)">
            Calculate the necessary round keys
            The number of calculations depends on key size and block size
            AES specified a fixed block size of 128 bits and key sizes 128/192/256 bits
            This code is written assuming those are the only possible values
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.AesLightEngine.#ctor">
            default constructor - 128 bit block size.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.AesLightEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise an AES cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.AesWrapEngine">
            <remarks>
            An implementation of the AES Key Wrapper from the NIST Key Wrap Specification.
            <p/>
            For further details see: <a href="http://csrc.nist.gov/encryption/kms/key-wrap.pdf">http://csrc.nist.gov/encryption/kms/key-wrap.pdf</a>.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.Rfc3394WrapEngine">
            <remarks>
            An implementation of the AES Key Wrapper from the NIST Key Wrap
            Specification as described in RFC 3394.
            <p/>
            For further details see: <a href="http://www.ietf.org/rfc/rfc3394.txt">http://www.ietf.org/rfc/rfc3394.txt</a>
            and  <a href="http://csrc.nist.gov/encryption/kms/key-wrap.pdf">http://csrc.nist.gov/encryption/kms/key-wrap.pdf</a>.
            </remarks>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IWrapper.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.BlowfishEngine">
            A class that provides Blowfish key encryption operations,
            such as encoding data and generating keys.
            All the algorithms herein are from Applied Cryptography
            and implement a simplified cryptography interface.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.BlowfishEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a Blowfish cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.BlowfishEngine.ProcessTable(System.UInt32,System.UInt32,System.UInt32[])">
            apply the encryption cycle to each value pair in the table.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.BlowfishEngine.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            Encrypt the given input starting at the given offset and place
            the result in the provided buffer starting at the given offset.
            The input will be an exact multiple of our blocksize.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.BlowfishEngine.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            Decrypt the given input starting at the given offset and place
            the result in the provided buffer starting at the given offset.
            The input will be an exact multiple of our blocksize.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.CamelliaEngine">
            Camellia - based on RFC 3713.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.CamelliaLightEngine">
            Camellia - based on RFC 3713, smaller implementation, about half the size of CamelliaEngine.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.CamelliaWrapEngine">
            <remarks>
            An implementation of the Camellia key wrapper based on RFC 3657/RFC 3394.
            <p/>
            For further details see: <a href="http://www.ietf.org/rfc/rfc3657.txt">http://www.ietf.org/rfc/rfc3657.txt</a>.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.Cast5Engine">
             A class that provides CAST key encryption operations,
             such as encoding data and generating keys.
            
             All the algorithms herein are from the Internet RFC's
            
             RFC2144 - Cast5 (64bit block, 40-128bit key)
             RFC2612 - CAST6 (128bit block, 128-256bit key)
            
             and implement a simplified cryptography interface.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast5Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a CAST cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast5Engine.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Encrypt the given input starting at the given offset and place
             the result in the provided buffer starting at the given offset.
            
             @param src        The plaintext buffer
             @param srcIndex    An offset into src
             @param dst        The ciphertext buffer
             @param dstIndex    An offset into dst
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast5Engine.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Decrypt the given input starting at the given offset and place
             the result in the provided buffer starting at the given offset.
            
             @param src        The plaintext buffer
             @param srcIndex    An offset into src
             @param dst        The ciphertext buffer
             @param dstIndex    An offset into dst
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast5Engine.F1(System.UInt32,System.UInt32,System.Int32)">
             The first of the three processing functions for the
             encryption and decryption.
            
             @param D            the input to be processed
             @param Kmi        the mask to be used from Km[n]
             @param Kri        the rotation value to be used
            
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast5Engine.F2(System.UInt32,System.UInt32,System.Int32)">
             The second of the three processing functions for the
             encryption and decryption.
            
             @param D            the input to be processed
             @param Kmi        the mask to be used from Km[n]
             @param Kri        the rotation value to be used
            
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast5Engine.F3(System.UInt32,System.UInt32,System.Int32)">
             The third of the three processing functions for the
             encryption and decryption.
            
             @param D            the input to be processed
             @param Kmi        the mask to be used from Km[n]
             @param Kri        the rotation value to be used
            
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast5Engine.CAST_Encipher(System.UInt32,System.UInt32,System.UInt32[])">
             Does the 16 rounds to encrypt the block.
            
             @param L0    the LH-32bits of the plaintext block
             @param R0    the RH-32bits of the plaintext block
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.Cast6Engine">
             A class that provides CAST6 key encryption operations,
             such as encoding data and generating keys.
            
             All the algorithms herein are from the Internet RFC
            
             RFC2612 - CAST6 (128bit block, 128-256bit key)
            
             and implement a simplified cryptography interface.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast6Engine.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Encrypt the given input starting at the given offset and place
             the result in the provided buffer starting at the given offset.
            
             @param src        The plaintext buffer
             @param srcIndex    An offset into src
             @param dst        The ciphertext buffer
             @param dstIndex    An offset into dst
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast6Engine.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Decrypt the given input starting at the given offset and place
             the result in the provided buffer starting at the given offset.
            
             @param src        The plaintext buffer
             @param srcIndex    An offset into src
             @param dst        The ciphertext buffer
             @param dstIndex    An offset into dst
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast6Engine.CAST_Encipher(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32[])">
             Does the 12 quad rounds rounds to encrypt the block.
            
             @param A    the 00-31  bits of the plaintext block
             @param B    the 32-63  bits of the plaintext block
             @param C    the 64-95  bits of the plaintext block
             @param D    the 96-127 bits of the plaintext block
             @param result the resulting ciphertext
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast6Engine.CAST_Decipher(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32[])">
             Does the 12 quad rounds rounds to decrypt the block.
            
             @param A    the 00-31  bits of the ciphertext block
             @param B    the 32-63  bits of the ciphertext block
             @param C    the 64-95  bits of the ciphertext block
             @param D    the 96-127 bits of the ciphertext block
             @param result the resulting plaintext
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.ChaCha7539Engine">
            <summary>
            Implementation of Daniel J. Bernstein's ChaCha stream cipher.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.Salsa20Engine">
            <summary>
            Implementation of Daniel J. Bernstein's Salsa20 stream cipher, Snuffle 2005
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IStreamCipher">
            <summary>The interface stream ciphers conform to.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IStreamCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">If true the cipher is initialised for encryption,
            if false for decryption.</param>
            <param name="parameters">The key and other data required by the cipher.</param>
            <exception cref="T:System.ArgumentException">
            If the parameters argument is inappropriate.
            </exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IStreamCipher.ReturnByte(System.Byte)">
            <summary>encrypt/decrypt a single byte returning the result.</summary>
            <param name="input">the byte to be processed.</param>
            <returns>the result of processing the input byte.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IStreamCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Process a block of bytes from <c>input</c> putting the result into <c>output</c>.
            </summary>
            <param name="input">The input byte array.</param>
            <param name="inOff">
            The offset into <c>input</c> where the data to be processed starts.
            </param>
            <param name="length">The number of bytes to be processed.</param>
            <param name="output">The output buffer the processed bytes go into.</param>
            <param name="outOff">
            The offset into <c>output</c> the processed data starts at.
            </param>
            <exception cref="T:Org.BouncyCastle.Crypto.DataLengthException">If the output buffer is too small.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IStreamCipher.Reset">
            <summary>
            Reset the cipher to the same state as it was after the last init (if there was one).
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IStreamCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.Salsa20Engine.StateSize">
            Constants 
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Salsa20Engine.#ctor">
            <summary>
            Creates a 20 round Salsa20 engine.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Salsa20Engine.#ctor(System.Int32)">
            <summary>
            Creates a Salsa20 engine with a specific number of rounds.
            </summary>
            <param name="rounds">the number of rounds (must be an even number).</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Salsa20Engine.R(System.UInt32,System.Int32)">
             Rotate left
            
             @param   x   value to rotate
             @param   y   amount to rotate x
            
             @return  rotated x
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ChaCha7539Engine.#ctor">
            <summary>
            Creates a 20 rounds ChaCha engine.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.ChaChaEngine">
            <summary>
            Implementation of Daniel J. Bernstein's ChaCha stream cipher.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ChaChaEngine.#ctor">
            <summary>
            Creates a 20 rounds ChaCha engine.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ChaChaEngine.#ctor(System.Int32)">
            <summary>
            Creates a ChaCha engine with a specific number of rounds.
            </summary>
            <param name="rounds">the number of rounds (must be an even number).</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ChaChaEngine.ChachaCore(System.Int32,System.UInt32[],System.UInt32[])">
            <summary>
            ChaCha function.
            </summary>
            <param name="rounds">The number of ChaCha rounds to execute</param>
            <param name="input">The input words.</param>
            <param name="x">The ChaCha state to modify.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.DesEdeEngine">
            <remarks>A class that provides a basic DESede (or Triple DES) engine.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.DesEngine">
            <remarks>A class that provides a basic DES engine.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.DesEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a DES cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.DesEngine.bytebit">
            what follows is mainly taken from "Applied Cryptography", by
            Bruce Schneier, however it also bears great resemblance to Richard
            Outerbridge's D3DES...
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.DesEngine.GenerateWorkingKey(System.Boolean,System.Byte[])">
             Generate an integer based working key based on our secret key
             and what we processing we are planning to do.
            
             Acknowledgements for this routine go to James Gillogly and Phil Karn.
                     (whoever, and wherever they are!).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.DesEngine.DesFunc(System.Int32[],System.Byte[],System.Int32,System.Byte[],System.Int32)">
            the DES engine.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.DesEdeEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a DESede cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine">
                * Wrap keys according to
                * <a href="http://www.ietf.org/internet-drafts/draft-ietf-smime-key-wrap-01.txt">
                * draft-ietf-smime-key-wrap-01.txt</a>.
                * <p>
                * Note:
                * <ul>
                * <li>this is based on a draft, and as such is subject to change - don't use this class for anything requiring long term storage.</li>
                * <li>if you are using this to wrap triple-des keys you need to set the
                * parity bits on the key and, if it's a two-key triple-des key, pad it
                * yourself.</li>
                * </ul>
            	* </p>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.engine">
            Field engine 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.param">
            Field param 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.paramPlusIV">
            Field paramPlusIV 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.iv">
            Field iv 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.forWrapping">
            Field forWrapping 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.IV2">
            Field IV2           
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Method init
            
             @param forWrapping
             @param param
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.Wrap(System.Byte[],System.Int32,System.Int32)">
             Method wrap
            
             @param in
             @param inOff
             @param inLen
             @return
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.Unwrap(System.Byte[],System.Int32,System.Int32)">
             Method unwrap
            
             @param in
             @param inOff
             @param inLen
             @return
             @throws InvalidCipherTextException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.CalculateCmsKeyChecksum(System.Byte[])">
             Some key wrap algorithms make use of the Key Checksum defined
             in CMS [CMS-Algorithms]. This is used to provide an integrity
             check value for the key being wrapped. The algorithm is
            
             - Compute the 20 octet SHA-1 hash on the key being wrapped.
             - Use the first 8 octets of this hash as the checksum value.
            
             @param key
             @return
             @throws Exception
             @see http://www.w3.org/TR/xmlenc-core/#sec-CMSKeyChecksum
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.CheckCmsKeyChecksum(System.Byte[],System.Byte[])">
            @param key
            @param checksum
            @return
            @see http://www.w3.org/TR/xmlenc-core/#sec-CMSKeyChecksum
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.AlgorithmName">
             Method GetAlgorithmName
            
             @return
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.ElGamalEngine">
            this does your basic ElGamal algorithm.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ElGamalEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the ElGamal engine.
            
             @param forEncryption true if we are encrypting, false otherwise.
             @param param the necessary ElGamal key parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ElGamalEngine.GetInputBlockSize">
             Return the maximum size for an input block to this engine.
             For ElGamal this is always one byte less than the size of P on
             encryption, and twice the length as the size of P on decryption.
            
             @return maximum size for an input block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ElGamalEngine.GetOutputBlockSize">
             Return the maximum size for an output block to this engine.
             For ElGamal this is always one byte less than the size of P on
             decryption, and twice the length as the size of P on encryption.
            
             @return maximum size for an output block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ElGamalEngine.ProcessBlock(System.Byte[],System.Int32,System.Int32)">
             Process a single block using the basic ElGamal algorithm.
            
             @param in the input array.
             @param inOff the offset into the input buffer where the data starts.
             @param length the length of the data to be processed.
             @return the result of the ElGamal process.
             @exception DataLengthException the input block is too large.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.Gost28147Engine">
            implementation of GOST 28147-89
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Gost28147Engine.#ctor">
            standard constructor.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Gost28147Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise an Gost28147 cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Gost28147Engine.GetSBox(System.String)">
            Return the S-Box associated with SBoxName
            @param sBoxName name of the S-Box
            @return byte array representing the S-Box
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.HC128Engine">
             HC-128 is a software-efficient stream cipher created by Hongjun Wu. It
             generates keystream from a 128-bit secret key and a 128-bit initialization
             vector.
             <p>
             http://www.ecrypt.eu.org/stream/p3ciphers/hc/hc128_p3.pdf
             </p><p>
             It is a third phase candidate in the eStream contest, and is patent-free.
             No attacks are known as of today (April 2007). See
            
             http://www.ecrypt.eu.org/stream/hcp3.html
             </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.HC128Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise a HC-128 cipher.
            
             @param forEncryption whether or not we are for encryption. Irrelevant, as
                                  encryption and decryption are the same.
             @param params        the parameters required to set up the cipher.
             @throws ArgumentException if the params argument is
                                              inappropriate (ie. the key is not 128 bit long).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.HC256Engine">
            HC-256 is a software-efficient stream cipher created by Hongjun Wu. It 
            generates keystream from a 256-bit secret key and a 256-bit initialization 
            vector.
            <p>
            http://www.ecrypt.eu.org/stream/p3ciphers/hc/hc256_p3.pdf
            </p><p>
            Its brother, HC-128, is a third phase candidate in the eStream contest.
            The algorithm is patent-free. No attacks are known as of today (April 2007). 
            See
            
            http://www.ecrypt.eu.org/stream/hcp3.html
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.HC256Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise a HC-256 cipher.
            
             @param forEncryption whether or not we are for encryption. Irrelevant, as
                                  encryption and decryption are the same.
             @param params        the parameters required to set up the cipher.
             @throws ArgumentException if the params argument is
                                              inappropriate (ie. the key is not 256 bit long).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.IdeaEngine">
            A class that provides a basic International Data Encryption Algorithm (IDEA) engine.
            <p>
            This implementation is based on the "HOWTO: INTERNATIONAL DATA ENCRYPTION ALGORITHM"
            implementation summary by Fauzan Mirza (F.U.Mirza@sheffield.ac.uk). (baring 1 typo at the
            end of the mulinv function!).
            </p>
            <p>
            It can be found at ftp://ftp.funet.fi/pub/crypt/cryptography/symmetric/idea/
            </p>
            <p>
            Note 1: This algorithm is patented in the USA, Japan, and Europe including
            at least Austria, France, Germany, Italy, Netherlands, Spain, Sweden, Switzerland
            and the United Kingdom. Non-commercial use is free, however any commercial
            products are liable for royalties. Please see
            <a href="http://www.mediacrypt.com">www.mediacrypt.com</a> for
            further details. This announcement has been included at the request of
            the patent holders.
            </p>
            <p>
            Note 2: Due to the requests concerning the above, this algorithm is now only
            included in the extended assembly. It is not included in the default distributions.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.IdeaEngine.#ctor">
            standard constructor.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.IdeaEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise an IDEA cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.IdeaEngine.Mul(System.Int32,System.Int32)">
             return x = x * y where the multiplication is done modulo
             65537 (0x10001) (as defined in the IDEA specification) and
             a zero input is taken to be 65536 (0x10000).
            
             @param x the x value
             @param y the y value
             @return x = x * y
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.IdeaEngine.ExpandKey(System.Byte[])">
            The following function is used to expand the user key to the encryption
            subkey. The first 16 bytes are the user key, and the rest of the subkey
            is calculated by rotating the previous 16 bytes by 25 bits to the left,
            and so on until the subkey is completed.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.IdeaEngine.MulInv(System.Int32)">
            This function computes multiplicative inverse using Euclid's Greatest
            Common Divisor algorithm. Zero and one are self inverse.
            <p>
            i.e. x * MulInv(x) == 1 (modulo BASE)
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.IdeaEngine.AddInv(System.Int32)">
            Return the additive inverse of x.
            <p>
            i.e. x + AddInv(x) == 0
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.IdeaEngine.InvertKey(System.Int32[])">
            The function to invert the encryption subkey to the decryption subkey.
            It also involves the multiplicative inverse and the additive inverse functions.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.IesEngine">
            support class for constructing intergrated encryption ciphers
            for doing basic message exchanges on top of key agreement ciphers
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.IesEngine.#ctor(Org.BouncyCastle.Crypto.IBasicAgreement,Org.BouncyCastle.Crypto.IDerivationFunction,Org.BouncyCastle.Crypto.IMac)">
             set up for use with stream mode, where the key derivation function
             is used to provide a stream of bytes to xor with the message.
            
             @param agree the key agreement used as the basis for the encryption
             @param kdf the key derivation function used for byte generation
             @param mac the message authentication code generator for the message
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.IesEngine.#ctor(Org.BouncyCastle.Crypto.IBasicAgreement,Org.BouncyCastle.Crypto.IDerivationFunction,Org.BouncyCastle.Crypto.IMac,Org.BouncyCastle.Crypto.BufferedBlockCipher)">
             set up for use in conjunction with a block cipher to handle the
             message.
            
             @param agree the key agreement used as the basis for the encryption
             @param kdf the key derivation function used for byte generation
             @param mac the message authentication code generator for the message
             @param cipher the cipher to used for encrypting the message
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.IesEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters,Org.BouncyCastle.Crypto.ICipherParameters,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the encryptor.
            
             @param forEncryption whether or not this is encryption/decryption.
             @param privParam our private key parameters
             @param pubParam the recipient's/sender's public key parameters
             @param param encoding and derivation parameters.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.IsaacEngine">
            Implementation of Bob Jenkin's ISAAC (Indirection Shift Accumulate Add and Count).
            see: http://www.burtleburtle.net/bob/rand/isaacafa.html
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.IsaacEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise an ISAAC cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param params the parameters required to set up the cipher.
             @exception ArgumentException if the params argument is
             inappropriate.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.NaccacheSternEngine">
            NaccacheStern Engine. For details on this cipher, please see
            http://www.gemplus.com/smart/rd/publications/pdf/NS98pkcs.pdf
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.NaccacheSternEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initializes this algorithm. Must be called before all other Functions.
            
             @see org.bouncycastle.crypto.AsymmetricBlockCipher#init(bool,
                  org.bouncycastle.crypto.CipherParameters)
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.NaccacheSternEngine.GetInputBlockSize">
             Returns the input block size of this algorithm.
            
             @see org.bouncycastle.crypto.AsymmetricBlockCipher#GetInputBlockSize()
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.NaccacheSternEngine.GetOutputBlockSize">
             Returns the output block size of this algorithm.
            
             @see org.bouncycastle.crypto.AsymmetricBlockCipher#GetOutputBlockSize()
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.NaccacheSternEngine.ProcessBlock(System.Byte[],System.Int32,System.Int32)">
             Process a single Block using the Naccache-Stern algorithm.
            
             @see org.bouncycastle.crypto.AsymmetricBlockCipher#ProcessBlock(byte[],
                  int, int)
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.NaccacheSternEngine.Encrypt(Org.BouncyCastle.Math.BigInteger)">
             Encrypts a BigInteger aka Plaintext with the public key.
            
             @param plain
                        The BigInteger to encrypt
             @return The byte[] representation of the encrypted BigInteger (i.e.
                     crypted.toByteArray())
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.NaccacheSternEngine.AddCryptedBlocks(System.Byte[],System.Byte[])">
             Adds the contents of two encrypted blocks mod sigma
            
             @param block1
                        the first encrypted block
             @param block2
                        the second encrypted block
             @return encrypt((block1 + block2) mod sigma)
             @throws InvalidCipherTextException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.NaccacheSternEngine.ProcessData(System.Byte[])">
             Convenience Method for data exchange with the cipher.
            
             Determines blocksize and splits data to blocksize.
            
             @param data the data to be processed
             @return the data after it went through the NaccacheSternEngine.
             @throws InvalidCipherTextException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.NaccacheSternEngine.chineseRemainder(System.Collections.IList,System.Collections.IList)">
             Computes the integer x that is expressed through the given primes and the
             congruences with the chinese remainder theorem (CRT).
            
             @param congruences
                        the congruences c_i
             @param primes
                        the primes p_i
             @return an integer x for that x % p_i == c_i
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.NoekeonEngine">
            A Noekeon engine, using direct-key mode.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.NoekeonEngine.#ctor">
            Create an instance of the Noekeon encryption algorithm
            and set some defaults
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.NoekeonEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise
            
             @param forEncryption whether or not we are for encryption.
             @param params the parameters required to set up the cipher.
             @exception ArgumentException if the params argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.NoekeonEngine.setKey(System.Byte[])">
             Re-key the cipher.
            
             @param  key  the key to be used
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.NullEngine">
            The no-op engine that just copies bytes through, irrespective of whether encrypting and decrypting.
            Provided for the sake of completeness.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RC2Engine">
            an implementation of RC2 as described in RFC 2268
                 "A Description of the RC2(r) Encryption Algorithm" R. Rivest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC2Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a RC2 cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC2Engine.RotateWordLeft(System.Int32,System.Int32)">
            return the result rotating the 16 bit number in x left by y
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine">
            Wrap keys according to RFC 3217 - RC2 mechanism
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.engine">
            Field engine 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.parameters">
            Field param 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.paramPlusIV">
            Field paramPlusIV 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.iv">
            Field iv 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.forWrapping">
            Field forWrapping 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.IV2">
            Field IV2           
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Method init
            
             @param forWrapping
             @param param
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.Wrap(System.Byte[],System.Int32,System.Int32)">
             Method wrap
            
             @param in
             @param inOff
             @param inLen
             @return
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.Unwrap(System.Byte[],System.Int32,System.Int32)">
             Method unwrap
            
             @param in
             @param inOff
             @param inLen
             @return
             @throws InvalidCipherTextException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.CalculateCmsKeyChecksum(System.Byte[])">
             Some key wrap algorithms make use of the Key Checksum defined
             in CMS [CMS-Algorithms]. This is used to provide an integrity
             check value for the key being wrapped. The algorithm is
            
             - Compute the 20 octet SHA-1 hash on the key being wrapped.
             - Use the first 8 octets of this hash as the checksum value.
            
             @param key
             @return
             @throws Exception
             @see http://www.w3.org/TR/xmlenc-core/#sec-CMSKeyChecksum
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.CheckCmsKeyChecksum(System.Byte[],System.Byte[])">
            @param key
            @param checksum
            @return
            @see http://www.w3.org/TR/xmlenc-core/#sec-CMSKeyChecksum
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.AlgorithmName">
             Method GetAlgorithmName
            
             @return
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC4Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a RC4 cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RC532Engine">
            The specification for RC5 came from the <code>RC5 Encryption Algorithm</code>
            publication in RSA CryptoBytes, Spring of 1995.
            <em>http://www.rsasecurity.com/rsalabs/cryptobytes</em>.
            <p>
            This implementation has a word size of 32 bits.</p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC532Engine.#ctor">
            Create an instance of the RC5 encryption algorithm
            and set some defaults
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC532Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a RC5-32 cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC532Engine.SetKey(System.Byte[])">
             Re-key the cipher.
            
             @param  key  the key to be used
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC532Engine.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Encrypt the given block starting at the given offset and place
             the result in the provided buffer starting at the given offset.
            
             @param  in     in byte buffer containing data to encrypt
             @param  inOff  offset into src buffer
             @param  out     out buffer where encrypted data is written
             @param  outOff  offset into out buffer
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC532Engine.RotateLeft(System.Int32,System.Int32)">
             Perform a left "spin" of the word. The rotation of the given
             word <em>x</em> is rotated left by <em>y</em> bits.
             Only the <em>lg(32)</em> low-order bits of <em>y</em>
             are used to determine the rotation amount. Here it is
             assumed that the wordsize used is a power of 2.
            
             @param  x  word to rotate
             @param  y    number of bits to rotate % 32
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC532Engine.RotateRight(System.Int32,System.Int32)">
             Perform a right "spin" of the word. The rotation of the given
             word <em>x</em> is rotated left by <em>y</em> bits.
             Only the <em>lg(32)</em> low-order bits of <em>y</em>
             are used to determine the rotation amount. Here it is
             assumed that the wordsize used is a power of 2.
            
             @param  x  word to rotate
             @param  y    number of bits to rotate % 32
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RC564Engine">
            The specification for RC5 came from the <code>RC5 Encryption Algorithm</code>
            publication in RSA CryptoBytes, Spring of 1995.
            <em>http://www.rsasecurity.com/rsalabs/cryptobytes</em>.
            <p>
            This implementation is set to work with a 64 bit word size.</p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC564Engine.#ctor">
            Create an instance of the RC5 encryption algorithm
            and set some defaults
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC564Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a RC5-64 cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC564Engine.SetKey(System.Byte[])">
             Re-key the cipher.
            
             @param  key  the key to be used
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC564Engine.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Encrypt the given block starting at the given offset and place
             the result in the provided buffer starting at the given offset.
            
             @param  in      in byte buffer containing data to encrypt
             @param  inOff   offset into src buffer
             @param  out     out buffer where encrypted data is written
             @param  outOff  offset into out buffer
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC564Engine.RotateLeft(System.Int64,System.Int64)">
             Perform a left "spin" of the word. The rotation of the given
             word <em>x</em> is rotated left by <em>y</em> bits.
             Only the <em>lg(wordSize)</em> low-order bits of <em>y</em>
             are used to determine the rotation amount. Here it is
             assumed that the wordsize used is a power of 2.
            
             @param  x  word to rotate
             @param  y    number of bits to rotate % wordSize
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC564Engine.RotateRight(System.Int64,System.Int64)">
             Perform a right "spin" of the word. The rotation of the given
             word <em>x</em> is rotated left by <em>y</em> bits.
             Only the <em>lg(wordSize)</em> low-order bits of <em>y</em>
             are used to determine the rotation amount. Here it is
             assumed that the wordsize used is a power of 2.
            
             @param x word to rotate
             @param y number of bits to rotate % wordSize
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RC6Engine">
            An RC6 engine.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC6Engine.#ctor">
            Create an instance of the RC6 encryption algorithm
            and set some defaults
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC6Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a RC5-32 cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC6Engine.SetKey(System.Byte[])">
             Re-key the cipher.
            
             @param inKey the key to be used
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC6Engine.RotateLeft(System.Int32,System.Int32)">
             Perform a left "spin" of the word. The rotation of the given
             word <em>x</em> is rotated left by <em>y</em> bits.
             Only the <em>lg(wordSize)</em> low-order bits of <em>y</em>
             are used to determine the rotation amount. Here it is
             assumed that the wordsize used is a power of 2.
            
             @param x word to rotate
             @param y number of bits to rotate % wordSize
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC6Engine.RotateRight(System.Int32,System.Int32)">
             Perform a right "spin" of the word. The rotation of the given
             word <em>x</em> is rotated left by <em>y</em> bits.
             Only the <em>lg(wordSize)</em> low-order bits of <em>y</em>
             are used to determine the rotation amount. Here it is
             assumed that the wordsize used is a power of 2.
            
             @param x word to rotate
             @param y number of bits to rotate % wordSize
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.Rfc3211WrapEngine">
            an implementation of the RFC 3211 Key Wrap
            Specification.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RijndaelEngine">
            an implementation of Rijndael, based on the documentation and reference implementation
            by Paulo Barreto, Vincent Rijmen, for v2.0 August '99.
            <p>
            Note: this implementation is based on information prior to readonly NIST publication.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.Mul0x2(System.Int32)">
            multiply two elements of GF(2^m)
            needed for MixColumn and InvMixColumn
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.KeyAddition(System.Int64[])">
            xor corresponding text input and round key input bytes
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.ShiftRow(System.Byte[])">
            Row 0 remains unchanged
            The other three rows are shifted a variable amount
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.Substitution(System.Byte[])">
            Replace every byte of the input by the byte at that place
            in the nonlinear S-box
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.MixColumn">
            Mix the bytes of every column in a linear way
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.InvMixColumn">
            Mix the bytes of every column in a linear way
            This is the opposite operation of Mixcolumn
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.GenerateWorkingKey(System.Byte[])">
            Calculate the necessary round keys
            The number of calculations depends on keyBits and blockBits
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.#ctor">
            default constructor - 128 bit block size.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.#ctor(System.Int32)">
             basic constructor - set the cipher up for a given blocksize
            
             @param blocksize the blocksize in bits, must be 128, 192, or 256.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a Rijndael cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RsaBlindedEngine">
            this does your basic RSA algorithm with blinding
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaBlindedEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the RSA engine.
            
             @param forEncryption true if we are encrypting, false otherwise.
             @param param the necessary RSA key parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaBlindedEngine.GetInputBlockSize">
             Return the maximum size for an input block to this engine.
             For RSA this is always one byte less than the key size on
             encryption, and the same length as the key size on decryption.
            
             @return maximum size for an input block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaBlindedEngine.GetOutputBlockSize">
             Return the maximum size for an output block to this engine.
             For RSA this is always one byte less than the key size on
             decryption, and the same length as the key size on encryption.
            
             @return maximum size for an output block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaBlindedEngine.ProcessBlock(System.Byte[],System.Int32,System.Int32)">
             Process a single block using the basic RSA algorithm.
            
             @param inBuf the input array.
             @param inOff the offset into the input buffer where the data starts.
             @param inLen the length of the data to be processed.
             @return the result of the RSA process.
             @exception DataLengthException the input block is too large.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RsaBlindingEngine">
            This does your basic RSA Chaum's blinding and unblinding as outlined in
            "Handbook of Applied Cryptography", page 475. You need to use this if you are
            trying to get another party to generate signatures without them being aware
            of the message they are signing.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaBlindingEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the blinding engine.
            
             @param forEncryption true if we are encrypting (blinding), false otherwise.
             @param param         the necessary RSA key parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaBlindingEngine.GetInputBlockSize">
             Return the maximum size for an input block to this engine.
             For RSA this is always one byte less than the key size on
             encryption, and the same length as the key size on decryption.
            
             @return maximum size for an input block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaBlindingEngine.GetOutputBlockSize">
             Return the maximum size for an output block to this engine.
             For RSA this is always one byte less than the key size on
             decryption, and the same length as the key size on encryption.
            
             @return maximum size for an output block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaBlindingEngine.ProcessBlock(System.Byte[],System.Int32,System.Int32)">
             Process a single block using the RSA blinding algorithm.
            
             @param in    the input array.
             @param inOff the offset into the input buffer where the data starts.
             @param inLen the length of the data to be processed.
             @return the result of the RSA process.
             @throws DataLengthException the input block is too large.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RsaCoreEngine">
            this does your basic RSA algorithm.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaCoreEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the RSA engine.
            
             @param forEncryption true if we are encrypting, false otherwise.
             @param param the necessary RSA key parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaCoreEngine.GetInputBlockSize">
             Return the maximum size for an input block to this engine.
             For RSA this is always one byte less than the key size on
             encryption, and the same length as the key size on decryption.
            
             @return maximum size for an input block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaCoreEngine.GetOutputBlockSize">
             Return the maximum size for an output block to this engine.
             For RSA this is always one byte less than the key size on
             decryption, and the same length as the key size on encryption.
            
             @return maximum size for an output block.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RsaEngine">
            this does your basic RSA algorithm.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the RSA engine.
            
             @param forEncryption true if we are encrypting, false otherwise.
             @param param the necessary RSA key parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaEngine.GetInputBlockSize">
             Return the maximum size for an input block to this engine.
             For RSA this is always one byte less than the key size on
             encryption, and the same length as the key size on decryption.
            
             @return maximum size for an input block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaEngine.GetOutputBlockSize">
             Return the maximum size for an output block to this engine.
             For RSA this is always one byte less than the key size on
             decryption, and the same length as the key size on encryption.
            
             @return maximum size for an output block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaEngine.ProcessBlock(System.Byte[],System.Int32,System.Int32)">
             Process a single block using the basic RSA algorithm.
            
             @param inBuf the input array.
             @param inOff the offset into the input buffer where the data starts.
             @param inLen the length of the data to be processed.
             @return the result of the RSA process.
             @exception DataLengthException the input block is too large.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.SeedEngine">
            Implementation of the SEED algorithm as described in RFC 4009
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.SeedWrapEngine">
            <remarks>
            An implementation of the SEED key wrapper based on RFC 4010/RFC 3394.
            <p/>
            For further details see: <a href="http://www.ietf.org/rfc/rfc4010.txt">http://www.ietf.org/rfc/rfc4010.txt</a>.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.SerpentEngine">
                 * Serpent is a 128-bit 32-round block cipher with variable key lengths,
                 * including 128, 192 and 256 bit keys conjectured to be at least as
                 * secure as three-key triple-DES.
                 * <p>
                 * Serpent was designed by Ross Anderson, Eli Biham and Lars Knudsen as a
                 * candidate algorithm for the NIST AES Quest.
            	 * </p>
                 * <p>
                 * For full details see <a href="http://www.cl.cam.ac.uk/~rja14/serpent.html">The Serpent home page</a>
            	 * </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a Serpent cipher.
            
             @param encrypting whether or not we are for encryption.
             @param params     the parameters required to set up the cipher.
             @throws IllegalArgumentException if the params argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Process one block of input from the array in and write it to
             the out array.
            
             @param in     the array containing the input data.
             @param inOff  offset into the in array the data starts at.
             @param out    the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @return the number of bytes processed and produced.
             @throws DataLengthException if there isn't enough data in in, or
             space in out.
             @throws IllegalStateException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Ib0(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvSO - {13, 3,11, 0,10, 6, 5,12, 1,14, 4, 7,15, 9, 8, 2 } - 15 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Sb1(System.Int32,System.Int32,System.Int32,System.Int32)">
            S1 - {15,12, 2, 7, 9, 0, 5,10, 1,11,14, 8, 6,13, 3, 4 } - 14 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Ib1(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS1 - { 5, 8, 2,14,15, 6,12, 3,11, 4, 7, 9, 1,13,10, 0 } - 14 steps.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Sb2(System.Int32,System.Int32,System.Int32,System.Int32)">
            S2 - { 8, 6, 7, 9, 3,12,10,15,13, 1,14, 4, 0,11, 5, 2 } - 16 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Ib2(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS2 - {12, 9,15, 4,11,14, 1, 2, 0, 3, 6,13, 5, 8,10, 7 } - 16 steps.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Sb3(System.Int32,System.Int32,System.Int32,System.Int32)">
            S3 - { 0,15,11, 8,12, 9, 6, 3,13, 1, 2, 4,10, 7, 5,14 } - 16 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Ib3(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS3 - { 0, 9,10, 7,11,14, 6,13, 3, 5,12, 2, 4, 8,15, 1 } - 15 terms
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Sb4(System.Int32,System.Int32,System.Int32,System.Int32)">
            S4 - { 1,15, 8, 3,12, 0,11, 6, 2, 5, 4,10, 9,14, 7,13 } - 15 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Ib4(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS4 - { 5, 0, 8, 3,10, 9, 7,14, 2,12,11, 6, 4,15,13, 1 } - 15 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Sb5(System.Int32,System.Int32,System.Int32,System.Int32)">
            S5 - {15, 5, 2,11, 4,10, 9,12, 0, 3,14, 8,13, 6, 7, 1 } - 16 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Ib5(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS5 - { 8,15, 2, 9, 4, 1,13,14,11, 6, 5, 3, 7,12,10, 0 } - 16 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Sb6(System.Int32,System.Int32,System.Int32,System.Int32)">
            S6 - { 7, 2,12, 5, 8, 4, 6,11,14, 9, 1,15,13, 3,10, 0 } - 15 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Ib6(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS6 - {15,10, 1,13, 5, 3, 6, 0, 4, 9,14, 7, 2,12, 8,11 } - 15 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Sb7(System.Int32,System.Int32,System.Int32,System.Int32)">
            S7 - { 1,13,15, 0,14, 8, 2,11, 7, 4,12,10, 9, 3, 5, 6 } - 16 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.Ib7(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS7 - { 3, 0, 6,13, 9,14,15, 8, 5,12,11, 7,10, 1, 4, 2 } - 17 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.LT">
            Apply the linear transformation to the register set.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngineBase.InverseLT">
            Apply the inverse of the linear transformation to the register set.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.MakeWorkingKey(System.Byte[])">
             Expand a user-supplied key material into a session key.
            
             @param key  The user-key bytes (multiples of 4) to use.
             @exception ArgumentException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Encrypt one block of plaintext.
            
             @param input the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param output the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Decrypt one block of ciphertext.
            
             @param input the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param output the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.SkipjackEngine">
            a class that provides a basic SKIPJACK engine.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SkipjackEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a SKIPJACK cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SkipjackEngine.G(System.Int32,System.Int32)">
            The G permutation
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SkipjackEngine.H(System.Int32,System.Int32)">
            the inverse of the G permutation.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.TeaEngine">
            An TEA engine.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TeaEngine.#ctor">
            Create an instance of the TEA encryption algorithm
            and set some defaults
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TeaEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise
            
             @param forEncryption whether or not we are for encryption.
             @param params the parameters required to set up the cipher.
             @exception ArgumentException if the params argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TeaEngine.setKey(System.Byte[])">
             Re-key the cipher.
            
             @param  key  the key to be used
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.ThreefishEngine">
            <summary>
            Implementation of the Threefish tweakable large block cipher in 256, 512 and 1024 bit block
            sizes.
            </summary>
            <remarks>
            This is the 1.3 version of Threefish defined in the Skein hash function submission to the NIST
            SHA-3 competition in October 2010.
            <p/>
            Threefish was designed by Niels Ferguson - Stefan Lucks - Bruce Schneier - Doug Whiting - Mihir
            Bellare - Tadayoshi Kohno - Jon Callas - Jesse Walker.
            <p/>
            This implementation inlines all round functions, unrolls 8 rounds, and uses 1.2k of static tables
            to speed up key schedule injection. <br/>
            2 x block size state is retained by each cipher instance.
            </remarks>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.BLOCKSIZE_256">
            <summary>
            256 bit block size - Threefish-256
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.BLOCKSIZE_512">
            <summary>
            512 bit block size - Threefish-512
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.BLOCKSIZE_1024">
            <summary>
            1024 bit block size - Threefish-1024
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.TWEAK_SIZE_BYTES">
            Size of the tweak in bytes (always 128 bit/16 bytes)
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.ROUNDS_256">
            Rounds in Threefish-256
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.ROUNDS_512">
            Rounds in Threefish-512
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.ROUNDS_1024">
            Rounds in Threefish-1024
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.MAX_ROUNDS">
            Max rounds of any of the variants
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.C_240">
            Key schedule parity constant
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.blocksizeBytes">
            Block size in bytes
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.blocksizeWords">
            Block size in 64 bit words
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.currentBlock">
            Buffer for byte oriented processBytes to call internal word API
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.t">
            Tweak bytes (2 byte t1,t2, calculated t3 and repeat of t1,t2 for modulo free lookup
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.kw">
            Key schedule words
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.cipher">
            The internal cipher implementation (varies by blocksize)
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.#ctor(System.Int32)">
            <summary>
            Constructs a new Threefish cipher, with a specified block size.
            </summary>
            <param name="blocksizeBits">the block size in bits, one of <see cref="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.BLOCKSIZE_256"/>, <see cref="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.BLOCKSIZE_512"/>,
                                 <see cref="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.BLOCKSIZE_1024"/> .</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>
            Initialise the engine.
            </summary>
            <param name="forEncryption">Initialise for encryption if true, for decryption if false.</param>
            <param name="parameters">an instance of <see cref="T:Org.BouncyCastle.Crypto.Parameters.TweakableBlockCipherParameters"/> or <see cref="T:Org.BouncyCastle.Crypto.Parameters.KeyParameter"/> (to
                          use a 0 tweak)</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Init(System.Boolean,System.UInt64[],System.UInt64[])">
            <summary>
            Initialise the engine, specifying the key and tweak directly.
            </summary>
            <param name="forEncryption">the cipher mode.</param>
            <param name="key">the words of the key, or <code>null</code> to use the current key.</param>
            <param name="tweak">the 2 word (128 bit) tweak, or <code>null</code> to use the current tweak.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.ProcessBlock(System.UInt64[],System.UInt64[])">
            <summary>
            Process a block of data represented as 64 bit words.
            </summary>
            <returns>the number of 8 byte words processed (which will be the same as the block size).</returns>
            <param name="inWords">a block sized buffer of words to process.</param>
            <param name="outWords">a block sized buffer of words to receive the output of the operation.</param>
            <exception cref="T:Org.BouncyCastle.Crypto.DataLengthException">if either the input or output is not block sized</exception>
            <exception cref="T:System.InvalidOperationException">if this engine is not initialised</exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.BytesToWord(System.Byte[],System.Int32)">
            <summary>
            Read a single 64 bit word from input in LSB first order.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.WordToBytes(System.UInt64,System.Byte[],System.Int32)">
            <summary>
            Write a 64 bit word to output in LSB first order.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.RotlXor(System.UInt64,System.Int32,System.UInt64)">
            Rotate left + xor part of the mix operation.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.XorRotr(System.UInt64,System.Int32,System.UInt64)">
            Rotate xor + rotate right part of the unmix operation.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.ThreefishCipher.t">
            The extended + repeated tweak words
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.ThreefishCipher.kw">
            The extended + repeated key words
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Threefish256Cipher.ROTATION_0_0">
            Mix rotation constants defined in Skein 1.3 specification
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Threefish256Cipher.ROTATION_0_1">
            Mix rotation constants defined in Skein 1.3 specification
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Threefish512Cipher.ROTATION_0_0">
            Mix rotation constants defined in Skein 1.3 specification
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Threefish512Cipher.ROTATION_0_1">
            Mix rotation constants defined in Skein 1.3 specification
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Threefish512Cipher.ROTATION_0_2">
            Mix rotation constants defined in Skein 1.3 specification
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Threefish512Cipher.ROTATION_0_3">
            Mix rotation constants defined in Skein 1.3 specification
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Threefish1024Cipher.ROTATION_0_0">
            Mix rotation constants defined in Skein 1.3 specification
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Threefish1024Cipher.ROTATION_0_1">
            Mix rotation constants defined in Skein 1.3 specification
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Threefish1024Cipher.ROTATION_0_2">
            Mix rotation constants defined in Skein 1.3 specification
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.ThreefishEngine.Threefish1024Cipher.ROTATION_0_3">
            Mix rotation constants defined in Skein 1.3 specification
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.TnepresEngine">
            Tnepres is a 128-bit 32-round block cipher with variable key lengths,
            including 128, 192 and 256 bit keys conjectured to be at least as
            secure as three-key triple-DES.
            <p>
            Tnepres is based on Serpent which was designed by Ross Anderson, Eli Biham and Lars Knudsen as a
            candidate algorithm for the NIST AES Quest. Unfortunately there was an endianness issue
            with test vectors in the AES submission and the resulting confusion lead to the Tnepres cipher
            as well, which is a byte swapped version of Serpent.
            </p>
            <p>
            For full details see <a href="http://www.cl.cam.ac.uk/~rja14/serpent.html">The Serpent home page</a>
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TnepresEngine.MakeWorkingKey(System.Byte[])">
             Expand a user-supplied key material into a session key.
            
             @param key  The user-key bytes (multiples of 4) to use.
             @exception ArgumentException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TnepresEngine.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Encrypt one block of plaintext.
            
             @param input the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param output the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TnepresEngine.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Decrypt one block of ciphertext.
            
             @param input the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param output the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.TwofishEngine">
             A class that provides Twofish encryption operations.
            
             This Java implementation is based on the Java reference
             implementation provided by Bruce Schneier and developed
             by Raif S. Naffah.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.TwofishEngine.P_00">
            Define the fixed p0/p1 permutations used in keyed S-box lookup.
            By changing the following constant definitions, the S-boxes will
            automatically Get changed in the Twofish engine.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.TwofishEngine.gSubKeys">
            gSubKeys[] and gSBox[] are eventually used in the
            encryption and decryption methods.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TwofishEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a Twofish cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TwofishEngine.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Encrypt the given input starting at the given offset and place
             the result in the provided buffer starting at the given offset.
             The input will be an exact multiple of our blocksize.
            
             encryptBlock uses the pre-calculated gSBox[] and subKey[]
             arrays.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TwofishEngine.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            Decrypt the given input starting at the given offset and place
            the result in the provided buffer starting at the given offset.
            The input will be an exact multiple of our blocksize.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TwofishEngine.RS_MDS_Encode(System.Int32,System.Int32)">
             Use (12, 8) Reed-Solomon code over GF(256) to produce
             a key S-box 32-bit entity from 2 key material 32-bit
             entities.
            
             @param    k0 first 32-bit entity
             @param    k1 second 32-bit entity
             @return     Remainder polynomial Generated using RS code
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TwofishEngine.RS_rem(System.Int32)">
                    * Reed-Solomon code parameters: (12,8) reversible code:
            		* <p>
                    * <pre>
                    * G(x) = x^4 + (a+1/a)x^3 + ax^2 + (a+1/a)x + 1
                    * </pre>
                    * where a = primitive root of field generator 0x14D
            		* </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.VmpcEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            initialise a VMPC cipher.
            
            @param forEncryption
               whether or not we are for encryption.
            @param params
               the parameters required to set up the cipher.
            @exception ArgumentException
               if the params argument is inappropriate.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.XSalsa20Engine">
            <summary>
            Implementation of Daniel J. Bernstein's XSalsa20 stream cipher - Salsa20 with an extended nonce.
            </summary>
            <remarks>
            XSalsa20 requires a 256 bit key, and a 192 bit nonce.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.XSalsa20Engine.SetKey(System.Byte[],System.Byte[])">
            <summary>
            XSalsa20 key generation: process 256 bit input key and 128 bits of the input nonce
            using a core Salsa20 function without input addition to produce 256 bit working key
            and use that with the remaining 64 bits of nonce to initialize a standard Salsa20 engine state.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.XteaEngine">
            An XTEA engine.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.XteaEngine.#ctor">
            Create an instance of the TEA encryption algorithm
            and set some defaults
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.XteaEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise
            
             @param forEncryption whether or not we are for encryption.
             @param params the parameters required to set up the cipher.
             @exception ArgumentException if the params argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.XteaEngine.setKey(System.Byte[])">
             Re-key the cipher.
            
             @param  key  the key to be used
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.BaseKdfBytesGenerator">
            Basic KDF generator for derived keys and ivs as defined by IEEE P1363a/ISO 18033
            <br/>
            This implementation is based on ISO 18033/P1363a.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.BaseKdfBytesGenerator.#ctor(System.Int32,Org.BouncyCastle.Crypto.IDigest)">
             Construct a KDF Parameters generator.
            
             @param counterStart value of counter.
             @param digest the digest to be used as the source of derived keys.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.BaseKdfBytesGenerator.GenerateBytes(System.Byte[],System.Int32,System.Int32)">
             fill len bytes of the output buffer with bytes generated from
             the derivation function.
            
             @throws ArgumentException if the size of the request will cause an overflow.
             @throws DataLengthException if the out buffer is too small.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Generators.BaseKdfBytesGenerator.Digest">
            return the underlying digest.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.BCrypt">
            Core of password hashing scheme Bcrypt,
            designed by Niels Provos and David Mazières,
            corresponds to the C reference implementation.
            <p>
            This implementation does not correspondent to the 1999 published paper
            "A Future-Adaptable Password Scheme" of Niels Provos and David Mazières,
            see: https://www.usenix.org/legacy/events/usenix99/provos/provos_html/node1.html.
            In contrast to the paper, the order of key setup and salt setup is reversed:
            state &lt;- ExpandKey(state, 0, key)
            state %lt;- ExpandKey(state, 0, salt)
            This corresponds to the OpenBSD reference implementation of Bcrypt. 
            </p><p>
            Note: 
            There is no successful cryptanalysis (status 2015), but
            the amount of memory and the band width of Bcrypt
            may be insufficient to effectively prevent attacks 
            with custom hardware like FPGAs, ASICs
            </p><p>
            This implementation uses some parts of Bouncy Castle's BlowfishEngine.
            </p>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Generators.BCrypt.SALT_SIZE_BYTES">
            Size of the salt parameter in bytes
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Generators.BCrypt.MIN_COST">
            Minimum value of cost parameter, equal to log2(bytes of salt)
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Generators.BCrypt.MAX_COST">
            Maximum value of cost parameter (31 == 2,147,483,648)
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Generators.BCrypt.MAX_PASSWORD_BYTES">
            Maximum size of password == max (unrestricted) size of Blowfish key
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.BCrypt.DeriveRawKey(System.Int32,System.Byte[],System.Byte[])">
             Derives a raw 192 bit Bcrypt key
            
             @param cost the cost factor, treated as an exponent of 2
             @param salt a 16 byte salt
             @param psw  the password
             @return a 192 bit key
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.BCrypt.Generate(System.Byte[],System.Byte[],System.Int32)">
            Calculates the <b>bcrypt</b> hash of a password.
            <p>
            This implements the raw <b>bcrypt</b> function as defined in the bcrypt specification, not
            the crypt encoded version implemented in OpenBSD.
            </p>
            @param password the password bytes (up to 72 bytes) to use for this invocation.
            @param salt     the 128 bit salt to use for this invocation.
            @param cost     the bcrypt cost parameter. The cost of the bcrypt function grows as
                            <code>2^cost</code>. Legal values are 4..31 inclusive.
            @return the output of the raw bcrypt operation: a 192 bit (24 byte) hash.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.DesKeyGenerator.engineInit(Org.BouncyCastle.Crypto.KeyGenerationParameters)">
             initialise the key generator - if strength is set to zero
             the key generated will be 64 bits in size, otherwise
             strength can be 64 or 56 bits (if you don't count the parity bits).
            
             @param param the parameters to be used for key generation
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.DesEdeKeyGenerator.engineInit(Org.BouncyCastle.Crypto.KeyGenerationParameters)">
             initialise the key generator - if strength is set to zero
             the key Generated will be 192 bits in size, otherwise
             strength can be 128 or 192 (or 112 or 168 if you don't count
             parity bits), depending on whether you wish to do 2-key or 3-key
             triple DES.
            
             @param param the parameters to be used for key generation
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.DHBasicKeyPairGenerator">
             a basic Diffie-Hellman key pair generator.
            
             This generates keys consistent for use with the basic algorithm for
             Diffie-Hellman.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IAsymmetricCipherKeyPairGenerator">
            interface that a public/private key pair generator should conform to.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAsymmetricCipherKeyPairGenerator.Init(Org.BouncyCastle.Crypto.KeyGenerationParameters)">
             intialise the key pair generator.
            
             @param the parameters the key pair is to be initialised with.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAsymmetricCipherKeyPairGenerator.GenerateKeyPair">
             return an AsymmetricCipherKeyPair containing the Generated keys.
            
             @return an AsymmetricCipherKeyPair containing the Generated keys.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.DHKeyPairGenerator">
             a Diffie-Hellman key pair generator.
            
             This generates keys consistent for use in the MTI/A0 key agreement protocol
             as described in "Handbook of Applied Cryptography", Pages 516-519.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.DHParametersGenerator.GenerateParameters">
            which Generates the p and g values from the given parameters,
            returning the DHParameters object.
            <p>
            Note: can take a while...</p>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.DsaKeyPairGenerator">
             a DSA key pair generator.
            
             This Generates DSA keys in line with the method described
             in <i>FIPS 186-3 B.1 FFC Key Pair Generation</i>.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.DsaParametersGenerator">
            Generate suitable parameters for DSA, in line with FIPS 186-2, or FIPS 186-3.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.DsaParametersGenerator.Init(System.Int32,System.Int32,Org.BouncyCastle.Security.SecureRandom)">
            <summary>Initialise the generator</summary>
            <remarks>This form can only be used for older DSA (pre-DSA2) parameters</remarks>
            <param name="size">the size of keys in bits (from 512 up to 1024, and a multiple of 64)</param>
            <param name="certainty">measure of robustness of primes (at least 80 for FIPS 186-2 compliance)</param>
            <param name="random">the source of randomness to use</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.DsaParametersGenerator.Init(Org.BouncyCastle.Crypto.Parameters.DsaParameterGenerationParameters)">
            <summary>Initialise the generator for DSA 2</summary>
            <remarks>You must use this Init method if you need to generate parameters for DSA 2 keys</remarks>
            <param name="parameters">An instance of <c>DsaParameterGenerationParameters</c> used to configure this generator</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.DsaParametersGenerator.GenerateParameters">
            <summary>Generates a set of <c>DsaParameters</c></summary>
            <remarks>Can take a while...</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.DsaParametersGenerator.GenerateParameters_FIPS186_3">
            generate suitable parameters for DSA, in line with
            <i>FIPS 186-3 A.1 Generation of the FFC Primes p and q</i>.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.ECKeyPairGenerator.GenerateKeyPair">
            Given the domain parameters this routine generates an EC key
            pair in accordance with X9.62 section 5.2.1 pages 26, 27.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.ElGamalKeyPairGenerator">
            a ElGamal key pair generator.
            <p>
            This Generates keys consistent for use with ElGamal as described in
            page 164 of "Handbook of Applied Cryptography".</p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.ElGamalParametersGenerator.GenerateParameters">
                     * which Generates the p and g values from the given parameters,
                     * returning the ElGamalParameters object.
                     * <p>
                     * Note: can take a while...
            		 * </p>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.Gost3410KeyPairGenerator">
            a GOST3410 key pair generator.
            This generates GOST3410 keys in line with the method described
            in GOST R 34.10-94.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.Gost3410ParametersGenerator">
            generate suitable parameters for GOST3410.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Gost3410ParametersGenerator.Init(System.Int32,System.Int32,Org.BouncyCastle.Security.SecureRandom)">
             initialise the key generator.
            
             @param size size of the key
             @param typeProcedure type procedure A,B = 1;  A',B' - else
             @param random random byte source.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Gost3410ParametersGenerator.procedure_C(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            Procedure C
            procedure generates the a value from the given p,q,
            returning the a value.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Gost3410ParametersGenerator.GenerateParameters">
            which generates the p , q and a values from the given parameters,
            returning the Gost3410Parameters object.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.HkdfBytesGenerator">
            HMAC-based Extract-and-Expand Key Derivation Function (HKDF) implemented
            according to IETF RFC 5869, May 2010 as specified by H. Krawczyk, IBM
            Research &amp; P. Eronen, Nokia. It uses a HMac internally to compute de OKM
            (output keying material) and is likely to have better security properties
            than KDF's based on just a hash function.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.HkdfBytesGenerator.#ctor(Org.BouncyCastle.Crypto.IDigest)">
             Creates a HKDFBytesGenerator based on the given hash function.
            
             @param hash the digest to be used as the source of generatedBytes bytes
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.HkdfBytesGenerator.Extract(System.Byte[],System.Byte[])">
             Performs the extract part of the key derivation function.
            
             @param salt the salt to use
             @param ikm  the input keying material
             @return the PRK as KeyParameter
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.HkdfBytesGenerator.ExpandNext">
             Performs the expand part of the key derivation function, using currentT
             as input and output buffer.
            
             @throws DataLengthException if the total number of bytes generated is larger than the one
             specified by RFC 5869 (255 * HashLen)
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.Kdf1BytesGenerator">
            KFD2 generator for derived keys and ivs as defined by IEEE P1363a/ISO 18033
            <br/>
            This implementation is based on IEEE P1363/ISO 18033.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Kdf1BytesGenerator.#ctor(Org.BouncyCastle.Crypto.IDigest)">
             Construct a KDF1 byte generator.
            
             @param digest the digest to be used as the source of derived keys.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.Kdf2BytesGenerator">
            KDF2 generator for derived keys and ivs as defined by IEEE P1363a/ISO 18033
            <br/>
            This implementation is based on IEEE P1363/ISO 18033.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Kdf2BytesGenerator.#ctor(Org.BouncyCastle.Crypto.IDigest)">
             Construct a KDF2 bytes generator. Generates key material
             according to IEEE P1363 or ISO 18033 depending on the initialisation.
            
             @param digest the digest to be used as the source of derived keys.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.Mgf1BytesGenerator">
            Generator for MGF1 as defined in Pkcs 1v2
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Mgf1BytesGenerator.#ctor(Org.BouncyCastle.Crypto.IDigest)">
            @param digest the digest to be used as the source of Generated bytes
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Mgf1BytesGenerator.ItoOSP(System.Int32,System.Byte[])">
            int to octet string.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Mgf1BytesGenerator.GenerateBytes(System.Byte[],System.Int32,System.Int32)">
             fill len bytes of the output buffer with bytes Generated from
             the derivation function.
            
             @throws DataLengthException if the out buffer is too small.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Generators.Mgf1BytesGenerator.Digest">
            return the underlying digest.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.NaccacheSternKeyPairGenerator">
             Key generation parameters for NaccacheStern cipher. For details on this cipher, please see
            
             http://www.gemplus.com/smart/rd/publications/pdf/NS98pkcs.pdf
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.NaccacheSternKeyPairGenerator.permuteList(System.Collections.IList,Org.BouncyCastle.Security.SecureRandom)">
             Generates a permuted ArrayList from the original one. The original List
             is not modified
            
             @param arr
                        the ArrayList to be permuted
             @param rand
                        the source of Randomness for permutation
             @return a new IList with the permuted elements.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.NaccacheSternKeyPairGenerator.findFirstPrimes(System.Int32)">
             Finds the first 'count' primes starting with 3
            
             @param count
                        the number of primes to find
             @return a vector containing the found primes as Integer
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.OpenBsdBCrypt">
            Password hashing scheme BCrypt,
            designed by Niels Provos and David Mazières, using the
            String format and the Base64 encoding
            of the reference implementation on OpenBSD
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.OpenBsdBCrypt.CreateBcryptString(System.Byte[],System.Byte[],System.Int32)">
             Creates a 60 character Bcrypt String, including
             version, cost factor, salt and hash, separated by '$'
            
             @param cost     the cost factor, treated as an exponent of 2
             @param salt     a 16 byte salt
             @param password the password
             @return a 60 character Bcrypt String
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.OpenBsdBCrypt.Generate(System.Char[],System.Byte[],System.Int32)">
             Creates a 60 character Bcrypt String, including
             version, cost factor, salt and hash, separated by '$'
            
             @param cost     the cost factor, treated as an exponent of 2
             @param salt     a 16 byte salt
             @param password the password
             @return a 60 character Bcrypt String
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.OpenBsdBCrypt.CheckPassword(System.String,System.Char[])">
             Checks if a password corresponds to a 60 character Bcrypt String
            
             @param bcryptString a 60 character Bcrypt String, including
                                 version, cost factor, salt and hash,
                                 separated by '$'
             @param password     the password as an array of chars
             @return true if the password corresponds to the
             Bcrypt String, otherwise false
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.OpenSslPbeParametersGenerator">
            Generator for PBE derived keys and ivs as usd by OpenSSL.
            <p>
            The scheme is a simple extension of PKCS 5 V2.0 Scheme 1 using MD5 with an
            iteration count of 1.
            </p>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.PbeParametersGenerator">
            super class for all Password Based Encyrption (Pbe) parameter generator classes.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.#ctor">
            base constructor.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.Init(System.Byte[],System.Byte[],System.Int32)">
             initialise the Pbe generator.
            
             @param password the password converted into bytes (see below).
             @param salt the salt to be mixed with the password.
             @param iterationCount the number of iterations the "mixing" function
             is to be applied for.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.GetPassword">
             return the password byte array.
            
             @return the password byte array.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.GetSalt">
             return the salt byte array.
            
             @return the salt byte array.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.GenerateDerivedParameters(System.Int32)">
             Generate derived parameters for a key of length keySize.
            
             @param keySize the length, in bits, of the key required.
             @return a parameters object representing a key.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.GenerateDerivedParameters(System.Int32,System.Int32)">
             Generate derived parameters for a key of length keySize, and
             an initialisation vector (IV) of length ivSize.
            
             @param keySize the length, in bits, of the key required.
             @param ivSize the length, in bits, of the iv required.
             @return a parameters object representing a key and an IV.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.GenerateDerivedMacParameters(System.Int32)">
             Generate derived parameters for a key of length keySize, specifically
             for use with a MAC.
            
             @param keySize the length, in bits, of the key required.
             @return a parameters object representing a key.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.Pkcs5PasswordToBytes(System.Char[])">
             converts a password to a byte array according to the scheme in
             Pkcs5 (ascii, no padding)
            
             @param password a character array representing the password.
             @return a byte array representing the password.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.Pkcs5PasswordToUtf8Bytes(System.Char[])">
             converts a password to a byte array according to the scheme in
             PKCS5 (UTF-8, no padding)
            
             @param password a character array representing the password.
             @return a byte array representing the password.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.Pkcs12PasswordToBytes(System.Char[])">
             converts a password to a byte array according to the scheme in
             Pkcs12 (unicode, big endian, 2 zero pad bytes at the end).
            
             @param password a character array representing the password.
             @return a byte array representing the password.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.PbeParametersGenerator.IterationCount">
             return the iteration count.
            
             @return the iteration count.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.OpenSslPbeParametersGenerator.#ctor">
            Construct a OpenSSL Parameters generator. 
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.OpenSslPbeParametersGenerator.Init(System.Byte[],System.Byte[])">
            Initialise - note the iteration count for this algorithm is fixed at 1.
            
            @param password password to use.
            @param salt salt to use.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.OpenSslPbeParametersGenerator.GenerateDerivedKey(System.Int32)">
            the derived key function, the ith hash of the password and the salt.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.OpenSslPbeParametersGenerator.GenerateDerivedParameters(System.Int32)">
             Generate a key parameter derived from the password, salt, and iteration
             count we are currently initialised with.
            
             @param keySize the size of the key we want (in bits)
             @return a KeyParameter object.
             @exception ArgumentException if the key length larger than the base hash size.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.OpenSslPbeParametersGenerator.GenerateDerivedParameters(System.Int32,System.Int32)">
             Generate a key with initialisation vector parameter derived from
             the password, salt, and iteration count we are currently initialised
             with.
            
             @param keySize the size of the key we want (in bits)
             @param ivSize the size of the iv we want (in bits)
             @return a ParametersWithIV object.
             @exception ArgumentException if keySize + ivSize is larger than the base hash size.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.OpenSslPbeParametersGenerator.GenerateDerivedMacParameters(System.Int32)">
             Generate a key parameter for use with a MAC derived from the password,
             salt, and iteration count we are currently initialised with.
            
             @param keySize the size of the key we want (in bits)
             @return a KeyParameter object.
             @exception ArgumentException if the key length larger than the base hash size.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.Pkcs12ParametersGenerator">
            Generator for Pbe derived keys and ivs as defined by Pkcs 12 V1.0.
            <p>
            The document this implementation is based on can be found at
            <a href="http://www.rsasecurity.com/rsalabs/pkcs/pkcs-12/index.html">
            RSA's Pkcs12 Page</a>
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs12ParametersGenerator.#ctor(Org.BouncyCastle.Crypto.IDigest)">
             Construct a Pkcs 12 Parameters generator.
            
             @param digest the digest to be used as the source of derived keys.
             @exception ArgumentException if an unknown digest is passed in.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs12ParametersGenerator.Adjust(System.Byte[],System.Int32,System.Byte[])">
            add a + b + 1, returning the result in a. The a value is treated
            as a BigInteger of length (b.Length * 8) bits. The result is
            modulo 2^b.Length in case of overflow.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs12ParametersGenerator.GenerateDerivedKey(System.Int32,System.Int32)">
            generation of a derived key ala Pkcs12 V1.0.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs12ParametersGenerator.GenerateDerivedParameters(System.Int32)">
             Generate a key parameter derived from the password, salt, and iteration
             count we are currently initialised with.
            
             @param keySize the size of the key we want (in bits)
             @return a KeyParameter object.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs12ParametersGenerator.GenerateDerivedParameters(System.Int32,System.Int32)">
             Generate a key with initialisation vector parameter derived from
             the password, salt, and iteration count we are currently initialised
             with.
            
             @param keySize the size of the key we want (in bits)
             @param ivSize the size of the iv we want (in bits)
             @return a ParametersWithIV object.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs12ParametersGenerator.GenerateDerivedMacParameters(System.Int32)">
             Generate a key parameter for use with a MAC derived from the password,
             salt, and iteration count we are currently initialised with.
            
             @param keySize the size of the key we want (in bits)
             @return a KeyParameter object.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.Pkcs5S1ParametersGenerator">
            Generator for Pbe derived keys and ivs as defined by Pkcs 5 V2.0 Scheme 1.
            Note this generator is limited to the size of the hash produced by the
            digest used to drive it.
            <p>
            The document this implementation is based on can be found at
            <a href="http://www.rsasecurity.com/rsalabs/pkcs/pkcs-5/index.html">
            RSA's Pkcs5 Page</a>
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs5S1ParametersGenerator.#ctor(Org.BouncyCastle.Crypto.IDigest)">
             Construct a Pkcs 5 Scheme 1 Parameters generator.
            
             @param digest the digest to be used as the source of derived keys.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs5S1ParametersGenerator.GenerateDerivedKey">
            the derived key function, the ith hash of the mPassword and the mSalt.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs5S1ParametersGenerator.GenerateDerivedParameters(System.Int32)">
             Generate a key parameter derived from the mPassword, mSalt, and iteration
             count we are currently initialised with.
            
             @param keySize the size of the key we want (in bits)
             @return a KeyParameter object.
             @exception ArgumentException if the key length larger than the base hash size.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs5S1ParametersGenerator.GenerateDerivedParameters(System.Int32,System.Int32)">
             Generate a key with initialisation vector parameter derived from
             the mPassword, mSalt, and iteration count we are currently initialised
             with.
            
             @param keySize the size of the key we want (in bits)
             @param ivSize the size of the iv we want (in bits)
             @return a ParametersWithIV object.
             @exception ArgumentException if keySize + ivSize is larger than the base hash size.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs5S1ParametersGenerator.GenerateDerivedMacParameters(System.Int32)">
             Generate a key parameter for use with a MAC derived from the mPassword,
             mSalt, and iteration count we are currently initialised with.
            
             @param keySize the size of the key we want (in bits)
             @return a KeyParameter object.
             @exception ArgumentException if the key length larger than the base hash size.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.Pkcs5S2ParametersGenerator">
            Generator for Pbe derived keys and ivs as defined by Pkcs 5 V2.0 Scheme 2.
            This generator uses a SHA-1 HMac as the calculation function.
            <p>
            The document this implementation is based on can be found at
            <a href="http://www.rsasecurity.com/rsalabs/pkcs/pkcs-5/index.html">
            RSA's Pkcs5 Page</a></p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs5S2ParametersGenerator.#ctor">
            construct a Pkcs5 Scheme 2 Parameters generator.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs5S2ParametersGenerator.GenerateDerivedParameters(System.Int32)">
             Generate a key parameter derived from the password, salt, and iteration
             count we are currently initialised with.
            
             @param keySize the size of the key we want (in bits)
             @return a KeyParameter object.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs5S2ParametersGenerator.GenerateDerivedParameters(System.Int32,System.Int32)">
             Generate a key with initialisation vector parameter derived from
             the password, salt, and iteration count we are currently initialised
             with.
            
             @param keySize the size of the key we want (in bits)
             @param ivSize the size of the iv we want (in bits)
             @return a ParametersWithIV object.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Pkcs5S2ParametersGenerator.GenerateDerivedMacParameters(System.Int32)">
             Generate a key parameter for use with a MAC derived from the password,
             salt, and iteration count we are currently initialised with.
            
             @param keySize the size of the key we want (in bits)
             @return a KeyParameter object.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.Poly1305KeyGenerator">
            <summary>
            Generates keys for the Poly1305 MAC.
            </summary>
            <remarks>
            Poly1305 keys are 256 bit keys consisting of a 128 bit secret key used for the underlying block
            cipher followed by a 128 bit {@code r} value used for the polynomial portion of the Mac. <br/>
            The {@code r} value has a specific format with some bits required to be cleared, resulting in an
            effective 106 bit key. <br/>
            A separately generated 256 bit key can be modified to fit the Poly1305 key format by using the
            {@link #clamp(byte[])} method to clear the required bits.
            </remarks>
            <seealso cref="T:Org.BouncyCastle.Crypto.Macs.Poly1305"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Poly1305KeyGenerator.engineInit(Org.BouncyCastle.Crypto.KeyGenerationParameters)">
            <summary>
            Initialises the key generator.
            </summary>
            <remarks>
            Poly1305 keys are always 256 bits, so the key length in the provided parameters is ignored.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Poly1305KeyGenerator.engineGenerateKey">
            <summary>
            Generates a 256 bit key in the format required for Poly1305 - e.g.
            <code>k[0] ... k[15], r[0] ... r[15]</code> with the required bits in <code>r</code> cleared
            as per <see cref="M:Org.BouncyCastle.Crypto.Generators.Poly1305KeyGenerator.Clamp(System.Byte[])"/>.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Poly1305KeyGenerator.Clamp(System.Byte[])">
            <summary>
            Modifies an existing 32 byte key value to comply with the requirements of the Poly1305 key by
            clearing required bits in the <code>r</code> (second 16 bytes) portion of the key.<br/>
            Specifically:
            <ul>
            <li>r[3], r[7], r[11], r[15] have top four bits clear (i.e., are {0, 1, . . . , 15})</li>
            <li>r[4], r[8], r[12] have bottom two bits clear (i.e., are in {0, 4, 8, . . . , 252})</li>
            </ul>
            </summary>
            <param name="key">a 32 byte key value <code>k[0] ... k[15], r[0] ... r[15]</code></param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Poly1305KeyGenerator.CheckKey(System.Byte[])">
            <summary>
            Checks a 32 byte key for compliance with the Poly1305 key requirements, e.g.
            <code>k[0] ... k[15], r[0] ... r[15]</code> with the required bits in <code>r</code> cleared
            as per <see cref="M:Org.BouncyCastle.Crypto.Generators.Poly1305KeyGenerator.Clamp(System.Byte[])"/>.
            </summary>
            <param name="key">Key.</param>
            <exception cref="T:System.ArgumentException">if the key is of the wrong length, or has invalid bits set
                      in the <code>r</code> portion of the key.</exception>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.RsaBlindingFactorGenerator">
            Generate a random factor suitable for use with RSA blind signatures
            as outlined in Chaum's blinding and unblinding as outlined in
            "Handbook of Applied Cryptography", page 475.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.RsaBlindingFactorGenerator.Init(Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the factor generator
            
             @param param the necessary RSA key parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.RsaBlindingFactorGenerator.GenerateBlindingFactor">
             Generate a suitable blind factor for the public key the generator was initialised with.
            
             @return a random blind factor
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.RsaKeyPairGenerator">
            an RSA key pair generator.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.RsaKeyPairGenerator.ChooseRandomPrime(System.Int32,Org.BouncyCastle.Math.BigInteger)">
            <summary>Choose a random prime value for use with RSA</summary>
            <param name="bitlength">the bit-length of the returned prime</param>
            <param name="e">the RSA public exponent</param>
            <returns>a prime p, with (p-1) relatively prime to e</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IBlockResult">
            <summary>
            Operators that reduce their input to a single block return an object
            of this type.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockResult.Collect">
            <summary>
            Return the final result of the operation.
            </summary>
            <returns>A block of bytes, representing the result of an operation.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockResult.Collect(System.Byte[],System.Int32)">
            <summary>
            Store the final result of the operation by copying it into the destination array.
            </summary>
            <returns>The number of bytes copied into destination.</returns>
            <param name="destination">The byte array to copy the result into.</param>
            <param name="offset">The offset into destination to start copying the result at.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IDsa">
            interface for classes implementing the Digital Signature Algorithm
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDsa.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the signer for signature generation or signature
             verification.
            
             @param forSigning true if we are generating a signature, false
             otherwise.
             @param param key parameters for signature generation.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDsa.GenerateSignature(System.Byte[])">
             sign the passed in message (usually the output of a hash function).
            
             @param message the message to be signed.
             @return two big integers representing the r and s values respectively.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDsa.VerifySignature(System.Byte[],Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
             verify the message message against the signature values r and s.
            
             @param message the message that was supposed to have been signed.
             @param r the r signature value.
             @param s the s signature value.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IEntropySource">
            <summary>
            Base interface describing an entropy source for a DRBG.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IEntropySource.GetEntropy">
            <summary>
            Return a byte array of entropy.
            </summary>
            <returns>The entropy bytes.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IEntropySource.IsPredictionResistant">
            <summary>
            Return whether or not this entropy source is regarded as prediction resistant.
            </summary>
            <value><c>true</c> if this instance is prediction resistant; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IEntropySource.EntropySize">
            <summary>
            Return the number of bits of entropy this source can produce.
            </summary>
            <value>The size, in bits, of the return value of getEntropy.</value>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IEntropySourceProvider">
            <summary>
            Base interface describing a provider of entropy sources.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IEntropySourceProvider.Get(System.Int32)">
            <summary>
            Return an entropy source providing a block of entropy.
            </summary>
            <param name="bitsRequired">The size of the block of entropy required.</param>
            <returns>An entropy source providing bitsRequired blocks of entropy.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IMac">
            The base interface for implementations of message authentication codes (MACs).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IMac.Init(Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the MAC.
            
             @param param the key and other data required by the MAC.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IMac.GetMacSize">
             Return the block size for this MAC (in bytes).
            
             @return the block size for this MAC in bytes.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IMac.Update(System.Byte)">
             add a single byte to the mac for processing.
            
             @param in the byte to be processed.
             @exception InvalidOperationException if the MAC is not initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IMac.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            @param in the array containing the input.
            @param inOff the index in the array the data begins at.
            @param len the length of the input starting at inOff.
            @exception InvalidOperationException if the MAC is not initialised.
            @exception DataLengthException if there isn't enough data in in.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IMac.DoFinal(System.Byte[],System.Int32)">
            Compute the final stage of the MAC writing the output to the out
            parameter.
            <p>
            doFinal leaves the MAC in the same state it was after the last init.
            </p>
            @param out the array the MAC is to be output to.
            @param outOff the offset into the out buffer the output is to start at.
            @exception DataLengthException if there isn't enough space in out.
            @exception InvalidOperationException if the MAC is not initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IMac.Reset">
            Reset the MAC. At the end of resetting the MAC should be in the
            in the same state it was after the last init (if there was one).
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IMac.AlgorithmName">
             Return the name of the algorithm the MAC implements.
            
             @return the name of the algorithm the MAC implements.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.InvalidCipherTextException">
            this exception is thrown whenever we find something we don't expect in a
            message.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.InvalidCipherTextException.#ctor">
            base constructor.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.InvalidCipherTextException.#ctor(System.String)">
             create a InvalidCipherTextException with the given message.
            
             @param message the message to be carried with the exception.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.ISignatureFactory">
            <summary>
            Base interface for operators that serve as stream-based signature calculators.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISignatureFactory.CreateCalculator">
            <summary>
            Create a stream calculator for this signature calculator. The stream
            calculator is used for the actual operation of entering the data to be signed
            and producing the signature block.
            </summary>
            <returns>A calculator producing an IBlockResult with a signature in it.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.ISignatureFactory.AlgorithmDetails">
            <summary>The algorithm details object for this calculator.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISigner.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the signer for signing or verification.
            
             @param forSigning true if for signing, false otherwise
             @param param necessary parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISigner.Update(System.Byte)">
            update the internal digest with the byte b
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISigner.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            update the internal digest with the byte array in
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISigner.GenerateSignature">
            Generate a signature for the message we've been loaded with using
            the key we were initialised with.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISigner.VerifySignature(System.Byte[])">
            return true if the internal state represents the signature described
            in the passed in array.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISigner.Reset">
            reset the internal state
        </member>
        <member name="P:Org.BouncyCastle.Crypto.ISigner.AlgorithmName">
             Return the name of the algorithm the signer implements.
            
             @return the name of the algorithm the signer implements.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.ISignerWithRecovery">
            Signer with message recovery.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISignerWithRecovery.HasFullMessage">
             Returns true if the signer has recovered the full message as
             part of signature verification.
            
             @return true if full message recovered.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISignerWithRecovery.GetRecoveredMessage">
             Returns a reference to what message was recovered (if any).
            
             @return full/partial message, null if nothing.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISignerWithRecovery.UpdateWithRecoveredMessage(System.Byte[])">
             Perform an update with the recovered message before adding any other data. This must
             be the first update method called, and calling it will result in the signer assuming
             that further calls to update will include message content past what is recoverable.
            
             @param signature the signature that we are in the process of verifying.
             @throws IllegalStateException
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IStreamCalculator">
            <summary>
            Base interface for cryptographic operations such as Hashes, MACs, and Signatures which reduce a stream of data
            to a single value.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IStreamCalculator.GetResult">
            <summary>
            Return the result of processing the stream. This value is only available once the stream
            has been closed.
            </summary>
            <returns>The result of processing the stream.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IStreamCalculator.Stream">
            <summary>Return a "sink" stream which only exists to update the implementing object.</summary>
            <returns>A stream to write to in order to update the implementing object.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IVerifier">
            <summary>
            Operators that reduce their input to the validation of a signature produce this type.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IVerifier.IsVerified(System.Byte[])">
            <summary>
            Return true if the passed in data matches what is expected by the verification result.
            </summary>
            <param name="data">The bytes representing the signature.</param>
            <returns>true if the signature verifies, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IVerifier.IsVerified(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Return true if the length bytes from off in the source array match the signature
            expected by the verification result.
            </summary>
            <param name="source">Byte array containing the signature.</param>
            <param name="off">The offset into the source array where the signature starts.</param>
            <param name="length">The number of bytes in source making up the signature.</param>
            <returns>true if the signature verifies, false otherwise.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IVerifierFactory">
            <summary>
            Base interface for operators that serve as stream-based signature verifiers.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IVerifierFactory.CreateCalculator">
            <summary>
            Create a stream calculator for this verifier. The stream
            calculator is used for the actual operation of entering the data to be verified
            and producing a result which can be used to verify the original signature.
            </summary>
            <returns>A calculator producing an IVerifier which can verify the signature.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IVerifierFactory.AlgorithmDetails">
            <summary>The algorithm details object for this verifier.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IVerifierFactoryProvider">
            <summary>
            Base interface for a provider to support the dynamic creation of signature verifiers.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IVerifierFactoryProvider.CreateVerifierFactory(System.Object)">
            <summary>
            Return a signature verfier for signature algorithm described in the passed in algorithm details object.
            </summary>
            <param name="algorithmDetails">The details of the signature algorithm verification is required for.</param>
            <returns>A new signature verifier.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.KeyGenerationParameters">
            The base class for parameters to key generators.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.KeyGenerationParameters.#ctor(Org.BouncyCastle.Security.SecureRandom,System.Int32)">
             initialise the generator with a source of randomness
             and a strength (in bits).
            
             @param random the random byte source.
             @param strength the size, in bits, of the keys we want to produce.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.KeyGenerationParameters.Random">
             return the random source associated with this
             generator.
            
             @return the generators random source.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.KeyGenerationParameters.Strength">
             return the bit strength for keys produced by this generator,
            
             @return the strength of the keys this generator produces (in bits).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Macs.CbcBlockCipherMac">
            standard CBC Block Cipher MAC - if no padding is specified the default of
            pad of zeroes is used.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CbcBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             create a standard MAC based on a CBC block cipher. This will produce an
             authentication code half the length of the block size of the cipher.
            
             @param cipher the cipher to be used as the basis of the MAC generation.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CbcBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
             create a standard MAC based on a CBC block cipher. This will produce an
             authentication code half the length of the block size of the cipher.
            
             @param cipher the cipher to be used as the basis of the MAC generation.
             @param padding the padding to be used to complete the last block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CbcBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32)">
            create a standard MAC based on a block cipher with the size of the
            MAC been given in bits. This class uses CBC mode as the basis for the
            MAC generation.
            <p>
            Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
            or 16 bits if being used as a data authenticator (FIPS Publication 113),
            and in general should be less than the size of the block cipher as it reduces
            the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            </p>
            @param cipher the cipher to be used as the basis of the MAC generation.
            @param macSizeInBits the size of the MAC in bits, must be a multiple of 8.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CbcBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32,Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
            create a standard MAC based on a block cipher with the size of the
            MAC been given in bits. This class uses CBC mode as the basis for the
            MAC generation.
            <p>
            Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
            or 16 bits if being used as a data authenticator (FIPS Publication 113),
            and in general should be less than the size of the block cipher as it reduces
            the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            </p>
            @param cipher the cipher to be used as the basis of the MAC generation.
            @param macSizeInBits the size of the MAC in bits, must be a multiple of 8.
            @param padding the padding to be used to complete the last block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CbcBlockCipherMac.Reset">
            Reset the mac generator.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Macs.MacCFBBlockCipher">
            implements a Cipher-FeedBack (CFB) mode on top of a simple cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.MacCFBBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of the
             feedback mode.
             @param blockSize the block size in bits (note: a multiple of 8)
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.MacCFBBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
             An IV which is too short is handled in FIPS compliant fashion.
            
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.MacCFBBlockCipher.GetBlockSize">
             return the block size we are operating at.
            
             @return the block size we are operating at (in bytes).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.MacCFBBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Process one block of input from the array in and write it to
             the out array.
            
             @param in the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param out the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.MacCFBBlockCipher.Reset">
            reset the chaining vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Macs.MacCFBBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/CFB"
             and the block size in bits.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CfbBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             create a standard MAC based on a CFB block cipher. This will produce an
             authentication code half the length of the block size of the cipher, with
             the CFB mode set to 8 bits.
            
             @param cipher the cipher to be used as the basis of the MAC generation.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CfbBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
             create a standard MAC based on a CFB block cipher. This will produce an
             authentication code half the length of the block size of the cipher, with
             the CFB mode set to 8 bits.
            
             @param cipher the cipher to be used as the basis of the MAC generation.
             @param padding the padding to be used.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CfbBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32,System.Int32)">
            create a standard MAC based on a block cipher with the size of the
            MAC been given in bits. This class uses CFB mode as the basis for the
            MAC generation.
            <p>
            Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
            or 16 bits if being used as a data authenticator (FIPS Publication 113),
            and in general should be less than the size of the block cipher as it reduces
            the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            </p>
            @param cipher the cipher to be used as the basis of the MAC generation.
            @param cfbBitSize the size of an output block produced by the CFB mode.
            @param macSizeInBits the size of the MAC in bits, must be a multiple of 8.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CfbBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32,System.Int32,Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
            create a standard MAC based on a block cipher with the size of the
            MAC been given in bits. This class uses CFB mode as the basis for the
            MAC generation.
            <p>
            Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
            or 16 bits if being used as a data authenticator (FIPS Publication 113),
            and in general should be less than the size of the block cipher as it reduces
            the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            </p>
            @param cipher the cipher to be used as the basis of the MAC generation.
            @param cfbBitSize the size of an output block produced by the CFB mode.
            @param macSizeInBits the size of the MAC in bits, must be a multiple of 8.
            @param padding a padding to be used.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CfbBlockCipherMac.Reset">
            Reset the mac generator.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Macs.CMac">
            CMAC - as specified at www.nuee.nagoya-u.ac.jp/labs/tiwata/omac/omac.html
            <p>
            CMAC is analogous to OMAC1 - see also en.wikipedia.org/wiki/CMAC
            </p><p>
            CMAC is a NIST recomendation - see 
            csrc.nist.gov/CryptoToolkit/modes/800-38_Series_Publications/SP800-38B.pdf
            </p><p>
            CMAC/OMAC1 is a blockcipher-based message authentication code designed and
            analyzed by Tetsu Iwata and Kaoru Kurosawa.
            </p><p>
            CMAC/OMAC1 is a simple variant of the CBC MAC (Cipher Block Chaining Message 
            Authentication Code). OMAC stands for One-Key CBC MAC.
            </p><p>
            It supports 128- or 64-bits block ciphers, with any key size, and returns
            a MAC with dimension less or equal to the block size of the underlying 
            cipher.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             create a standard MAC based on a CBC block cipher (64 or 128 bit block).
             This will produce an authentication code the length of the block size
             of the cipher.
            
             @param cipher the cipher to be used as the basis of the MAC generation.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32)">
             create a standard MAC based on a block cipher with the size of the
             MAC been given in bits.
             <p/>
             Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
             or 16 bits if being used as a data authenticator (FIPS Publication 113),
             and in general should be less than the size of the block cipher as it reduces
             the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            
             @param cipher        the cipher to be used as the basis of the MAC generation.
             @param macSizeInBits the size of the MAC in bits, must be a multiple of 8 and @lt;= 128.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CMac.Reset">
            Reset the mac generator.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Macs.GMac">
            <summary>
            The GMAC specialisation of Galois/Counter mode (GCM) detailed in NIST Special Publication
            800-38D.
            </summary>
            <remarks>
            GMac is an invocation of the GCM mode where no data is encrypted (i.e. all input data to the Mac
            is processed as additional authenticated data with the underlying GCM block cipher).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.GMac.#ctor(Org.BouncyCastle.Crypto.Modes.GcmBlockCipher)">
            <summary>
            Creates a GMAC based on the operation of a block cipher in GCM mode.
            </summary>
            <remarks>
            This will produce an authentication code the length of the block size of the cipher.
            </remarks>
            <param name="cipher">the cipher to be used in GCM mode to generate the MAC.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.GMac.#ctor(Org.BouncyCastle.Crypto.Modes.GcmBlockCipher,System.Int32)">
            <summary>
            Creates a GMAC based on the operation of a 128 bit block cipher in GCM mode.
            </summary>
            <remarks>
            This will produce an authentication code the length of the block size of the cipher.
            </remarks>
            <param name="cipher">the cipher to be used in GCM mode to generate the MAC.</param>
            <param name="macSizeBits">the mac size to generate, in bits. Must be a multiple of 8, between 32 and 128 (inclusive).
            Sizes less than 96 are not recommended, but are supported for specialized applications.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.GMac.Init(Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>
            Initialises the GMAC - requires a <see cref="T:Org.BouncyCastle.Crypto.Parameters.ParametersWithIV"/> 
            providing a <see cref="T:Org.BouncyCastle.Crypto.Parameters.KeyParameter"/> and a nonce.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Macs.Gost28147Mac">
            implementation of GOST 28147-89 MAC
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Macs.HMac">
             HMAC implementation based on RFC2104
            
             H(K XOR opad, H(K XOR ipad, text))
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.HMac.Reset">
            Reset the mac generator.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Macs.ISO9797Alg3Mac">
             DES based CBC Block Cipher MAC according to ISO9797, algorithm 3 (ANSI X9.19 Retail MAC)
            
             This could as well be derived from CBCBlockCipherMac, but then the property mac in the base
             class must be changed to protected
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.ISO9797Alg3Mac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             create a Retail-MAC based on a CBC block cipher. This will produce an
             authentication code of the length of the block size of the cipher.
            
             @param cipher the cipher to be used as the basis of the MAC generation. This must
             be DESEngine.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.ISO9797Alg3Mac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
             create a Retail-MAC based on a CBC block cipher. This will produce an
             authentication code of the length of the block size of the cipher.
            
             @param cipher the cipher to be used as the basis of the MAC generation.
             @param padding the padding to be used to complete the last block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.ISO9797Alg3Mac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32)">
            create a Retail-MAC based on a block cipher with the size of the
            MAC been given in bits. This class uses single DES CBC mode as the basis for the
            MAC generation.
            <p>
            Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
            or 16 bits if being used as a data authenticator (FIPS Publication 113),
            and in general should be less than the size of the block cipher as it reduces
            the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            </p>
            @param cipher the cipher to be used as the basis of the MAC generation.
            @param macSizeInBits the size of the MAC in bits, must be a multiple of 8.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.ISO9797Alg3Mac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32,Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
            create a standard MAC based on a block cipher with the size of the
            MAC been given in bits. This class uses single DES CBC mode as the basis for the
            MAC generation. The final block is decrypted and then encrypted using the
            middle and right part of the key.
            <p>
            Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
            or 16 bits if being used as a data authenticator (FIPS Publication 113),
            and in general should be less than the size of the block cipher as it reduces
            the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            </p>
            @param cipher the cipher to be used as the basis of the MAC generation.
            @param macSizeInBits the size of the MAC in bits, must be a multiple of 8.
            @param padding the padding to be used to complete the last block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.ISO9797Alg3Mac.Reset">
            Reset the mac generator.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Macs.Poly1305">
            <summary>
            Poly1305 message authentication code, designed by D. J. Bernstein.
            </summary>
            <remarks>
            Poly1305 computes a 128-bit (16 bytes) authenticator, using a 128 bit nonce and a 256 bit key
            consisting of a 128 bit key applied to an underlying cipher, and a 128 bit key (with 106
            effective key bits) used in the authenticator.
            
            The polynomial calculation in this implementation is adapted from the public domain <a href="https://github.com/floodyberry/poly1305-donna">poly1305-donna-unrolled</a> C implementation
            by Andrew M (@floodyberry).
            </remarks>
            <seealso cref="T:Org.BouncyCastle.Crypto.Generators.Poly1305KeyGenerator"/>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.r0">
            Polynomial key 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.r1">
            Polynomial key 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.r2">
            Polynomial key 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.r3">
            Polynomial key 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.r4">
            Polynomial key 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.s1">
            Precomputed 5 * r[1..4] 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.s2">
            Precomputed 5 * r[1..4] 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.s3">
            Precomputed 5 * r[1..4] 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.s4">
            Precomputed 5 * r[1..4] 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.k0">
            Encrypted nonce 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.k1">
            Encrypted nonce 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.k2">
            Encrypted nonce 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.k3">
            Encrypted nonce 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.currentBlock">
            Current block of buffered input 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.currentBlockOffset">
            Current offset in input buffer 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.h0">
            Polynomial accumulator 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.h1">
            Polynomial accumulator 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.h2">
            Polynomial accumulator 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.h3">
            Polynomial accumulator 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.h4">
            Polynomial accumulator 
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.Poly1305.#ctor">
            Constructs a Poly1305 MAC, where the key passed to init() will be used directly.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.Poly1305.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
            Constructs a Poly1305 MAC, using a 128 bit block cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.Poly1305.Init(Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>
            Initialises the Poly1305 MAC.
            </summary>
            <param name="parameters">a {@link ParametersWithIV} containing a 128 bit nonce and a {@link KeyParameter} with
                     a 256 bit key complying to the {@link Poly1305KeyGenerator Poly1305 key format}.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Macs.SipHash">
            <summary>
            Implementation of SipHash as specified in "SipHash: a fast short-input PRF", by Jean-Philippe
            Aumasson and Daniel J. Bernstein (https://131002.net/siphash/siphash.pdf).
            </summary>
            <remarks>
            "SipHash is a family of PRFs SipHash-c-d where the integer parameters c and d are the number of
            compression rounds and the number of finalization rounds. A compression round is identical to a
            finalization round and this round function is called SipRound. Given a 128-bit key k and a
            (possibly empty) byte string m, SipHash-c-d returns a 64-bit value..."
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.SipHash.#ctor">
            <summary>SipHash-2-4</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.SipHash.#ctor(System.Int32,System.Int32)">
            <summary>SipHash-c-d</summary>
            <param name="c">the number of compression rounds</param>
            <param name="d">the number of finalization rounds</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Macs.SkeinMac">
            <summary>
            Implementation of the Skein parameterised MAC function in 256, 512 and 1024 bit block sizes,
            based on the <see cref="T:Org.BouncyCastle.Crypto.Engines.ThreefishEngine">Threefish</see> tweakable block cipher.
            </summary>
            <remarks>
            This is the 1.3 version of Skein defined in the Skein hash function submission to the NIST SHA-3
            competition in October 2010.
            <p/>
            Skein was designed by Niels Ferguson - Stefan Lucks - Bruce Schneier - Doug Whiting - Mihir
            Bellare - Tadayoshi Kohno - Jon Callas - Jesse Walker.
            </remarks>
            <seealso cref="T:Org.BouncyCastle.Crypto.Digests.SkeinEngine"/>
            <seealso cref="T:Org.BouncyCastle.Crypto.Parameters.SkeinParameters"/>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.SkeinMac.SKEIN_256">
            <summary>
            256 bit block size - Skein-256
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.SkeinMac.SKEIN_512">
            <summary>
            512 bit block size - Skein-512
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.SkeinMac.SKEIN_1024">
            <summary>
            1024 bit block size - Skein-1024
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.SkeinMac.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a Skein MAC with an internal state size and output size.
            </summary>
            <param name="stateSizeBits">the internal state size in bits - one of <see cref="F:Org.BouncyCastle.Crypto.Macs.SkeinMac.SKEIN_256"/> <see cref="F:Org.BouncyCastle.Crypto.Macs.SkeinMac.SKEIN_512"/> or
                                  <see cref="F:Org.BouncyCastle.Crypto.Macs.SkeinMac.SKEIN_1024"/>.</param>
            <param name="digestSizeBits">the output/MAC size to produce in bits, which must be an integral number of
                                 bytes.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.SkeinMac.Init(Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>
            Optionally initialises the Skein digest with the provided parameters.
            </summary>
            See <see cref="T:Org.BouncyCastle.Crypto.Parameters.SkeinParameters"></see> for details on the parameterisation of the Skein hash function.
            <param name="parameters">the parameters to apply to this engine, or <code>null</code> to use no parameters.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.MaxBytesExceededException">
            <summary>
            This exception is thrown whenever a cipher requires a change of key, iv
            or similar after x amount of bytes enciphered
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher">
            implements Cipher-Block-Chaining (CBC) mode on top of a simple cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of chaining.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.GetUnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.GetBlockSize">
             return the block size of the underlying cipher.
            
             @return the block size of the underlying cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Process one block of input from the array in and write it to
             the out array.
            
             @param in the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param out the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.Reset">
            reset the chaining vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Do the appropriate chaining step for CBC mode encryption.
            
             @param in the array containing the data to be encrypted.
             @param inOff offset into the in array the data starts at.
             @param out the array the encrypted data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Do the appropriate chaining step for CBC mode decryption.
            
             @param in the array containing the data to be decrypted.
             @param inOff offset into the in array the data starts at.
             @param out the array the decrypted data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/CBC".
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.CcmBlockCipher">
            Implements the Counter with Cipher Block Chaining mode (CCM) detailed in
            NIST Special Publication 800-38C.
            <p>
            <b>Note</b>: this mode is a packet mode - it needs all the data up front.
            </p>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher">
            <summary>
            A block cipher mode that includes authenticated encryption with a streaming mode
            and optional associated data.</summary>
            <see cref="T:Org.BouncyCastle.Crypto.Parameters.AeadParameters"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.GetUnderlyingCipher">
            <summary>The block cipher underlying this algorithm.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <remarks>Parameter can either be an AeadParameters or a ParametersWithIV object.</remarks>
            <param name="forEncryption">Initialise for encryption if true, for decryption if false.</param>
            <param name="parameters">The key or other data required by the cipher.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.GetBlockSize">
            <returns>The block size for this cipher, in bytes.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.ProcessAadByte(System.Byte)">
            <summary>Add a single byte to the associated data check.</summary>
            <remarks>If the implementation supports it, this will be an online operation and will not retain the associated data.</remarks>
            <param name="input">The byte to be processed.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.ProcessAadBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>Add a sequence of bytes to the associated data check.</summary>
            <remarks>If the implementation supports it, this will be an online operation and will not retain the associated data.</remarks>
            <param name="inBytes">The input byte array.</param>
            <param name="inOff">The offset into the input array where the data to be processed starts.</param>
            <param name="len">The number of bytes to be processed.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             Encrypt/decrypt a single byte.
            
             @param input the byte to be processed.
             @param outBytes the output buffer the processed byte goes into.
             @param outOff the offset into the output byte array the processed data starts at.
             @return the number of bytes written to out.
             @exception DataLengthException if the output buffer is too small.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             Process a block of bytes from in putting the result into out.
            
             @param inBytes the input byte array.
             @param inOff the offset into the in array where the data to be processed starts.
             @param len the number of bytes to be processed.
             @param outBytes the output buffer the processed bytes go into.
             @param outOff the offset into the output byte array the processed data starts at.
             @return the number of bytes written to out.
             @exception DataLengthException if the output buffer is too small.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Finish the operation either appending or verifying the MAC at the end of the data.
            
             @param outBytes space for any resulting output data.
             @param outOff offset into out to start copying the data at.
             @return number of bytes written into out.
             @throws InvalidOperationException if the cipher is in an inappropriate state.
             @throws InvalidCipherTextException if the MAC fails to match.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.GetMac">
             Return the value of the MAC associated with the last stream processed.
            
             @return MAC for plaintext data.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.GetUpdateOutputSize(System.Int32)">
             Return the size of the output buffer required for a ProcessBytes
             an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to ProcessBytes
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.GetOutputSize(System.Int32)">
             Return the size of the output buffer required for a ProcessBytes plus a
             DoFinal with an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to ProcessBytes and DoFinal
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.Reset">
            <summary>
            Reset the cipher to the same state as it was after the last init (if there was one).
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CcmBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Basic constructor.
            
             @param cipher the block cipher to be used.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CcmBlockCipher.GetUnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CcmBlockCipher.GetMac">
             Returns a byte array containing the mac calculated as part of the
             last encrypt or decrypt operation.
            
             @return the last mac calculated.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CcmBlockCipher.ProcessPacket(System.Byte[],System.Int32,System.Int32)">
             Process a packet of data for either CCM decryption or encryption.
            
             @param in data for processing.
             @param inOff offset at which data starts in the input array.
             @param inLen length of the data in the input array.
             @return a byte array containing the processed input..
             @throws IllegalStateException if the cipher is not appropriately set up.
             @throws InvalidCipherTextException if the input data is truncated or the mac check fails.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CcmBlockCipher.ProcessPacket(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             Process a packet of data for either CCM decryption or encryption.
            
             @param in data for processing.
             @param inOff offset at which data starts in the input array.
             @param inLen length of the data in the input array.
             @param output output array.
             @param outOff offset into output array to start putting processed bytes.
             @return the number of bytes added to output.
             @throws IllegalStateException if the cipher is not appropriately set up.
             @throws InvalidCipherTextException if the input data is truncated or the mac check fails.
             @throws DataLengthException if output buffer too short.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher">
            implements a Cipher-FeedBack (CFB) mode on top of a simple cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of the
             feedback mode.
             @param blockSize the block size in bits (note: a multiple of 8)
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.GetUnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
             An IV which is too short is handled in FIPS compliant fashion.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.GetBlockSize">
             return the block size we are operating at.
            
             @return the block size we are operating at (in bytes).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Process one block of input from the array in and write it to
             the out array.
            
             @param in the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param out the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Do the appropriate processing for CFB mode encryption.
            
             @param in the array containing the data to be encrypted.
             @param inOff offset into the in array the data starts at.
             @param out the array the encrypted data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Do the appropriate processing for CFB mode decryption.
            
             @param in the array containing the data to be decrypted.
             @param inOff offset into the in array the data starts at.
             @param out the array the encrypted data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.Reset">
            reset the chaining vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/CFB"
             and the block size in bits.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.CtsBlockCipher">
            A Cipher Text Stealing (CTS) mode cipher. CTS allows block ciphers to
            be used to produce cipher text which is the same outLength as the plain text.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CtsBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Create a buffered block cipher that uses Cipher Text Stealing
            
             @param cipher the underlying block cipher this buffering object wraps.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CtsBlockCipher.GetUpdateOutputSize(System.Int32)">
             return the size of the output buffer required for an update of 'length' bytes.
            
             @param length the outLength of the input.
             @return the space required to accommodate a call to update
             with length bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CtsBlockCipher.GetOutputSize(System.Int32)">
             return the size of the output buffer required for an update plus a
             doFinal with an input of length bytes.
            
             @param length the outLength of the input.
             @return the space required to accommodate a call to update and doFinal
             with length bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CtsBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             process a single byte, producing an output block if necessary.
            
             @param in the input byte.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CtsBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process an array of bytes, producing output if necessary.
            
             @param in the input byte array.
             @param inOff the offset at which the input data starts.
             @param length the number of bytes to be copied out of the input array.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CtsBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Process the last block in the buffer.
            
             @param out the array the block currently being held is copied into.
             @param outOff the offset at which the copying starts.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there is insufficient space in out for
             the output.
             @exception InvalidOperationException if the underlying cipher is not
             initialised.
             @exception InvalidCipherTextException if cipher text decrypts wrongly (in
             case the exception will never Get thrown).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.EaxBlockCipher">
            A Two-Pass Authenticated-Encryption Scheme Optimized for Simplicity and 
            Efficiency - by M. Bellare, P. Rogaway, D. Wagner.
            
            http://www.cs.ucdavis.edu/~rogaway/papers/eax.pdf
            
            EAX is an AEAD scheme based on CTR and OMAC1/CMAC, that uses a single block 
            cipher to encrypt and authenticate data. It's on-line (the length of a 
            message isn't needed to begin processing it), has good performances, it's
            simple and provably secure (provided the underlying block cipher is secure).
            
            Of course, this implementations is NOT thread-safe.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.EaxBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Constructor that accepts an instance of a block cipher engine.
            
             @param cipher the engine to use
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.GcmBlockCipher">
            <summary>
            Implements the Galois/Counter mode (GCM) detailed in
            NIST Special Publication 800-38D.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.GcmBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            <remarks>
            MAC sizes from 32 bits to 128 bits (must be a multiple of 8) are supported. The default is 128 bits.
            Sizes less than 96 are not recommended, but are supported for specialized applications.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher">
            implements the GOST 28147 OFB counter mode (GCTR).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of the
             counter mode (must have a 64 bit block size).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher.GetUnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
             An IV which is too short is handled in FIPS compliant fashion.
            
             @param encrypting if true the cipher is initialised for
              encryption, if false for decryption.
             @param parameters the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher.GetBlockSize">
             return the block size we are operating at (in bytes).
            
             @return the block size we are operating at (in bytes).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Process one block of input from the array in and write it to
             the out array.
            
             @param in the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param out the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher.Reset">
            reset the feedback vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/GCTR"
             and the block size in bits
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.OcbBlockCipher">
            An implementation of <a href="http://tools.ietf.org/html/rfc7253">RFC 7253 on The OCB
            Authenticated-Encryption Algorithm</a>, licensed per:
            
            <blockquote><p><a href="http://www.cs.ucdavis.edu/~rogaway/ocb/license1.pdf">License for
            Open-Source Software Implementations of OCB</a> (Jan 9, 2013) - 'License 1'<br/>
            Under this license, you are authorized to make, use, and distribute open-source software
            implementations of OCB. This license terminates for you if you sue someone over their open-source
            software implementation of OCB claiming that you have a patent covering their implementation.
            </p><p>
            This is a non-binding summary of a legal document (the link above). The parameters of the license
            are specified in the license document and that document is controlling.</p></blockquote>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.OfbBlockCipher">
            implements a Output-FeedBack (OFB) mode on top of a simple cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OfbBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of the
             feedback mode.
             @param blockSize the block size in bits (note: a multiple of 8)
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OfbBlockCipher.GetUnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OfbBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
             An IV which is too short is handled in FIPS compliant fashion.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OfbBlockCipher.GetBlockSize">
             return the block size we are operating at (in bytes).
            
             @return the block size we are operating at (in bytes).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OfbBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Process one block of input from the array in and write it to
             the out array.
            
             @param in the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param out the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OfbBlockCipher.Reset">
            reset the feedback vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.OfbBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/OFB"
             and the block size in bits
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher">
                * Implements OpenPGP's rather strange version of Cipher-FeedBack (CFB) mode
                * on top of a simple cipher. This class assumes the IV has been prepended
                * to the data stream already, and just accomodates the reset after
                * (blockSize + 2) bytes have been read.
                * <p>
                * For further info see <a href="http://www.ietf.org/rfc/rfc2440.html">RFC 2440</a>.
            	* </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of the
             feedback mode.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.GetUnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.GetBlockSize">
             return the block size we are operating at.
            
             @return the block size we are operating at (in bytes).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Process one block of input from the array in and write it to
             the out array.
            
             @param in the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param out the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.Reset">
            reset the chaining vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
             An IV which is too short is handled in FIPS compliant fashion.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param parameters the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.EncryptByte(System.Byte,System.Int32)">
            Encrypt one byte of data according to CFB mode.
            @param data the byte to encrypt
            @param blockOff offset in the current block
            @returns the encrypted byte
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Do the appropriate processing for CFB IV mode encryption.
            
             @param in the array containing the data to be encrypted.
             @param inOff offset into the in array the data starts at.
             @param out the array the encrypted data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Do the appropriate processing for CFB IV mode decryption.
            
             @param in the array containing the data to be decrypted.
             @param inOff offset into the in array the data starts at.
             @param out the array the encrypted data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/PGPCFB"
             and the block size in bits.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.SicBlockCipher">
            Implements the Segmented Integer Counter (SIC) mode on top of a simple
            block cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.SicBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Basic constructor.
            
             @param c the block cipher to be used.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.SicBlockCipher.GetUnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Operators.X509Utilities.GetDigestAlgName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            Return the digest algorithm using one of the standard JCA string
            representations rather than the algorithm identifier (if possible).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Operators.Asn1SignatureFactory">
            <summary>
            Calculator factory class for signature generation in ASN.1 based profiles that use an AlgorithmIdentifier to preserve
            signature algorithm details.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Operators.Asn1SignatureFactory.#ctor(System.String,Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Base constructor.
            </summary>
            <param name="algorithm">The name of the signature algorithm to use.</param>
            <param name="privateKey">The private key to be used in the signing operation.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Operators.Asn1SignatureFactory.#ctor(System.String,Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Constructor which also specifies a source of randomness to be used if one is required.
            </summary>
            <param name="algorithm">The name of the signature algorithm to use.</param>
            <param name="privateKey">The private key to be used in the signing operation.</param>
            <param name="random">The source of randomness to be used in signature calculation.</param>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Operators.Asn1SignatureFactory.SignatureAlgNames">
            <summary>
            Allows enumeration of the signature names supported by the verifier provider.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Operators.Asn1VerifierFactory">
            <summary>
            Verifier class for signature verification in ASN.1 based profiles that use an AlgorithmIdentifier to preserve
            signature algorithm details.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Operators.Asn1VerifierFactory.#ctor(System.String,Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Base constructor.
            </summary>
            <param name="algorithm">The name of the signature algorithm to use.</param>
            <param name="publicKey">The public key to be used in the verification operation.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Operators.Asn1VerifierFactoryProvider">
            <summary>
            Provider class which supports dynamic creation of signature verifiers.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Operators.Asn1VerifierFactoryProvider.#ctor(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Base constructor - specify the public key to be used in verification.
            </summary>
            <param name="publicKey">The public key to be used in creating verifiers provided by this object.</param>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Operators.Asn1VerifierFactoryProvider.SignatureAlgNames">
            <summary>
            Allows enumeration of the signature names supported by the verifier provider.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding">
            Block cipher padders are expected to conform to this interface
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.Init(Org.BouncyCastle.Security.SecureRandom)">
             Initialise the padder.
            
             @param param parameters, if any required.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.AddPadding(System.Byte[],System.Int32)">
            add the pad bytes to the passed in block, returning the
            number of bytes added.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.PadCount(System.Byte[])">
            return the number of pad bytes present in the block.
            @exception InvalidCipherTextException if the padding is badly formed
            or invalid.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.PaddingName">
             Return the name of the algorithm the cipher implements.
            
             @return the name of the algorithm the cipher implements.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.ISO10126d2Padding">
            A padder that adds ISO10126-2 padding to a block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.ISO10126d2Padding.Init(Org.BouncyCastle.Security.SecureRandom)">
             Initialise the padder.
            
             @param random a SecureRandom if available.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.ISO10126d2Padding.AddPadding(System.Byte[],System.Int32)">
            add the pad bytes to the passed in block, returning the
            number of bytes added.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.ISO10126d2Padding.PadCount(System.Byte[])">
            return the number of pad bytes present in the block.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Paddings.ISO10126d2Padding.PaddingName">
             Return the name of the algorithm the cipher implements.
            
             @return the name of the algorithm the cipher implements.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.ISO7816d4Padding">
            A padder that adds the padding according to the scheme referenced in
            ISO 7814-4 - scheme 2 from ISO 9797-1. The first byte is 0x80, rest is 0x00
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.ISO7816d4Padding.Init(Org.BouncyCastle.Security.SecureRandom)">
             Initialise the padder.
            
             @param random - a SecureRandom if available.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.ISO7816d4Padding.AddPadding(System.Byte[],System.Int32)">
            add the pad bytes to the passed in block, returning the
            number of bytes added.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.ISO7816d4Padding.PadCount(System.Byte[])">
            return the number of pad bytes present in the block.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Paddings.ISO7816d4Padding.PaddingName">
             Return the name of the algorithm the padder implements.
            
             @return the name of the algorithm the padder implements.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher">
            A wrapper class that allows block ciphers to be used to process data in
            a piecemeal fashion with padding. The PaddedBufferedBlockCipher
            outputs a block only when the buffer is full and more data is being added,
            or on a doFinal (unless the current block in the buffer is a pad block).
            The default padding mechanism used is the one outlined in Pkcs5/Pkcs7.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
             Create a buffered block cipher with the desired padding.
            
             @param cipher the underlying block cipher this buffering object wraps.
             @param padding the padding type.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Create a buffered block cipher Pkcs7 padding
            
             @param cipher the underlying block cipher this buffering object wraps.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the cipher.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.GetOutputSize(System.Int32)">
             return the minimum size of the output buffer required for an update
             plus a doFinal with an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update and doFinal
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.GetUpdateOutputSize(System.Int32)">
             return the size of the output buffer required for an update
             an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             process a single byte, producing an output block if necessary.
            
             @param in the input byte.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process an array of bytes, producing output if necessary.
            
             @param in the input byte array.
             @param inOff the offset at which the input data starts.
             @param len the number of bytes to be copied out of the input array.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Process the last block in the buffer. If the buffer is currently
             full and padding needs to be added a call to doFinal will produce
             2 * GetBlockSize() bytes.
            
             @param out the array the block currently being held is copied into.
             @param outOff the offset at which the copying starts.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there is insufficient space in out for
             the output or we are decrypting and the input is not block size aligned.
             @exception InvalidOperationException if the underlying cipher is not
             initialised.
             @exception InvalidCipherTextException if padding is expected and not found.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.Pkcs7Padding">
            A padder that adds Pkcs7/Pkcs5 padding to a block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.Pkcs7Padding.Init(Org.BouncyCastle.Security.SecureRandom)">
             Initialise the padder.
            
             @param random - a SecureRandom if available.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.Pkcs7Padding.AddPadding(System.Byte[],System.Int32)">
            add the pad bytes to the passed in block, returning the
            number of bytes added.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.Pkcs7Padding.PadCount(System.Byte[])">
            return the number of pad bytes present in the block.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Paddings.Pkcs7Padding.PaddingName">
             Return the name of the algorithm the cipher implements.
            
             @return the name of the algorithm the cipher implements.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.TbcPadding">
            <summary> A padder that adds Trailing-Bit-Compliment padding to a block.
            <p>
            This padding pads the block out compliment of the last bit
            of the plain text.
            </p>
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.TbcPadding.Init(Org.BouncyCastle.Security.SecureRandom)">
            <summary> Initialise the padder.</summary>
            <param name="random">- a SecureRandom if available.
            </param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.TbcPadding.AddPadding(System.Byte[],System.Int32)">
            <summary> add the pad bytes to the passed in block, returning the
            number of bytes added.
            <p>
            Note: this assumes that the last block of plain text is always
            passed to it inside in. i.e. if inOff is zero, indicating the
            entire block is to be overwritten with padding the value of in
            should be the same as the last block of plain text.
            </p>
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.TbcPadding.PadCount(System.Byte[])">
            <summary> return the number of pad bytes present in the block.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Paddings.TbcPadding.PaddingName">
            <summary> Return the name of the algorithm the cipher implements.</summary>
            <returns> the name of the algorithm the cipher implements.
            </returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.X923Padding">
            A padder that adds X9.23 padding to a block - if a SecureRandom is
            passed in random padding is assumed, otherwise padding with zeros is used.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.X923Padding.Init(Org.BouncyCastle.Security.SecureRandom)">
             Initialise the padder.
            
             @param random a SecureRandom if one is available.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.X923Padding.AddPadding(System.Byte[],System.Int32)">
            add the pad bytes to the passed in block, returning the
            number of bytes added.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.X923Padding.PadCount(System.Byte[])">
            return the number of pad bytes present in the block.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Paddings.X923Padding.PaddingName">
             Return the name of the algorithm the cipher implements.
            
             @return the name of the algorithm the cipher implements.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.ZeroBytePadding">
            <summary> A padder that adds Null byte padding to a block.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.ZeroBytePadding.Init(Org.BouncyCastle.Security.SecureRandom)">
             <summary> Initialise the padder.
            
             </summary>
             <param name="random">- a SecureRandom if available.
             </param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.ZeroBytePadding.AddPadding(System.Byte[],System.Int32)">
            <summary> add the pad bytes to the passed in block, returning the
            number of bytes added.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.ZeroBytePadding.PadCount(System.Byte[])">
            <summary> return the number of pad bytes present in the block.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Paddings.ZeroBytePadding.PaddingName">
             <summary> Return the name of the algorithm the cipher implements.
            
             </summary>
             <returns> the name of the algorithm the cipher implements.
             </returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.AeadParameters.#ctor(Org.BouncyCastle.Crypto.Parameters.KeyParameter,System.Int32,System.Byte[])">
             Base constructor.
            
             @param key key to be used by underlying cipher
             @param macSize macSize in bits
             @param nonce nonce to be used
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.AeadParameters.#ctor(Org.BouncyCastle.Crypto.Parameters.KeyParameter,System.Int32,System.Byte[],System.Byte[])">
             Base constructor.
            
             @param key key to be used by underlying cipher
             @param macSize macSize in bits
             @param nonce nonce to be used
             @param associatedText associated text, if any
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.CcmParameters.#ctor(Org.BouncyCastle.Crypto.Parameters.KeyParameter,System.Int32,System.Byte[],System.Byte[])">
            Base constructor.
            
            @param key key to be used by underlying cipher
            @param macSize macSize in bits
            @param nonce nonce to be used
            @param associatedText associated text, if any
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.DesParameters.IsWeakKey(System.Byte[],System.Int32)">
            DES has 16 weak keys.  This method will check
            if the given DES key material is weak or semi-weak.
            Key material that is too short is regarded as weak.
            <p>
            See <a href="http://www.counterpane.com/applied.html">"Applied
            Cryptography"</a> by Bruce Schneier for more information.
            </p>
            @return true if the given DES key material is weak or semi-weak,
                false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.DesParameters.SetOddParity(System.Byte[])">
             DES Keys use the LSB as the odd parity bit.  This can
             be used to check for corrupt keys.
            
             @param bytes the byte array to set the parity on.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.DesEdeParameters.IsWeakKey(System.Byte[],System.Int32,System.Int32)">
             return true if the passed in key is a DES-EDE weak key.
            
             @param key bytes making up the key
             @param offset offset into the byte array the key starts at
             @param length number of bytes making up the key
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.DesEdeParameters.IsWeakKey(System.Byte[],System.Int32)">
             return true if the passed in key is a DES-EDE weak key.
            
             @param key bytes making up the key
             @param offset offset into the byte array the key starts at
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.DesEdeParameters.IsRealEdeKey(System.Byte[],System.Int32)">
             return true if the passed in key is a real 2/3 part DES-EDE key.
            
             @param key bytes making up the key
             @param offset offset into the byte array the key starts at
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.DesEdeParameters.IsReal2Key(System.Byte[],System.Int32)">
             return true if the passed in key is a real 2 part DES-EDE key.
            
             @param key bytes making up the key
             @param offset offset into the byte array the key starts at
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.DesEdeParameters.IsReal3Key(System.Byte[],System.Int32)">
             return true if the passed in key is a real 3 part DES-EDE key.
            
             @param key bytes making up the key
             @param offset offset into the byte array the key starts at
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.DHParameters.M">
            <summary>The minimum bitlength of the private value.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.DHParameters.L">
            <summary>The bitlength of the private value.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.DsaParameterGenerationParameters.#ctor(System.Int32,System.Int32,System.Int32,Org.BouncyCastle.Security.SecureRandom)">
             Construct without a usage index, this will do a random construction of G.
            
             @param L desired length of prime P in bits (the effective key size).
             @param N desired length of prime Q in bits.
             @param certainty certainty level for prime number generation.
             @param random the source of randomness to use.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.DsaParameterGenerationParameters.#ctor(System.Int32,System.Int32,System.Int32,Org.BouncyCastle.Security.SecureRandom,System.Int32)">
             Construct for a specific usage index - this has the effect of using verifiable canonical generation of G.
            
             @param L desired length of prime P in bits (the effective key size).
             @param N desired length of prime Q in bits.
             @param certainty certainty level for prime number generation.
             @param random the source of randomness to use.
             @param usageIndex a valid usage index.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.ElGamalParameters.G">
            return the generator - g
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.ElGamalParameters.L">
            return private value limit - l
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Parameters.HkdfParameters">
            Parameter class for the HkdfBytesGenerator class.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.HkdfParameters.#ctor(System.Byte[],System.Byte[],System.Byte[])">
             Generates parameters for HKDF, specifying both the optional salt and
             optional info. Step 1: Extract won't be skipped.
            
             @param ikm  the input keying material or seed
             @param salt the salt to use, may be null for a salt for hashLen zeros
             @param info the info to use, may be null for an info field of zero bytes
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.HkdfParameters.SkipExtractParameters(System.Byte[],System.Byte[])">
             Factory method that makes the HKDF skip the extract part of the key
             derivation function.
            
             @param ikm  the input keying material or seed, directly used for step 2:
                         Expand
             @param info the info to use, may be null for an info field of zero bytes
             @return HKDFParameters that makes the implementation skip step 1
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.HkdfParameters.GetIkm">
             Returns the input keying material or seed.
            
             @return the keying material
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.HkdfParameters.GetSalt">
             Returns the salt, or null if the salt should be generated as a byte array
             of HashLen zeros.
            
             @return the salt, or null
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.HkdfParameters.GetInfo">
             Returns the info field, which may be empty (null is converted to empty).
            
             @return the info field, never null
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.HkdfParameters.SkipExtract">
             Returns if step 1: extract has to be skipped or not
            
             @return true for skipping, false for no skipping of step 1
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Parameters.IesParameters">
            parameters for using an integrated cipher in stream mode.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.IesParameters.#ctor(System.Byte[],System.Byte[],System.Int32)">
            @param derivation the derivation parameter for the KDF function.
            @param encoding the encoding parameter for the KDF function.
            @param macKeySize the size of the MAC key (in bits).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.IesWithCipherParameters.#ctor(System.Byte[],System.Byte[],System.Int32,System.Int32)">
            @param derivation the derivation parameter for the KDF function.
            @param encoding the encoding parameter for the KDF function.
            @param macKeySize the size of the MAC key (in bits).
            @param cipherKeySize the size of the associated Cipher key (in bits).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Parameters.Iso18033KdfParameters">
            parameters for Key derivation functions for ISO-18033
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Parameters.KdfParameters">
            parameters for Key derivation functions for IEEE P1363a
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Parameters.MgfParameters">
            <remarks>Parameters for mask derivation functions.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyGenerationParameters">
             Parameters for NaccacheStern public private key generation. For details on
             this cipher, please see
            
             http://www.gemplus.com/smart/rd/publications/pdf/NS98pkcs.pdf
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyGenerationParameters.#ctor(Org.BouncyCastle.Security.SecureRandom,System.Int32,System.Int32,System.Int32)">
             Parameters for generating a NaccacheStern KeyPair.
            
             @param random
                        The source of randomness
             @param strength
                        The desired strength of the Key in Bits
             @param certainty
                        the probability that the generated primes are not really prime
                        as integer: 2^(-certainty) is then the probability
             @param countSmallPrimes
                        How many small key factors are desired
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyGenerationParameters.#ctor(Org.BouncyCastle.Security.SecureRandom,System.Int32,System.Int32,System.Int32,System.Boolean)">
            		 * Parameters for a NaccacheStern KeyPair.
            		 *
            		 * @param random
            		 *            The source of randomness
            		 * @param strength
            		 *            The desired strength of the Key in Bits
            		 * @param certainty
            		 *            the probability that the generated primes are not really prime
            		 *            as integer: 2^(-certainty) is then the probability
            		 * @param cntSmallPrimes
            		 *            How many small key factors are desired
            		 * @param debug
                     *            Ignored
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyGenerationParameters.Certainty">
            @return Returns the certainty.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyGenerationParameters.CountSmallPrimes">
            @return Returns the countSmallPrimes.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyParameters">
             Public key parameters for NaccacheStern cipher. For details on this cipher,
             please see
            
             http://www.gemplus.com/smart/rd/publications/pdf/NS98pkcs.pdf
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyParameters.#ctor(System.Boolean,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,System.Int32)">
            @param privateKey
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyParameters.G">
            @return Returns the g.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyParameters.LowerSigmaBound">
            @return Returns the lowerSigmaBound.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.NaccacheSternKeyParameters.Modulus">
            @return Returns the n.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Parameters.NaccacheSternPrivateKeyParameters">
             Private key parameters for NaccacheStern cipher. For details on this cipher,
             please see
            
             http://www.gemplus.com/smart/rd/publications/pdf/NS98pkcs.pdf
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.NaccacheSternPrivateKeyParameters.#ctor(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,System.Int32,System.Collections.IList,Org.BouncyCastle.Math.BigInteger)">
             Constructs a NaccacheSternPrivateKey
            
             @param g
                        the public enryption parameter g
             @param n
                        the public modulus n = p*q
             @param lowerSigmaBound
                        the public lower sigma bound up to which data can be encrypted
             @param smallPrimes
                        the small primes, of which sigma is constructed in the right
                        order
             @param phi_n
                        the private modulus phi(n) = (p-1)(q-1)
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Parameters.ParametersWithSalt">
            <summary> Cipher parameters with a fixed salt value associated with them.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Parameters.SkeinParameters">
            <summary>
            Parameters for the Skein hash function - a series of byte[] strings identified by integer tags.
            </summary>
            <remarks>
            Parameterised Skein can be used for:
            <ul> 
            <li>MAC generation, by providing a <see cref="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetKey(System.Byte[])">key</see>.</li>
            <li>Randomised hashing, by providing a <see cref="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetNonce(System.Byte[])">nonce</see>.</li>
            <li>A hash function for digital signatures, associating a
            <see cref="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetPublicKey(System.Byte[])">public key</see> with the message digest.</li>
            <li>A key derivation function, by providing a
            <see cref="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetKeyIdentifier(System.Byte[])">key identifier</see>.</li>
            <li>Personalised hashing, by providing a
            <see cref="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetPersonalisation(System.DateTime,System.String,System.String)">recommended format</see> or
            <see cref="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetPersonalisation(System.Byte[])">arbitrary</see> personalisation string.</li>
            </ul>
            </remarks>
            <seealso cref="T:Org.BouncyCastle.Crypto.Digests.SkeinEngine"/>
            <seealso cref="T:Org.BouncyCastle.Crypto.Digests.SkeinDigest"/>
            <seealso cref="T:Org.BouncyCastle.Crypto.Macs.SkeinMac"/>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_KEY">
            <summary>
            The parameter type for a secret key, supporting MAC or KDF functions: 0
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_CONFIG">
            <summary>
            The parameter type for the Skein configuration block: 4
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_PERSONALISATION">
            <summary>
            The parameter type for a personalisation string: 8
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_PUBLIC_KEY">
            <summary>
            The parameter type for a public key: 12
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_KEY_IDENTIFIER">
            <summary>
            The parameter type for a key identifier string: 16
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_NONCE">
            <summary>
            The parameter type for a nonce: 20
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_MESSAGE">
            <summary>
            The parameter type for the message: 48
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_OUTPUT">
            <summary>
            The parameter type for the output transformation: 63
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.GetParameters">
            <summary>
            Obtains a map of type (int) to value (byte[]) for the parameters tracked in this object.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.GetKey">
            <summary>
            Obtains the value of the <see cref="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_KEY">key parameter</see>, or <code>null</code> if not
            set.
            </summary>
            <returns>The key.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.GetPersonalisation">
            <summary>
            Obtains the value of the <see cref="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_PERSONALISATION">personalisation parameter</see>, or
            <code>null</code> if not set.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.GetPublicKey">
            <summary>
            Obtains the value of the <see cref="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_PUBLIC_KEY">public key parameter</see>, or
            <code>null</code> if not set.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.GetKeyIdentifier">
            <summary>
            Obtains the value of the <see cref="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_KEY_IDENTIFIER">key identifier parameter</see>, or
            <code>null</code> if not set.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.GetNonce">
            <summary>
            Obtains the value of the <see cref="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_NONCE">nonce parameter</see>, or <code>null</code> if
            not set.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder">
            <summary>
            A builder for <see cref="T:Org.BouncyCastle.Crypto.Parameters.SkeinParameters"/>.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.Set(System.Int32,System.Byte[])">
            <summary>
            Sets a parameters to apply to the Skein hash function.
            </summary>
            <remarks>
            Parameter types must be in the range 0,5..62, and cannot use the value 48
            (reserved for message body).
            <p/>
            Parameters with type &lt; 48 are processed before
            the message content, parameters with type &gt; 48
            are processed after the message and prior to output.
            </remarks>
            <param name="type">the type of the parameter, in the range 5..62.</param>
            <param name="value">the byte sequence of the parameter.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetKey(System.Byte[])">
            <summary>
            Sets the <see cref="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_KEY"/> parameter.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetPersonalisation(System.Byte[])">
            <summary>
            Sets the <see cref="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_PERSONALISATION"/> parameter.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetPersonalisation(System.DateTime,System.String,System.String)">
            <summary>
            Implements the recommended personalisation format for Skein defined in Section 4.11 of
            the Skein 1.3 specification.
            </summary>
            <remarks>
            The format is <code>YYYYMMDD email@address distinguisher</code>, encoded to a byte
            sequence using UTF-8 encoding.
            </remarks>
            <param name="date">the date the personalised application of the Skein was defined.</param>
            <param name="emailAddress">the email address of the creation of the personalised application.</param>
            <param name="distinguisher">an arbitrary personalisation string distinguishing the application.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetPublicKey(System.Byte[])">
            <summary>
            Sets the <see cref="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_KEY_IDENTIFIER"/> parameter.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetKeyIdentifier(System.Byte[])">
            <summary>
            Sets the <see cref="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_KEY_IDENTIFIER"/> parameter.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.SetNonce(System.Byte[])">
            <summary>
            Sets the <see cref="F:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.PARAM_TYPE_NONCE"/> parameter.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.SkeinParameters.Builder.Build">
            <summary>
            Constructs a new <see cref="T:Org.BouncyCastle.Crypto.Parameters.SkeinParameters"/> instance with the parameters provided to this
            builder.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Parameters.TweakableBlockCipherParameters">
            <summary>
            Parameters for tweakable block ciphers.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.TweakableBlockCipherParameters.Key">
            <summary>
            Gets the key.
            </summary>
            <value>the key to use, or <code>null</code> to use the current key.</value>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.TweakableBlockCipherParameters.Tweak">
            <summary>
            Gets the tweak value.
            </summary>
            <value>The tweak to use, or <code>null</code> to use the current tweak.</value>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Prng.BasicEntropySourceProvider">
            An EntropySourceProvider where entropy generation is based on a SecureRandom output using SecureRandom.generateSeed().
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.BasicEntropySourceProvider.#ctor(Org.BouncyCastle.Security.SecureRandom,System.Boolean)">
             Create a entropy source provider based on the passed in SecureRandom.
            
             @param secureRandom the SecureRandom to base EntropySource construction on.
             @param isPredictionResistant boolean indicating if the SecureRandom is based on prediction resistant entropy or not (true if it is).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.BasicEntropySourceProvider.Get(System.Int32)">
             Return an entropy source that will create bitsRequired bits of entropy on
             each invocation of getEntropy().
            
             @param bitsRequired size (in bits) of entropy to be created by the provided source.
             @return an EntropySource that generates bitsRequired bits of entropy on each call to its getEntropy() method.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Prng.CryptoApiRandomGenerator">
            <summary>
            Uses Microsoft's RNGCryptoServiceProvider
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Prng.IRandomGenerator">
            <remarks>Generic interface for objects generating random bytes.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.IRandomGenerator.AddSeedMaterial(System.Byte[])">
            <summary>Add more seed material to the generator.</summary>
            <param name="seed">A byte array to be mixed into the generator's state.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.IRandomGenerator.AddSeedMaterial(System.Int64)">
            <summary>Add more seed material to the generator.</summary>
            <param name="seed">A long value to be mixed into the generator's state.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.IRandomGenerator.NextBytes(System.Byte[])">
            <summary>Fill byte array with random values.</summary>
            <param name="bytes">Array to be filled.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.IRandomGenerator.NextBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>Fill byte array with random values.</summary>
            <param name="bytes">Array to receive bytes.</param>
            <param name="start">Index to start filling at.</param>
            <param name="len">Length of segment to fill.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Prng.DigestRandomGenerator">
            Random generation based on the digest with counter. Calling AddSeedMaterial will
            always increase the entropy of the hash.
            <p>
            Internal access to the digest is synchronized so a single one of these can be shared.
            </p>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Prng.Drbg.CtrSP800Drbg">
            A SP800-90A CTR DRBG.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Prng.Drbg.ISP80090Drbg">
            Interface to SP800-90A deterministic random bit generators.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.Drbg.ISP80090Drbg.Generate(System.Byte[],System.Byte[],System.Boolean)">
             Populate a passed in array with random data.
            
             @param output output array for generated bits.
             @param additionalInput additional input to be added to the DRBG in this step.
             @param predictionResistant true if a reseed should be forced, false otherwise.
            
             @return number of bits generated, -1 if a reseed required.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.Drbg.ISP80090Drbg.Reseed(System.Byte[])">
             Reseed the DRBG.
            
             @param additionalInput additional input to be added to the DRBG in this step.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Prng.Drbg.ISP80090Drbg.BlockSize">
             Return the block size of the DRBG.
            
             @return the block size (in bits) produced by each round of the DRBG.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.Drbg.CtrSP800Drbg.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32,System.Int32,Org.BouncyCastle.Crypto.IEntropySource,System.Byte[],System.Byte[])">
            Construct a SP800-90A CTR DRBG.
            <p>
            Minimum entropy requirement is the security strength requested.
            </p>
            @param engine underlying block cipher to use to support DRBG
            @param keySizeInBits size of the key to use with the block cipher.
            @param securityStrength security strength required (in bits)
            @param entropySource source of entropy to use for seeding/reseeding.
            @param personalizationString personalization string to distinguish this DRBG (may be null).
            @param nonce nonce to further distinguish this DRBG (may be null).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.Drbg.CtrSP800Drbg.Generate(System.Byte[],System.Byte[],System.Boolean)">
             Populate a passed in array with random data.
            
             @param output output array for generated bits.
             @param additionalInput additional input to be added to the DRBG in this step.
             @param predictionResistant true if a reseed should be forced, false otherwise.
            
             @return number of bits generated, -1 if a reseed required.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.Drbg.CtrSP800Drbg.Reseed(System.Byte[])">
             Reseed the DRBG.
            
             @param additionalInput additional input to be added to the DRBG in this step.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.Drbg.CtrSP800Drbg.PadKey(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Pad out a key for TDEA, setting odd parity for each byte.
            
             @param keyMaster
             @param keyOff
             @param tmp
             @param tmpOff
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Prng.Drbg.CtrSP800Drbg.BlockSize">
             Return the block size (in bits) of the DRBG.
            
             @return the number of bits produced on each internal round of the DRBG.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.Drbg.DrbgUtilities.HashDF(Org.BouncyCastle.Crypto.IDigest,System.Byte[],System.Int32)">
            Used by both Dual EC and Hash.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Prng.Drbg.HashSP800Drbg">
            A SP800-90A Hash DRBG.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.Drbg.HashSP800Drbg.#ctor(Org.BouncyCastle.Crypto.IDigest,System.Int32,Org.BouncyCastle.Crypto.IEntropySource,System.Byte[],System.Byte[])">
            Construct a SP800-90A Hash DRBG.
            <p>
            Minimum entropy requirement is the security strength requested.
            </p>
            @param digest  source digest to use for DRB stream.
            @param securityStrength security strength required (in bits)
            @param entropySource source of entropy to use for seeding/reseeding.
            @param personalizationString personalization string to distinguish this DRBG (may be null).
            @param nonce nonce to further distinguish this DRBG (may be null).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.Drbg.HashSP800Drbg.Generate(System.Byte[],System.Byte[],System.Boolean)">
             Populate a passed in array with random data.
            
             @param output output array for generated bits.
             @param additionalInput additional input to be added to the DRBG in this step.
             @param predictionResistant true if a reseed should be forced, false otherwise.
            
             @return number of bits generated, -1 if a reseed required.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.Drbg.HashSP800Drbg.Reseed(System.Byte[])">
             Reseed the DRBG.
            
             @param additionalInput additional input to be added to the DRBG in this step.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Prng.Drbg.HashSP800Drbg.BlockSize">
             Return the block size (in bits) of the DRBG.
            
             @return the number of bits produced on each internal round of the DRBG.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Prng.Drbg.HMacSP800Drbg">
            A SP800-90A HMAC DRBG.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.Drbg.HMacSP800Drbg.#ctor(Org.BouncyCastle.Crypto.IMac,System.Int32,Org.BouncyCastle.Crypto.IEntropySource,System.Byte[],System.Byte[])">
            Construct a SP800-90A Hash DRBG.
            <p>
            Minimum entropy requirement is the security strength requested.
            </p>
            @param hMac Hash MAC to base the DRBG on.
            @param securityStrength security strength required (in bits)
            @param entropySource source of entropy to use for seeding/reseeding.
            @param personalizationString personalization string to distinguish this DRBG (may be null).
            @param nonce nonce to further distinguish this DRBG (may be null).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.Drbg.HMacSP800Drbg.Generate(System.Byte[],System.Byte[],System.Boolean)">
             Populate a passed in array with random data.
            
             @param output output array for generated bits.
             @param additionalInput additional input to be added to the DRBG in this step.
             @param predictionResistant true if a reseed should be forced, false otherwise.
            
             @return number of bits generated, -1 if a reseed required.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.Drbg.HMacSP800Drbg.Reseed(System.Byte[])">
             Reseed the DRBG.
            
             @param additionalInput additional input to be added to the DRBG in this step.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Prng.Drbg.HMacSP800Drbg.BlockSize">
             Return the block size (in bits) of the DRBG.
            
             @return the number of bits produced on each round of the DRBG.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.EntropyUtilities.GenerateSeed(Org.BouncyCastle.Crypto.IEntropySource,System.Int32)">
             Generate numBytes worth of entropy from the passed in entropy source.
            
             @param entropySource the entropy source to request the data from.
             @param numBytes the number of bytes of entropy requested.
             @return a byte array populated with the random data.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Prng.ReversedWindowGenerator">
            <remarks>
            Takes bytes generated by an underling RandomGenerator and reverses the order in
            each small window (of configurable size).
            <p>
            Access to internals is synchronized so a single one of these can be shared.
            </p>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.ReversedWindowGenerator.AddSeedMaterial(System.Byte[])">
            <summary>Add more seed material to the generator.</summary>
            <param name="seed">A byte array to be mixed into the generator's state.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.ReversedWindowGenerator.AddSeedMaterial(System.Int64)">
            <summary>Add more seed material to the generator.</summary>
            <param name="seed">A long value to be mixed into the generator's state.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.ReversedWindowGenerator.NextBytes(System.Byte[])">
            <summary>Fill byte array with random values.</summary>
            <param name="bytes">Array to be filled.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.ReversedWindowGenerator.NextBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>Fill byte array with random values.</summary>
            <param name="bytes">Array to receive bytes.</param>
            <param name="start">Index to start filling at.</param>
            <param name="len">Length of segment to fill.</param>
        </member>
        <member name="M:Org.BouncyCastle.Security.SecureRandom.GetInstance(System.String)">
            <summary>
            Create and auto-seed an instance based on the given algorithm.
            </summary>
            <remarks>Equivalent to GetInstance(algorithm, true)</remarks>
            <param name="algorithm">e.g. "SHA256PRNG"</param>
        </member>
        <member name="M:Org.BouncyCastle.Security.SecureRandom.GetInstance(System.String,System.Boolean)">
            <summary>
            Create an instance based on the given algorithm, with optional auto-seeding
            </summary>
            <param name="algorithm">e.g. "SHA256PRNG"</param>
            <param name="autoSeed">If true, the instance will be auto-seeded.</param>
        </member>
        <member name="M:Org.BouncyCastle.Security.SecureRandom.#ctor(System.Byte[])">
            <remarks>
            To replicate existing predictable output, replace with GetInstance("SHA1PRNG", false), followed by SetSeed(seed)
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Security.SecureRandom.#ctor(Org.BouncyCastle.Crypto.Prng.IRandomGenerator)">
            <summary>Use the specified instance of IRandomGenerator as random source.</summary>
            <remarks>
            This constructor performs no seeding of either the <c>IRandomGenerator</c> or the
            constructed <c>SecureRandom</c>. It is the responsibility of the client to provide
            proper seed material as necessary/appropriate for the given <c>IRandomGenerator</c>
            implementation.
            </remarks>
            <param name="generator">The source to generate all random bytes from.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Prng.SP800SecureRandomBuilder">
            Builder class for making SecureRandom objects based on SP 800-90A Deterministic Random Bit Generators (DRBG).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.SP800SecureRandomBuilder.#ctor">
            Basic constructor, creates a builder using an EntropySourceProvider based on the default SecureRandom with
            predictionResistant set to false.
            <p>
            Any SecureRandom created from a builder constructed like this will make use of input passed to SecureRandom.setSeed() if
            the default SecureRandom does for its generateSeed() call.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.SP800SecureRandomBuilder.#ctor(Org.BouncyCastle.Security.SecureRandom,System.Boolean)">
            Construct a builder with an EntropySourceProvider based on the passed in SecureRandom and the passed in value
            for prediction resistance.
            <p>
            Any SecureRandom created from a builder constructed like this will make use of input passed to SecureRandom.setSeed() if
            the passed in SecureRandom does for its generateSeed() call.
            </p>
            @param entropySource
            @param predictionResistant
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.SP800SecureRandomBuilder.#ctor(Org.BouncyCastle.Crypto.IEntropySourceProvider)">
            Create a builder which makes creates the SecureRandom objects from a specified entropy source provider.
            <p>
            <b>Note:</b> If this constructor is used any calls to setSeed() in the resulting SecureRandom will be ignored.
            </p>
            @param entropySourceProvider a provider of EntropySource objects.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.SP800SecureRandomBuilder.SetPersonalizationString(System.Byte[])">
            Set the personalization string for DRBG SecureRandoms created by this builder
            @param personalizationString  the personalisation string for the underlying DRBG.
            @return the current builder.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.SP800SecureRandomBuilder.SetSecurityStrength(System.Int32)">
             Set the security strength required for DRBGs used in building SecureRandom objects.
            
             @param securityStrength the security strength (in bits)
             @return the current builder.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.SP800SecureRandomBuilder.SetEntropyBitsRequired(System.Int32)">
             Set the amount of entropy bits required for seeding and reseeding DRBGs used in building SecureRandom objects.
            
             @param entropyBitsRequired the number of bits of entropy to be requested from the entropy source on each seed/reseed.
             @return the current builder.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.SP800SecureRandomBuilder.BuildHash(Org.BouncyCastle.Crypto.IDigest,System.Byte[],System.Boolean)">
             Build a SecureRandom based on a SP 800-90A Hash DRBG.
            
             @param digest digest algorithm to use in the DRBG underneath the SecureRandom.
             @param nonce  nonce value to use in DRBG construction.
             @param predictionResistant specify whether the underlying DRBG in the resulting SecureRandom should reseed on each request for bytes.
             @return a SecureRandom supported by a Hash DRBG.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.SP800SecureRandomBuilder.BuildCtr(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32,System.Byte[],System.Boolean)">
             Build a SecureRandom based on a SP 800-90A CTR DRBG.
            
             @param cipher the block cipher to base the DRBG on.
             @param keySizeInBits key size in bits to be used with the block cipher.
             @param nonce nonce value to use in DRBG construction.
             @param predictionResistant  specify whether the underlying DRBG in the resulting SecureRandom should reseed on each request for bytes.
             @return  a SecureRandom supported by a CTR DRBG.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.SP800SecureRandomBuilder.BuildHMac(Org.BouncyCastle.Crypto.IMac,System.Byte[],System.Boolean)">
             Build a SecureRandom based on a SP 800-90A HMAC DRBG.
            
             @param hMac HMAC algorithm to use in the DRBG underneath the SecureRandom.
             @param nonce  nonce value to use in DRBG construction.
             @param predictionResistant specify whether the underlying DRBG in the resulting SecureRandom should reseed on each request for bytes.
             @return a SecureRandom supported by a HMAC DRBG.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Prng.ThreadedSeedGenerator">
            A thread based seed generator - one source of randomness.
            <p>
            Based on an idea from Marcus Lippert.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.ThreadedSeedGenerator.GenerateSeed(System.Int32,System.Boolean)">
            Generate seed bytes. Set fast to false for best quality.
            <p>
            If fast is set to true, the code should be round about 8 times faster when
            generating a long sequence of random bytes. 20 bytes of random values using
            the fast mode take less than half a second on a Nokia e70. If fast is set to false,
            it takes round about 2500 ms.
            </p>
            @param numBytes the number of bytes to generate
            @param fast true if fast mode should be used
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Prng.VmpcRandomGenerator.P">
            <remarks>
            Permutation generated by code:
            <code>
            // First 1850 fractional digit of Pi number. 
            byte[] key = new BigInteger("14159265358979323846...5068006422512520511").ToByteArray();
            s = 0;
            P = new byte[256];
            for (int i = 0; i &lt; 256; i++) 
            {
                P[i] = (byte) i;
            }
            for (int m = 0; m &lt; 768; m++) 
            {
                s = P[(s + P[m &amp; 0xff] + key[m % key.length]) &amp; 0xff];
                byte temp = P[m &amp; 0xff];
                P[m &amp; 0xff] = P[s &amp; 0xff];
                P[s &amp; 0xff] = temp;
            } </code>
            </remarks>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Prng.VmpcRandomGenerator.s">
            <remarks>Value generated in the same way as <c>P</c>.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.X931Rng.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Byte[],Org.BouncyCastle.Crypto.IEntropySource)">
            
             @param engine
             @param entropySource
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.X931Rng.Generate(System.Byte[],System.Boolean)">
             Populate a passed in array with random data.
            
             @param output output array for generated bits.
             @param predictionResistant true if a reseed should be forced, false otherwise.
            
             @return number of bits generated, -1 if a reseed required.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.X931Rng.Reseed">
            Reseed the RNG.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.X931SecureRandomBuilder.#ctor">
            Basic constructor, creates a builder using an EntropySourceProvider based on the default SecureRandom with
            predictionResistant set to false.
            <p>
            Any SecureRandom created from a builder constructed like this will make use of input passed to SecureRandom.setSeed() if
            the default SecureRandom does for its generateSeed() call.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.X931SecureRandomBuilder.#ctor(Org.BouncyCastle.Security.SecureRandom,System.Boolean)">
            Construct a builder with an EntropySourceProvider based on the passed in SecureRandom and the passed in value
            for prediction resistance.
            <p>
            Any SecureRandom created from a builder constructed like this will make use of input passed to SecureRandom.setSeed() if
            the passed in SecureRandom does for its generateSeed() call.
            </p>
            @param entropySource
            @param predictionResistant
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.X931SecureRandomBuilder.#ctor(Org.BouncyCastle.Crypto.IEntropySourceProvider)">
            Create a builder which makes creates the SecureRandom objects from a specified entropy source provider.
            <p>
            <b>Note:</b> If this constructor is used any calls to setSeed() in the resulting SecureRandom will be ignored.
            </p>
            @param entropySourceProvider a provider of EntropySource objects.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.X931SecureRandomBuilder.Build(Org.BouncyCastle.Crypto.IBlockCipher,Org.BouncyCastle.Crypto.Parameters.KeyParameter,System.Boolean)">
             Construct a X9.31 secure random generator using the passed in engine and key. If predictionResistant is true the
             generator will be reseeded on each request.
            
             @param engine a block cipher to use as the operator.
             @param key the block cipher key to initialise engine with.
             @param predictionResistant true if engine to be reseeded on each use, false otherwise.
             @return a SecureRandom.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.DsaDigestSigner.Update(System.Byte)">
            update the internal digest with the byte b
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.DsaDigestSigner.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            update the internal digest with the byte array in
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.DsaDigestSigner.GenerateSignature">
            Generate a signature for the message we've been loaded with using
            the key we were initialised with.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.DsaDigestSigner.VerifySignature(System.Byte[])">
            <returns>true if the internal state represents the signature described in the passed in array.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.DsaDigestSigner.Reset">
            <summary>Reset the internal state</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.DsaSigner">
            The Digital Signature Algorithm - as described in "Handbook of Applied
            Cryptography", pages 452 - 453.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.DsaSigner.#ctor">
            Default configuration, random K values.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.DsaSigner.#ctor(Org.BouncyCastle.Crypto.Signers.IDsaKCalculator)">
             Configuration with an alternate, possibly deterministic calculator of K.
            
             @param kCalculator a K value calculator.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.DsaSigner.GenerateSignature(System.Byte[])">
             Generate a signature for the given message using the key we were
             initialised with. For conventional DSA the message should be a SHA-1
             hash of the message of interest.
            
             @param message the message that will be verified later.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.DsaSigner.VerifySignature(System.Byte[],Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            return true if the value r and s represent a DSA signature for
            the passed in message for standard DSA the message should be a
            SHA-1 hash of the real message to be verified.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.ECDsaSigner">
            EC-DSA as described in X9.62
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.ECDsaSigner.#ctor">
            Default configuration, random K values.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.ECDsaSigner.#ctor(Org.BouncyCastle.Crypto.Signers.IDsaKCalculator)">
             Configuration with an alternate, possibly deterministic calculator of K.
            
             @param kCalculator a K value calculator.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.ECDsaSigner.GenerateSignature(System.Byte[])">
             Generate a signature for the given message using the key we were
             initialised with. For conventional DSA the message should be a SHA-1
             hash of the message of interest.
            
             @param message the message that will be verified later.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.ECDsaSigner.VerifySignature(System.Byte[],Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            return true if the value r and s represent a DSA signature for
            the passed in message (for standard DSA the message should be
            a SHA-1 hash of the real message to be verified).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.ECGost3410Signer">
            GOST R 34.10-2001 Signature Algorithm
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.ECGost3410Signer.GenerateSignature(System.Byte[])">
             generate a signature for the given message using the key we were
             initialised with. For conventional GOST3410 the message should be a GOST3411
             hash of the message of interest.
            
             @param message the message that will be verified later.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.ECGost3410Signer.VerifySignature(System.Byte[],Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            return true if the value r and s represent a GOST3410 signature for
            the passed in message (for standard GOST3410 the message should be
            a GOST3411 hash of the real message to be verified).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.ECNRSigner">
            EC-NR as described in IEEE 1363-2000
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.ECNRSigner.GenerateSignature(System.Byte[])">
             generate a signature for the given message using the key we were
             initialised with.  Generally, the order of the curve should be at
             least as long as the hash of the message of interest, and with
             ECNR it *must* be at least as long.
            
             @param digest  the digest to be signed.
             @exception DataLengthException if the digest is longer than the key allows
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.ECNRSigner.VerifySignature(System.Byte[],Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
             return true if the value r and s represent a signature for the
             message passed in. Generally, the order of the curve should be at
             least as long as the hash of the message of interest, and with
             ECNR, it *must* be at least as long.  But just in case the signer
             applied mod(n) to the longer digest, this implementation will
             apply mod(n) during verification.
            
             @param digest  the digest to be verified.
             @param r       the r value of the signature.
             @param s       the s value of the signature.
             @exception DataLengthException if the digest is longer than the key allows
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.GenericSigner.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the signer for signing or verification.
            
             @param forSigning
                        true if for signing, false otherwise
             @param parameters
                        necessary parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.GenericSigner.Update(System.Byte)">
            update the internal digest with the byte b
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.GenericSigner.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            update the internal digest with the byte array in
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.GenericSigner.GenerateSignature">
            Generate a signature for the message we've been loaded with using the key
            we were initialised with.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.GenericSigner.VerifySignature(System.Byte[])">
            return true if the internal state represents the signature described in
            the passed in array.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Gost3410DigestSigner.Update(System.Byte)">
            update the internal digest with the byte b
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Gost3410DigestSigner.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            update the internal digest with the byte array in
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Gost3410DigestSigner.GenerateSignature">
            Generate a signature for the message we've been loaded with using
            the key we were initialised with.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Gost3410DigestSigner.VerifySignature(System.Byte[])">
            <returns>true if the internal state represents the signature described in the passed in array.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Gost3410DigestSigner.Reset">
            <summary>Reset the internal state</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.Gost3410Signer">
            Gost R 34.10-94 Signature Algorithm
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Gost3410Signer.GenerateSignature(System.Byte[])">
             generate a signature for the given message using the key we were
             initialised with. For conventional Gost3410 the message should be a Gost3411
             hash of the message of interest.
            
             @param message the message that will be verified later.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Gost3410Signer.VerifySignature(System.Byte[],Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            return true if the value r and s represent a Gost3410 signature for
            the passed in message for standard Gost3410 the message should be a
            Gost3411 hash of the real message to be verified.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.HMacDsaKCalculator">
            A deterministic K calculator based on the algorithm in section 3.2 of RFC 6979.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.IDsaKCalculator">
            Interface define calculators of K values for DSA/ECDSA.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.IDsaKCalculator.Init(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Security.SecureRandom)">
             Non-deterministic initialiser.
            
             @param n the order of the DSA group.
             @param random a source of randomness.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.IDsaKCalculator.Init(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,System.Byte[])">
             Deterministic initialiser.
            
             @param n the order of the DSA group.
             @param d the DSA private value.
             @param message the message being signed.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.IDsaKCalculator.NextK">
             Return the next valid value of K.
            
             @return a K value.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Signers.IDsaKCalculator.IsDeterministic">
             Return true if this calculator is deterministic, false otherwise.
            
             @return true if deterministic, otherwise false.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.HMacDsaKCalculator.#ctor(Org.BouncyCastle.Crypto.IDigest)">
             Base constructor.
            
             @param digest digest to build the HMAC on.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner">
            <summary> ISO9796-2 - mechanism using a hash function with recovery (scheme 2 and 3).
            <p>
            Note: the usual length for the salt is the length of the hash
            function used in bytes.</p>
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.GetRecoveredMessage">
            <summary>
            Return a reference to the recoveredMessage message.
            </summary>
            <returns>The full/partial recoveredMessage message.</returns>
            <seealso cref="M:Org.BouncyCastle.Crypto.ISignerWithRecovery.GetRecoveredMessage"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,Org.BouncyCastle.Crypto.IDigest,System.Int32,System.Boolean)">
            <summary>
            Generate a signer with either implicit or explicit trailers for ISO9796-2, scheme 2 or 3.
            </summary>
            <param name="cipher">base cipher to use for signature creation/verification</param>
            <param name="digest">digest to use.</param>
            <param name="saltLength">length of salt in bytes.</param>
            <param name="isImplicit">whether or not the trailer is implicit or gives the hash.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,Org.BouncyCastle.Crypto.IDigest,System.Int32)">
             <summary> Constructor for a signer with an explicit digest trailer.
            
             </summary>
             <param name="cipher">cipher to use.
             </param>
             <param name="digest">digest to sign with.
             </param>
             <param name="saltLength">length of salt in bytes.
             </param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the signer.</summary>
            <param name="forSigning">true if for signing, false if for verification.</param>
            <param name="parameters">parameters for signature generation/verification. If the
            parameters are for generation they should be a ParametersWithRandom,
            a ParametersWithSalt, or just an RsaKeyParameters object. If RsaKeyParameters
            are passed in a SecureRandom will be created.
            </param>
            <exception cref="T:System.ArgumentException">if wrong parameter type or a fixed
            salt is passed in which is the wrong length.
            </exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.IsSameAs(System.Byte[],System.Byte[])">
            <summary> compare two byte arrays - constant time.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.ClearBlock(System.Byte[])">
            <summary> clear possible sensitive data</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.Update(System.Byte)">
            <summary> update the internal digest with the byte b</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary> update the internal digest with the byte array in</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.Reset">
            <summary> reset the internal state</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.GenerateSignature">
            <summary> Generate a signature for the loaded message using the key we were
            initialised with.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.VerifySignature(System.Byte[])">
            <summary> return true if the signature represents a ISO9796-2 signature
            for the passed in message.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.HasFullMessage">
            <summary>
            Return true if the full message was recoveredMessage.
            </summary>
            <returns>true on full message recovery, false otherwise, or if not sure.</returns>
            <seealso cref="M:Org.BouncyCastle.Crypto.ISignerWithRecovery.HasFullMessage"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.ItoOSP(System.Int32,System.Byte[])">
            <summary> int to octet string.</summary>
            <summary> int to octet string.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.LtoOSP(System.Int64,System.Byte[])">
            <summary> long to octet string.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2PssSigner.MaskGeneratorFunction1(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary> mask generator function, as described in Pkcs1v2.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer">
            <summary> ISO9796-2 - mechanism using a hash function with recovery (scheme 1)</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.GetRecoveredMessage">
            <summary>
            Return a reference to the recoveredMessage message.
            </summary>
            <returns>The full/partial recoveredMessage message.</returns>
            <seealso cref="M:Org.BouncyCastle.Crypto.ISignerWithRecovery.GetRecoveredMessage"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,Org.BouncyCastle.Crypto.IDigest,System.Boolean)">
            <summary>
            Generate a signer with either implicit or explicit trailers for ISO9796-2.
            </summary>
            <param name="cipher">base cipher to use for signature creation/verification</param>
            <param name="digest">digest to use.</param>
            <param name="isImplicit">whether or not the trailer is implicit or gives the hash.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,Org.BouncyCastle.Crypto.IDigest)">
             <summary> Constructor for a signer with an explicit digest trailer.
            
             </summary>
             <param name="cipher">cipher to use.
             </param>
             <param name="digest">digest to sign with.
             </param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.IsSameAs(System.Byte[],System.Byte[])">
            <summary> compare two byte arrays - constant time.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.ClearBlock(System.Byte[])">
            <summary> clear possible sensitive data</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.Update(System.Byte)">
            <summary> update the internal digest with the byte b</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary> update the internal digest with the byte array in</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.Reset">
            <summary> reset the internal state</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.GenerateSignature">
            <summary> Generate a signature for the loaded message using the key we were
            initialised with.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.VerifySignature(System.Byte[])">
            <summary> return true if the signature represents a ISO9796-2 signature
            for the passed in message.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.HasFullMessage">
            <summary>
            Return true if the full message was recoveredMessage.
            </summary>
            <returns> true on full message recovery, false otherwise.</returns>
            <seealso cref="M:Org.BouncyCastle.Crypto.ISignerWithRecovery.HasFullMessage"/>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.PssSigner">
            <summary> RSA-PSS as described in Pkcs# 1 v 2.1.
            <p>
            Note: the usual value for the salt length is the number of
            bytes in the hash function.</p>
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.PssSigner.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,Org.BouncyCastle.Crypto.IDigest,System.Int32)">
            <summary>Basic constructor</summary>
            <param name="cipher">the asymmetric cipher to use.</param>
            <param name="digest">the digest to use.</param>
            <param name="saltLen">the length of the salt to use (in bytes).</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.PssSigner.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,Org.BouncyCastle.Crypto.IDigest,System.Byte[])">
            <summary>Basic constructor</summary>
            <param name="cipher">the asymmetric cipher to use.</param>
            <param name="digest">the digest to use.</param>
            <param name="salt">the fixed salt to be used.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.PssSigner.ClearBlock(System.Byte[])">
            <summary> clear possible sensitive data</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.PssSigner.Update(System.Byte)">
            <summary> update the internal digest with the byte b</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.PssSigner.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary> update the internal digest with the byte array in</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.PssSigner.Reset">
            <summary> reset the internal state</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.PssSigner.GenerateSignature">
            <summary> Generate a signature for the message we've been loaded with using
            the key we were initialised with.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.PssSigner.VerifySignature(System.Byte[])">
            <summary> return true if the internal state represents the signature described
            in the passed in array.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.PssSigner.ItoOSP(System.Int32,System.Byte[])">
            <summary> int to octet string.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.PssSigner.MaskGeneratorFunction1(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary> mask generator function, as described in Pkcs1v2.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.RsaDigestSigner.#cctor">
            <summary>
            Load oid table.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.RsaDigestSigner.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the signer for signing or verification.
            
             @param forSigning true if for signing, false otherwise
             @param param necessary parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.RsaDigestSigner.Update(System.Byte)">
            update the internal digest with the byte b
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.RsaDigestSigner.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            update the internal digest with the byte array in
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.RsaDigestSigner.GenerateSignature">
            Generate a signature for the message we've been loaded with using
            the key we were initialised with.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.RsaDigestSigner.VerifySignature(System.Byte[])">
            return true if the internal state represents the signature described
            in the passed in array.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.X931Signer">
            X9.31-1998 - signing using a hash.
            <p>
            The message digest hash, H, is encapsulated to form a byte string as follows
            </p>
            <pre>
            EB = 06 || PS || 0xBA || H || TRAILER
            </pre>
            where PS is a string of bytes all of value 0xBB of length such that |EB|=|n|, and TRAILER is the ISO/IEC 10118 part numberâ€  for the digest. The byte string, EB, is converted to an integer value, the message representative, f.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.X931Signer.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,Org.BouncyCastle.Crypto.IDigest,System.Boolean)">
             Generate a signer with either implicit or explicit trailers for X9.31.
            
             @param cipher base cipher to use for signature creation/verification
             @param digest digest to use.
             @param implicit whether or not the trailer is implicit or gives the hash.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.X931Signer.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,Org.BouncyCastle.Crypto.IDigest)">
             Constructor for a signer with an explicit digest trailer.
            
             @param cipher cipher to use.
             @param digest digest to sign with.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.X931Signer.ClearBlock(System.Byte[])">
            <summary> clear possible sensitive data</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.X931Signer.Update(System.Byte)">
            update the internal digest with the byte b
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.X931Signer.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            update the internal digest with the byte array in
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.X931Signer.Reset">
            reset the internal state
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.X931Signer.GenerateSignature">
            generate a signature for the loaded message using the key we were
            initialised with.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.X931Signer.VerifySignature(System.Byte[])">
            return true if the signature represents a ISO9796-2 signature
            for the passed in message.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.StreamBlockCipher">
            a wrapper for block ciphers with a single byte block size, so that they
            can be treated like stream ciphers.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.StreamBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             basic constructor.
            
             @param cipher the block cipher to be wrapped.
             @exception ArgumentException if the cipher has a block size other than
             one.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.StreamBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the underlying cipher.
            
             @param forEncryption true if we are setting up for encryption, false otherwise.
             @param param the necessary parameters for the underlying cipher to be initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.StreamBlockCipher.ReturnByte(System.Byte)">
             encrypt/decrypt a single byte returning the result.
            
             @param in the byte to be processed.
             @return the result of processing the input byte.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.StreamBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process a block of bytes from in putting the result into out.
            
             @param in the input byte array.
             @param inOff the offset into the in array where the data to be processed starts.
             @param len the number of bytes to be processed.
             @param out the output buffer the processed bytes go into.
             @param outOff the offset into the output byte array the processed data stars at.
             @exception DataLengthException if the output buffer is too small.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.StreamBlockCipher.Reset">
            reset the underlying cipher. This leaves it in the same state
            it was at after the last init (if there was one).
        </member>
        <member name="P:Org.BouncyCastle.Crypto.StreamBlockCipher.AlgorithmName">
             return the name of the algorithm we are wrapping.
            
             @return the name of the algorithm we are wrapping.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsAgreementCredentials.GenerateAgreement(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.AbstractTlsAgreementCredentials.GenerateAgreement(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsCipherFactory.CreateCipher(Org.BouncyCastle.Crypto.Tls.TlsContext,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.AbstractTlsCipherFactory.CreateCipher(Org.BouncyCastle.Crypto.Tls.TlsContext,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsPeer.ShouldUseGmtUnixTime">
            <summary>
            draft-mathewson-no-gmtunixtime-00 2. "If existing users of a TLS implementation may rely on
            gmt_unix_time containing the current time, we recommend that implementors MAY provide the
            ability to set gmt_unix_time as an option only, off by default."
            </summary>
            <returns>
            <code>true</code> if the current time should be used in the gmt_unix_time field of
            Random, or <code>false</code> if gmt_unix_time should contain a cryptographically
            random value.
            </returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsPeer.NotifySecureRenegotiation(System.Boolean)">
            <summary>
            Report whether the server supports secure renegotiation
            </summary>
            <remarks>
            The protocol handler automatically processes the relevant extensions
            </remarks>
            <param name="secureRenegotiation">
            A <see cref="T:System.Boolean"/>, true if the server supports secure renegotiation
            </param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsPeer.GetCompression">
            <summary>
            Return an implementation of <see cref="T:Org.BouncyCastle.Crypto.Tls.TlsCompression"/> to handle record compression.
            </summary>
            <returns>A <see cref="T:Org.BouncyCastle.Crypto.Tls.TlsCompression"/></returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsPeer.GetCipher">
            <summary>
            Return an implementation of <see cref="T:Org.BouncyCastle.Crypto.Tls.TlsCipher"/> to use for encryption/decryption.
            </summary>
            <returns>A <see cref="T:Org.BouncyCastle.Crypto.Tls.TlsCipher"/></returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsPeer.NotifyAlertRaised(System.Byte,System.Byte,System.String,System.Exception)">
            <summary>This method will be called when an alert is raised by the protocol.</summary>
            <param name="alertLevel"><see cref="T:Org.BouncyCastle.Crypto.Tls.AlertLevel"/></param>
            <param name="alertDescription"><see cref="T:Org.BouncyCastle.Crypto.Tls.AlertDescription"/></param>
            <param name="message">A human-readable message explaining what caused this alert. May be null.</param>
            <param name="cause">The <c>Exception</c> that caused this alert to be raised. May be null.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsPeer.NotifyAlertReceived(System.Byte,System.Byte)">
            <summary>This method will be called when an alert is received from the remote peer.</summary>
            <param name="alertLevel"><see cref="T:Org.BouncyCastle.Crypto.Tls.AlertLevel"/></param>
            <param name="alertDescription"><see cref="T:Org.BouncyCastle.Crypto.Tls.AlertDescription"/></param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsPeer.NotifyHandshakeComplete">
            <summary>Notifies the peer that the handshake has been successfully completed.</summary>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.Init(Org.BouncyCastle.Crypto.Tls.TlsClientContext)">
            <summary>
            Called at the start of a new TLS session, before any other methods.
            </summary>
            <param name="context">
            A <see cref="T:Org.BouncyCastle.Crypto.Tls.TlsProtocolHandler"/>
            </param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.GetSessionToResume">
            <summary>Return the session this client wants to resume, if any.</summary>
            <remarks>Note that the peer's certificate chain for the session (if any) may need to be periodically revalidated.</remarks>
            <returns>
            A <see cref="T:Org.BouncyCastle.Crypto.Tls.TlsSession"/> representing the resumable session to be used for this connection,
            or null to use a new session.
            </returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.GetCipherSuites">
            <summary>
            Get the list of cipher suites that this client supports.
            </summary>
            <returns>
            An array of <see cref="T:Org.BouncyCastle.Crypto.Tls.CipherSuite"/> values, each specifying a supported cipher suite.
            </returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.GetCompressionMethods">
            <summary>
            Get the list of compression methods that this client supports.
            </summary>
            <returns>
            An array of <see cref="T:Org.BouncyCastle.Crypto.Tls.CompressionMethod"/> values, each specifying a supported compression method.
            </returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.GetClientExtensions">
            <summary>
            Get the (optional) table of client extensions to be included in (extended) client hello.
            </summary>
            <returns>
            A <see cref="T:System.Collections.IDictionary"/> (Int32 -&gt; byte[]). May be null.
            </returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.NotifyServerVersion(Org.BouncyCastle.Crypto.Tls.ProtocolVersion)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.NotifySessionID(System.Byte[])">
            <summary>
            Notifies the client of the session_id sent in the ServerHello.
            </summary>
            <param name="sessionID">An array of <see cref="T:System.Byte"/></param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.NotifySelectedCipherSuite(System.Int32)">
            <summary>
            Report the cipher suite that was selected by the server.
            </summary>
            <remarks>
            The protocol handler validates this value against the offered cipher suites
            <seealso cref="M:Org.BouncyCastle.Crypto.Tls.TlsClient.GetCipherSuites"/>
            </remarks>
            <param name="selectedCipherSuite">
            A <see cref="T:Org.BouncyCastle.Crypto.Tls.CipherSuite"/>
            </param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.NotifySelectedCompressionMethod(System.Byte)">
            <summary>
            Report the compression method that was selected by the server.
            </summary>
            <remarks>
            The protocol handler validates this value against the offered compression methods
            <seealso cref="M:Org.BouncyCastle.Crypto.Tls.TlsClient.GetCompressionMethods"/>
            </remarks>
            <param name="selectedCompressionMethod">
            A <see cref="T:Org.BouncyCastle.Crypto.Tls.CompressionMethod"/>
            </param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.ProcessServerExtensions(System.Collections.IDictionary)">
            <summary>
            Report the extensions from an extended server hello.
            </summary>
            <remarks>
            Will only be called if we returned a non-null result from <see cref="M:Org.BouncyCastle.Crypto.Tls.TlsClient.GetClientExtensions"/>.
            </remarks>
            <param name="serverExtensions">
            A <see cref="T:System.Collections.IDictionary"/>  (Int32 -&gt; byte[])
            </param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.ProcessServerSupplementalData(System.Collections.IList)">
            <param name="serverSupplementalData">A <see cref="T:System.Collections.IList">list</see> of <see cref="T:Org.BouncyCastle.Crypto.Tls.SupplementalDataEntry"/></param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.GetKeyExchange">
            <summary>
            Return an implementation of <see cref="T:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange"/> to negotiate the key exchange
            part of the protocol.
            </summary>
            <returns>
            A <see cref="T:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange"/>
            </returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.GetAuthentication">
            <summary>
            Return an implementation of <see cref="T:Org.BouncyCastle.Crypto.Tls.TlsAuthentication"/> to handle authentication
            part of the protocol.
            </summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.GetClientSupplementalData">
            <returns>A <see cref="T:System.Collections.IList">list</see> of <see cref="T:Org.BouncyCastle.Crypto.Tls.SupplementalDataEntry"/></returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.NotifyNewSessionTicket(Org.BouncyCastle.Crypto.Tls.NewSessionTicket)">
            <summary>RFC 5077 3.3. NewSessionTicket Handshake Message</summary>
            <remarks>
            This method will be called (only) when a NewSessionTicket handshake message is received. The
            ticket is opaque to the client and clients MUST NOT examine the ticket under the assumption
            that it complies with e.g. <i>RFC 5077 4. Recommended Ticket Construction</i>.
            </remarks>
            <param name="newSessionTicket">The <see cref="T:Org.BouncyCastle.Crypto.Tls.NewSessionTicket">ticket</see></param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.TlsClient.ClientHelloRecordLayerVersion">
            <summary>
            Return the <see cref="T:Org.BouncyCastle.Crypto.Tls.ProtocolVersion"/> to use for the <c>TLSPlaintext.version</c> field prior to
            receiving the server version. NOTE: This method is <b>not</b> called for DTLS.
            </summary>
            <remarks>
            See RFC 5246 E.1.: "TLS clients that wish to negotiate with older servers MAY send any value
            {03,XX} as the record layer version number. Typical values would be {03,00}, the lowest
            version number supported by the client, and the value of ClientHello.client_version. No
            single value will guarantee interoperability with all old servers, but this is a complex
            topic beyond the scope of this document."
            </remarks>
            <returns>The <see cref="T:Org.BouncyCastle.Crypto.Tls.ProtocolVersion"/> to use.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsContext.ExportKeyingMaterial(System.String,System.Byte[],System.Int32)">
             Export keying material according to RFC 5705: "Keying Material Exporters for TLS".
            
             @param asciiLabel    indicates which application will use the exported keys.
             @param context_value allows the application using the exporter to mix its own data with the TLS PRF for
                                  the exporter output.
             @param length        the number of bytes to generate
             @return a pseudorandom bit string of 'length' bytes generated from the master_secret.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.TlsContext.ResumableSession">
            Used to get the resumable session, if any, used by this connection. Only available after the
            handshake has successfully completed.
            
            @return A {@link TlsSession} representing the resumable session used by this connection, or
                    null if no resumable session available.
            @see TlsPeer#NotifyHandshakeComplete()
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsEncryptionCredentials.DecryptPreMasterSecret(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.AbstractTlsEncryptionCredentials.DecryptPreMasterSecret(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange">
            <summary>
            A generic interface for key exchange implementations in (D)TLS.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange.SkipServerCredentials">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange.ProcessServerCredentials(Org.BouncyCastle.Crypto.Tls.TlsCredentials)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange.ProcessServerCertificate(Org.BouncyCastle.Crypto.Tls.Certificate)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange.GenerateServerKeyExchange">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange.SkipServerKeyExchange">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange.ProcessServerKeyExchange(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange.ValidateCertificateRequest(Org.BouncyCastle.Crypto.Tls.CertificateRequest)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange.SkipClientCredentials">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange.ProcessClientCredentials(Org.BouncyCastle.Crypto.Tls.TlsCredentials)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange.ProcessClientCertificate(Org.BouncyCastle.Crypto.Tls.Certificate)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange.GenerateClientKeyExchange(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange.ProcessClientKeyExchange(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange.GeneratePremasterSecret">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServer.NotifyClientVersion(Org.BouncyCastle.Crypto.Tls.ProtocolVersion)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServer.NotifyFallback(System.Boolean)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServer.NotifyOfferedCipherSuites(System.Int32[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServer.NotifyOfferedCompressionMethods(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServer.ProcessClientExtensions(System.Collections.IDictionary)">
            <param name="clientExtensions">A <see cref="T:System.Collections.IDictionary"/> (Int32 -&gt; byte[]). Will never be null.</param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServer.GetServerVersion">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServer.GetSelectedCipherSuite">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServer.GetSelectedCompressionMethod">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServer.GetServerExtensions">
            <summary>
            Get the (optional) table of server extensions to be included in (extended) server hello.
            </summary>
            <returns>
            A <see cref="T:System.Collections.IDictionary"/> (Int32 -&gt; byte[]). May be null.
            </returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServer.GetServerSupplementalData">
            <returns>
            A <see cref="T:System.Collections.IList"/> (<see cref="T:Org.BouncyCastle.Crypto.Tls.SupplementalDataEntry"/>). May be null.
            </returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServer.GetCredentials">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServer.GetCertificateStatus">
            <remarks>
            This method will be called (only) if the server included an extension of type
            "status_request" with empty "extension_data" in the extended server hello. See <i>RFC 3546
            3.6. Certificate Status Request</i>. If a non-null <see cref="T:Org.BouncyCastle.Crypto.Tls.CertificateStatus"/> is returned, it
            is sent to the client as a handshake message of type "certificate_status".
            </remarks>
            <returns>A <see cref="T:Org.BouncyCastle.Crypto.Tls.CertificateStatus"/> to be sent to the client (or null for none).</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServer.GetKeyExchange">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServer.GetCertificateRequest">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServer.ProcessClientSupplementalData(System.Collections.IList)">
            <param name="clientSupplementalData"><see cref="T:System.Collections.IList"/> (<see cref="T:Org.BouncyCastle.Crypto.Tls.SupplementalDataEntry"/>)</param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServer.NotifyClientCertificate(Org.BouncyCastle.Crypto.Tls.Certificate)">
            <summary>
            Called by the protocol handler to report the client certificate, only if <c>GetCertificateRequest</c>
            returned non-null.
            </summary>
            <remarks>Note: this method is responsible for certificate verification and validation.</remarks>
            <param name="clientCertificate">the effective client certificate (may be an empty chain).</param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServer.GetNewSessionTicket">
            <summary>RFC 5077 3.3. NewSessionTicket Handshake Message.</summary>
            <remarks>
            This method will be called (only) if a NewSessionTicket extension was sent by the server. See
            <i>RFC 5077 4. Recommended Ticket Construction</i> for recommended format and protection.
            </remarks>
            <returns>The <see cref="T:Org.BouncyCastle.Crypto.Tls.NewSessionTicket">ticket</see>)</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsSignerCredentials.GenerateCertificateSignature(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.AbstractTlsSignerCredentials.GenerateCertificateSignature(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.AlertDescription">
            <summary>
            RFC 5246 7.2
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.close_notify">
            This message notifies the recipient that the sender will not send any more messages on this
            connection. Note that as of TLS 1.1, failure to properly close a connection no longer
            requires that a session not be resumed. This is a change from TLS 1.0 ("The session becomes
            unresumable if any connection is terminated without proper close_notify messages with level
            equal to warning.") to conform with widespread implementation practice.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.unexpected_message">
            An inappropriate message was received. This alert is always fatal and should never be
            observed in communication between proper implementations.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.bad_record_mac">
            This alert is returned if a record is received with an incorrect MAC. This alert also MUST be
            returned if an alert is sent because a TLSCiphertext decrypted in an invalid way: either it
            wasn't an even multiple of the block length, or its padding values, when checked, weren't
            correct. This message is always fatal and should never be observed in communication between
            proper implementations (except when messages were corrupted in the network).
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.decryption_failed">
            This alert was used in some earlier versions of TLS, and may have permitted certain attacks
            against the CBC mode [CBCATT]. It MUST NOT be sent by compliant implementations.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.record_overflow">
            A TLSCiphertext record was received that had a length more than 2^14+2048 bytes, or a record
            decrypted to a TLSCompressed record with more than 2^14+1024 bytes. This message is always
            fatal and should never be observed in communication between proper implementations (except
            when messages were corrupted in the network).
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.decompression_failure">
            The decompression function received improper input (e.g., data that would expand to excessive
            length). This message is always fatal and should never be observed in communication between
            proper implementations.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.handshake_failure">
            Reception of a handshake_failure alert message indicates that the sender was unable to
            negotiate an acceptable set of security parameters given the options available. This is a
            fatal error.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.no_certificate">
            This alert was used in SSLv3 but not any version of TLS. It MUST NOT be sent by compliant
            implementations.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.bad_certificate">
            A certificate was corrupt, contained signatures that did not verify correctly, etc.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.unsupported_certificate">
            A certificate was of an unsupported type.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.certificate_revoked">
            A certificate was revoked by its signer.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.certificate_expired">
            A certificate has expired or is not currently valid.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.certificate_unknown">
            Some other (unspecified) issue arose in processing the certificate, rendering it
            unacceptable.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.illegal_parameter">
            A field in the handshake was out of range or inconsistent with other fields. This message is
            always fatal.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.unknown_ca">
            A valid certificate chain or partial chain was received, but the certificate was not accepted
            because the CA certificate could not be located or couldn't be matched with a known, trusted
            CA. This message is always fatal.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.access_denied">
            A valid certificate was received, but when access control was applied, the sender decided not
            to proceed with negotiation. This message is always fatal.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.decode_error">
            A message could not be decoded because some field was out of the specified range or the
            length of the message was incorrect. This message is always fatal and should never be
            observed in communication between proper implementations (except when messages were corrupted
            in the network).
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.decrypt_error">
            A handshake cryptographic operation failed, including being unable to correctly verify a
            signature or validate a Finished message. This message is always fatal.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.export_restriction">
            This alert was used in some earlier versions of TLS. It MUST NOT be sent by compliant
            implementations.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.protocol_version">
            The protocol version the client has attempted to negotiate is recognized but not supported.
            (For example, old protocol versions might be avoided for security reasons.) This message is
            always fatal.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.insufficient_security">
            Returned instead of handshake_failure when a negotiation has failed specifically because the
            server requires ciphers more secure than those supported by the client. This message is
            always fatal.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.internal_error">
            An internal error unrelated to the peer or the correctness of the protocol (such as a memory
            allocation failure) makes it impossible to continue. This message is always fatal.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.user_canceled">
            This handshake is being canceled for some reason unrelated to a protocol failure. If the user
            cancels an operation after the handshake is complete, just closing the connection by sending
            a close_notify is more appropriate. This alert should be followed by a close_notify. This
            message is generally a warning.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.no_renegotiation">
            Sent by the client in response to a hello request or by the server in response to a client
            hello after initial handshaking. Either of these would normally lead to renegotiation; when
            that is not appropriate, the recipient should respond with this alert. At that point, the
            original requester can decide whether to proceed with the connection. One case where this
            would be appropriate is where a server has spawned a process to satisfy a request; the
            process might receive security parameters (key length, authentication, etc.) at startup, and
            it might be difficult to communicate changes to these parameters after that point. This
            message is always a warning.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.unsupported_extension">
            Sent by clients that receive an extended server hello containing an extension that they did
            not put in the corresponding client hello. This message is always fatal.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.certificate_unobtainable">
            This alert is sent by servers who are unable to retrieve a certificate chain from the URL
            supplied by the client (see Section 3.3). This message MAY be fatal - for example if client
            authentication is required by the server for the handshake to continue and the server is
            unable to retrieve the certificate chain, it may send a fatal alert.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.unrecognized_name">
            This alert is sent by servers that receive a server_name extension request, but do not
            recognize the server name. This message MAY be fatal.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.bad_certificate_status_response">
            This alert is sent by clients that receive an invalid certificate status response (see
            Section 3.6). This message is always fatal.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.bad_certificate_hash_value">
            This alert is sent by servers when a certificate hash does not match a client provided
            certificate_hash. This message is always fatal.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.unknown_psk_identity">
            If the server does not recognize the PSK identity, it MAY respond with an
            "unknown_psk_identity" alert message.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.inappropriate_fallback">
            If TLS_FALLBACK_SCSV appears in ClientHello.cipher_suites and the highest protocol version
            supported by the server is higher than the version indicated in ClientHello.client_version,
            the server MUST respond with a fatal inappropriate_fallback alert [..].
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.AlertLevel">
            <summary>
            RFC 5246 7.2
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.BulkCipherAlgorithm">
            <summary>RFC 2246</summary>
            <remarks>
            Note that the values here are implementation-specific and arbitrary. It is recommended not to
            depend on the particular values (e.g. serialization).
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.ByteQueue">
            <remarks>
            A queue for bytes.
            <p>
            This file could be more optimized.
            </p>
            </remarks>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.ByteQueue.DefaultCapacity">
            The initial size for our buffer.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.ByteQueue.NextTwoPow(System.Int32)">
            <returns>The smallest number which can be written as 2^x which is bigger than i.</returns>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.ByteQueue.databuf">
            The buffer where we store our data.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.ByteQueue.skipped">
            How many bytes at the beginning of the buffer are skipped.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.ByteQueue.available">
            How many bytes in the buffer are valid data.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.ByteQueue.Read(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>Read data from the buffer.</summary>
            <param name="buf">The buffer where the read data will be copied to.</param>
            <param name="offset">How many bytes to skip at the beginning of buf.</param>
            <param name="len">How many bytes to read at all.</param>
            <param name="skip">How many bytes from our data to skip.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.ByteQueue.AddData(System.Byte[],System.Int32,System.Int32)">
            <summary>Add some data to our buffer.</summary>
            <param name="data">A byte-array to read data from.</param>
            <param name="offset">How many bytes to skip at the beginning of the array.</param>
            <param name="len">How many bytes to read from the array.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.ByteQueue.RemoveData(System.Int32)">
            <summary>Remove some bytes from our data from the beginning.</summary>
            <param name="i">How many bytes to remove.</param>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.ByteQueue.Available">
            <summary>The number of bytes which are available in this buffer.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.Certificate">
             Parsing and encoding of a <i>Certificate</i> struct from RFC 4346.
             <p/>
             <pre>
             opaque ASN.1Cert&lt;2^24-1&gt;;
            
             struct {
                 ASN.1Cert certificate_list&lt;0..2^24-1&gt;;
             } Certificate;
             </pre>
            
             @see Org.BouncyCastle.Asn1.X509.X509CertificateStructure
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.Certificate.mCertificateList">
            The certificates.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.Certificate.GetCertificateList">
            @return an array of {@link org.bouncycastle.asn1.x509.Certificate} representing a certificate
                    chain.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.Certificate.Encode(System.IO.Stream)">
             Encode this {@link Certificate} to a {@link Stream}.
            
             @param output the {@link Stream} to encode to.
             @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.Certificate.Parse(System.IO.Stream)">
             Parse a {@link Certificate} from a {@link Stream}.
            
             @param input the {@link Stream} to parse from.
             @return a {@link Certificate} object.
             @throws IOException
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.Certificate.IsEmpty">
            @return <code>true</code> if this certificate chain contains no certificates, or
                    <code>false</code> otherwise.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.CertificateRequest">
             Parsing and encoding of a <i>CertificateRequest</i> struct from RFC 4346.
             <p/>
             <pre>
             struct {
                 ClientCertificateType certificate_types&lt;1..2^8-1&gt;;
                 DistinguishedName certificate_authorities&lt;3..2^16-1&gt;
             } CertificateRequest;
             </pre>
            
             @see ClientCertificateType
             @see X509Name
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.CertificateRequest.#ctor(System.Byte[],System.Collections.IList,System.Collections.IList)">
            @param certificateTypes       see {@link ClientCertificateType} for valid constants.
            @param certificateAuthorities an {@link IList} of {@link X509Name}.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.CertificateRequest.Encode(System.IO.Stream)">
             Encode this {@link CertificateRequest} to a {@link Stream}.
            
             @param output the {@link Stream} to encode to.
             @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.CertificateRequest.Parse(Org.BouncyCastle.Crypto.Tls.TlsContext,System.IO.Stream)">
            Parse a {@link CertificateRequest} from a {@link Stream}.
            
            @param context
                       the {@link TlsContext} of the current connection.
            @param input
                       the {@link Stream} to parse from.
            @return a {@link CertificateRequest} object.
            @throws IOException
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.CertificateRequest.CertificateTypes">
            @return an array of certificate types
            @see {@link ClientCertificateType}
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.CertificateRequest.SupportedSignatureAlgorithms">
            @return an {@link IList} of {@link SignatureAndHashAlgorithm} (or null before TLS 1.2).
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.CertificateRequest.CertificateAuthorities">
            @return an {@link IList} of {@link X509Name}
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.CertificateStatus.Encode(System.IO.Stream)">
            Encode this {@link CertificateStatus} to a {@link Stream}.
            
            @param output
                       the {@link Stream} to encode to.
            @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.CertificateStatus.Parse(System.IO.Stream)">
            Parse a {@link CertificateStatus} from a {@link Stream}.
            
            @param input
                       the {@link Stream} to parse from.
            @return a {@link CertificateStatus} object.
            @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.CertificateStatusRequest.Encode(System.IO.Stream)">
            Encode this {@link CertificateStatusRequest} to a {@link Stream}.
            
            @param output
                       the {@link Stream} to encode to.
            @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.CertificateStatusRequest.Parse(System.IO.Stream)">
            Parse a {@link CertificateStatusRequest} from a {@link Stream}.
            
            @param input
                       the {@link Stream} to parse from.
            @return a {@link CertificateStatusRequest} object.
            @throws IOException
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.CertificateType">
            RFC 6091 
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.CertificateUrl.#ctor(System.Byte,System.Collections.IList)">
            @param type
                       see {@link CertChainType} for valid constants.
            @param urlAndHashList
                       a {@link IList} of {@link UrlAndHash}.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.CertificateUrl.Encode(System.IO.Stream)">
             Encode this {@link CertificateUrl} to a {@link Stream}.
            
             @param output the {@link Stream} to encode to.
             @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.CertificateUrl.parse(Org.BouncyCastle.Crypto.Tls.TlsContext,System.IO.Stream)">
            Parse a {@link CertificateUrl} from a {@link Stream}.
            
            @param context
                       the {@link TlsContext} of the current connection.
            @param input
                       the {@link Stream} to parse from.
            @return a {@link CertificateUrl} object.
            @throws IOException
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.CertificateUrl.Type">
            @return {@link CertChainType}
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.CertificateUrl.UrlAndHashList">
            @return an {@link IList} of {@link UrlAndHash} 
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.Chacha20Poly1305">
            draft-ietf-tls-chacha20-poly1305-04
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsCipher.EncodePlaintext(System.Int64,System.Byte,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsCipher.DecodeCiphertext(System.Int64,System.Byte,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.Chacha20Poly1305.#ctor(Org.BouncyCastle.Crypto.Tls.TlsContext)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.Chacha20Poly1305.EncodePlaintext(System.Int64,System.Byte,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.Chacha20Poly1305.DecodeCiphertext(System.Int64,System.Byte,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.Chacha20Poly1305.GetAdditionalData(System.Int64,System.Byte,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.CipherSuite">
            <summary>
            RFC 2246 A.5
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.CipherType">
            <summary>RFC 2246</summary>
            <remarks>
            Note that the values here are implementation-specific and arbitrary. It is recommended not to
            depend on the particular values (e.g. serialization).
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.CombinedHash">
            A combined hash, which implements md5(m) || sha1(m).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.CombinedHash.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            @see org.bouncycastle.crypto.Digest#update(byte[], int, int)
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.CombinedHash.DoFinal(System.Byte[],System.Int32)">
            @see org.bouncycastle.crypto.Digest#doFinal(byte[], int)
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.CombinedHash.Reset">
            @see org.bouncycastle.crypto.Digest#reset()
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.CompressionMethod">
            <summary>
            RFC 2246 6.1
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.ConnectionEnd">
            <summary>RFC 2246</summary>
            <remarks>
            Note that the values here are implementation-specific and arbitrary. It is recommended not to
            depend on the particular values (e.g. serialization).
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.ContentType">
            RFC 2246 6.2.1
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DatagramTransport.GetReceiveLimit">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DatagramTransport.GetSendLimit">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DatagramTransport.Receive(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DatagramTransport.Send(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DatagramTransport.Close">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DefaultTlsAgreementCredentials.GenerateAgreement(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DefaultTlsCipherFactory.CreateCipher(Org.BouncyCastle.Crypto.Tls.TlsContext,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DefaultTlsCipherFactory.CreateAESCipher(Org.BouncyCastle.Crypto.Tls.TlsContext,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DefaultTlsCipherFactory.CreateCamelliaCipher(Org.BouncyCastle.Crypto.Tls.TlsContext,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DefaultTlsCipherFactory.CreateChaCha20Poly1305(Org.BouncyCastle.Crypto.Tls.TlsContext)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DefaultTlsCipherFactory.CreateCipher_Aes_Ccm(Org.BouncyCastle.Crypto.Tls.TlsContext,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DefaultTlsCipherFactory.CreateCipher_Aes_Gcm(Org.BouncyCastle.Crypto.Tls.TlsContext,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DefaultTlsCipherFactory.CreateCipher_Aes_Ocb(Org.BouncyCastle.Crypto.Tls.TlsContext,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DefaultTlsCipherFactory.CreateCipher_Camellia_Gcm(Org.BouncyCastle.Crypto.Tls.TlsContext,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DefaultTlsCipherFactory.CreateDesEdeCipher(Org.BouncyCastle.Crypto.Tls.TlsContext,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DefaultTlsCipherFactory.CreateNullCipher(Org.BouncyCastle.Crypto.Tls.TlsContext,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DefaultTlsCipherFactory.CreateRC4Cipher(Org.BouncyCastle.Crypto.Tls.TlsContext,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DefaultTlsCipherFactory.CreateSeedCipher(Org.BouncyCastle.Crypto.Tls.TlsContext,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DefaultTlsCipherFactory.CreateHMacDigest(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DefaultTlsEncryptionCredentials.DecryptPreMasterSecret(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DefaultTlsSignerCredentials.GenerateCertificateSignature(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsSrpGroupVerifier.Accept(Org.BouncyCastle.Crypto.Parameters.Srp6GroupParameters)">
            Check whether the given SRP group parameters are acceptable for use.
            
            @param group the {@link SRP6GroupParameters} to check
            @return true if (and only if) the specified group parameters are acceptable
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DefaultTlsSrpGroupVerifier.#ctor">
            Accept only the group parameters specified in RFC 5054 Appendix A.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DefaultTlsSrpGroupVerifier.#ctor(System.Collections.IList)">
            Specify a custom set of acceptable group parameters.
            
            @param groups a {@link Vector} of acceptable {@link SRP6GroupParameters}
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.DeferredHash">
            Buffers input until the hash algorithm is determined.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DigitallySigned.Encode(System.IO.Stream)">
            Encode this {@link DigitallySigned} to a {@link Stream}.
            
            @param output
                       the {@link Stream} to encode to.
            @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DigitallySigned.Parse(Org.BouncyCastle.Crypto.Tls.TlsContext,System.IO.Stream)">
            Parse a {@link DigitallySigned} from a {@link Stream}.
            
            @param context
                       the {@link TlsContext} of the current connection.
            @param input
                       the {@link Stream} to parse from.
            @return a {@link DigitallySigned} object.
            @throws IOException
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.DigitallySigned.Algorithm">
            @return a {@link SignatureAndHashAlgorithm} (or null before TLS 1.2).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DtlsProtocol.ProcessFinished(System.Byte[],System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DtlsProtocol.ApplyMaxFragmentLengthExtension(Org.BouncyCastle.Crypto.Tls.DtlsRecordLayer,System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DtlsProtocol.EvaluateMaxFragmentLengthExtension(System.Boolean,System.Collections.IDictionary,System.Collections.IDictionary,System.Byte)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DtlsProtocol.GenerateCertificate(Org.BouncyCastle.Crypto.Tls.Certificate)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DtlsProtocol.GenerateSupplementalData(System.Collections.IList)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DtlsProtocol.ValidateSelectedCipherSuite(System.Int32,System.Byte)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DtlsHandshakeRetransmit.ReceivedHandshakeRecord(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DtlsRecordLayer.Send(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DtlsReliableHandshake.CheckInboundFlight">
            Check that there are no "extra" messages left in the current inbound flight
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.DtlsReplayWindow">
            RFC 4347 4.1.2.5 Anti-replay
            <p/>
            Support fast rejection of duplicate records by maintaining a sliding receive window
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DtlsReplayWindow.ShouldDiscard(System.Int64)">
             Check whether a received record with the given sequence number should be rejected as a duplicate.
            
             @param seq the 48-bit DTLSPlainText.sequence_number field of a received record.
             @return true if the record should be discarded without further processing.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DtlsReplayWindow.ReportAuthenticated(System.Int64)">
             Report that a received record with the given sequence number passed authentication checks.
            
             @param seq the 48-bit DTLSPlainText.sequence_number field of an authenticated record.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DtlsReplayWindow.Reset">
            When a new epoch begins, sequence numbers begin again at 0
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.ECBasisType">
            <summary>RFC 4492 5.4. (Errata ID: 2389)</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.ECCurveType">
            <summary>
            RFC 4492 5.4
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.ECCurveType.explicit_prime">
            Indicates the elliptic curve domain parameters are conveyed verbosely, and the
            underlying finite field is a prime field.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.ECCurveType.explicit_char2">
            Indicates the elliptic curve domain parameters are conveyed verbosely, and the
            underlying finite field is a characteristic-2 field.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.ECCurveType.named_curve">
            Indicates that a named curve is used. This option SHOULD be used when applicable.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.ECPointFormat">
            <summary>
            RFC 4492 5.1.2
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.EncryptionAlgorithm">
            <summary>RFC 2246</summary>
            <remarks>
            Note that the values here are implementation-specific and arbitrary. It is recommended not to
            depend on the particular values (e.g. serialization).
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.ExporterLabel">
            <summary>RFC 5705</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.HashAlgorithm">
            <summary>RFC 5246 7.4.1.4.1</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.HeartbeatExtension.Encode(System.IO.Stream)">
            Encode this {@link HeartbeatExtension} to a {@link Stream}.
            
            @param output
                       the {@link Stream} to encode to.
            @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.HeartbeatExtension.Parse(System.IO.Stream)">
            Parse a {@link HeartbeatExtension} from a {@link Stream}.
            
            @param input
                       the {@link Stream} to parse from.
            @return a {@link HeartbeatExtension} object.
            @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.HeartbeatMessage.Encode(Org.BouncyCastle.Crypto.Tls.TlsContext,System.IO.Stream)">
            Encode this {@link HeartbeatMessage} to a {@link Stream}.
            
            @param output
                       the {@link Stream} to encode to.
            @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.HeartbeatMessage.Parse(System.IO.Stream)">
            Parse a {@link HeartbeatMessage} from a {@link Stream}.
            
            @param input
                       the {@link Stream} to parse from.
            @return a {@link HeartbeatMessage} object.
            @throws IOException
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.KeyExchangeAlgorithm">
            <summary>RFC 2246</summary>
            <remarks>
            Note that the values here are implementation-specific and arbitrary. It is recommended not to
            depend on the particular values (e.g. serialization).
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.MacAlgorithm">
            <summary>RFC 2246</summary>
            <remarks>
            Note that the values here are implementation-specific and arbitrary. It is recommended not to
            depend on the particular values (e.g. serialization).
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.NamedCurve">
            <summary>
            RFC 4492 5.1.1
            The named curves defined here are those specified in SEC 2 [13]. Note that many of
            these curves are also recommended in ANSI X9.62 [7] and FIPS 186-2 [11]. Values 0xFE00
            through 0xFEFF are reserved for private use. Values 0xFF01 and 0xFF02 indicate that the
            client supports arbitrary prime and characteristic-2 curves, respectively (the curve
            parameters must be encoded explicitly in ECParameters).
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.NewSessionTicket.Encode(System.IO.Stream)">
             Encode this {@link NewSessionTicket} to a {@link Stream}.
            
             @param output the {@link Stream} to encode to.
             @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.NewSessionTicket.Parse(System.IO.Stream)">
             Parse a {@link NewSessionTicket} from a {@link Stream}.
            
             @param input the {@link Stream} to parse from.
             @return a {@link NewSessionTicket} object.
             @throws IOException
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.OcspStatusRequest">
            RFC 3546 3.6
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.OcspStatusRequest.#ctor(System.Collections.IList,Org.BouncyCastle.Asn1.X509.X509Extensions)">
            @param responderIDList
                       an {@link IList} of {@link ResponderID}, specifying the list of trusted OCSP
                       responders. An empty list has the special meaning that the responders are
                       implicitly known to the server - e.g., by prior arrangement.
            @param requestExtensions
                       OCSP request extensions. A null value means that there are no extensions.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.OcspStatusRequest.Encode(System.IO.Stream)">
            Encode this {@link OcspStatusRequest} to a {@link Stream}.
            
            @param output
                       the {@link Stream} to encode to.
            @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.OcspStatusRequest.Parse(System.IO.Stream)">
            Parse a {@link OcspStatusRequest} from a {@link Stream}.
            
            @param input
                       the {@link Stream} to parse from.
            @return an {@link OcspStatusRequest} object.
            @throws IOException
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.OcspStatusRequest.ResponderIDList">
            @return an {@link IList} of {@link ResponderID}
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.OcspStatusRequest.RequestExtensions">
            @return OCSP request extensions
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.PrfAlgorithm">
            <summary>RFC 5246</summary>
            <remarks>
            Note that the values here are implementation-specific and arbitrary. It is recommended not to
            depend on the particular values (e.g. serialization).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.ProtocolVersion.Get(System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.RecordStream">
            <summary>An implementation of the TLS 1.0/1.1/1.2 record layer, allowing downgrade to SSLv3.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.RecordStream.SetRestrictReadVersion(System.Boolean)">
            RFC 5246 E.1. "Earlier versions of the TLS specification were not fully clear on what the
            record layer version number (TLSPlaintext.version) should contain when sending ClientHello
            (i.e., before it is known which version of the protocol will be employed). Thus, TLS servers
            compliant with this specification MUST accept any value {03,XX} as the record layer version
            number for ClientHello."
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.SecurityParameters.Entity">
            @return {@link ConnectionEnd}
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.SecurityParameters.CipherSuite">
            @return {@link CipherSuite}
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.SecurityParameters.CompressionAlgorithm">
            @return {@link CompressionMethod}
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.SecurityParameters.PrfAlgorithm">
            @return {@link PRFAlgorithm}
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.ServerDHParams.Encode(System.IO.Stream)">
            Encode this {@link ServerDHParams} to a {@link Stream}.
            
            @param output
                       the {@link Stream} to encode to.
            @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.ServerDHParams.Parse(System.IO.Stream)">
            Parse a {@link ServerDHParams} from a {@link Stream}.
            
            @param input
                       the {@link Stream} to parse from.
            @return a {@link ServerDHParams} object.
            @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.ServerName.Encode(System.IO.Stream)">
            Encode this {@link ServerName} to a {@link Stream}.
            
            @param output
                       the {@link Stream} to encode to.
            @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.ServerName.Parse(System.IO.Stream)">
            Parse a {@link ServerName} from a {@link Stream}.
            
            @param input
                       the {@link Stream} to parse from.
            @return a {@link ServerName} object.
            @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.ServerNameList.#ctor(System.Collections.IList)">
            @param serverNameList an {@link IList} of {@link ServerName}.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.ServerNameList.Encode(System.IO.Stream)">
            Encode this {@link ServerNameList} to a {@link Stream}.
            
            @param output
                       the {@link Stream} to encode to.
            @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.ServerNameList.Parse(System.IO.Stream)">
            Parse a {@link ServerNameList} from a {@link Stream}.
            
            @param input
                       the {@link Stream} to parse from.
            @return a {@link ServerNameList} object.
            @throws IOException
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.ServerNameList.ServerNames">
            @return an {@link IList} of {@link ServerName}.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsAuthentication.NotifyServerCertificate(Org.BouncyCastle.Crypto.Tls.Certificate)">
            <summary>
            Called by the protocol handler to report the server certificate.
            </summary>
            <remarks>
            This method is responsible for certificate verification and validation
            </remarks>
            <param name="serverCertificate">The server <see cref="T:Org.BouncyCastle.Crypto.Tls.Certificate"/> received</param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsAuthentication.GetClientCredentials(Org.BouncyCastle.Crypto.Tls.CertificateRequest)">
            <summary>
            Return client credentials in response to server's certificate request
            </summary>
            <param name="certificateRequest">
            A <see cref="T:Org.BouncyCastle.Crypto.Tls.CertificateRequest"/> containing server certificate request details
            </param>
            <returns>
            A <see cref="T:Org.BouncyCastle.Crypto.Tls.TlsCredentials"/> to be used for client authentication
            (or <c>null</c> for no client authentication)
            </returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.ServerSrpParams.Encode(System.IO.Stream)">
            Encode this {@link ServerSRPParams} to an {@link OutputStream}.
            
            @param output
                       the {@link OutputStream} to encode to.
            @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.ServerSrpParams.Parse(System.IO.Stream)">
            Parse a {@link ServerSRPParams} from an {@link InputStream}.
            
            @param input
                       the {@link InputStream} to parse from.
            @return a {@link ServerSRPParams} object.
            @throws IOException
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.SignatureAlgorithm">
            RFC 5246 7.4.1.4.1 (in RFC 2246, there were no specific values assigned)
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.SignatureAndHashAlgorithm">
            RFC 5246 7.4.1.4.1
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.SignatureAndHashAlgorithm.#ctor(System.Byte,System.Byte)">
            @param hash      {@link HashAlgorithm}
            @param signature {@link SignatureAlgorithm}
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.SignatureAndHashAlgorithm.Encode(System.IO.Stream)">
             Encode this {@link SignatureAndHashAlgorithm} to a {@link Stream}.
            
             @param output the {@link Stream} to encode to.
             @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.SignatureAndHashAlgorithm.Parse(System.IO.Stream)">
             Parse a {@link SignatureAndHashAlgorithm} from a {@link Stream}.
            
             @param input the {@link Stream} to parse from.
             @return a {@link SignatureAndHashAlgorithm} object.
             @throws IOException
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.SignatureAndHashAlgorithm.Hash">
            @return {@link HashAlgorithm}
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.SignatureAndHashAlgorithm.Signature">
            @return {@link SignatureAlgorithm}
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.SimulatedTlsSrpIdentityManager">
            An implementation of {@link TlsSRPIdentityManager} that simulates the existence of "unknown" identities
            to obscure the fact that there is no verifier for them. 
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsSrpIdentityManager.GetLoginParameters(System.Byte[])">
            Lookup the {@link TlsSRPLoginParameters} corresponding to the specified identity.
            
            NOTE: To avoid "identity probing", unknown identities SHOULD be handled as recommended in RFC
            5054 2.5.1.3. {@link SimulatedTlsSRPIdentityManager} is provided for this purpose.
            
            @param identity
                       the SRP identity sent by the connecting client
            @return the {@link TlsSRPLoginParameters} for the specified identity, or else 'simulated'
                    parameters if the identity is not recognized. A null value is also allowed, but not
                    recommended.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.SimulatedTlsSrpIdentityManager.GetRfc5054Default(Org.BouncyCastle.Crypto.Parameters.Srp6GroupParameters,System.Byte[])">
             Create a {@link SimulatedTlsSRPIdentityManager} that implements the algorithm from RFC 5054 2.5.1.3
            
             @param group the {@link SRP6GroupParameters} defining the group that SRP is operating in
             @param seedKey the secret "seed key" referred to in RFC 5054 2.5.1.3
             @return an instance of {@link SimulatedTlsSRPIdentityManager}
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.Ssl3Mac">
            HMAC implementation based on original internet draft for HMAC (RFC 2104)
            
            The difference is that padding is concatentated versus XORed with the key
            
            H(K + opad, H(K + ipad, text))
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.Ssl3Mac.#ctor(Org.BouncyCastle.Crypto.IDigest)">
            Base constructor for one of the standard digest algorithms that the byteLength of
            the algorithm is know for. Behaviour is undefined for digests other than MD5 or SHA1.
            
            @param digest the digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.Ssl3Mac.Reset">
            Reset the mac generator.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.SupplementalDataType">
            <summary>RFC 4680</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsAeadCipher.#ctor(Org.BouncyCastle.Crypto.Tls.TlsContext,Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher,Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsAeadCipher.#ctor(Org.BouncyCastle.Crypto.Tls.TlsContext,Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher,Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher,System.Int32,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsAeadCipher.EncodePlaintext(System.Int64,System.Byte,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsAeadCipher.DecodeCiphertext(System.Int64,System.Byte,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsAeadCipher.GetAdditionalData(System.Int64,System.Byte,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.TlsBlockCipher">
            <summary>
            A generic TLS 1.0-1.2 / SSLv3 block cipher. This can be used for AES or 3DES for example.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsBlockCipher.#ctor(Org.BouncyCastle.Crypto.Tls.TlsContext,Org.BouncyCastle.Crypto.IBlockCipher,Org.BouncyCastle.Crypto.IBlockCipher,Org.BouncyCastle.Crypto.IDigest,Org.BouncyCastle.Crypto.IDigest,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsBlockCipher.DecodeCiphertext(System.Int64,System.Byte,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsProtocol.ProcessChangeCipherSpec(System.Byte[],System.Int32,System.Int32)">
             This method is called, when a change cipher spec message is received.
            
             @throws IOException If the message has an invalid content or the handshake is not in the correct
             state.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsProtocol.ReadApplicationData(System.Byte[],System.Int32,System.Int32)">
             Read data from the network. The method will return immediately, if there is still some data
             left in the buffer, or block until some application data has been read from the network.
            
             @param buf    The buffer where the data will be copied to.
             @param offset The position where the data will be placed in the buffer.
             @param len    The maximum number of bytes to read.
             @return The number of bytes read.
             @throws IOException If something goes wrong during reading data.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsProtocol.WriteData(System.Byte[],System.Int32,System.Int32)">
             Send some application data to the remote system.
             <p/>
             The method will handle fragmentation internally.
            
             @param buf    The buffer with the data.
             @param offset The position in the buffer where the data is placed.
             @param len    The length of the data.
             @throws IOException If something goes wrong during sending.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsProtocol.OfferInput(System.Byte[])">
            Offer input from an arbitrary source. Only allowed in non-blocking mode.<br/>
            <br/>
            After this method returns, the input buffer is "owned" by this object. Other code
            must not attempt to do anything with it.<br/>
            <br/>
            This method will decrypt and process all records that are fully available.
            If only part of a record is available, the buffer will be retained until the
            remainder of the record is offered.<br/>
            <br/>
            If any records containing application data were processed, the decrypted data
            can be obtained using {@link #readInput(byte[], int, int)}. If any records
            containing protocol data were processed, a response may have been generated.
            You should always check to see if there is any available output after calling
            this method by calling {@link #getAvailableOutputBytes()}.
            @param input The input buffer to offer
            @throws IOException If an error occurs while decrypting or processing a record
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsProtocol.GetAvailableInputBytes">
            Gets the amount of received application data. A call to {@link #readInput(byte[], int, int)}
            is guaranteed to be able to return at least this much data.<br/>
            <br/>
            Only allowed in non-blocking mode.
            @return The number of bytes of available application data
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsProtocol.ReadInput(System.Byte[],System.Int32,System.Int32)">
            Retrieves received application data. Use {@link #getAvailableInputBytes()} to check
            how much application data is currently available. This method functions similarly to
            {@link InputStream#read(byte[], int, int)}, except that it never blocks. If no data
            is available, nothing will be copied and zero will be returned.<br/>
            <br/>
            Only allowed in non-blocking mode.
            @param buffer The buffer to hold the application data
            @param offset The start offset in the buffer at which the data is written
            @param length The maximum number of bytes to read
            @return The total number of bytes copied to the buffer. May be less than the
                     length specified if the length was greater than the amount of available data.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsProtocol.OfferOutput(System.Byte[],System.Int32,System.Int32)">
            Offer output from an arbitrary source. Only allowed in non-blocking mode.<br/>
            <br/>
            After this method returns, the specified section of the buffer will have been
            processed. Use {@link #readOutput(byte[], int, int)} to get the bytes to
            transmit to the other peer.<br/>
            <br/>
            This method must not be called until after the handshake is complete! Attempting
            to call it before the handshake is complete will result in an exception.
            @param buffer The buffer containing application data to encrypt
            @param offset The offset at which to begin reading data
            @param length The number of bytes of data to read
            @throws IOException If an error occurs encrypting the data, or the handshake is not complete
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsProtocol.GetAvailableOutputBytes">
            Gets the amount of encrypted data available to be sent. A call to
            {@link #readOutput(byte[], int, int)} is guaranteed to be able to return at
            least this much data.<br/>
            <br/>
            Only allowed in non-blocking mode.
            @return The number of bytes of available encrypted data
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsProtocol.ReadOutput(System.Byte[],System.Int32,System.Int32)">
            Retrieves encrypted data to be sent. Use {@link #getAvailableOutputBytes()} to check
            how much encrypted data is currently available. This method functions similarly to
            {@link InputStream#read(byte[], int, int)}, except that it never blocks. If no data
            is available, nothing will be copied and zero will be returned.<br/>
            <br/>
            Only allowed in non-blocking mode.
            @param buffer The buffer to hold the encrypted data
            @param offset The start offset in the buffer at which the data is written
            @param length The maximum number of bytes to read
            @return The total number of bytes copied to the buffer. May be less than the
                     length specified if the length was greater than the amount of available data.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsProtocol.FailWithError(System.Byte,System.Byte,System.String,System.Exception)">
            Terminate this connection with an alert. Can be used for normal closure too.
            
            @param alertLevel
                       See {@link AlertLevel} for values.
            @param alertDescription
                       See {@link AlertDescription} for values.
            @throws IOException
                        If alert was fatal.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsProtocol.Close">
             Closes this connection.
            
             @throws IOException If something goes wrong during closing.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsProtocol.AssertEmpty(System.IO.MemoryStream)">
             Make sure the InputStream 'buf' now empty. Fail otherwise.
            
             @param buf The InputStream to check.
             @throws IOException If 'buf' is not empty.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsProtocol.GetCurrentPrfHash(Org.BouncyCastle.Crypto.Tls.TlsContext,Org.BouncyCastle.Crypto.Tls.TlsHandshakeHash,System.Byte[])">
            'sender' only relevant to SSLv3
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.TlsProtocol.Stream">
            <summary>The secure bidirectional stream for this connection</summary>
            <remarks>Only allowed in blocking mode.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClientProtocol.#ctor(System.IO.Stream,Org.BouncyCastle.Security.SecureRandom)">
            Constructor for blocking mode.
            @param stream The bi-directional stream of data to/from the server
            @param secureRandom Random number generator for various cryptographic functions
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClientProtocol.#ctor(System.IO.Stream,System.IO.Stream,Org.BouncyCastle.Security.SecureRandom)">
            Constructor for blocking mode.
            @param input The stream of data from the server
            @param output The stream of data to the server
            @param secureRandom Random number generator for various cryptographic functions
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClientProtocol.#ctor(Org.BouncyCastle.Security.SecureRandom)">
            Constructor for non-blocking mode.<br/>
            <br/>
            When data is received, use {@link #offerInput(java.nio.ByteBuffer)} to
            provide the received ciphertext, then use
            {@link #readInput(byte[], int, int)} to read the corresponding cleartext.<br/>
            <br/>
            Similarly, when data needs to be sent, use
            {@link #offerOutput(byte[], int, int)} to provide the cleartext, then use
            {@link #readOutput(byte[], int, int)} to get the corresponding
            ciphertext.
            
            @param secureRandom
                       Random number generator for various cryptographic functions
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClientProtocol.Connect(Org.BouncyCastle.Crypto.Tls.TlsClient)">
             Initiates a TLS handshake in the role of client.<br/>
             <br/>
             In blocking mode, this will not return until the handshake is complete.
             In non-blocking mode, use {@link TlsPeer#NotifyHandshakeComplete()} to
             receive a callback when the handshake is complete.
            
             @param tlsClient The {@link TlsClient} to use for the handshake.
             @throws IOException If in blocking mode and handshake was not successful.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.TlsDHKeyExchange">
            <summary>(D)TLS DH key exchange.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.TlsECDheKeyExchange">
            <summary>(D)TLS ECDHE key exchange (see RFC 4492).</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.TlsECDHKeyExchange">
            <summary>(D)TLS ECDH key exchange (see RFC 4492).</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.AddHeartbeatExtension(System.Collections.IDictionary,Org.BouncyCastle.Crypto.Tls.HeartbeatExtension)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.AddMaxFragmentLengthExtension(System.Collections.IDictionary,System.Byte)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.AddPaddingExtension(System.Collections.IDictionary,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.AddServerNameExtension(System.Collections.IDictionary,Org.BouncyCastle.Crypto.Tls.ServerNameList)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.AddStatusRequestExtension(System.Collections.IDictionary,Org.BouncyCastle.Crypto.Tls.CertificateStatusRequest)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.GetHeartbeatExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.GetMaxFragmentLengthExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.GetPaddingExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.GetServerNameExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.GetStatusRequestExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.HasEncryptThenMacExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.HasExtendedMasterSecretExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.HasTruncatedHMacExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.CreateHeartbeatExtension(Org.BouncyCastle.Crypto.Tls.HeartbeatExtension)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.CreateMaxFragmentLengthExtension(System.Byte)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.CreatePaddingExtension(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.CreateServerNameExtension(Org.BouncyCastle.Crypto.Tls.ServerNameList)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.CreateStatusRequestExtension(Org.BouncyCastle.Crypto.Tls.CertificateStatusRequest)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.ReadEmptyExtensionData(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.ReadEncryptThenMacExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.ReadExtendedMasterSecretExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.ReadHeartbeatExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.ReadMaxFragmentLengthExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.ReadPaddingExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.ReadServerNameExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.ReadStatusRequestExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.ReadTruncatedHMacExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.TlsMac">
            <summary>
            A generic TLS MAC implementation, acting as an HMAC based on some underlying Digest.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsMac.#ctor(Org.BouncyCastle.Crypto.Tls.TlsContext,Org.BouncyCastle.Crypto.IDigest,System.Byte[],System.Int32,System.Int32)">
             Generate a new instance of an TlsMac.
            
             @param context the TLS client context
             @param digest  The digest to use.
             @param key     A byte-array where the key for this MAC is located.
             @param keyOff  The number of bytes to skip, before the key starts in the buffer.
             @param keyLen  The length of the key.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsMac.CalculateMac(System.Int64,System.Byte,System.Byte[],System.Int32,System.Int32)">
             Calculate the MAC for some given data.
            
             @param type    The message type of the message.
             @param message A byte-buffer containing the message.
             @param offset  The number of bytes to skip, before the message starts.
             @param length  The length of the message.
             @return A new byte-buffer containing the MAC value.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.TlsMac.MacSecret">
            @return the MAC write secret
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.TlsMac.Size">
            @return The output length of this MAC.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.TlsNullCipher">
            <summary>
            A NULL CipherSuite, with optional MAC.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsNullCipher.#ctor(Org.BouncyCastle.Crypto.Tls.TlsContext,Org.BouncyCastle.Crypto.IDigest,Org.BouncyCastle.Crypto.IDigest)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsNullCipher.EncodePlaintext(System.Int64,System.Byte,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsNullCipher.DecodeCiphertext(System.Int64,System.Byte,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsProtocolHandler.#ctor(System.IO.Stream,System.IO.Stream,Org.BouncyCastle.Security.SecureRandom)">
            <remarks>Both streams can be the same object</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.TlsPskKeyExchange">
            <summary>(D)TLS PSK key exchange (RFC 4279).</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.TlsRsaKeyExchange">
            <summary>(D)TLS and SSLv3 RSA key exchange.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsRsaUtilities.GenerateEncryptedPreMasterSecret(Org.BouncyCastle.Crypto.Tls.TlsContext,Org.BouncyCastle.Crypto.Parameters.RsaKeyParameters,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServerProtocol.#ctor(System.IO.Stream,Org.BouncyCastle.Security.SecureRandom)">
            Constructor for blocking mode.
            @param stream The bi-directional stream of data to/from the client
            @param output The stream of data to the client
            @param secureRandom Random number generator for various cryptographic functions
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServerProtocol.#ctor(System.IO.Stream,System.IO.Stream,Org.BouncyCastle.Security.SecureRandom)">
            Constructor for blocking mode.
            @param input The stream of data from the client
            @param output The stream of data to the client
            @param secureRandom Random number generator for various cryptographic functions
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServerProtocol.#ctor(Org.BouncyCastle.Security.SecureRandom)">
            Constructor for non-blocking mode.<br/>
            <br/>
            When data is received, use {@link #offerInput(java.nio.ByteBuffer)} to
            provide the received ciphertext, then use
            {@link #readInput(byte[], int, int)} to read the corresponding cleartext.<br/>
            <br/>
            Similarly, when data needs to be sent, use
            {@link #offerOutput(byte[], int, int)} to provide the cleartext, then use
            {@link #readOutput(byte[], int, int)} to get the corresponding
            ciphertext.
            
            @param secureRandom
                       Random number generator for various cryptographic functions
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServerProtocol.Accept(Org.BouncyCastle.Crypto.Tls.TlsServer)">
             Receives a TLS handshake in the role of server.<br/>
             <br/>
             In blocking mode, this will not return until the handshake is complete.
             In non-blocking mode, use {@link TlsPeer#notifyHandshakeComplete()} to
             receive a callback when the handshake is complete.
            
             @param tlsServer
             @throws IOException If in blocking mode and handshake was not successful.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.TlsSrpKeyExchange">
            <summary>(D)TLS SRP key exchange (RFC 5054).</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.TlsSRTPUtils">
            RFC 5764 DTLS Extension to Establish Keys for SRTP.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsStreamCipher.#ctor(Org.BouncyCastle.Crypto.Tls.TlsContext,Org.BouncyCastle.Crypto.IStreamCipher,Org.BouncyCastle.Crypto.IStreamCipher,Org.BouncyCastle.Crypto.IDigest,Org.BouncyCastle.Crypto.IDigest,System.Int32,System.Boolean)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsStreamCipher.DecodeCiphertext(System.Int64,System.Byte,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsStreamCipher.CheckMac(System.Int64,System.Byte,System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.TlsUtilities">
            <remarks>Some helper functions for MicroTLS.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsUtilities.AddSignatureAlgorithmsExtension(System.Collections.IDictionary,System.Collections.IList)">
             Add a 'signature_algorithms' extension to existing extensions.
            
             @param extensions                   A {@link Hashtable} to add the extension to.
             @param supportedSignatureAlgorithms {@link Vector} containing at least 1 {@link SignatureAndHashAlgorithm}.
             @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsUtilities.GetSignatureAlgorithmsExtension(System.Collections.IDictionary)">
             Get a 'signature_algorithms' extension from extensions.
            
             @param extensions A {@link Hashtable} to get the extension from, if it is present.
             @return A {@link Vector} containing at least 1 {@link SignatureAndHashAlgorithm}, or null.
             @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsUtilities.CreateSignatureAlgorithmsExtension(System.Collections.IList)">
             Create a 'signature_algorithms' extension value.
            
             @param supportedSignatureAlgorithms A {@link Vector} containing at least 1 {@link SignatureAndHashAlgorithm}.
             @return A byte array suitable for use as an extension value.
             @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsUtilities.ReadSignatureAlgorithmsExtension(System.Byte[])">
             Read 'signature_algorithms' extension data.
            
             @param extensionData The extension data.
             @return A {@link Vector} containing at least 1 {@link SignatureAndHashAlgorithm}.
             @throws IOException
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.UrlAndHash">
            RFC 6066 5.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.UrlAndHash.Encode(System.IO.Stream)">
             Encode this {@link UrlAndHash} to a {@link Stream}.
            
             @param output the {@link Stream} to encode to.
             @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.UrlAndHash.Parse(Org.BouncyCastle.Crypto.Tls.TlsContext,System.IO.Stream)">
            Parse a {@link UrlAndHash} from a {@link Stream}.
            
            @param context
                       the {@link TlsContext} of the current connection.
            @param input
                       the {@link Stream} to parse from.
            @return a {@link UrlAndHash} object.
            @throws IOException
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.UserMappingType">
            <remarks>RFC 4681</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.UseSrtpData">
            RFC 5764 4.1.1
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.UseSrtpData.#ctor(System.Int32[],System.Byte[])">
            @param protectionProfiles see {@link SrtpProtectionProfile} for valid constants.
            @param mki                valid lengths from 0 to 255.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.UseSrtpData.ProtectionProfiles">
            @return see {@link SrtpProtectionProfile} for valid constants.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.UseSrtpData.Mki">
            @return valid lengths from 0 to 255.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.AddMagnitudes(System.Int32[],System.Int32[])">
            return a = a + b - b preserved.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.CompareTo(System.Int32,System.Int32[],System.Int32,System.Int32[])">
            unsigned comparison on two arrays - note the arrays may
            start with leading zeros.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.Divide(System.Int32[],System.Int32[])">
            return z = x / y - done in place (z value preserved, x contains the
            remainder)
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.IsProbablePrime(System.Int32)">
            return whether or not a BigInteger is probably prime with a
            probability of 1 - (1/2)**certainty.
            <p>From Knuth Vol 2, pg 395.</p>
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.ExtEuclid(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger@)">
             Calculate the numbers u1, u2, and u3 such that:
            
             u1 * a + u2 * b = u3
            
             where u3 is the greatest common divider of a and b.
             a and b using the extended Euclid algorithm (refer p. 323
             of The Art of Computer Programming vol 2, 2nd ed).
             This also seems to have the side effect of calculating
             some form of multiplicative inverse.
            
             @param a    First number to calculate gcd for
             @param b    Second number to calculate gcd for
             @param u1Out      the return object for the u1 value
             @return     The greatest common divisor of a and b
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.Square(System.Int32[],System.Int32[])">
            return w with w = x * x - w is assumed to have enough space.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.Multiply(System.Int32[],System.Int32[],System.Int32[])">
            return x with x = y * z - x is assumed to have enough space.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.GetMQuote">
            Calculate mQuote = -m^(-1) mod b with b = 2^32 (32 = word size)
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.MultiplyMonty(System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.UInt32,System.Boolean)">
            Montgomery multiplication: a = x * y * R^(-1) mod m
            <br/>
            Based algorithm 14.36 of Handbook of Applied Cryptography.
            <br/>
            <li> m, x, y should have length n </li>
            <li> a should have length (n + 1) </li>
            <li> b = 2^32, R = b^n </li>
            <br/>
            The result is put in x
            <br/>
            NOTE: the indices of x, y, m, a different in HAC and in Java
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.Remainder(System.Int32[],System.Int32[])">
            return x = x % y - done in place (y value preserved)
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.ShiftLeft(System.Int32[],System.Int32)">
            do a left shift - this returns a new array.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.ShiftRightInPlace(System.Int32,System.Int32[],System.Int32)">
            do a right shift - this does it in place.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.ShiftRightOneInPlace(System.Int32,System.Int32[])">
            do a right shift by one - this does it in place.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.Subtract(System.Int32,System.Int32[],System.Int32,System.Int32[])">
            returns x = x - y - we assume x is >= y
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal">
            Class representing a simple version of a big decimal. A
            <code>SimpleBigDecimal</code> is basically a
            {@link java.math.BigInteger BigInteger} with a few digits on the right of
            the decimal point. The number of (binary) digits on the right of the decimal
            point is called the <code>scale</code> of the <code>SimpleBigDecimal</code>.
            Unlike in {@link java.math.BigDecimal BigDecimal}, the scale is not adjusted
            automatically, but must be set manually. All <code>SimpleBigDecimal</code>s
            taking part in the same arithmetic operation must have equal scale. The
            result of a multiplication of two <code>SimpleBigDecimal</code>s returns a
            <code>SimpleBigDecimal</code> with double scale.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal.GetInstance(Org.BouncyCastle.Math.BigInteger,System.Int32)">
            Returns a <code>SimpleBigDecimal</code> representing the same numerical
            value as <code>value</code>.
            @param value The value of the <code>SimpleBigDecimal</code> to be
            created. 
            @param scale The scale of the <code>SimpleBigDecimal</code> to be
            created. 
            @return The such created <code>SimpleBigDecimal</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal.#ctor(Org.BouncyCastle.Math.BigInteger,System.Int32)">
            Constructor for <code>SimpleBigDecimal</code>. The value of the
            constructed <code>SimpleBigDecimal</code> Equals <code>bigInt / 
            2<sup>scale</sup></code>.
            @param bigInt The <code>bigInt</code> value parameter.
            @param scale The scale of the constructed <code>SimpleBigDecimal</code>.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Abc.Tnaf">
            Class holding methods for point multiplication based on the window
            &#964;-adic nonadjacent form (WTNAF). The algorithms are based on the
            paper "Improved Algorithms for Arithmetic on Anomalous Binary Curves"
            by Jerome A. Solinas. The paper first appeared in the Proceedings of
            Crypto 1997.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.Tnaf.Width">
            The window width of WTNAF. The standard value of 4 is slightly less
            than optimal for running time, but keeps space requirements for
            precomputation low. For typical curves, a value of 5 or 6 results in
            a better running time. When changing this value, the
            <code>&#945;<sub>u</sub></code>'s must be computed differently, see
            e.g. "Guide to Elliptic Curve Cryptography", Darrel Hankerson,
            Alfred Menezes, Scott Vanstone, Springer-Verlag New York Inc., 2004,
            p. 121-122
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.Tnaf.Pow2Width">
            2<sup>4</sup>
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.Tnaf.Alpha0">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=0</code> as an array
            of <code>ZTauElement</code>s.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.Tnaf.Alpha0Tnaf">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=0</code> as an array
            of TNAFs.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.Tnaf.Alpha1">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=1</code> as an array
            of <code>ZTauElement</code>s.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.Tnaf.Alpha1Tnaf">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=1</code> as an array
            of TNAFs.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.Norm(System.SByte,Org.BouncyCastle.Math.EC.Abc.ZTauElement)">
            Computes the norm of an element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @return The norm of <code>&#955;</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.Norm(System.SByte,Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal,Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal)">
            Computes the norm of an element <code>&#955;</code> of
            <code><b>R</b>[&#964;]</code>, where <code>&#955; = u + v&#964;</code>
            and <code>u</code> and <code>u</code> are real numbers (elements of
            <code><b>R</b></code>). 
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param u The real part of the element <code>&#955;</code> of
            <code><b>R</b>[&#964;]</code>.
            @param v The <code>&#964;</code>-adic part of the element
            <code>&#955;</code> of <code><b>R</b>[&#964;]</code>.
            @return The norm of <code>&#955;</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.Round(Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal,Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal,System.SByte)">
            Rounds an element <code>&#955;</code> of <code><b>R</b>[&#964;]</code>
            to an element of <code><b>Z</b>[&#964;]</code>, such that their difference
            has minimal norm. <code>&#955;</code> is given as
            <code>&#955; = &#955;<sub>0</sub> + &#955;<sub>1</sub>&#964;</code>.
            @param lambda0 The component <code>&#955;<sub>0</sub></code>.
            @param lambda1 The component <code>&#955;<sub>1</sub></code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve. Must
            equal 1 or -1.
            @return The rounded element of <code><b>Z</b>[&#964;]</code>.
            @throws ArgumentException if <code>lambda0</code> and
            <code>lambda1</code> do not have same scale.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.ApproximateDivisionByN(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,System.SByte,System.Int32,System.Int32)">
            Approximate division by <code>n</code>. For an integer
            <code>k</code>, the value <code>&#955; = s k / n</code> is
            computed to <code>c</code> bits of accuracy.
            @param k The parameter <code>k</code>.
            @param s The curve parameter <code>s<sub>0</sub></code> or
            <code>s<sub>1</sub></code>.
            @param vm The Lucas Sequence element <code>V<sub>m</sub></code>.
            @param a The parameter <code>a</code> of the elliptic curve.
            @param m The bit length of the finite field
            <code><b>F</b><sub>m</sub></code>.
            @param c The number of bits of accuracy, i.e. the scale of the returned
            <code>SimpleBigDecimal</code>.
            @return The value <code>&#955; = s k / n</code> computed to
            <code>c</code> bits of accuracy.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.TauAdicNaf(System.SByte,Org.BouncyCastle.Math.EC.Abc.ZTauElement)">
            Computes the <code>&#964;</code>-adic NAF (non-adjacent form) of an
            element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @return The <code>&#964;</code>-adic NAF of <code>&#955;</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.Tau(Org.BouncyCastle.Math.EC.AbstractF2mPoint)">
            Applies the operation <code>&#964;()</code> to an
            <code>AbstractF2mPoint</code>. 
            @param p The AbstractF2mPoint to which <code>&#964;()</code> is applied.
            @return <code>&#964;(p)</code>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.GetMu(Org.BouncyCastle.Math.EC.AbstractF2mCurve)">
            Returns the parameter <code>&#956;</code> of the elliptic curve.
            @param curve The elliptic curve from which to obtain <code>&#956;</code>.
            The curve must be a Koblitz curve, i.e. <code>a</code> Equals
            <code>0</code> or <code>1</code> and <code>b</code> Equals
            <code>1</code>. 
            @return <code>&#956;</code> of the elliptic curve.
            @throws ArgumentException if the given ECCurve is not a Koblitz
            curve.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.GetLucas(System.SByte,System.Int32,System.Boolean)">
            Calculates the Lucas Sequence elements <code>U<sub>k-1</sub></code> and
            <code>U<sub>k</sub></code> or <code>V<sub>k-1</sub></code> and
            <code>V<sub>k</sub></code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param k The index of the second element of the Lucas Sequence to be
            returned.
            @param doV If set to true, computes <code>V<sub>k-1</sub></code> and
            <code>V<sub>k</sub></code>, otherwise <code>U<sub>k-1</sub></code> and
            <code>U<sub>k</sub></code>.
            @return An array with 2 elements, containing <code>U<sub>k-1</sub></code>
            and <code>U<sub>k</sub></code> or <code>V<sub>k-1</sub></code>
            and <code>V<sub>k</sub></code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.GetTw(System.SByte,System.Int32)">
            Computes the auxiliary value <code>t<sub>w</sub></code>. If the width is
            4, then for <code>mu = 1</code>, <code>t<sub>w</sub> = 6</code> and for
            <code>mu = -1</code>, <code>t<sub>w</sub> = 10</code> 
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param w The window width of the WTNAF.
            @return the auxiliary value <code>t<sub>w</sub></code>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.GetSi(Org.BouncyCastle.Math.EC.AbstractF2mCurve)">
            Computes the auxiliary values <code>s<sub>0</sub></code> and
            <code>s<sub>1</sub></code> used for partial modular reduction. 
            @param curve The elliptic curve for which to compute
            <code>s<sub>0</sub></code> and <code>s<sub>1</sub></code>.
            @throws ArgumentException if <code>curve</code> is not a
            Koblitz curve (Anomalous Binary Curve, ABC).
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.PartModReduction(Org.BouncyCastle.Math.BigInteger,System.Int32,System.SByte,Org.BouncyCastle.Math.BigInteger[],System.SByte,System.SByte)">
            Partial modular reduction modulo
            <code>(&#964;<sup>m</sup> - 1)/(&#964; - 1)</code>.
            @param k The integer to be reduced.
            @param m The bitlength of the underlying finite field.
            @param a The parameter <code>a</code> of the elliptic curve.
            @param s The auxiliary values <code>s<sub>0</sub></code> and
            <code>s<sub>1</sub></code>.
            @param mu The parameter &#956; of the elliptic curve.
            @param c The precision (number of bits of accuracy) of the partial
            modular reduction.
            @return <code>&#961; := k partmod (&#964;<sup>m</sup> - 1)/(&#964; - 1)</code>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.MultiplyRTnaf(Org.BouncyCastle.Math.EC.AbstractF2mPoint,Org.BouncyCastle.Math.BigInteger)">
            Multiplies a {@link org.bouncycastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by a <code>BigInteger</code> using the reduced <code>&#964;</code>-adic
            NAF (RTNAF) method.
            @param p The AbstractF2mPoint to Multiply.
            @param k The <code>BigInteger</code> by which to Multiply <code>p</code>.
            @return <code>k * p</code>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.MultiplyTnaf(Org.BouncyCastle.Math.EC.AbstractF2mPoint,Org.BouncyCastle.Math.EC.Abc.ZTauElement)">
            Multiplies a {@link org.bouncycastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>
            using the <code>&#964;</code>-adic NAF (TNAF) method.
            @param p The AbstractF2mPoint to Multiply.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @return <code>&#955; * p</code>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.MultiplyFromTnaf(Org.BouncyCastle.Math.EC.AbstractF2mPoint,System.SByte[])">
            Multiplies a {@link org.bouncycastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>
            using the <code>&#964;</code>-adic NAF (TNAF) method, given the TNAF
            of <code>&#955;</code>.
            @param p The AbstractF2mPoint to Multiply.
            @param u The the TNAF of <code>&#955;</code>..
            @return <code>&#955; * p</code>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.TauAdicWNaf(System.SByte,Org.BouncyCastle.Math.EC.Abc.ZTauElement,System.SByte,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.EC.Abc.ZTauElement[])">
            Computes the <code>[&#964;]</code>-adic window NAF of an element
            <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>.
            @param mu The parameter &#956; of the elliptic curve.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code> of which to compute the
            <code>[&#964;]</code>-adic NAF.
            @param width The window width of the resulting WNAF.
            @param pow2w 2<sup>width</sup>.
            @param tw The auxiliary value <code>t<sub>w</sub></code>.
            @param alpha The <code>&#945;<sub>u</sub></code>'s for the window width.
            @return The <code>[&#964;]</code>-adic window NAF of
            <code>&#955;</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.GetPreComp(Org.BouncyCastle.Math.EC.AbstractF2mPoint,System.SByte)">
            Does the precomputation for WTNAF multiplication.
            @param p The <code>ECPoint</code> for which to do the precomputation.
            @param a The parameter <code>a</code> of the elliptic curve.
            @return The precomputation array for <code>p</code>. 
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Abc.ZTauElement">
            Class representing an element of <code><b>Z</b>[&#964;]</code>. Let
            <code>&#955;</code> be an element of <code><b>Z</b>[&#964;]</code>. Then
            <code>&#955;</code> is given as <code>&#955; = u + v&#964;</code>. The
            components <code>u</code> and <code>v</code> may be used directly, there
            are no accessor methods.
            Immutable class.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.ZTauElement.u">
            The &quot;real&quot; part of <code>&#955;</code>.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.ZTauElement.v">
            The &quot;<code>&#964;</code>-adic&quot; part of <code>&#955;</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.ZTauElement.#ctor(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            Constructor for an element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @param u The &quot;real&quot; part of <code>&#955;</code>.
            @param v The &quot;<code>&#964;</code>-adic&quot; part of
            <code>&#955;</code>.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.ECCurve">
            <remarks>Base class for an elliptic curve.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECCurve.SetPreCompInfo(Org.BouncyCastle.Math.EC.ECPoint,System.String,Org.BouncyCastle.Math.EC.Multiplier.PreCompInfo)">
            Adds <code>PreCompInfo</code> for a point on this curve, under a given name. Used by
            <code>ECMultiplier</code>s to save the precomputation for this <code>ECPoint</code> for use
            by subsequent multiplication.
            
            @param point
                       The <code>ECPoint</code> to store precomputations for.
            @param name
                       A <code>String</code> used to index precomputations of different types.
            @param preCompInfo
                       The values precomputed by the <code>ECMultiplier</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECCurve.NormalizeAll(Org.BouncyCastle.Math.EC.ECPoint[])">
            Normalization ensures that any projective coordinate is 1, and therefore that the x, y
            coordinates reflect those of the equivalent point in an affine coordinate system. Where more
            than one point is to be normalized, this method will generally be more efficient than
            normalizing each point separately.
            
            @param points
                       An array of points that will be updated in place with their normalized versions,
                       where necessary
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECCurve.NormalizeAll(Org.BouncyCastle.Math.EC.ECPoint[],System.Int32,System.Int32,Org.BouncyCastle.Math.EC.ECFieldElement)">
            Normalization ensures that any projective coordinate is 1, and therefore that the x, y
            coordinates reflect those of the equivalent point in an affine coordinate system. Where more
            than one point is to be normalized, this method will generally be more efficient than
            normalizing each point separately. An (optional) z-scaling factor can be applied; effectively
            each z coordinate is scaled by this value prior to normalization (but only one
            actual multiplication is needed).
            
            @param points
                       An array of points that will be updated in place with their normalized versions,
                       where necessary
            @param off
                       The start of the range of points to normalize
            @param len
                       The length of the range of points to normalize
            @param iso
                       The (optional) z-scaling factor - can be null
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECCurve.GetMultiplier">
            Sets the default <code>ECMultiplier</code>, unless already set. 
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECCurve.DecodePoint(System.Byte[])">
            Decode a point on this curve from its ASN.1 encoding. The different
            encodings are taken account of, including point compression for
            <code>F<sub>p</sub></code> (X9.62 s 4.2.1 pg 17).
            @return The decoded point.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Djb.Curve25519FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.ECPoint">
            base class for points on elliptic curves.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECPoint.Normalize">
            Normalization ensures that any projective coordinate is 1, and therefore that the x, y
            coordinates reflect those of the equivalent point in an affine coordinate system.
            
            @return a new ECPoint instance representing the same point, but with normalized coordinates
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.ECPoint.X">
            Normalizes this point, and then returns the affine x-coordinate.
            
            Note: normalization can be expensive, this method is deprecated in favour
            of caller-controlled normalization.
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.ECPoint.Y">
            Normalizes this point, and then returns the affine y-coordinate.
            
            Note: normalization can be expensive, this method is deprecated in favour
            of caller-controlled normalization.
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.ECPoint.AffineXCoord">
            Returns the affine x-coordinate after checking that this point is normalized.
            
            @return The affine x-coordinate of this point
            @throws IllegalStateException if the point is not normalized
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.ECPoint.AffineYCoord">
            Returns the affine y-coordinate after checking that this point is normalized
            
            @return The affine y-coordinate of this point
            @throws IllegalStateException if the point is not normalized
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.ECPoint.XCoord">
            Returns the x-coordinate.
            
            Caution: depending on the curve's coordinate system, this may not be the same value as in an
            affine coordinate system; use Normalize() to get a point where the coordinates have their
            affine values, or use AffineXCoord if you expect the point to already have been normalized.
            
            @return the x-coordinate of this point
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.ECPoint.YCoord">
            Returns the y-coordinate.
            
            Caution: depending on the curve's coordinate system, this may not be the same value as in an
            affine coordinate system; use Normalize() to get a point where the coordinates have their
            affine values, or use AffineYCoord if you expect the point to already have been normalized.
            
            @return the y-coordinate of this point
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECPointBase.GetEncoded(System.Boolean)">
            return the field element encoded with point compression. (S 4.3.6)
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECPointBase.Multiply(Org.BouncyCastle.Math.BigInteger)">
            Multiplies this <code>ECPoint</code> by the given number.
            @param k The multiplicator.
            @return <code>k * this</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Djb.Curve25519Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            Create a point which encodes with point compression.
            
            @param curve the curve to use
            @param x affine x co-ordinate
            @param y affine y co-ordinate
            
            @deprecated Use ECCurve.CreatePoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Djb.Curve25519Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            Create a point that encodes with or without point compresion.
            
            @param curve the curve to use
            @param x affine x co-ordinate
            @param y affine y co-ordinate
            @param withCompression if true encode with point compression
            
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP128R1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP128R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            Create a point which encodes with point compression.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP128R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            Create a point that encodes with or without point compresion.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            @param withCompression
                       if true encode with point compression
            
            @deprecated per-point compression property will be removed, refer
                        {@link #getEncoded(boolean)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP160K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            Create a point which encodes with point compression.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            
            @deprecated Use ECCurve.CreatePoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP160K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            Create a point that encodes with or without point compresion.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            @param withCompression
                       if true encode with point compression
            
            @deprecated per-point compression property will be removed, refer
                        {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP160R1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP160R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            Create a point which encodes with point compression.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            
            @deprecated Use ECCurve.CreatePoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP160R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            Create a point that encodes with or without point compresion.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            @param withCompression
                       if true encode with point compression
            
            @deprecated per-point compression property will be removed, refer
                        {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP160R2FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP160R2Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            Create a point which encodes with point compression.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            
            @deprecated Use ECCurve.CreatePoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP160R2Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            Create a point that encodes with or without point compresion.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            @param withCompression
                       if true encode with point compression
            
            @deprecated per-point compression property will be removed, refer
                        {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP192K1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP192K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            Create a point which encodes with point compression.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP192K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            Create a point that encodes with or without point compresion.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            @param withCompression
                       if true encode with point compression
            
            @deprecated per-point compression property will be removed, refer
                        {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP192R1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP192R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            Create a point which encodes with point compression.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP192R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            Create a point that encodes with or without point compresion.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            @param withCompression
                       if true encode with point compression
            
            @deprecated per-point compression property will be removed, refer
                        {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP224K1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP224K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            Create a point which encodes with point compression.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP224K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            Create a point that encodes with or without point compresion.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            @param withCompression
                       if true encode with point compression
            
            @deprecated per-point compression property will be removed, refer
                        {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP224R1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP224R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            Create a point which encodes with point compression.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP224R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            Create a point that encodes with or without point compresion.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            @param withCompression
                       if true encode with point compression
            
            @deprecated per-point compression property will be removed, refer
                        {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP256K1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP256K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            Create a point which encodes with point compression.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP256K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            Create a point that encodes with or without point compresion.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            @param withCompression
                       if true encode with point compression
            
            @deprecated per-point compression property will be removed, refer
                        {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP256R1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP256R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            Create a point which encodes with point compression.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP256R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            Create a point that encodes with or without point compresion.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            @param withCompression
                       if true encode with point compression
            
            @deprecated per-point compression property will be removed, refer
                        {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP384R1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP384R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            Create a point which encodes with point compression.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP384R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            Create a point that encodes with or without point compresion.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            @param withCompression
                       if true encode with point compression
            
            @deprecated per-point compression property will be removed, refer
                        {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP521R1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP521R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            Create a point which encodes with point compression.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP521R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            Create a point that encodes with or without point compresion.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            @param withCompression
                       if true encode with point compression
            
            @deprecated per-point compression property will be removed, refer
                        {@link #getEncoded(bool)}
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.AbstractF2mCurve.si">
            The auxiliary values <code>s<sub>0</sub></code> and
            <code>s<sub>1</sub></code> used for partial modular reduction for
            Koblitz curves.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.AbstractF2mCurve.SolveQuadradicEquation(Org.BouncyCastle.Math.EC.ECFieldElement)">
             Solves a quadratic equation <code>z<sup>2</sup> + z = beta</code>(X9.62
             D.1.6) The other solution is <code>z + 1</code>.
            
             @param beta
                        The value to solve the qradratic equation for.
             @return the solution for <code>z<sup>2</sup> + z = beta</code> or
                     <code>null</code> if no solution exists.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.AbstractF2mCurve.GetSi">
            @return the auxiliary values <code>s<sub>0</sub></code> and
            <code>s<sub>1</sub></code> used for partial modular reduction for
            Koblitz curves.
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.AbstractF2mCurve.IsKoblitz">
            Returns true if this is a Koblitz curve (ABC curve).
            @return true if this is a Koblitz curve (ABC curve), false otherwise
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT113R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT113R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT113R2Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT113R2Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT131R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT131R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT131R2Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT131R2Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT163K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT163K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT163R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT163R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT163R2Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT163R2Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT193R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT193R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT193R2Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT193R2Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT233K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT233K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT233R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT233R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT239K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT239K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT283K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT283K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT283R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT283R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT409K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT409K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT409R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT409R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT571K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT571K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT571R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT571R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECAlgorithms.ReferenceMultiply(Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.BigInteger)">
            Simple shift-and-add multiplication. Serves as reference implementation
            to verify (possibly faster) implementations, and for very small scalars.
            
            @param p
                       The point to multiply.
            @param k
                       The multiplier.
            @return The result of the point multiplication <code>kP</code>.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.FpCurve">
            Elliptic curve over Fp
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.F2mCurve">
            Elliptic curves over F2m. The Weierstrass equation is given by
            <code>y<sup>2</sup> + xy = x<sup>3</sup> + ax<sup>2</sup> + b</code>.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mCurve.m">
            The exponent <code>m</code> of <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mCurve.k1">
            TPB: The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction polynomial
            <code>f(z)</code>.<br/>
            PPB: The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mCurve.k2">
            TPB: Always set to <code>0</code><br/>
            PPB: The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mCurve.k3">
            TPB: Always set to <code>0</code><br/>
            PPB: The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mCurve.m_infinity">
            The point at infinity on this curve.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mCurve.#ctor(System.Int32,System.Int32,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            Constructor for Trinomial Polynomial Basis (TPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction
            polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mCurve.#ctor(System.Int32,System.Int32,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            Constructor for Trinomial Polynomial Basis (TPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction
            polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param order The order of the main subgroup of the elliptic curve.
            @param cofactor The cofactor of the elliptic curve, i.e.
            <code>#E<sub>a</sub>(F<sub>2<sup>m</sup></sub>) = h * n</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mCurve.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            Constructor for Pentanomial Polynomial Basis (PPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mCurve.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            Constructor for Pentanomial Polynomial Basis (PPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param order The order of the main subgroup of the elliptic curve.
            @param cofactor The cofactor of the elliptic curve, i.e.
            <code>#E<sub>a</sub>(F<sub>2<sup>m</sup></sub>) = h * n</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mCurve.IsTrinomial">
             Return true if curve uses a Trinomial basis.
            
             @return true if curve Trinomial, false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.FpFieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation
            returns the right value - if none exists it returns null.
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.FpFieldElement.FieldName">
             return the field name for this field.
            
             @return the string "Fp".
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.F2mFieldElement">
            Class representing the Elements of the finite field
            <code>F<sub>2<sup>m</sup></sub></code> in polynomial basis (PB)
            representation. Both trinomial (Tpb) and pentanomial (Ppb) polynomial
            basis representations are supported. Gaussian normal basis (GNB)
            representation is not supported.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mFieldElement.Gnb">
            Indicates gaussian normal basis representation (GNB). Number chosen
            according to X9.62. GNB is not implemented at present.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mFieldElement.Tpb">
            Indicates trinomial basis representation (Tpb). Number chosen
            according to X9.62.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mFieldElement.Ppb">
            Indicates pentanomial basis representation (Ppb). Number chosen
            according to X9.62.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mFieldElement.representation">
            Tpb or Ppb.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mFieldElement.m">
            The exponent <code>m</code> of <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mFieldElement.x">
            The <code>LongArray</code> holding the bits.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mFieldElement.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,Org.BouncyCastle.Math.BigInteger)">
            Constructor for Ppb.
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param x The BigInteger representing the value of the field element.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mFieldElement.#ctor(System.Int32,System.Int32,Org.BouncyCastle.Math.BigInteger)">
            Constructor for Tpb.
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction
            polynomial <code>f(z)</code>.
            @param x The BigInteger representing the value of the field element.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mFieldElement.CheckFieldElements(Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            Checks, if the ECFieldElements <code>a</code> and <code>b</code>
            are elements of the same field <code>F<sub>2<sup>m</sup></sub></code>
            (having the same representation).
            @param a field element.
            @param b field element to be compared.
            @throws ArgumentException if <code>a</code> and <code>b</code>
            are not elements of the same field
            <code>F<sub>2<sup>m</sup></sub></code> (having the same
            representation).
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.F2mFieldElement.Representation">
            @return the representation of the field
            <code>F<sub>2<sup>m</sup></sub></code>, either of
            {@link F2mFieldElement.Tpb} (trinomial
            basis representation) or
            {@link F2mFieldElement.Ppb} (pentanomial
            basis representation).
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.F2mFieldElement.M">
            @return the degree <code>m</code> of the reduction polynomial
            <code>f(z)</code>.
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.F2mFieldElement.K1">
            @return Tpb: The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction polynomial
            <code>f(z)</code>.<br/>
            Ppb: The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.F2mFieldElement.K2">
            @return Tpb: Always returns <code>0</code><br/>
            Ppb: The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.F2mFieldElement.K3">
            @return Tpb: Always set to <code>0</code><br/>
            Ppb: The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.FpPoint">
            Elliptic curve points over Fp
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.FpPoint.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
             Create a point which encodes without point compression.
            
             @param curve the curve to use
             @param x affine x co-ordinate
             @param y affine y co-ordinate
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.FpPoint.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
             Create a point that encodes with or without point compression.
            
             @param curve the curve to use
             @param x affine x co-ordinate
             @param y affine y co-ordinate
             @param withCompression if true encode with point compression
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.F2mPoint">
            Elliptic curve points over F2m
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mPoint.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @param curve base curve
            @param x x point
            @param y y point
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mPoint.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @param curve base curve
            @param x x point
            @param y y point
            @param withCompression true if encode with point compression.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mPoint.#ctor(Org.BouncyCastle.Math.EC.ECCurve)">
            Constructor for point at infinity
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.ECMultiplier">
            Interface for classes encapsulating a point multiplication algorithm
            for <code>ECPoint</code>s.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.ECMultiplier.Multiply(Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.BigInteger)">
            Multiplies the <code>ECPoint p</code> by <code>k</code>, i.e.
            <code>p</code> is added <code>k</code> times to itself.
            @param p The <code>ECPoint</code> to be multiplied.
            @param k The factor by which <code>p</code> is multiplied.
            @return <code>p</code> multiplied by <code>k</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.DoubleAddMultiplier.MultiplyPositive(Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.BigInteger)">
            Joye's double-add algorithm.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.FixedPointPreCompInfo">
            Class holding precomputation data for fixed-point multiplications.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.PreCompInfo">
            Interface for classes storing precomputation data for multiplication
            algorithms. Used as a Memento (see GOF patterns) for
            <code>WNafMultiplier</code>.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Multiplier.FixedPointPreCompInfo.m_preComp">
            Array holding the precomputed <code>ECPoint</code>s used for a fixed
            point multiplication.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Multiplier.FixedPointPreCompInfo.m_width">
            The width used for the precomputation. If a larger width precomputation
            is already available this may be larger than was requested, so calling
            code should refer to the actual width.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.MixedNafR2LMultiplier">
            Class implementing the NAF (Non-Adjacent Form) multiplication algorithm (right-to-left) using
            mixed coordinates.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.MixedNafR2LMultiplier.#ctor">
            By default, addition will be done in Jacobian coordinates, and doubling will be done in
            Modified Jacobian coordinates (independent of the original coordinate system of each point).
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.MontgomeryLadderMultiplier.MultiplyPositive(Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.BigInteger)">
            Montgomery ladder.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.NafL2RMultiplier">
            Class implementing the NAF (Non-Adjacent Form) multiplication algorithm (left-to-right).
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.NafR2LMultiplier">
            Class implementing the NAF (Non-Adjacent Form) multiplication algorithm (right-to-left).
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.WNafL2RMultiplier">
            Class implementing the WNAF (Window Non-Adjacent Form) multiplication
            algorithm.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WNafL2RMultiplier.MultiplyPositive(Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.BigInteger)">
            Multiplies <code>this</code> by an integer <code>k</code> using the
            Window NAF method.
            @param k The integer by which <code>this</code> is multiplied.
            @return A new <code>ECPoint</code> which equals <code>this</code>
            multiplied by <code>k</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WNafL2RMultiplier.GetWindowSize(System.Int32)">
            Determine window width to use for a scalar multiplication of the given size.
            
            @param bits the bit-length of the scalar to multiply by
            @return the window size to use
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo">
            Class holding precomputation data for the WNAF (Window Non-Adjacent Form)
            algorithm.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo.m_preComp">
            Array holding the precomputed <code>ECPoint</code>s used for a Window
            NAF multiplication.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo.m_preCompNeg">
            Array holding the negations of the precomputed <code>ECPoint</code>s used
            for a Window NAF multiplication.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo.m_twice">
            Holds an <code>ECPoint</code> representing Twice(this). Used for the
            Window NAF multiplication to create or extend the precomputed values.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WNafUtilities.GenerateWindowNaf(System.Int32,Org.BouncyCastle.Math.BigInteger)">
            Computes the Window NAF (non-adjacent Form) of an integer.
            @param width The width <code>w</code> of the Window NAF. The width is
            defined as the minimal number <code>w</code>, such that for any
            <code>w</code> consecutive digits in the resulting representation, at
            most one is non-zero.
            @param k The integer of which the Window NAF is computed.
            @return The Window NAF of the given width, such that the following holds:
            <code>k = &amp;sum;<sub>i=0</sub><sup>l-1</sup> k<sub>i</sub>2<sup>i</sup>
            </code>, where the <code>k<sub>i</sub></code> denote the elements of the
            returned <code>byte[]</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WNafUtilities.GetWindowSize(System.Int32)">
            Determine window width to use for a scalar multiplication of the given size.
            
            @param bits the bit-length of the scalar to multiply by
            @return the window size to use
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WNafUtilities.GetWindowSize(System.Int32,System.Int32[])">
            Determine window width to use for a scalar multiplication of the given size.
            
            @param bits the bit-length of the scalar to multiply by
            @param windowSizeCutoffs a monotonically increasing list of bit sizes at which to increment the window width
            @return the window size to use
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier">
            Class implementing the WTNAF (Window
            <code>&#964;</code>-adic Non-Adjacent Form) algorithm.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier.MultiplyPositive(Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.BigInteger)">
            Multiplies a {@link org.bouncycastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by <code>k</code> using the reduced <code>&#964;</code>-adic NAF (RTNAF)
            method.
            @param p The AbstractF2mPoint to multiply.
            @param k The integer by which to multiply <code>k</code>.
            @return <code>p</code> multiplied by <code>k</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier.MultiplyWTnaf(Org.BouncyCastle.Math.EC.AbstractF2mPoint,Org.BouncyCastle.Math.EC.Abc.ZTauElement,Org.BouncyCastle.Math.EC.Multiplier.PreCompInfo,System.SByte,System.SByte)">
            Multiplies a {@link org.bouncycastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code> using
            the <code>&#964;</code>-adic NAF (TNAF) method.
            @param p The AbstractF2mPoint to multiply.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code> of which to compute the
            <code>[&#964;]</code>-adic NAF.
            @return <code>p</code> multiplied by <code>&#955;</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier.MultiplyFromWTnaf(Org.BouncyCastle.Math.EC.AbstractF2mPoint,System.SByte[],Org.BouncyCastle.Math.EC.Multiplier.PreCompInfo)">
            Multiplies a {@link org.bouncycastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>
            using the window <code>&#964;</code>-adic NAF (TNAF) method, given the
            WTNAF of <code>&#955;</code>.
            @param p The AbstractF2mPoint to multiply.
            @param u The the WTNAF of <code>&#955;</code>..
            @return <code>&#955; * p</code>
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.WTauNafPreCompInfo">
            Class holding precomputation data for the WTNAF (Window
            <code>&#964;</code>-adic Non-Adjacent Form) algorithm.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Multiplier.WTauNafPreCompInfo.m_preComp">
            Array holding the precomputed <code>AbstractF2mPoint</code>s used for the
            WTNAF multiplication in <code>
            {@link org.bouncycastle.math.ec.multiplier.WTauNafMultiplier.multiply()
            WTauNafMultiplier.multiply()}</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.ZSignedDigitL2RMultiplier.MultiplyPositive(Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.BigInteger)">
            'Zeroless' Signed Digit Left-to-Right.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.ZSignedDigitR2LMultiplier.MultiplyPositive(Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.BigInteger)">
            'Zeroless' Signed Digit Right-to-Left.
        </member>
        <member name="T:Org.BouncyCastle.Math.Primes">
            Utility methods for generating primes and testing for primality.
        </member>
        <member name="M:Org.BouncyCastle.Math.Primes.GenerateSTRandomPrime(Org.BouncyCastle.Crypto.IDigest,System.Int32,System.Byte[])">
            FIPS 186-4 C.6 Shawe-Taylor Random_Prime Routine
            
            Construct a provable prime number using a hash function.
            
            @param hash
                       the {@link Digest} instance to use (as "Hash()"). Cannot be null.
            @param length
                       the length (in bits) of the prime to be generated. Must be at least 2.
            @param inputSeed
                       the seed to be used for the generation of the requested prime. Cannot be null or
                       empty.
            @return an {@link STOutput} instance containing the requested prime.
        </member>
        <member name="M:Org.BouncyCastle.Math.Primes.EnhancedMRProbablePrimeTest(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Security.SecureRandom,System.Int32)">
            FIPS 186-4 C.3.2 Enhanced Miller-Rabin Probabilistic Primality Test
            
            Run several iterations of the Miller-Rabin algorithm with randomly-chosen bases. This is an
            alternative to {@link #isMRProbablePrime(BigInteger, SecureRandom, int)} that provides more
            information about a composite candidate, which may be useful when generating or validating
            RSA moduli.
            
            @param candidate
                       the {@link BigInteger} instance to test for primality.
            @param random
                       the source of randomness to use to choose bases.
            @param iterations
                       the number of randomly-chosen bases to perform the test for.
            @return an {@link MROutput} instance that can be further queried for details.
        </member>
        <member name="M:Org.BouncyCastle.Math.Primes.HasAnySmallFactors(Org.BouncyCastle.Math.BigInteger)">
            A fast check for small divisors, up to some implementation-specific limit.
            
            @param candidate
                       the {@link BigInteger} instance to test for division by small factors.
            
            @return <code>true</code> if the candidate is found to have any small factors,
                    <code>false</code> otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Math.Primes.IsMRProbablePrime(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Security.SecureRandom,System.Int32)">
            FIPS 186-4 C.3.1 Miller-Rabin Probabilistic Primality Test
            
            Run several iterations of the Miller-Rabin algorithm with randomly-chosen bases.
            
            @param candidate
                       the {@link BigInteger} instance to test for primality.
            @param random
                       the source of randomness to use to choose bases.
            @param iterations
                       the number of randomly-chosen bases to perform the test for.
            @return <code>false</code> if any witness to compositeness is found amongst the chosen bases
                    (so <code>candidate</code> is definitely NOT prime), or else <code>true</code>
                    (indicating primality with some probability dependent on the number of iterations
                    that were performed).
        </member>
        <member name="M:Org.BouncyCastle.Math.Primes.IsMRProbablePrimeToBase(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            FIPS 186-4 C.3.1 Miller-Rabin Probabilistic Primality Test (to a fixed base).
            
            Run a single iteration of the Miller-Rabin algorithm against the specified base.
            
            @param candidate
                       the {@link BigInteger} instance to test for primality.
            @param baseValue
                       the base value to use for this iteration.
            @return <code>false</code> if the specified base is a witness to compositeness (so
                    <code>candidate</code> is definitely NOT prime), or else <code>true</code>.
        </member>
        <member name="T:Org.BouncyCastle.Math.Primes.MROutput">
            Used to return the output from the
            {@linkplain Primes#enhancedMRProbablePrimeTest(BigInteger, SecureRandom, int) Enhanced
            Miller-Rabin Probabilistic Primality Test}
        </member>
        <member name="T:Org.BouncyCastle.Math.Primes.STOutput">
            Used to return the output from the {@linkplain Primes#generateSTRandomPrime(Digest, int, byte[]) Shawe-Taylor Random_Prime Routine} 
        </member>
        <member name="T:Org.BouncyCastle.Ocsp.BasicOcspResp">
            <remarks>
            <code>
            BasicOcspResponse ::= SEQUENCE {
            	tbsResponseData		ResponseData,
            	signatureAlgorithm	AlgorithmIdentifier,
            	signature			BIT STRING,
            	certs				[0] EXPLICIT SEQUENCE OF Certificate OPTIONAL
            }
            </code>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.X509.IX509Extension.GetCriticalExtensionOids">
            <summary>
            Get all critical extension values, by oid
            </summary>
            <returns>IDictionary with string (OID) keys and Asn1OctetString values</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.IX509Extension.GetNonCriticalExtensionOids">
            <summary>
            Get all non-critical extension values, by oid
            </summary>
            <returns>IDictionary with string (OID) keys and Asn1OctetString values</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509ExtensionBase.GetNonCriticalExtensionOids">
            <summary>
            Get non critical extensions.
            </summary>
            <returns>A set of non critical extension oids.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509ExtensionBase.GetCriticalExtensionOids">
            <summary>
            Get any critical extensions.
            </summary>
            <returns>A sorted list of critical entension.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509ExtensionBase.GetExtensionValue(System.String)">
            <summary>
            Get the value of a given extension.
            </summary>
            <param name="oid">The object ID of the extension. </param>
            <returns>An Asn1OctetString object if that extension is found or null if not.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.BasicOcspResp.GetTbsResponseData">
            <returns>The DER encoding of the tbsResponseData field.</returns>
            <exception cref="T:Org.BouncyCastle.Ocsp.OcspException">In the event of an encoding error.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.BasicOcspResp.GetCertificates(System.String)">
            <returns>The certificates, if any, associated with the response.</returns>
            <exception cref="T:Org.BouncyCastle.Ocsp.OcspException">In the event of an encoding error.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.BasicOcspResp.Verify(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Verify the signature against the tbsResponseData object we contain.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.BasicOcspResp.GetEncoded">
            <returns>The ASN.1 encoded representation of this object.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Ocsp.BasicOcspRespGenerator">
            Generator for basic OCSP response objects.
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.BasicOcspRespGenerator.#ctor(Org.BouncyCastle.Ocsp.RespID)">
            basic constructor
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.BasicOcspRespGenerator.#ctor(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            construct with the responderID to be the SHA-1 keyHash of the passed in public key.
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.BasicOcspRespGenerator.AddResponse(Org.BouncyCastle.Ocsp.CertificateID,Org.BouncyCastle.Ocsp.CertificateStatus)">
             Add a response for a particular Certificate ID.
            
             @param certID certificate ID details
             @param certStatus status of the certificate - null if okay
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.BasicOcspRespGenerator.AddResponse(Org.BouncyCastle.Ocsp.CertificateID,Org.BouncyCastle.Ocsp.CertificateStatus,Org.BouncyCastle.Asn1.X509.X509Extensions)">
             Add a response for a particular Certificate ID.
            
             @param certID certificate ID details
             @param certStatus status of the certificate - null if okay
             @param singleExtensions optional extensions
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.BasicOcspRespGenerator.AddResponse(Org.BouncyCastle.Ocsp.CertificateID,Org.BouncyCastle.Ocsp.CertificateStatus,System.DateTime,Org.BouncyCastle.Asn1.X509.X509Extensions)">
             Add a response for a particular Certificate ID.
            
             @param certID certificate ID details
             @param nextUpdate date when next update should be requested
             @param certStatus status of the certificate - null if okay
             @param singleExtensions optional extensions
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.BasicOcspRespGenerator.AddResponse(Org.BouncyCastle.Ocsp.CertificateID,Org.BouncyCastle.Ocsp.CertificateStatus,System.DateTime,System.DateTime,Org.BouncyCastle.Asn1.X509.X509Extensions)">
             Add a response for a particular Certificate ID.
            
             @param certID certificate ID details
             @param thisUpdate date this response was valid on
             @param nextUpdate date when next update should be requested
             @param certStatus status of the certificate - null if okay
             @param singleExtensions optional extensions
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.BasicOcspRespGenerator.SetResponseExtensions(Org.BouncyCastle.Asn1.X509.X509Extensions)">
             Set the extensions for the response.
            
             @param responseExtensions the extension object to carry.
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.BasicOcspRespGenerator.Generate(Org.BouncyCastle.Crypto.ISignatureFactory,Org.BouncyCastle.X509.X509Certificate[],System.DateTime)">
            <summary>
            Generate the signed response using the passed in signature calculator.
            </summary>
            <param name="signatureCalculatorFactory">Implementation of signing calculator factory.</param>
            <param name="chain">The certificate chain associated with the response signer.</param>
            <param name="producedAt">"produced at" date.</param>
            <returns></returns>
        </member>
        <member name="P:Org.BouncyCastle.Ocsp.BasicOcspRespGenerator.SignatureAlgNames">
             Return an IEnumerable of the signature names supported by the generator.
            
             @return an IEnumerable containing recognised names.
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.CertificateID.#ctor(System.String,Org.BouncyCastle.X509.X509Certificate,Org.BouncyCastle.Math.BigInteger)">
            create from an issuer certificate and the serial number of the
            certificate it signed.
            @exception OcspException if any problems occur creating the id fields.
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.CertificateID.DeriveCertificateID(Org.BouncyCastle.Ocsp.CertificateID,Org.BouncyCastle.Math.BigInteger)">
             Create a new CertificateID for a new serial number derived from a previous one
             calculated for the same CA certificate.
            
             @param original the previously calculated CertificateID for the CA.
             @param newSerialNumber the serial number for the new certificate of interest.
            
             @return a new CertificateID for newSerialNumber
        </member>
        <member name="P:Org.BouncyCastle.Ocsp.CertificateID.SerialNumber">
            return the serial number for the certificate associated
            with this request.
        </member>
        <member name="T:Org.BouncyCastle.Ocsp.OcspReq">
             <pre>
             OcspRequest     ::=     SEQUENCE {
                   tbsRequest                  TBSRequest,
                   optionalSignature   [0]     EXPLICIT Signature OPTIONAL }
            
               TBSRequest      ::=     SEQUENCE {
                   version             [0]     EXPLICIT Version DEFAULT v1,
                   requestorName       [1]     EXPLICIT GeneralName OPTIONAL,
                   requestList                 SEQUENCE OF Request,
                   requestExtensions   [2]     EXPLICIT Extensions OPTIONAL }
            
               Signature       ::=     SEQUENCE {
                   signatureAlgorithm      AlgorithmIdentifier,
                   signature               BIT STRING,
                   certs               [0] EXPLICIT SEQUENCE OF Certificate OPTIONAL}
            
               Version         ::=             INTEGER  {  v1(0) }
            
               Request         ::=     SEQUENCE {
                   reqCert                     CertID,
                   singleRequestExtensions     [0] EXPLICIT Extensions OPTIONAL }
            
               CertID          ::=     SEQUENCE {
                   hashAlgorithm       AlgorithmIdentifier,
                   issuerNameHash      OCTET STRING, -- Hash of Issuer's DN
                   issuerKeyHash       OCTET STRING, -- Hash of Issuers public key
                   serialNumber        CertificateSerialNumber }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.OcspReq.GetTbsRequest">
            Return the DER encoding of the tbsRequest field.
            @return DER encoding of tbsRequest
            @throws OcspException in the event of an encoding error.
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.OcspReq.GetCertificates(System.String)">
             If the request is signed return a possibly empty CertStore containing the certificates in the
             request. If the request is not signed the method returns null.
            
             @return null if not signed, a CertStore otherwise
             @throws OcspException
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.OcspReq.Verify(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            Verify the signature against the TBSRequest object we contain.
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.OcspReq.GetEncoded">
            return the ASN.1 encoded representation of this object.
        </member>
        <member name="P:Org.BouncyCastle.Ocsp.OcspReq.SignatureAlgOid">
            return the object identifier representing the signature algorithm
        </member>
        <member name="P:Org.BouncyCastle.Ocsp.OcspReq.IsSigned">
             Return whether or not this request is signed.
            
             @return true if signed false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.OcspReqGenerator.AddRequest(Org.BouncyCastle.Ocsp.CertificateID)">
             Add a request for the given CertificateID.
            
             @param certId certificate ID of interest
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.OcspReqGenerator.AddRequest(Org.BouncyCastle.Ocsp.CertificateID,Org.BouncyCastle.Asn1.X509.X509Extensions)">
             Add a request with extensions
            
             @param certId certificate ID of interest
             @param singleRequestExtensions the extensions to attach to the request
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.OcspReqGenerator.SetRequestorName(Org.BouncyCastle.Asn1.X509.X509Name)">
             Set the requestor name to the passed in X509Principal
            
             @param requestorName a X509Principal representing the requestor name.
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.OcspReqGenerator.Generate">
             Generate an unsigned request
            
             @return the OcspReq
             @throws OcspException
        </member>
        <member name="P:Org.BouncyCastle.Ocsp.OcspReqGenerator.SignatureAlgNames">
             Return an IEnumerable of the signature names supported by the generator.
            
             @return an IEnumerable containing recognised names.
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.OcspResp.GetEncoded">
            return the ASN.1 encoded representation of this object.
        </member>
        <member name="T:Org.BouncyCastle.Ocsp.OCSPRespGenerator">
            base generator for an OCSP response - at the moment this only supports the
            generation of responses containing BasicOCSP responses.
        </member>
        <member name="F:Org.BouncyCastle.Ocsp.OcspRespStatus.Successful">
            note 4 is not used.
        </member>
        <member name="T:Org.BouncyCastle.Ocsp.RespID">
            Carrier for a ResponderID.
        </member>
        <member name="T:Org.BouncyCastle.Ocsp.RevokedStatus">
            wrapper for the RevokedInfo object
        </member>
        <member name="P:Org.BouncyCastle.Ocsp.RevokedStatus.RevocationReason">
            return the revocation reason. Note: this field is optional, test for it
            with hasRevocationReason() first.
            @exception InvalidOperationException if a reason is asked for and none is avaliable
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.SingleResp.GetCertStatus">
             Return the status object for the response - null indicates good.
            
             @return the status object for the response, null if it is good.
        </member>
        <member name="P:Org.BouncyCastle.Ocsp.SingleResp.NextUpdate">
             return the NextUpdate value - note: this is an optional field so may
             be returned as null.
            
             @return nextUpdate, or null if not present.
        </member>
        <member name="T:Org.BouncyCastle.Ocsp.UnknownStatus">
            wrapper for the UnknownInfo object
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpCompressedData">
            <remarks>Compressed data objects</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpCompressedData.GetInputStream">
            <summary>Get the raw input stream contained in the object.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpCompressedData.GetDataStream">
            <summary>Return an uncompressed input stream which allows reading of the compressed data.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpCompressedData.Algorithm">
            <summary>The algorithm used for compression</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpCompressedDataGenerator">
            <remarks>Class for producing compressed data packets.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpCompressedDataGenerator.Open(System.IO.Stream)">
            <summary>
            <p>
            Return an output stream which will save the data being written to
            the compressed object.
            </p>
            <p>
            The stream created can be closed off by either calling Close()
            on the stream or Close() on the generator. Closing the returned
            stream does not close off the Stream parameter <c>outStr</c>.
            </p>
            </summary>
            <param name="outStr">Stream to be used for output.</param>
            <returns>A Stream for output of the compressed data.</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpCompressedDataGenerator.Open(System.IO.Stream,System.Byte[])">
            <summary>
            <p>
            Return an output stream which will compress the data as it is written to it.
            The stream will be written out in chunks according to the size of the passed in buffer.
            </p>
            <p>
            The stream created can be closed off by either calling Close()
            on the stream or Close() on the generator. Closing the returned
            stream does not close off the Stream parameter <c>outStr</c>.
            </p>
            <p>
            <b>Note</b>: if the buffer is not a power of 2 in length only the largest power of 2
            bytes worth of the buffer will be used.
            </p>
            <p>
            <b>Note</b>: using this may break compatibility with RFC 1991 compliant tools.
            Only recent OpenPGP implementations are capable of accepting these streams.
            </p>
            </summary>
            <param name="outStr">Stream to be used for output.</param>
            <param name="buffer">The buffer to use.</param>
            <returns>A Stream for output of the compressed data.</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpCompressedDataGenerator.Close">
            <summary>Close the compressed object.</summary>summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpDataValidationException">
            <remarks>
            Thrown if the IV at the start of a data stream indicates the wrong key is being used.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpException">
            <remarks>Generic exception class for PGP encoding/decoding problems.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedData.GetInputStream">
            <summary>Return the raw input stream for the data stream.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedData.IsIntegrityProtected">
            <summary>Return true if the message is integrity protected.</summary>
            <returns>True, if there is a modification detection code namespace associated
            with this stream.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedData.Verify">
            <summary>Note: This can only be called after the message has been read.</summary>
            <returns>True, if the message verifies, false otherwise</returns>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator">
            <remarks>Generator for encrypted objects.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator.#ctor(Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,Org.BouncyCastle.Security.SecureRandom)">
            <summary>Existing SecureRandom constructor.</summary>
            <param name="encAlgorithm">The symmetric algorithm to use.</param>
            <param name="rand">Source of randomness.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator.#ctor(Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,System.Boolean,Org.BouncyCastle.Security.SecureRandom)">
            <summary>Creates a cipher stream which will have an integrity packet associated with it.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator.#ctor(Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,Org.BouncyCastle.Security.SecureRandom,System.Boolean)">
            <summary>Base constructor.</summary>
            <param name="encAlgorithm">The symmetric algorithm to use.</param>
            <param name="rand">Source of randomness.</param>
            <param name="oldFormat">PGP 2.6.x compatibility required.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator.AddMethod(System.Char[])">
            <summary>
            Add a PBE encryption method to the encrypted object using the default algorithm (S2K_SHA1).
            </summary>
            <remarks>
            Conversion of the passphrase characters to bytes is performed using Convert.ToByte(), which is
            the historical behaviour of the library (1.7 and earlier).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator.AddMethod(System.Char[],Org.BouncyCastle.Bcpg.HashAlgorithmTag)">
            <summary>Add a PBE encryption method to the encrypted object.</summary>
            <remarks>
            Conversion of the passphrase characters to bytes is performed using Convert.ToByte(), which is
            the historical behaviour of the library (1.7 and earlier).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator.AddMethodUtf8(System.Char[],Org.BouncyCastle.Bcpg.HashAlgorithmTag)">
            <summary>Add a PBE encryption method to the encrypted object.</summary>
            <remarks>
            The passphrase is encoded to bytes using UTF8 (Encoding.UTF8.GetBytes).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator.AddMethodRaw(System.Byte[],Org.BouncyCastle.Bcpg.HashAlgorithmTag)">
            <summary>Add a PBE encryption method to the encrypted object.</summary>
            <remarks>
            Allows the caller to handle the encoding of the passphrase to bytes.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator.AddMethod(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>Add a public key encrypted session key to the encrypted object.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator.Open(System.IO.Stream,System.Int64,System.Byte[])">
            <summary>
            <p>
            If buffer is non null stream assumed to be partial, otherwise the length will be used
            to output a fixed length packet.
            </p>
            <p>
            The stream created can be closed off by either calling Close()
            on the stream or Close() on the generator. Closing the returned
            stream does not close off the Stream parameter <c>outStr</c>.
            </p>
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator.Open(System.IO.Stream,System.Int64)">
            <summary>
            <p>
            Return an output stream which will encrypt the data as it is written to it.
            </p>
            <p>
            The stream created can be closed off by either calling Close()
            on the stream or Close() on the generator. Closing the returned
            stream does not close off the Stream parameter <c>outStr</c>.
            </p>
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator.Open(System.IO.Stream,System.Byte[])">
            <summary>
            <p>
            Return an output stream which will encrypt the data as it is written to it.
            The stream will be written out in chunks according to the size of the passed in buffer.
            </p>
            <p>
            The stream created can be closed off by either calling Close()
            on the stream or Close() on the generator. Closing the returned
            stream does not close off the Stream parameter <c>outStr</c>.
            </p>
            <p>
            <b>Note</b>: if the buffer is not a power of 2 in length only the largest power of 2
            bytes worth of the buffer will be used.
            </p>
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataGenerator.Close">
            <summary>
            <p>
            Close off the encrypted object - this is equivalent to calling Close() on the stream
            returned by the Open() method.
            </p>
            <p>
            <b>Note</b>: This does not close the underlying output stream, only the stream on top of
            it created by the Open() method.
            </p>
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpEncryptedDataList">
            <remarks>A holder for a list of PGP encryption method packets.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyFlags">
            <remarks>Key flag values for the KeyFlags subpacket.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair">
            <remarks>
            General class to handle JCA key pairs and convert them into OpenPGP ones.
            <p>
            A word for the unwary, the KeyId for an OpenPGP public key is calculated from
            a hash that includes the time of creation, if you pass a different date to the
            constructor below with the same public private key pair the KeyIs will not be the
            same as for previous generations of the key, so ideally you only want to do
            this once.
            </p>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair.#ctor(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey,Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey)">
            <summary>Create a key pair from a PgpPrivateKey and a PgpPublicKey.</summary>
            <param name="pub">The public key.</param>
            <param name="priv">The private key.</param>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair.KeyId">
            <summary>The keyId associated with this key pair.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator">
            <remarks>
            Generator for a PGP master and subkey ring.
            This class will generate both the secret and public key rings
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator.#ctor(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,System.String,Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,System.Char[],Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Create a new key ring generator using old style checksumming. It is recommended to use
            SHA1 checksumming where possible.
            </summary>
            <remarks>
            Conversion of the passphrase characters to bytes is performed using Convert.ToByte(), which is
            the historical behaviour of the library (1.7 and earlier).
            </remarks>
            <param name="certificationLevel">The certification level for keys on this ring.</param>
            <param name="masterKey">The master key pair.</param>
            <param name="id">The id to be associated with the ring.</param>
            <param name="encAlgorithm">The algorithm to be used to protect secret keys.</param>
            <param name="passPhrase">The passPhrase to be used to protect secret keys.</param>
            <param name="hashedPackets">Packets to be included in the certification hash.</param>
            <param name="unhashedPackets">Packets to be attached unhashed to the certification.</param>
            <param name="rand">input secured random.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator.#ctor(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,System.String,Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,System.Char[],System.Boolean,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Create a new key ring generator.
            </summary>
            <remarks>
            Conversion of the passphrase characters to bytes is performed using Convert.ToByte(), which is
            the historical behaviour of the library (1.7 and earlier).
            </remarks>
            <param name="certificationLevel">The certification level for keys on this ring.</param>
            <param name="masterKey">The master key pair.</param>
            <param name="id">The id to be associated with the ring.</param>
            <param name="encAlgorithm">The algorithm to be used to protect secret keys.</param>
            <param name="passPhrase">The passPhrase to be used to protect secret keys.</param>
            <param name="useSha1">Checksum the secret keys with SHA1 rather than the older 16 bit checksum.</param>
            <param name="hashedPackets">Packets to be included in the certification hash.</param>
            <param name="unhashedPackets">Packets to be attached unhashed to the certification.</param>
            <param name="rand">input secured random.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator.#ctor(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,System.String,Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,System.Boolean,System.Char[],System.Boolean,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Create a new key ring generator.
            </summary>
            <param name="certificationLevel">The certification level for keys on this ring.</param>
            <param name="masterKey">The master key pair.</param>
            <param name="id">The id to be associated with the ring.</param>
            <param name="encAlgorithm">The algorithm to be used to protect secret keys.</param>
            <param name="utf8PassPhrase">
            If true, conversion of the passphrase to bytes uses Encoding.UTF8.GetBytes(), otherwise the conversion
            is performed using Convert.ToByte(), which is the historical behaviour of the library (1.7 and earlier).
            </param>
            <param name="passPhrase">The passPhrase to be used to protect secret keys.</param>
            <param name="useSha1">Checksum the secret keys with SHA1 rather than the older 16 bit checksum.</param>
            <param name="hashedPackets">Packets to be included in the certification hash.</param>
            <param name="unhashedPackets">Packets to be attached unhashed to the certification.</param>
            <param name="rand">input secured random.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator.#ctor(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,System.String,Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,System.Byte[],System.Boolean,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Create a new key ring generator.
            </summary>
            <param name="certificationLevel">The certification level for keys on this ring.</param>
            <param name="masterKey">The master key pair.</param>
            <param name="id">The id to be associated with the ring.</param>
            <param name="encAlgorithm">The algorithm to be used to protect secret keys.</param>
            <param name="rawPassPhrase">The passPhrase to be used to protect secret keys.</param>
            <param name="useSha1">Checksum the secret keys with SHA1 rather than the older 16 bit checksum.</param>
            <param name="hashedPackets">Packets to be included in the certification hash.</param>
            <param name="unhashedPackets">Packets to be attached unhashed to the certification.</param>
            <param name="rand">input secured random.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator.#ctor(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,System.String,Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,Org.BouncyCastle.Bcpg.HashAlgorithmTag,System.Char[],System.Boolean,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Create a new key ring generator.
            </summary>
            <remarks>
            Conversion of the passphrase characters to bytes is performed using Convert.ToByte(), which is
            the historical behaviour of the library (1.7 and earlier).
            </remarks>
            <param name="certificationLevel">The certification level for keys on this ring.</param>
            <param name="masterKey">The master key pair.</param>
            <param name="id">The id to be associated with the ring.</param>
            <param name="encAlgorithm">The algorithm to be used to protect secret keys.</param>
            <param name="hashAlgorithm">The hash algorithm.</param>
            <param name="passPhrase">The passPhrase to be used to protect secret keys.</param>
            <param name="useSha1">Checksum the secret keys with SHA1 rather than the older 16 bit checksum.</param>
            <param name="hashedPackets">Packets to be included in the certification hash.</param>
            <param name="unhashedPackets">Packets to be attached unhashed to the certification.</param>
            <param name="rand">input secured random.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator.#ctor(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,System.String,Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,Org.BouncyCastle.Bcpg.HashAlgorithmTag,System.Boolean,System.Char[],System.Boolean,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Create a new key ring generator.
            </summary>
            <param name="certificationLevel">The certification level for keys on this ring.</param>
            <param name="masterKey">The master key pair.</param>
            <param name="id">The id to be associated with the ring.</param>
            <param name="encAlgorithm">The algorithm to be used to protect secret keys.</param>
            <param name="hashAlgorithm">The hash algorithm.</param>
            <param name="utf8PassPhrase">
            If true, conversion of the passphrase to bytes uses Encoding.UTF8.GetBytes(), otherwise the conversion
            is performed using Convert.ToByte(), which is the historical behaviour of the library (1.7 and earlier).
            </param>
            <param name="passPhrase">The passPhrase to be used to protect secret keys.</param>
            <param name="useSha1">Checksum the secret keys with SHA1 rather than the older 16 bit checksum.</param>
            <param name="hashedPackets">Packets to be included in the certification hash.</param>
            <param name="unhashedPackets">Packets to be attached unhashed to the certification.</param>
            <param name="rand">input secured random.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator.#ctor(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,System.String,Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,Org.BouncyCastle.Bcpg.HashAlgorithmTag,System.Byte[],System.Boolean,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Create a new key ring generator.
            </summary>
            <remarks>
            Allows the caller to handle the encoding of the passphrase to bytes.
            </remarks>
            <param name="certificationLevel">The certification level for keys on this ring.</param>
            <param name="masterKey">The master key pair.</param>
            <param name="id">The id to be associated with the ring.</param>
            <param name="encAlgorithm">The algorithm to be used to protect secret keys.</param>
            <param name="hashAlgorithm">The hash algorithm.</param>
            <param name="rawPassPhrase">The passPhrase to be used to protect secret keys.</param>
            <param name="useSha1">Checksum the secret keys with SHA1 rather than the older 16 bit checksum.</param>
            <param name="hashedPackets">Packets to be included in the certification hash.</param>
            <param name="unhashedPackets">Packets to be attached unhashed to the certification.</param>
            <param name="rand">input secured random.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator.AddSubKey(Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair)">
            <summary>Add a subkey to the key ring to be generated with default certification.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator.AddSubKey(Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,Org.BouncyCastle.Bcpg.HashAlgorithmTag)">
            <summary>
            Add a subkey to the key ring to be generated with default certification.
            </summary>
            <param name="keyPair">The key pair.</param>
            <param name="hashAlgorithm">The hash algorithm.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator.AddSubKey(Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector)">
            <summary>
            Add a subkey with specific hashed and unhashed packets associated with it and
            default certification.
            </summary>
            <param name="keyPair">Public/private key pair.</param>
            <param name="hashedPackets">Hashed packet values to be included in certification.</param>
            <param name="unhashedPackets">Unhashed packets values to be included in certification.</param>
            <exception cref="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator.AddSubKey(Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.HashAlgorithmTag)">
            <summary>
            Add a subkey with specific hashed and unhashed packets associated with it and
            default certification.
            </summary>
            <param name="keyPair">Public/private key pair.</param>
            <param name="hashedPackets">Hashed packet values to be included in certification.</param>
            <param name="unhashedPackets">Unhashed packets values to be included in certification.</param>
            <param name="hashAlgorithm">The hash algorithm.</param>
            <exception cref="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpException">exception adding subkey: </exception>
            <exception cref="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator.GenerateSecretKeyRing">
            <summary>Return the secret key ring.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyRingGenerator.GeneratePublicKeyRing">
            <summary>Return the public key ring that corresponds to the secret key ring.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyValidationException">
            <remarks>
            Thrown if the key checksum is invalid.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralData">
            <summary>Class for processing literal data objects.</summary>
        </member>
        <member name="F:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralData.Console">
            <summary>The special name indicating a "for your eyes only" packet.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralData.GetRawFileName">
            Return the file name as an unintrepreted byte array.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralData.GetInputStream">
            <summary>The raw input stream for the data stream.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralData.GetDataStream">
            <summary>The input stream representing the data stream.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralData.Format">
            <summary>The format of the data stream - Binary or Text</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralData.FileName">
            <summary>The file name that's associated with the data stream.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralData.ModificationTime">
            <summary>The modification time for the file.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralDataGenerator">
            <remarks>Class for producing literal data packets.</remarks>
        </member>
        <member name="F:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralDataGenerator.Console">
            <summary>The special name indicating a "for your eyes only" packet.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralDataGenerator.#ctor(System.Boolean)">
            <summary>
            Generates literal data objects in the old format.
            This is important if you need compatibility with PGP 2.6.x.
            </summary>
            <param name="oldFormat">If true, uses old format.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralDataGenerator.Open(System.IO.Stream,System.Char,System.String,System.Int64,System.DateTime)">
            <summary>
            <p>
            Open a literal data packet, returning a stream to store the data inside the packet.
            </p>
            <p>
            The stream created can be closed off by either calling Close()
            on the stream or Close() on the generator. Closing the returned
            stream does not close off the Stream parameter <c>outStr</c>.
            </p>
            </summary>
            <param name="outStr">The stream we want the packet in.</param>
            <param name="format">The format we are using.</param>
            <param name="name">The name of the 'file'.</param>
            <param name="length">The length of the data we will write.</param>
            <param name="modificationTime">The time of last modification we want stored.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralDataGenerator.Open(System.IO.Stream,System.Char,System.String,System.DateTime,System.Byte[])">
            <summary>
            <p>
            Open a literal data packet, returning a stream to store the data inside the packet,
            as an indefinite length stream. The stream is written out as a series of partial
            packets with a chunk size determined by the size of the passed in buffer.
            </p>
            <p>
            The stream created can be closed off by either calling Close()
            on the stream or Close() on the generator. Closing the returned
            stream does not close off the Stream parameter <c>outStr</c>.
            </p>
            <p>
            <b>Note</b>: if the buffer is not a power of 2 in length only the largest power of 2
            bytes worth of the buffer will be used.</p>
            </summary>
            <param name="outStr">The stream we want the packet in.</param>
            <param name="format">The format we are using.</param>
            <param name="name">The name of the 'file'.</param>
            <param name="modificationTime">The time of last modification we want stored.</param>
            <param name="buffer">The buffer to use for collecting data to put into chunks.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralDataGenerator.Open(System.IO.Stream,System.Char,System.IO.FileInfo)">
            <summary>
            <p>
            Open a literal data packet for the passed in <c>FileInfo</c> object, returning
            an output stream for saving the file contents.
            </p>
            <p>
            The stream created can be closed off by either calling Close()
            on the stream or Close() on the generator. Closing the returned
            stream does not close off the Stream parameter <c>outStr</c>.
            </p>
            </summary>
            <param name="outStr">The stream we want the packet in.</param>
            <param name="format">The format we are using.</param>
            <param name="file">The <c>FileInfo</c> object containg the packet details.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpLiteralDataGenerator.Close">
            <summary>
            Close the literal data packet - this is equivalent to calling Close()
            on the stream returned by the Open() method.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpMarker">
            <remarks>
            A PGP marker packet - in general these should be ignored other than where
            the idea is to preserve the original input stream.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpObjectFactory">
            <remarks>
            General class for reading a PGP object stream.
            <p>
            Note: if this class finds a PgpPublicKey or a PgpSecretKey it
            will create a PgpPublicKeyRing, or a PgpSecretKeyRing for each
            key found. If all you are trying to do is read a key ring file use
            either PgpPublicKeyRingBundle or PgpSecretKeyRingBundle.</p>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpObjectFactory.NextPgpObject">
            <summary>Return the next object in the stream, or null if the end is reached.</summary>
            <exception cref="T:System.IO.IOException">On a parse error</exception>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpObjectFactory.AllPgpObjects">
            <summary>
            Return all available objects in a list.
            </summary>
            <returns>An <c>IList</c> containing all objects from this factory, in order.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpOnePassSignature">
            <remarks>A one pass signature object.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpOnePassSignature.InitVerify(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>Initialise the signature object for verification.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpOnePassSignature.Verify(Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature)">
            <summary>Verify the calculated signature against the passed in PgpSignature.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpOnePassSignatureList">
            <remarks>Holder for a list of PgpOnePassSignature objects.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpPad">
            <remarks>Padding functions.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpPbeEncryptedData">
            <remarks>A password based encryption object.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPbeEncryptedData.GetInputStream">
            <summary>Return the raw input stream for the data stream.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPbeEncryptedData.GetDataStream(System.Char[])">
            <summary>Return the decrypted input stream, using the passed in passphrase.</summary>
            <remarks>
            Conversion of the passphrase characters to bytes is performed using Convert.ToByte(), which is
            the historical behaviour of the library (1.7 and earlier).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPbeEncryptedData.GetDataStreamUtf8(System.Char[])">
            <summary>Return the decrypted input stream, using the passed in passphrase.</summary>
            <remarks>
            The passphrase is encoded to bytes using UTF8 (Encoding.UTF8.GetBytes).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPbeEncryptedData.GetDataStreamRaw(System.Byte[])">
            <summary>Return the decrypted input stream, using the passed in passphrase.</summary>
            <remarks>
            Allows the caller to handle the encoding of the passphrase to bytes.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey">
            <remarks>General class to contain a private key for use with other OpenPGP objects.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey.#ctor(System.Int64,Org.BouncyCastle.Bcpg.PublicKeyPacket,Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Create a PgpPrivateKey from a keyID, the associated public data packet, and a regular private key.
            </summary>
            <param name="keyID">ID of the corresponding public key.</param>
            <param name="publicKeyPacket">the public key data packet to be associated with this private key.</param>
            <param name="privateKey">the private key data packet to be associated with this private key.</param>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey.KeyId">
            <summary>The keyId associated with the contained private key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey.PublicKeyPacket">
            <summary>The public key packet associated with this private key, if available.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey.Key">
            <summary>The contained private key.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey">
            <remarks>General class to handle a PGP public key object.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.#ctor(Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag,Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.DateTime)">
            <summary>
            Create a PgpPublicKey from the passed in lightweight one.
            </summary>
            <remarks>
            Note: the time passed in affects the value of the key's keyId, so you probably only want
            to do this once for a lightweight key, or make sure you keep track of the time you used.
            </remarks>
            <param name="algorithm">Asymmetric algorithm type representing the public key.</param>
            <param name="pubKey">Actual public key to associate.</param>
            <param name="time">Date of creation.</param>
            <exception cref="T:System.ArgumentException">If <c>pubKey</c> is not public.</exception>
            <exception cref="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpException">On key creation problem.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.#ctor(Org.BouncyCastle.Bcpg.PublicKeyPacket,Org.BouncyCastle.Bcpg.TrustPacket,System.Collections.IList)">
            <summary>Constructor for a sub-key.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.#ctor(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>Copy constructor.</summary>
            <param name="pubKey">The public key to copy.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.GetTrustData">
            <summary>Return the trust data associated with the public key, if present.</summary>
            <returns>A byte array with trust data, null otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.GetValidSeconds">
            <summary>The number of valid seconds from creation time - zero means no expiry.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.GetFingerprint">
            <summary>The fingerprint of the key</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.GetKey">
            <summary>The public key contained in the object.</summary>
            <returns>A lightweight public key.</returns>
            <exception cref="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpException">If the key algorithm is not recognised.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.GetUserIds">
            <summary>Allows enumeration of any user IDs associated with the key.</summary>
            <returns>An <c>IEnumerable</c> of <c>string</c> objects.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.GetUserAttributes">
            <summary>Allows enumeration of any user attribute vectors associated with the key.</summary>
            <returns>An <c>IEnumerable</c> of <c>PgpUserAttributeSubpacketVector</c> objects.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.GetSignaturesForId(System.String)">
            <summary>Allows enumeration of any signatures associated with the passed in id.</summary>
            <param name="id">The ID to be matched.</param>
            <returns>An <c>IEnumerable</c> of <c>PgpSignature</c> objects.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.GetSignaturesForUserAttribute(Org.BouncyCastle.Bcpg.OpenPgp.PgpUserAttributeSubpacketVector)">
            <summary>Allows enumeration of signatures associated with the passed in user attributes.</summary>
            <param name="userAttributes">The vector of user attributes to be matched.</param>
            <returns>An <c>IEnumerable</c> of <c>PgpSignature</c> objects.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.GetSignaturesOfType(System.Int32)">
            <summary>Allows enumeration of signatures of the passed in type that are on this key.</summary>
            <param name="signatureType">The type of the signature to be returned.</param>
            <returns>An <c>IEnumerable</c> of <c>PgpSignature</c> objects.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.GetSignatures">
            <summary>Allows enumeration of all signatures/certifications associated with this key.</summary>
            <returns>An <c>IEnumerable</c> with all signatures/certifications.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.GetKeySignatures">
             Return all signatures/certifications directly associated with this key (ie, not to a user id).
            
             @return an iterator (possibly empty) with all signatures/certifications.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.IsRevoked">
            <summary>Check whether this (sub)key has a revocation signature on it.</summary>
            <returns>True, if this (sub)key has been revoked.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.AddCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey,System.String,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature)">
            <summary>Add a certification for an id to the given public key.</summary>
            <param name="key">The key the certification is to be added to.</param>
            <param name="id">The ID the certification is associated with.</param>
            <param name="certification">The new certification.</param>
            <returns>The re-certified key.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.AddCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey,Org.BouncyCastle.Bcpg.OpenPgp.PgpUserAttributeSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature)">
            <summary>Add a certification for the given UserAttributeSubpackets to the given public key.</summary>
            <param name="key">The key the certification is to be added to.</param>
            <param name="userAttributes">The attributes the certification is associated with.</param>
            <param name="certification">The new certification.</param>
            <returns>The re-certified key.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.RemoveCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey,Org.BouncyCastle.Bcpg.OpenPgp.PgpUserAttributeSubpacketVector)">
            <summary>
            Remove any certifications associated with a user attribute subpacket on a key.
            </summary>
            <param name="key">The key the certifications are to be removed from.</param>
            <param name="userAttributes">The attributes to be removed.</param>
            <returns>
            The re-certified key, or null if the user attribute subpacket was not found on the key.
            </returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.RemoveCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey,System.String)">
            <summary>Remove any certifications associated with a given ID on a key.</summary>
            <param name="key">The key the certifications are to be removed from.</param>
            <param name="id">The ID that is to be removed.</param>
            <returns>The re-certified key, or null if the ID was not found on the key.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.RemoveCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey,System.String,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature)">
            <summary>Remove a certification associated with a given ID on a key.</summary>
            <param name="key">The key the certifications are to be removed from.</param>
            <param name="id">The ID that the certfication is to be removed from.</param>
            <param name="certification">The certfication to be removed.</param>
            <returns>The re-certified key, or null if the certification was not found.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.RemoveCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey,Org.BouncyCastle.Bcpg.OpenPgp.PgpUserAttributeSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature)">
            <summary>Remove a certification associated with a given user attributes on a key.</summary>
            <param name="key">The key the certifications are to be removed from.</param>
            <param name="userAttributes">The user attributes that the certfication is to be removed from.</param>
            <param name="certification">The certification to be removed.</param>
            <returns>The re-certified key, or null if the certification was not found.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.AddCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature)">
            <summary>Add a revocation or some other key certification to a key.</summary>
            <param name="key">The key the revocation is to be added to.</param>
            <param name="certification">The key signature to be added.</param>
            <returns>The new changed public key object.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.RemoveCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature)">
            <summary>Remove a certification from the key.</summary>
            <param name="key">The key the certifications are to be removed from.</param>
            <param name="certification">The certfication to be removed.</param>
            <returns>The modified key, null if the certification was not found.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.Version">
            <summary>The version of this key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.CreationTime">
            <summary>The creation time of this key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.ValidDays">
            <summary>The number of valid days from creation time - zero means no expiry.</summary>
            <remarks>WARNING: This method will return 1 for keys with version > 3 that expire in less than 1 day</remarks>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.KeyId">
            <summary>The keyId associated with the public key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.IsEncryptionKey">
            <summary>
            Check if this key has an algorithm type that makes it suitable to use for encryption.
            </summary>
            <remarks>
            Note: with version 4 keys KeyFlags subpackets should also be considered when present for
            determining the preferred use of the key.
            </remarks>
            <returns>
            <c>true</c> if this key algorithm is suitable for encryption.
            </returns>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.IsMasterKey">
            <summary>True, if this is a master key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.Algorithm">
            <summary>The algorithm code associated with the public key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey.BitStrength">
            <summary>The strength of the key in bits.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyEncryptedData">
            <remarks>A public key encrypted data object.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyEncryptedData.GetSymmetricAlgorithm(Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey)">
            <summary>
            Return the algorithm code for the symmetric algorithm used to encrypt the data.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyEncryptedData.GetDataStream(Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey)">
            <summary>Return the decrypted data stream for the packet.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyEncryptedData.KeyId">
            <summary>The key ID for the key used to encrypt the data.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing">
            <remarks>
            Class to hold a single master public key and its subkeys.
            <p>
            Often PGP keyring files consist of multiple master keys, if you are trying to process
            or construct one of these you should use the <c>PgpPublicKeyRingBundle</c> class.
            </p>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing.GetPublicKey">
            <summary>Return the first public key in the ring.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing.GetPublicKey(System.Int64)">
            <summary>Return the public key referred to by the passed in key ID if it is present.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing.GetPublicKeys">
            <summary>Allows enumeration of all the public keys.</summary>
            <returns>An <c>IEnumerable</c> of <c>PgpPublicKey</c> objects.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing.InsertPublicKey(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>
            Returns a new key ring with the public key passed in either added or
            replacing an existing one.
            </summary>
            <param name="pubRing">The public key ring to be modified.</param>
            <param name="pubKey">The public key to be inserted.</param>
            <returns>A new <c>PgpPublicKeyRing</c></returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing.RemovePublicKey(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>Returns a new key ring with the public key passed in removed from the key ring.</summary>
            <param name="pubRing">The public key ring to be modified.</param>
            <param name="pubKey">The public key to be removed.</param>
            <returns>A new <c>PgpPublicKeyRing</c>, or null if pubKey is not found.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle">
            <remarks>
            Often a PGP key ring file is made up of a succession of master/sub-key key rings.
            If you want to read an entire public key file in one hit this is the class for you.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle.#ctor(System.IO.Stream)">
            <summary>Build a PgpPublicKeyRingBundle from the passed in input stream.</summary>
            <param name="inputStream">Input stream containing data.</param>
            <exception cref="T:System.IO.IOException">If a problem parsing the stream occurs.</exception>
            <exception cref="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpException">If an object is encountered which isn't a PgpPublicKeyRing.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle.GetKeyRings">
            <summary>Allow enumeration of the public key rings making up this collection.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle.GetKeyRings(System.String)">
            <summary>Allow enumeration of the key rings associated with the passed in userId.</summary>
            <param name="userId">The user ID to be matched.</param>
            <returns>An <c>IEnumerable</c> of key rings which matched (possibly none).</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle.GetKeyRings(System.String,System.Boolean)">
            <summary>Allow enumeration of the key rings associated with the passed in userId.</summary>
            <param name="userId">The user ID to be matched.</param>
            <param name="matchPartial">If true, userId need only be a substring of an actual ID string to match.</param>
            <returns>An <c>IEnumerable</c> of key rings which matched (possibly none).</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle.GetKeyRings(System.String,System.Boolean,System.Boolean)">
            <summary>Allow enumeration of the key rings associated with the passed in userId.</summary>
            <param name="userId">The user ID to be matched.</param>
            <param name="matchPartial">If true, userId need only be a substring of an actual ID string to match.</param>
            <param name="ignoreCase">If true, case is ignored in user ID comparisons.</param>
            <returns>An <c>IEnumerable</c> of key rings which matched (possibly none).</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle.GetPublicKey(System.Int64)">
            <summary>Return the PGP public key associated with the given key id.</summary>
            <param name="keyId">The ID of the public key to return.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle.GetPublicKeyRing(System.Int64)">
            <summary>Return the public key ring which contains the key referred to by keyId</summary>
            <param name="keyId">key ID to match against</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle.Contains(System.Int64)">
            <summary>
            Return true if a key matching the passed in key ID is present, false otherwise.
            </summary>
            <param name="keyID">key ID to look for.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle.AddPublicKeyRing(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing)">
            <summary>
            Return a new bundle containing the contents of the passed in bundle and
            the passed in public key ring.
            </summary>
            <param name="bundle">The <c>PgpPublicKeyRingBundle</c> the key ring is to be added to.</param>
            <param name="publicKeyRing">The key ring to be added.</param>
            <returns>A new <c>PgpPublicKeyRingBundle</c> merging the current one with the passed in key ring.</returns>
            <exception cref="T:System.ArgumentException">If the keyId for the passed in key ring is already present.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle.RemovePublicKeyRing(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing)">
            <summary>
            Return a new bundle containing the contents of the passed in bundle with
            the passed in public key ring removed.
            </summary>
            <param name="bundle">The <c>PgpPublicKeyRingBundle</c> the key ring is to be removed from.</param>
            <param name="publicKeyRing">The key ring to be removed.</param>
            <returns>A new <c>PgpPublicKeyRingBundle</c> not containing the passed in key ring.</returns>
            <exception cref="T:System.ArgumentException">If the keyId for the passed in key ring is not present.</exception>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRingBundle.Count">
            <summary>Return the number of key rings in this collection.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey">
            <remarks>General class to handle a PGP secret key object.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.#ctor(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,System.String,Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,System.Char[],Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Security.SecureRandom)">
            <remarks>
            Conversion of the passphrase characters to bytes is performed using Convert.ToByte(), which is
            the historical behaviour of the library (1.7 and earlier).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.#ctor(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,System.String,Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,System.Char[],System.Boolean,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Security.SecureRandom)">
            <remarks>
            Conversion of the passphrase characters to bytes is performed using Convert.ToByte(), which is
            the historical behaviour of the library (1.7 and earlier).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.#ctor(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,System.String,Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,System.Boolean,System.Char[],System.Boolean,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Security.SecureRandom)">
            <remarks>
            If utf8PassPhrase is true, conversion of the passphrase to bytes uses Encoding.UTF8.GetBytes(), otherwise the conversion
            is performed using Convert.ToByte(), which is the historical behaviour of the library (1.7 and earlier).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.#ctor(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,System.String,Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,System.Byte[],System.Boolean,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Security.SecureRandom)">
            <remarks>
            Allows the caller to handle the encoding of the passphrase to bytes.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.#ctor(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,System.String,Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,Org.BouncyCastle.Bcpg.HashAlgorithmTag,System.Char[],System.Boolean,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Security.SecureRandom)">
            <remarks>
            Conversion of the passphrase characters to bytes is performed using Convert.ToByte(), which is
            the historical behaviour of the library (1.7 and earlier).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.#ctor(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,System.String,Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,Org.BouncyCastle.Bcpg.HashAlgorithmTag,System.Boolean,System.Char[],System.Boolean,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Security.SecureRandom)">
            <remarks>
            If utf8PassPhrase is true, conversion of the passphrase to bytes uses Encoding.UTF8.GetBytes(), otherwise the conversion
            is performed using Convert.ToByte(), which is the historical behaviour of the library (1.7 and earlier).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.#ctor(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpKeyPair,System.String,Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,Org.BouncyCastle.Bcpg.HashAlgorithmTag,System.Byte[],System.Boolean,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector,Org.BouncyCastle.Security.SecureRandom)">
            <remarks>
            Allows the caller to handle the encoding of the passphrase to bytes.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.ExtractPrivateKey(System.Char[])">
            <summary>Extract a <c>PgpPrivateKey</c> from this secret key's encrypted contents.</summary>
            <remarks>
            Conversion of the passphrase characters to bytes is performed using Convert.ToByte(), which is
            the historical behaviour of the library (1.7 and earlier).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.ExtractPrivateKeyUtf8(System.Char[])">
            <summary>Extract a <c>PgpPrivateKey</c> from this secret key's encrypted contents.</summary>
            <remarks>
            The passphrase is encoded to bytes using UTF8 (Encoding.UTF8.GetBytes).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.ExtractPrivateKeyRaw(System.Byte[])">
            <summary>Extract a <c>PgpPrivateKey</c> from this secret key's encrypted contents.</summary>
            <remarks>
            Allows the caller to handle the encoding of the passphrase to bytes.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.CopyWithNewPassword(Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey,System.Char[],System.Char[],Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Return a copy of the passed in secret key, encrypted using a new password
            and the passed in algorithm.
            </summary>
            <remarks>
            Conversion of the passphrase characters to bytes is performed using Convert.ToByte(), which is
            the historical behaviour of the library (1.7 and earlier).
            </remarks>
            <param name="key">The PgpSecretKey to be copied.</param>
            <param name="oldPassPhrase">The current password for the key.</param>
            <param name="newPassPhrase">The new password for the key.</param>
            <param name="newEncAlgorithm">The algorithm to be used for the encryption.</param>
            <param name="rand">Source of randomness.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.CopyWithNewPasswordUtf8(Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey,System.Char[],System.Char[],Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Return a copy of the passed in secret key, encrypted using a new password
            and the passed in algorithm.
            </summary>
            <remarks>
            The passphrase is encoded to bytes using UTF8 (Encoding.UTF8.GetBytes).
            </remarks>
            <param name="key">The PgpSecretKey to be copied.</param>
            <param name="oldPassPhrase">The current password for the key.</param>
            <param name="newPassPhrase">The new password for the key.</param>
            <param name="newEncAlgorithm">The algorithm to be used for the encryption.</param>
            <param name="rand">Source of randomness.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.CopyWithNewPasswordRaw(Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey,System.Byte[],System.Byte[],Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Return a copy of the passed in secret key, encrypted using a new password
            and the passed in algorithm.
            </summary>
            <remarks>
            Allows the caller to handle the encoding of the passphrase to bytes.
            </remarks>
            <param name="key">The PgpSecretKey to be copied.</param>
            <param name="rawOldPassPhrase">The current password for the key.</param>
            <param name="rawNewPassPhrase">The new password for the key.</param>
            <param name="newEncAlgorithm">The algorithm to be used for the encryption.</param>
            <param name="rand">Source of randomness.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.ReplacePublicKey(Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>Replace the passed the public key on the passed in secret key.</summary>
            <param name="secretKey">Secret key to change.</param>
            <param name="publicKey">New public key.</param>
            <returns>A new secret key.</returns>
            <exception cref="T:System.ArgumentException">If KeyId's do not match.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.ParseSecretKeyFromSExpr(System.IO.Stream,System.Char[],Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>
            Parse a secret key from one of the GPG S expression keys associating it with the passed in public key.
            </summary>
            <remarks>
            Conversion of the passphrase characters to bytes is performed using Convert.ToByte(), which is
            the historical behaviour of the library (1.7 and earlier).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.ParseSecretKeyFromSExprUtf8(System.IO.Stream,System.Char[],Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>
            Parse a secret key from one of the GPG S expression keys associating it with the passed in public key.
            </summary>
            <remarks>
            The passphrase is encoded to bytes using UTF8 (Encoding.UTF8.GetBytes).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.ParseSecretKeyFromSExprRaw(System.IO.Stream,System.Byte[],Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>
            Parse a secret key from one of the GPG S expression keys associating it with the passed in public key.
            </summary>
            <remarks>
            Allows the caller to handle the encoding of the passphrase to bytes.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.ParseSecretKeyFromSExpr(System.IO.Stream,System.Char[])">
            <summary>
            Parse a secret key from one of the GPG S expression keys.
            </summary>
            <remarks>
            Conversion of the passphrase characters to bytes is performed using Convert.ToByte(), which is
            the historical behaviour of the library (1.7 and earlier).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.ParseSecretKeyFromSExprUtf8(System.IO.Stream,System.Char[])">
            <summary>
            Parse a secret key from one of the GPG S expression keys.
            </summary>
            <remarks>
            The passphrase is encoded to bytes using UTF8 (Encoding.UTF8.GetBytes).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.ParseSecretKeyFromSExprRaw(System.IO.Stream,System.Byte[])">
            <summary>
            Parse a secret key from one of the GPG S expression keys.
            </summary>
            <remarks>
            Allows the caller to handle the encoding of the passphrase to bytes.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.DoParseSecretKeyFromSExpr(System.IO.Stream,System.Byte[],System.Boolean)">
            <summary>
            Parse a secret key from one of the GPG S expression keys.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.IsSigningKey">
            <summary>
            Check if this key has an algorithm type that makes it suitable to use for signing.
            </summary>
            <remarks>
            Note: with version 4 keys KeyFlags subpackets should also be considered when present for
            determining the preferred use of the key.
            </remarks>
            <returns>
            <c>true</c> if this key algorithm is suitable for use with signing.
            </returns>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.IsMasterKey">
            <summary>True, if this is a master key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.IsPrivateKeyEmpty">
            <summary>Detect if the Secret Key's Private Key is empty or not</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.KeyEncryptionAlgorithm">
            <summary>The algorithm the key is encrypted with.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.KeyId">
            <summary>The key ID of the public key associated with this key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.S2kUsage">
            <summary>Return the S2K usage associated with this key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.S2k">
            <summary>Return the S2K used to process this key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.PublicKey">
            <summary>The public key associated with this key.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.UserIds">
            <summary>Allows enumeration of any user IDs associated with the key.</summary>
            <returns>An <c>IEnumerable</c> of <c>string</c> objects.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey.UserAttributes">
            <summary>Allows enumeration of any user attribute vectors associated with the key.</summary>
            <returns>An <c>IEnumerable</c> of <c>string</c> objects.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing">
            <remarks>
            Class to hold a single master secret key and its subkeys.
            <p>
            Often PGP keyring files consist of multiple master keys, if you are trying to process
            or construct one of these you should use the <c>PgpSecretKeyRingBundle</c> class.
            </p>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing.GetPublicKey">
            <summary>Return the public key for the master key.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing.GetSecretKey">
            <summary>Return the master private key.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing.GetSecretKeys">
            <summary>Allows enumeration of the secret keys.</summary>
            <returns>An <c>IEnumerable</c> of <c>PgpSecretKey</c> objects.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing.GetExtraPublicKeys">
            <summary>
            Return an iterator of the public keys in the secret key ring that
            have no matching private key. At the moment only personal certificate data
            appears in this fashion.
            </summary>
            <returns>An <c>IEnumerable</c> of unattached, or extra, public keys.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing.ReplacePublicKeys(Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKeyRing)">
            <summary>
            Replace the public key set on the secret ring with the corresponding key off the public ring.
            </summary>
            <param name="secretRing">Secret ring to be changed.</param>
            <param name="publicRing">Public ring containing the new public key set.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing.CopyWithNewPassword(Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing,System.Char[],System.Char[],Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Return a copy of the passed in secret key ring, with the master key and sub keys encrypted
            using a new password and the passed in algorithm.
            </summary>
            <param name="ring">The <c>PgpSecretKeyRing</c> to be copied.</param>
            <param name="oldPassPhrase">The current password for key.</param>
            <param name="newPassPhrase">The new password for the key.</param>
            <param name="newEncAlgorithm">The algorithm to be used for the encryption.</param>
            <param name="rand">Source of randomness.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing.InsertSecretKey(Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing,Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey)">
            <summary>
            Returns a new key ring with the secret key passed in either added or
            replacing an existing one with the same key ID.
            </summary>
            <param name="secRing">The secret key ring to be modified.</param>
            <param name="secKey">The secret key to be inserted.</param>
            <returns>A new <c>PgpSecretKeyRing</c></returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing.RemoveSecretKey(Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing,Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKey)">
            <summary>Returns a new key ring with the secret key passed in removed from the key ring.</summary>
            <param name="secRing">The secret key ring to be modified.</param>
            <param name="secKey">The secret key to be removed.</param>
            <returns>A new <c>PgpSecretKeyRing</c>, or null if secKey is not found.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle">
            <remarks>
            Often a PGP key ring file is made up of a succession of master/sub-key key rings.
            If you want to read an entire secret key file in one hit this is the class for you.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle.#ctor(System.IO.Stream)">
            <summary>Build a PgpSecretKeyRingBundle from the passed in input stream.</summary>
            <param name="inputStream">Input stream containing data.</param>
            <exception cref="T:System.IO.IOException">If a problem parsing the stream occurs.</exception>
            <exception cref="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpException">If an object is encountered which isn't a PgpSecretKeyRing.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle.GetKeyRings">
            <summary>Allow enumeration of the secret key rings making up this collection.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle.GetKeyRings(System.String)">
            <summary>Allow enumeration of the key rings associated with the passed in userId.</summary>
            <param name="userId">The user ID to be matched.</param>
            <returns>An <c>IEnumerable</c> of key rings which matched (possibly none).</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle.GetKeyRings(System.String,System.Boolean)">
            <summary>Allow enumeration of the key rings associated with the passed in userId.</summary>
            <param name="userId">The user ID to be matched.</param>
            <param name="matchPartial">If true, userId need only be a substring of an actual ID string to match.</param>
            <returns>An <c>IEnumerable</c> of key rings which matched (possibly none).</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle.GetKeyRings(System.String,System.Boolean,System.Boolean)">
            <summary>Allow enumeration of the key rings associated with the passed in userId.</summary>
            <param name="userId">The user ID to be matched.</param>
            <param name="matchPartial">If true, userId need only be a substring of an actual ID string to match.</param>
            <param name="ignoreCase">If true, case is ignored in user ID comparisons.</param>
            <returns>An <c>IEnumerable</c> of key rings which matched (possibly none).</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle.GetSecretKey(System.Int64)">
            <summary>Return the PGP secret key associated with the given key id.</summary>
            <param name="keyId">The ID of the secret key to return.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle.GetSecretKeyRing(System.Int64)">
            <summary>Return the secret key ring which contains the key referred to by keyId</summary>
            <param name="keyId">The ID of the secret key</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle.Contains(System.Int64)">
            <summary>
            Return true if a key matching the passed in key ID is present, false otherwise.
            </summary>
            <param name="keyID">key ID to look for.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle.AddSecretKeyRing(Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle,Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing)">
            <summary>
            Return a new bundle containing the contents of the passed in bundle and
            the passed in secret key ring.
            </summary>
            <param name="bundle">The <c>PgpSecretKeyRingBundle</c> the key ring is to be added to.</param>
            <param name="secretKeyRing">The key ring to be added.</param>
            <returns>A new <c>PgpSecretKeyRingBundle</c> merging the current one with the passed in key ring.</returns>
            <exception cref="T:System.ArgumentException">If the keyId for the passed in key ring is already present.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle.RemoveSecretKeyRing(Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle,Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRing)">
            <summary>
            Return a new bundle containing the contents of the passed in bundle with
            the passed in secret key ring removed.
            </summary>
            <param name="bundle">The <c>PgpSecretKeyRingBundle</c> the key ring is to be removed from.</param>
            <param name="secretKeyRing">The key ring to be removed.</param>
            <returns>A new <c>PgpSecretKeyRingBundle</c> not containing the passed in key ring.</returns>
            <exception cref="T:System.ArgumentException">If the keyId for the passed in key ring is not present.</exception>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSecretKeyRingBundle.Count">
            <summary>Return the number of rings in this collection.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature">
            <remarks>A PGP signature object.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature.IsCertification">
            <summary>Return true if this signature represents a certification.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature.VerifyCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpUserAttributeSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>
            Verify the signature as certifying the passed in public key as associated
            with the passed in user attributes.
            </summary>
            <param name="userAttributes">User attributes the key was stored under.</param>
            <param name="key">The key to be verified.</param>
            <returns>True, if the signature matches, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature.VerifyCertification(System.String,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>
            Verify the signature as certifying the passed in public key as associated
            with the passed in ID.
            </summary>
            <param name="id">ID the key was stored under.</param>
            <param name="key">The key to be verified.</param>
            <returns>True, if the signature matches, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature.VerifyCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>Verify a certification for the passed in key against the passed in master key.</summary>
            <param name="masterKey">The key we are verifying against.</param>
            <param name="pubKey">The key we are verifying.</param>
            <returns>True, if the certification is valid, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature.VerifyCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>Verify a key certification, such as revocation, for the passed in key.</summary>
            <param name="pubKey">The key we are checking.</param>
            <returns>True, if the certification is valid, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature.IsCertification(System.Int32)">
            <summary>
            Return true if the passed in signature type represents a certification, false if the signature type is not.
            </summary>
            <param name="signatureType"></param>
            <returns>true if signatureType is a certification, false otherwise.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature.Version">
            <summary>The OpenPGP version number for this signature.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature.KeyAlgorithm">
            <summary>The key algorithm associated with this signature.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature.HashAlgorithm">
            <summary>The hash algorithm associated with this signature.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature.KeyId">
            <summary>The ID of the key that created the signature.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature.CreationTime">
            <summary>The creation time of this signature.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignature.HasSubpackets">
            <summary>
            Return true if the signature has either hashed or unhashed subpackets.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureGenerator">
            <remarks>Generator for PGP signatures.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureGenerator.#ctor(Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag,Org.BouncyCastle.Bcpg.HashAlgorithmTag)">
            <summary>Create a generator for the passed in keyAlgorithm and hashAlgorithm codes.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureGenerator.InitSign(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey)">
            <summary>Initialise the generator for signing.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureGenerator.InitSign(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey,Org.BouncyCastle.Security.SecureRandom)">
            <summary>Initialise the generator for signing.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureGenerator.GenerateOnePassVersion(System.Boolean)">
            <summary>Return the one pass header associated with the current signature.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureGenerator.Generate">
            <summary>Return a signature object containing the current signature state.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureGenerator.GenerateCertification(System.String,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>Generate a certification for the passed in ID and key.</summary>
            <param name="id">The ID we are certifying against the public key.</param>
            <param name="pubKey">The key we are certifying against the ID.</param>
            <returns>The certification.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureGenerator.GenerateCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpUserAttributeSubpacketVector,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>Generate a certification for the passed in userAttributes.</summary>
            <param name="userAttributes">The ID we are certifying against the public key.</param>
            <param name="pubKey">The key we are certifying against the ID.</param>
            <returns>The certification.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureGenerator.GenerateCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey,Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>Generate a certification for the passed in key against the passed in master key.</summary>
            <param name="masterKey">The key we are certifying against.</param>
            <param name="pubKey">The key we are certifying.</param>
            <returns>The certification.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureGenerator.GenerateCertification(Org.BouncyCastle.Bcpg.OpenPgp.PgpPublicKey)">
            <summary>Generate a certification, such as a revocation, for the passed in key.</summary>
            <param name="pubKey">The key we are certifying.</param>
            <returns>The certification.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureList">
            <remarks>A list of PGP signatures - normally in the signature block after literal data.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketGenerator">
            <remarks>Generator for signature subpackets.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketGenerator.SetTrust(System.Boolean,System.Int32,System.Int32)">
            <summary>
            Add a TrustSignature packet to the signature. The values for depth and trust are largely
            installation dependent but there are some guidelines in RFC 4880 - 5.2.3.13.
            </summary>
            <param name="isCritical">true if the packet is critical.</param>
            <param name="depth">depth level.</param>
            <param name="trustAmount">trust amount.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketGenerator.SetKeyExpirationTime(System.Boolean,System.Int64)">
            <summary>
            Set the number of seconds a key is valid for after the time of its creation.
            A value of zero means the key never expires.
            </summary>
            <param name="isCritical">True, if should be treated as critical, false otherwise.</param>
            <param name="seconds">The number of seconds the key is valid, or zero if no expiry.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketGenerator.SetSignatureExpirationTime(System.Boolean,System.Int64)">
            <summary>
            Set the number of seconds a signature is valid for after the time of its creation.
            A value of zero means the signature never expires.
            </summary>
            <param name="isCritical">True, if should be treated as critical, false otherwise.</param>
            <param name="seconds">The number of seconds the signature is valid, or zero if no expiry.</param>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketGenerator.SetSignatureCreationTime(System.Boolean,System.DateTime)">
            <summary>
            Set the creation time for the signature.
            <p>
            Note: this overrides the generation of a creation time when the signature
            is generated.</p>
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketGenerator.SetRevocationReason(System.Boolean,Org.BouncyCastle.Bcpg.RevocationReasonTag,System.String)">
            <summary>
            Sets revocation reason sub packet
            </summary>	    
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketGenerator.SetRevocationKey(System.Boolean,Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag,System.Byte[])">
            <summary>
            Sets revocation key sub packet
            </summary>	
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketGenerator.SetIssuerKeyID(System.Boolean,System.Int64)">
            <summary>
            Sets issuer key sub packet
            </summary>	
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector">
            <remarks>Container for a list of signature subpackets.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector.HasSubpacket(Org.BouncyCastle.Bcpg.SignatureSubpacketTag)">
             Return true if a particular subpacket type exists.
            
             @param type type to look for.
             @return true if present, false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector.GetSubpackets(Org.BouncyCastle.Bcpg.SignatureSubpacketTag)">
            Return all signature subpackets of the passed in type.
            @param type subpacket type code
            @return an array of zero or more matching subpackets.
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector.GetSignatureExpirationTime">
            <summary>
            Return the number of seconds a signature is valid for after its creation date.
            A value of zero means the signature never expires.
            </summary>
            <returns>Seconds a signature is valid for.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector.GetKeyExpirationTime">
            <summary>
            Return the number of seconds a key is valid for after its creation date.
            A value of zero means the key never expires.
            </summary>
            <returns>Seconds a signature is valid for.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Bcpg.OpenPgp.PgpSignatureSubpacketVector.Count">
            <summary>Return the number of packets this vector contains.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpUserAttributeSubpacketVector">
            <remarks>Container for a list of user attribute subpackets.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpUtilities">
            <remarks>Basic utility class.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpUtilities.MakeKeyFromPassPhrase(Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,Org.BouncyCastle.Bcpg.S2k,System.Char[])">
            <remarks>
            Conversion of the passphrase characters to bytes is performed using Convert.ToByte(), which is
            the historical behaviour of the library (1.7 and earlier).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpUtilities.MakeKeyFromPassPhraseUtf8(Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,Org.BouncyCastle.Bcpg.S2k,System.Char[])">
            <remarks>
            The passphrase is encoded to bytes using UTF8 (Encoding.UTF8.GetBytes).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpUtilities.MakeKeyFromPassPhraseRaw(Org.BouncyCastle.Bcpg.SymmetricKeyAlgorithmTag,Org.BouncyCastle.Bcpg.S2k,System.Byte[])">
            <remarks>
            Allows the caller to handle the encoding of the passphrase to bytes.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpUtilities.WriteFileToLiteralData(System.IO.Stream,System.Char,System.IO.FileInfo)">
            <summary>Write out the passed in file as a literal data packet.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpUtilities.WriteFileToLiteralData(System.IO.Stream,System.Char,System.IO.FileInfo,System.Byte[])">
            <summary>Write out the passed in file as a literal data packet in partial packet format.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpUtilities.GetDecoderStream(System.IO.Stream)">
            <summary>
            Return either an ArmoredInputStream or a BcpgInputStream based on whether
            the initial characters of the stream are binary PGP encodings or not.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.PgpV3SignatureGenerator">
            <remarks>Generator for old style PGP V3 Signatures.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpV3SignatureGenerator.#ctor(Org.BouncyCastle.Bcpg.PublicKeyAlgorithmTag,Org.BouncyCastle.Bcpg.HashAlgorithmTag)">
            <summary>Create a generator for the passed in keyAlgorithm and hashAlgorithm codes.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpV3SignatureGenerator.InitSign(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey)">
            <summary>Initialise the generator for signing.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpV3SignatureGenerator.InitSign(System.Int32,Org.BouncyCastle.Bcpg.OpenPgp.PgpPrivateKey,Org.BouncyCastle.Security.SecureRandom)">
            <summary>Initialise the generator for signing.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpV3SignatureGenerator.GenerateOnePassVersion(System.Boolean)">
            <summary>Return the one pass header associated with the current signature.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Bcpg.OpenPgp.PgpV3SignatureGenerator.Generate">
            <summary>Return a V3 signature object containing the current signature state.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Bcpg.OpenPgp.SXprUtilities">
            Utility functions for looking a S-expression keys. This class will move when it finds a better home!
            <p>
            Format documented here:
            http://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob;f=agent/keyformat.txt;h=42c4b1f06faf1bbe71ffadc2fee0fad6bec91a97;hb=refs/heads/master
            </p>
        </member>
        <member name="T:Org.BouncyCastle.OpenSsl.MiscPemGenerator">
            PEM generator for the original set of PEM objects used in Open SSL.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IO.Pem.PemObjectGenerator.Generate">
            <returns>
            A <see cref="T:Org.BouncyCastle.Utilities.IO.Pem.PemObject"/>
            </returns>
            <exception cref="T:Org.BouncyCastle.Utilities.IO.Pem.PemGenerationException"></exception>
        </member>
        <member name="T:Org.BouncyCastle.OpenSsl.PemReader">
            Class for reading OpenSSL PEM encoded streams containing 
            X509 certificates, PKCS8 encoded keys and PKCS7 objects.
            <p>
            In the case of PKCS7 objects the reader will return a CMS ContentInfo object. Keys and
            Certificates will be returned using the appropriate java.security type.</p>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IO.Pem.PemReader.ReadPemObject">
            <returns>
            A <see cref="T:Org.BouncyCastle.Utilities.IO.Pem.PemObject"/>
            </returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.PemReader.#ctor(System.IO.TextReader)">
             Create a new PemReader
            
             @param reader the Reader
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.PemReader.#ctor(System.IO.TextReader,Org.BouncyCastle.OpenSsl.IPasswordFinder)">
             Create a new PemReader with a password finder
            
             @param reader the Reader
             @param pFinder the password finder
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.PemReader.ReadCertificate(Org.BouncyCastle.Utilities.IO.Pem.PemObject)">
             Reads in a X509Certificate.
            
             @return the X509Certificate
             @throws IOException if an I/O error occured
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.PemReader.ReadCrl(Org.BouncyCastle.Utilities.IO.Pem.PemObject)">
             Reads in a X509CRL.
            
             @return the X509Certificate
             @throws IOException if an I/O error occured
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.PemReader.ReadCertificateRequest(Org.BouncyCastle.Utilities.IO.Pem.PemObject)">
             Reads in a PKCS10 certification request.
            
             @return the certificate request.
             @throws IOException if an I/O error occured
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.PemReader.ReadAttributeCertificate(Org.BouncyCastle.Utilities.IO.Pem.PemObject)">
             Reads in a X509 Attribute Certificate.
            
             @return the X509 Attribute Certificate
             @throws IOException if an I/O error occured
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.PemReader.ReadPkcs7(Org.BouncyCastle.Utilities.IO.Pem.PemObject)">
             Reads in a PKCS7 object. This returns a ContentInfo object suitable for use with the CMS
             API.
            
             @return the X509Certificate
             @throws IOException if an I/O error occured
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.PemReader.ReadPrivateKey(Org.BouncyCastle.Utilities.IO.Pem.PemObject)">
            Read a Key Pair
        </member>
        <member name="T:Org.BouncyCastle.OpenSsl.PemWriter">
            <remarks>General purpose writer for OpenSSL PEM objects.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.IO.Pem.PemWriter">
            A generic PEM writer, based on RFC 1421
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IO.Pem.PemWriter.#ctor(System.IO.TextWriter)">
             Base constructor.
            
             @param out output stream to use.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IO.Pem.PemWriter.GetOutputSize(Org.BouncyCastle.Utilities.IO.Pem.PemObject)">
             Return the number of bytes or characters required to contain the
             passed in object if it is PEM encoded.
            
             @param obj pem object to be output
             @return an estimate of the number of bytes
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.PemWriter.#ctor(System.IO.TextWriter)">
            <param name="writer">The TextWriter object to write the output to.</param>
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.Pkcs8Generator.#ctor(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
             Constructor for an unencrypted private key PEM object.
            
             @param key private key to be encoded.
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.Pkcs8Generator.#ctor(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.String)">
             Constructor for an encrypted private key PEM object.
            
             @param key       private key to be encoded
             @param algorithm encryption algorithm to use
             @param provider  provider to use
             @throws NoSuchAlgorithmException if algorithm/mode cannot be found
        </member>
        <member name="T:Org.BouncyCastle.Pkcs.Pkcs10CertificationRequest">
             <remarks>
             A class for verifying and creating Pkcs10 Certification requests.
             </remarks>
             <code>
             CertificationRequest ::= Sequence {
               certificationRequestInfo  CertificationRequestInfo,
               signatureAlgorithm        AlgorithmIdentifier{{ SignatureAlgorithms }},
               signature                 BIT STRING
             }
            
             CertificationRequestInfo ::= Sequence {
               version             Integer { v1(0) } (v1,...),
               subject             Name,
               subjectPKInfo   SubjectPublicKeyInfo{{ PKInfoAlgorithms }},
               attributes          [0] Attributes{{ CRIAttributes }}
              }
            
              Attributes { ATTRIBUTE:IOSet } ::= Set OF Attr{{ IOSet }}
            
              Attr { ATTRIBUTE:IOSet } ::= Sequence {
                type    ATTRIBUTE.&amp;id({IOSet}),
                values  Set SIZE(1..MAX) OF ATTRIBUTE.&amp;Type({IOSet}{\@type})
              }
             </code>
             see <a href="http://www.rsasecurity.com/rsalabs/node.asp?id=2132"/>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs10CertificationRequest.#ctor(System.String,Org.BouncyCastle.Asn1.X509.X509Name,Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.Asn1.Asn1Set,Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
             <summary>
             Instantiate a Pkcs10CertificationRequest object with the necessary credentials.
             </summary>
            <param name="signatureAlgorithm">Name of Sig Alg.</param>
             <param name="subject">X509Name of subject eg OU="My unit." O="My Organisatioin" C="au" </param>
             <param name="publicKey">Public Key to be included in cert reqest.</param>
             <param name="attributes">ASN1Set of Attributes.</param>
             <param name="signingKey">Matching Private key for nominated (above) public key to be used to sign the request.</param>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs10CertificationRequest.#ctor(Org.BouncyCastle.Crypto.ISignatureFactory,Org.BouncyCastle.Asn1.X509.X509Name,Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.Asn1.Asn1Set,Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
             <summary>
             Instantiate a Pkcs10CertificationRequest object with the necessary credentials.
             </summary>
            <param name="signatureCalculatorFactory">The factory for signature calculators to sign the PKCS#10 request with.</param>
             <param name="subject">X509Name of subject eg OU="My unit." O="My Organisatioin" C="au" </param>
             <param name="publicKey">Public Key to be included in cert reqest.</param>
             <param name="attributes">ASN1Set of Attributes.</param>
             <param name="signingKey">Matching Private key for nominated (above) public key to be used to sign the request.</param>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs10CertificationRequest.GetPublicKey">
            <summary>
            Get the public key.
            </summary>
            <returns>The public key.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs10CertificationRequest.Verify">
            <summary>
            Verify Pkcs10 Cert Request is valid.
            </summary>
            <returns>true = valid.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Pkcs.Pkcs10CertificationRequestDelaySigned">
             <remarks>
             A class for creating and verifying Pkcs10 Certification requests (this is an extension on <see cref="T:Org.BouncyCastle.Pkcs.Pkcs10CertificationRequest"/>).
             The requests are made using delay signing. This is useful for situations where
             the private key is in another environment and not directly accessible (e.g. HSM)
             So the first step creates the request, then the signing is done outside this
             object and the signature is then used to complete the request.
             </remarks>
             <code>
             CertificationRequest ::= Sequence {
               certificationRequestInfo  CertificationRequestInfo,
               signatureAlgorithm        AlgorithmIdentifier{{ SignatureAlgorithms }},
               signature                 BIT STRING
             }
            
             CertificationRequestInfo ::= Sequence {
               version             Integer { v1(0) } (v1,...),
               subject             Name,
               subjectPKInfo   SubjectPublicKeyInfo{{ PKInfoAlgorithms }},
               attributes          [0] Attributes{{ CRIAttributes }}
              }
            
              Attributes { ATTRIBUTE:IOSet } ::= Set OF Attr{{ IOSet }}
            
              Attr { ATTRIBUTE:IOSet } ::= Sequence {
                type    ATTRIBUTE.&amp;id({IOSet}),
                values  Set SIZE(1..MAX) OF ATTRIBUTE.&amp;Type({IOSet}{\@type})
              }
             </code>
             see <a href="http://www.rsasecurity.com/rsalabs/node.asp?id=2132"/>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs10CertificationRequestDelaySigned.#ctor(System.String,Org.BouncyCastle.Asn1.X509.X509Name,Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.Asn1.Asn1Set)">
            <summary>
            Instantiate a Pkcs10CertificationRequest object with the necessary credentials.
            </summary>
            <param name="signatureAlgorithm">Name of Sig Alg.</param>
            <param name="subject">X509Name of subject eg OU="My unit." O="My Organisatioin" C="au" </param>
            <param name="publicKey">Public Key to be included in cert reqest.</param>
            <param name="attributes">ASN1Set of Attributes.</param>
            <remarks>
            After the object is constructed use the <see cref="M:Org.BouncyCastle.Pkcs.Pkcs10CertificationRequestDelaySigned.GetDataToSign"/> and finally the
            SignRequest methods to finalize the request.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs12Store.GetCertificate(System.String)">
            simply return the cert entry for the private key
        </member>
        <member name="T:Org.BouncyCastle.Pkcs.Pkcs12Utilities">
            Utility class for reencoding PKCS#12 files to definite length.
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs12Utilities.ConvertToDefiniteLength(System.Byte[])">
             Just re-encode the outer layer of the PKCS#12 file to definite length encoding.
            
             @param berPKCS12File - original PKCS#12 file
             @return a byte array representing the DER encoding of the PFX structure
             @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs12Utilities.ConvertToDefiniteLength(System.Byte[],System.Char[])">
             Re-encode the PKCS#12 structure to definite length encoding at the inner layer
             as well, recomputing the MAC accordingly.
            
             @param berPKCS12File - original PKCS12 file.
             @param provider - provider to use for MAC calculation.
             @return a byte array representing the DER encoding of the PFX structure.
             @throws IOException on parsing, encoding errors.
        </member>
        <member name="P:Org.BouncyCastle.Pkix.CertStatus.RevocationDate">
            <summary>
            Returns the revocationDate.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Pkix.CertStatus.Status">
            <summary>
            Returns the certStatus.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixAttrCertChecker.GetSupportedExtensions">
            Returns an immutable <code>Set</code> of X.509 attribute certificate
            extensions that this <code>PkixAttrCertChecker</code> supports or
            <code>null</code> if no extensions are supported.
            <p>
            Each element of the set is a <code>String</code> representing the
            Object Identifier (OID) of the X.509 extension that is supported.
            </p>
            <p>
            All X.509 attribute certificate extensions that a
            <code>PkixAttrCertChecker</code> might possibly be able to process
            should be included in the set.
            </p>
            
            @return an immutable <code>Set</code> of X.509 extension OIDs (in
                    <code>String</code> format) supported by this
                    <code>PkixAttrCertChecker</code>, or <code>null</code> if no
                    extensions are supported
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixAttrCertChecker.Check(Org.BouncyCastle.X509.IX509AttributeCertificate,Org.BouncyCastle.Pkix.PkixCertPath,Org.BouncyCastle.Pkix.PkixCertPath,System.Collections.ICollection)">
            Performs checks on the specified attribute certificate. Every handled
            extension is rmeoved from the <code>unresolvedCritExts</code>
            collection.
            
            @param attrCert The attribute certificate to be checked.
            @param certPath The certificate path which belongs to the attribute
                       certificate issuer public key certificate.
            @param holderCertPath The certificate path which belongs to the holder
                       certificate.
            @param unresolvedCritExts a <code>Collection</code> of OID strings
                       representing the current set of unresolved critical extensions
            @throws CertPathValidatorException if the specified attribute certificate
                        does not pass the check.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixAttrCertChecker.Clone">
            Returns a clone of this object.
            
            @return a copy of this <code>PkixAttrCertChecker</code>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixAttrCertPathBuilder.Build(Org.BouncyCastle.Pkix.PkixBuilderParameters)">
             Build and validate a CertPath using the given parameter.
            
             @param params PKIXBuilderParameters object containing all information to
                        build the CertPath
        </member>
        <member name="T:Org.BouncyCastle.Pkix.PkixAttrCertPathValidator">
            CertPathValidatorSpi implementation for X.509 Attribute Certificates la RFC 3281.
            
            @see org.bouncycastle.x509.ExtendedPkixParameters
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixAttrCertPathValidator.Validate(Org.BouncyCastle.Pkix.PkixCertPath,Org.BouncyCastle.Pkix.PkixParameters)">
            Validates an attribute certificate with the given certificate path.
            
            <p>
            <code>params</code> must be an instance of
            <code>ExtendedPkixParameters</code>.
            </p><p>
            The target constraints in the <code>params</code> must be an
            <code>X509AttrCertStoreSelector</code> with at least the attribute
            certificate criterion set. Obey that also target informations may be
            necessary to correctly validate this attribute certificate.
            </p><p>
            The attribute certificate issuer must be added to the trusted attribute
            issuers with {@link ExtendedPkixParameters#setTrustedACIssuers(Set)}.
            </p>
            @param certPath The certificate path which belongs to the attribute
                       certificate issuer public key certificate.
            @param params The PKIX parameters.
            @return A <code>PKIXCertPathValidatorResult</code> of the result of
                    validating the <code>certPath</code>.
            @throws InvalidAlgorithmParameterException if <code>params</code> is
                        inappropriate for this validator.
            @throws CertPathValidatorException if the verification fails.
        </member>
        <member name="T:Org.BouncyCastle.Pkix.PkixBuilderParameters">
            <summary>
            Summary description for PkixBuilderParameters.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Pkix.PkixParameters">
            <summary>
            Summary description for PkixParameters.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Pkix.PkixParameters.PkixValidityModel">
            This is the default PKIX validity model. Actually there are two variants
            of this: The PKIX model and the modified PKIX model. The PKIX model
            verifies that all involved certificates must have been valid at the
            current time. The modified PKIX model verifies that all involved
            certificates were valid at the signing time. Both are indirectly choosen
            with the {@link PKIXParameters#setDate(java.util.Date)} method, so this
            methods sets the Date when <em>all</em> certificates must have been
            valid.
        </member>
        <member name="F:Org.BouncyCastle.Pkix.PkixParameters.ChainValidityModel">
            This model uses the following validity model. Each certificate must have
            been valid at the moment where is was used. That means the end
            certificate must have been valid at the time the signature was done. The
            CA certificate which signed the end certificate must have been valid,
            when the end certificate was signed. The CA (or Root CA) certificate must
            have been valid, when the CA certificate was signed and so on. So the
            {@link PKIXParameters#setDate(java.util.Date)} method sets the time, when
            the <em>end certificate</em> must have been valid. <p/> It is used e.g.
            in the German signature law.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.#ctor(Org.BouncyCastle.Utilities.Collections.ISet)">
             Creates an instance of PKIXParameters with the specified Set of
             most-trusted CAs. Each element of the set is a TrustAnchor.<br />
             <br />
             Note that the Set is copied to protect against subsequent modifications.
            
             @param trustAnchors
                        a Set of TrustAnchors
            
             @exception InvalidAlgorithmParameterException
                            if the specified Set is empty
                            <code>(trustAnchors.isEmpty() == true)</code>
             @exception NullPointerException
                            if the specified Set is <code>null</code>
             @exception ClassCastException
                            if any of the elements in the Set are not of type
                            <code>java.security.cert.TrustAnchor</code>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.GetTargetCertConstraints">
             Returns the required constraints on the target certificate. The
             constraints are returned as an instance of CertSelector. If
             <code>null</code>, no constraints are defined.<br />
             <br />
             Note that the CertSelector returned is cloned to protect against
             subsequent modifications.
            
             @return a CertSelector specifying the constraints on the target
                     certificate (or <code>null</code>)
            
             @see #setTargetCertConstraints(CertSelector)
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.SetTargetCertConstraints(Org.BouncyCastle.X509.Store.IX509Selector)">
             Sets the required constraints on the target certificate. The constraints
             are specified as an instance of CertSelector. If null, no constraints are
             defined.<br />
             <br />
             Note that the CertSelector specified is cloned to protect against
             subsequent modifications.
            
             @param selector
                        a CertSelector specifying the constraints on the target
                        certificate (or <code>null</code>)
            
             @see #getTargetCertConstraints()
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.GetInitialPolicies">
             Returns an immutable Set of initial policy identifiers (OID strings),
             indicating that any one of these policies would be acceptable to the
             certificate user for the purposes of certification path processing. The
             default return value is an empty <code>Set</code>, which is
             interpreted as meaning that any policy would be acceptable.
            
             @return an immutable <code>Set</code> of initial policy OIDs in String
                     format, or an empty <code>Set</code> (implying any policy is
                     acceptable). Never returns <code>null</code>.
            
             @see #setInitialPolicies(java.util.Set)
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.SetInitialPolicies(Org.BouncyCastle.Utilities.Collections.ISet)">
             Sets the <code>Set</code> of initial policy identifiers (OID strings),
             indicating that any one of these policies would be acceptable to the
             certificate user for the purposes of certification path processing. By
             default, any policy is acceptable (i.e. all policies), so a user that
             wants to allow any policy as acceptable does not need to call this
             method, or can call it with an empty <code>Set</code> (or
             <code>null</code>).<br />
             <br />
             Note that the Set is copied to protect against subsequent modifications.<br />
             <br />
            
             @param initialPolicies
                        a Set of initial policy OIDs in String format (or
                        <code>null</code>)
            
             @exception ClassCastException
                            if any of the elements in the set are not of type String
            
             @see #getInitialPolicies()
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.SetCertPathCheckers(System.Collections.IList)">
             Sets a <code>List</code> of additional certification path checkers. If
             the specified List contains an object that is not a PKIXCertPathChecker,
             it is ignored.<br />
             <br />
             Each <code>PKIXCertPathChecker</code> specified implements additional
             checks on a certificate. Typically, these are checks to process and
             verify private extensions contained in certificates. Each
             <code>PKIXCertPathChecker</code> should be instantiated with any
             initialization parameters needed to execute the check.<br />
             <br />
             This method allows sophisticated applications to extend a PKIX
             <code>CertPathValidator</code> or <code>CertPathBuilder</code>. Each
             of the specified PKIXCertPathCheckers will be called, in turn, by a PKIX
             <code>CertPathValidator</code> or <code>CertPathBuilder</code> for
             each certificate processed or validated.<br />
             <br />
             Regardless of whether these additional PKIXCertPathCheckers are set, a
             PKIX <code>CertPathValidator</code> or <code>CertPathBuilder</code>
             must perform all of the required PKIX checks on each certificate. The one
             exception to this rule is if the RevocationEnabled flag is set to false
             (see the {@link #setRevocationEnabled(boolean) setRevocationEnabled}
             method).<br />
             <br />
             Note that the List supplied here is copied and each PKIXCertPathChecker
             in the list is cloned to protect against subsequent modifications.
            
             @param checkers
                        a List of PKIXCertPathCheckers. May be null, in which case no
                        additional checkers will be used.
             @exception ClassCastException
                            if any of the elements in the list are not of type
                            <code>java.security.cert.PKIXCertPathChecker</code>
             @see #getCertPathCheckers()
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.GetCertPathCheckers">
             Returns the List of certification path checkers. Each PKIXCertPathChecker
             in the returned IList is cloned to protect against subsequent modifications.
            
             @return an immutable List of PKIXCertPathCheckers (may be empty, but not
                     <code>null</code>)
            
             @see #setCertPathCheckers(java.util.List)
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.AddCertPathChecker(Org.BouncyCastle.Pkix.PkixCertPathChecker)">
             Adds a <code>PKIXCertPathChecker</code> to the list of certification
             path checkers. See the {@link #setCertPathCheckers setCertPathCheckers}
             method for more details.
             <p>
             Note that the <code>PKIXCertPathChecker</code> is cloned to protect
             against subsequent modifications.</p>
            
             @param checker a <code>PKIXCertPathChecker</code> to add to the list of
             checks. If <code>null</code>, the checker is ignored (not added to list).
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.SetParams(Org.BouncyCastle.Pkix.PkixParameters)">
             Method to support <code>Clone()</code> under J2ME.
             <code>super.Clone()</code> does not exist and fields are not copied.
            
             @param params Parameters to set. If this are
                        <code>ExtendedPkixParameters</code> they are copied to.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.SetStores(System.Collections.IList)">
             Sets the Bouncy Castle Stores for finding CRLs, certificates, attribute
             certificates or cross certificates.
             <p>
             The <code>IList</code> is cloned.
             </p>
            
             @param stores A list of stores to use.
             @see #getStores
             @throws ClassCastException if an element of <code>stores</code> is not
                         a {@link Store}.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.AddStore(Org.BouncyCastle.X509.Store.IX509Store)">
             Adds a Bouncy Castle {@link Store} to find CRLs, certificates, attribute
             certificates or cross certificates.
             <p>
             This method should be used to add local stores, like collection based
             X.509 stores, if available. Local stores should be considered first,
             before trying to use additional (remote) locations, because they do not
             need possible additional network traffic.
             </p><p>
             If <code>store</code> is <code>null</code> it is ignored.
             </p>
            
             @param store The store to add.
             @see #getStores
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.AddAdditionalStore(Org.BouncyCastle.X509.Store.IX509Store)">
             Adds an additional Bouncy Castle {@link Store} to find CRLs, certificates,
             attribute certificates or cross certificates.
             <p>
             You should not use this method. This method is used for adding additional
             X.509 stores, which are used to add (remote) locations, e.g. LDAP, found
             during X.509 object processing, e.g. in certificates or CRLs. This method
             is used in PKIX certification path processing.
             </p><p>
             If <code>store</code> is <code>null</code> it is ignored.
             </p>
            
             @param store The store to add.
             @see #getStores()
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.GetAdditionalStores">
             Returns an <code>IList</code> of additional Bouncy Castle
             <code>Store</code>s used for finding CRLs, certificates, attribute
             certificates or cross certificates.
            
             @return an immutable <code>IList</code> of additional Bouncy Castle
                     <code>Store</code>s. Never <code>null</code>.
            
             @see #addAddionalStore(Store)
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.GetStores">
             Returns an <code>IList</code> of Bouncy Castle
             <code>Store</code>s used for finding CRLs, certificates, attribute
             certificates or cross certificates.
            
             @return an immutable <code>IList</code> of Bouncy Castle
                     <code>Store</code>s. Never <code>null</code>.
            
             @see #setStores(IList)
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.SetAdditionalLocationsEnabled(System.Boolean)">
             Sets if additional {@link X509Store}s for locations like LDAP found in
             certificates or CRLs should be used.
            
             @param enabled <code>true</code> if additional stores are used.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.GetTargetConstraints">
             Returns the required constraints on the target certificate or attribute
             certificate. The constraints are returned as an instance of
             <code>IX509Selector</code>. If <code>null</code>, no constraints are
             defined.
            
             <p>
             The target certificate in a PKIX path may be a certificate or an
             attribute certificate.
             </p><p>
             Note that the <code>IX509Selector</code> returned is cloned to protect
             against subsequent modifications.
             </p>
             @return a <code>IX509Selector</code> specifying the constraints on the
                     target certificate or attribute certificate (or <code>null</code>)
             @see #setTargetConstraints
             @see X509CertStoreSelector
             @see X509AttributeCertStoreSelector
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.SetTargetConstraints(Org.BouncyCastle.X509.Store.IX509Selector)">
             Sets the required constraints on the target certificate or attribute
             certificate. The constraints are specified as an instance of
             <code>IX509Selector</code>. If <code>null</code>, no constraints are
             defined.
             <p>
             The target certificate in a PKIX path may be a certificate or an
             attribute certificate.
             </p><p>
             Note that the <code>IX509Selector</code> specified is cloned to protect
             against subsequent modifications.
             </p>
            
             @param selector a <code>IX509Selector</code> specifying the constraints on
                        the target certificate or attribute certificate (or
                        <code>null</code>)
             @see #getTargetConstraints
             @see X509CertStoreSelector
             @see X509AttributeCertStoreSelector
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.GetTrustedACIssuers">
             Returns the trusted attribute certificate issuers. If attribute
             certificates is verified the trusted AC issuers must be set.
             <p>
             The returned <code>ISet</code> consists of <code>TrustAnchor</code>s.
             </p><p>
             The returned <code>ISet</code> is immutable. Never <code>null</code>
             </p>
            
             @return Returns an immutable set of the trusted AC issuers.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.SetTrustedACIssuers(Org.BouncyCastle.Utilities.Collections.ISet)">
             Sets the trusted attribute certificate issuers. If attribute certificates
             is verified the trusted AC issuers must be set.
             <p>
             The <code>trustedACIssuers</code> must be a <code>ISet</code> of
             <code>TrustAnchor</code>
             </p><p>
             The given set is cloned.
             </p>
            
             @param trustedACIssuers The trusted AC issuers to set. Is never
                        <code>null</code>.
             @throws ClassCastException if an element of <code>stores</code> is not
                         a <code>TrustAnchor</code>.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.GetNecessaryACAttributes">
             Returns the necessary attributes which must be contained in an attribute
             certificate.
             <p>
             The returned <code>ISet</code> is immutable and contains
             <code>String</code>s with the OIDs.
             </p>
            
             @return Returns the necessary AC attributes.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.SetNecessaryACAttributes(Org.BouncyCastle.Utilities.Collections.ISet)">
             Sets the necessary which must be contained in an attribute certificate.
             <p>
             The <code>ISet</code> must contain <code>String</code>s with the
             OIDs.
             </p><p>
             The set is cloned.
             </p>
            
             @param necessaryACAttributes The necessary AC attributes to set.
             @throws ClassCastException if an element of
                         <code>necessaryACAttributes</code> is not a
                         <code>String</code>.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.GetProhibitedACAttributes">
             Returns the attribute certificates which are not allowed.
             <p>
             The returned <code>ISet</code> is immutable and contains
             <code>String</code>s with the OIDs.
             </p>
            
             @return Returns the prohibited AC attributes. Is never <code>null</code>.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.SetProhibitedACAttributes(Org.BouncyCastle.Utilities.Collections.ISet)">
             Sets the attribute certificates which are not allowed.
             <p>
             The <code>ISet</code> must contain <code>String</code>s with the
             OIDs.
             </p><p>
             The set is cloned.
             </p>
            
             @param prohibitedACAttributes The prohibited AC attributes to set.
             @throws ClassCastException if an element of
                         <code>prohibitedACAttributes</code> is not a
                         <code>String</code>.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.GetAttrCertCheckers">
             Returns the attribute certificate checker. The returned set contains
             {@link PKIXAttrCertChecker}s and is immutable.
            
             @return Returns the attribute certificate checker. Is never
                     <code>null</code>.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.SetAttrCertCheckers(Org.BouncyCastle.Utilities.Collections.ISet)">
             Sets the attribute certificate checkers.
             <p>
             All elements in the <code>ISet</code> must a {@link PKIXAttrCertChecker}.
             </p>
             <p>
             The given set is cloned.
             </p>
            
             @param attrCertCheckers The attribute certificate checkers to set. Is
                        never <code>null</code>.
             @throws ClassCastException if an element of <code>attrCertCheckers</code>
                         is not a <code>PKIXAttrCertChecker</code>.
        </member>
        <member name="P:Org.BouncyCastle.Pkix.PkixParameters.IsUseDeltasEnabled">
            Whether delta CRLs should be used for checking the revocation status.
            Defaults to <code>false</code>.
        </member>
        <member name="P:Org.BouncyCastle.Pkix.PkixParameters.ValidityModel">
            The validity model.
            @see #CHAIN_VALIDITY_MODEL
            @see #PKIX_VALIDITY_MODEL
        </member>
        <member name="P:Org.BouncyCastle.Pkix.PkixParameters.IsAdditionalLocationsEnabled">
             Returns if additional {@link X509Store}s for locations like LDAP found
             in certificates or CRLs should be used.
            
             @return Returns <code>true</code> if additional stores are used.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixBuilderParameters.GetInstance(Org.BouncyCastle.Pkix.PkixParameters)">
             Returns an instance of <code>PkixBuilderParameters</code>.
             <p>
             This method can be used to get a copy from other
             <code>PKIXBuilderParameters</code>, <code>PKIXParameters</code>,
             and <code>ExtendedPKIXParameters</code> instances.
             </p>
            
             @param pkixParams The PKIX parameters to create a copy of.
             @return An <code>PkixBuilderParameters</code> instance.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixBuilderParameters.GetExcludedCerts">
            <summary>
            Excluded certificates are not used for building a certification path.
            </summary>
            <returns>the excluded certificates.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixBuilderParameters.SetExcludedCerts(Org.BouncyCastle.Utilities.Collections.ISet)">
            <summary>
            Sets the excluded certificates which are not used for building a
            certification path. If the <code>ISet</code> is <code>null</code> an
            empty set is assumed.
            </summary>
            <remarks>
            The given set is cloned to protect it against subsequent modifications.
            </remarks>
            <param name="excludedCerts">The excluded certificates to set.</param>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixBuilderParameters.SetParams(Org.BouncyCastle.Pkix.PkixParameters)">
            Can alse handle <code>ExtendedPKIXBuilderParameters</code> and
            <code>PKIXBuilderParameters</code>.
            
            @param params Parameters to set.
            @see org.bouncycastle.x509.ExtendedPKIXParameters#setParams(java.security.cert.PKIXParameters)
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixBuilderParameters.Clone">
             Makes a copy of this <code>PKIXParameters</code> object. Changes to the
             copy will not affect the original and vice versa.
            
             @return a copy of this <code>PKIXParameters</code> object
        </member>
        <member name="T:Org.BouncyCastle.Pkix.PkixCertPath">
             An immutable sequence of certificates (a certification path).<br />
             <br />
             This is an abstract class that defines the methods common to all CertPaths.
             Subclasses can handle different kinds of certificates (X.509, PGP, etc.).<br />
             <br />
             All CertPath objects have a type, a list of Certificates, and one or more
             supported encodings. Because the CertPath class is immutable, a CertPath
             cannot change in any externally visible way after being constructed. This
             stipulation applies to all public fields and methods of this class and any
             added or overridden by subclasses.<br />
             <br />
             The type is a string that identifies the type of Certificates in the
             certification path. For each certificate cert in a certification path
             certPath, cert.getType().equals(certPath.getType()) must be true.<br />
             <br />
             The list of Certificates is an ordered List of zero or more Certificates.
             This List and all of the Certificates contained in it must be immutable.<br />
             <br />
             Each CertPath object must support one or more encodings so that the object
             can be translated into a byte array for storage or transmission to other
             parties. Preferably, these encodings should be well-documented standards
             (such as PKCS#7). One of the encodings supported by a CertPath is considered
             the default encoding. This encoding is used if no encoding is explicitly
             requested (for the {@link #getEncoded()} method, for instance).<br />
             <br />
             All CertPath objects are also Serializable. CertPath objects are resolved
             into an alternate {@link CertPathRep} object during serialization. This
             allows a CertPath object to be serialized into an equivalent representation
             regardless of its underlying implementation.<br />
             <br />
             CertPath objects can be created with a CertificateFactory or they can be
             returned by other classes, such as a CertPathBuilder.<br />
             <br />
             By convention, X.509 CertPaths (consisting of X509Certificates), are ordered
             starting with the target certificate and ending with a certificate issued by
             the trust anchor. That is, the issuer of one certificate is the subject of
             the following one. The certificate representing the
             {@link TrustAnchor TrustAnchor} should not be included in the certification
             path. Unvalidated X.509 CertPaths may not follow these conventions. PKIX
             CertPathValidators will detect any departure from these conventions that
             cause the certification path to be invalid and throw a
             CertPathValidatorException.<br />
             <br />
             <strong>Concurrent Access</strong><br />
             <br />
             All CertPath objects must be thread-safe. That is, multiple threads may
             concurrently invoke the methods defined in this class on a single CertPath
             object (or more than one) with no ill effects. This is also true for the List
             returned by CertPath.getCertificates.<br />
             <br />
             Requiring CertPath objects to be immutable and thread-safe allows them to be
             passed around to various pieces of code without worrying about coordinating
             access. Providing this thread-safety is generally not difficult, since the
             CertPath and List objects in question are immutable.
            
             @see CertificateFactory
             @see CertPathBuilder
            <summary>
            CertPath implementation for X.509 certificates.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPath.SortCerts(System.Collections.IList)">
            @param certs
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPath.#ctor(System.Collections.ICollection)">
             Creates a CertPath of the specified type.
             This constructor is protected because most users should use
             a CertificateFactory to create CertPaths.
             @param type the standard name of the type of Certificatesin this path
            
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPath.#ctor(System.IO.Stream,System.String)">
             Creates a CertPath of the specified type.
             This constructor is protected because most users should use
             a CertificateFactory to create CertPaths.
            
             @param type the standard name of the type of Certificatesin this path
            
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPath.Equals(System.Object)">
             Compares this certification path for equality with the specified object.
             Two CertPaths are equal if and only if their types are equal and their
             certificate Lists (and by implication the Certificates in those Lists)
             are equal. A CertPath is never equal to an object that is not a CertPath.<br />
             <br />
             This algorithm is implemented by this method. If it is overridden, the
             behavior specified here must be maintained.
            
             @param other
                        the object to test for equality with this certification path
            
             @return true if the specified object is equal to this certification path,
                     false otherwise
            
             @see Object#hashCode() Object.hashCode()
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPath.GetEncoded">
             Returns the encoded form of this certification path, using
             the default encoding.
            
             @return the encoded bytes
             @exception CertificateEncodingException if an encoding error occurs
            
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPath.GetEncoded(System.String)">
             Returns the encoded form of this certification path, using
             the specified encoding.
            
             @param encoding the name of the encoding to use
             @return the encoded bytes
             @exception CertificateEncodingException if an encoding error
             occurs or the encoding requested is not supported
            
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPath.ToAsn1Object(Org.BouncyCastle.X509.X509Certificate)">
             Return a DERObject containing the encoded certificate.
            
             @param cert the X509Certificate object to be encoded
            
             @return the DERObject
            
        </member>
        <member name="P:Org.BouncyCastle.Pkix.PkixCertPath.Encodings">
             Returns an iteration of the encodings supported by this
             certification path, with the default encoding
             first. Attempts to modify the returned Iterator via its
             remove method result in an UnsupportedOperationException.
            
             @return an Iterator over the names of the supported encodings (as Strings)
            
        </member>
        <member name="P:Org.BouncyCastle.Pkix.PkixCertPath.Certificates">
            <summary>
            Returns the list of certificates in this certification
            path.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Pkix.PkixCertPathBuilder">
             Implements the PKIX CertPathBuilding algorithm for BouncyCastle.
            
             @see CertPathBuilderSpi
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathBuilder.Build(Org.BouncyCastle.Pkix.PkixBuilderParameters)">
             Build and validate a CertPath using the given parameter.
            
             @param params PKIXBuilderParameters object containing all information to
                        build the CertPath
        </member>
        <member name="T:Org.BouncyCastle.Pkix.PkixCertPathBuilderException">
            <summary>
            Summary description for PkixCertPathBuilderException.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Pkix.PkixCertPathBuilderResult">
            <summary>
            Summary description for PkixCertPathBuilderResult.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Pkix.PkixCertPathValidatorResult">
            <summary>
            Summary description for PkixCertPathValidatorResult.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathChecker.Init(System.Boolean)">
                     * Initializes the internal state of this <code>PKIXCertPathChecker</code>.
                     * <p>
                     * The <code>forward</code> flag specifies the order that certificates
                     * will be passed to the {@link #check check} method (forward or reverse). A
                     * <code>PKIXCertPathChecker</code> <b>must</b> support reverse checking
                     * and <b>may</b> support forward checking.
            		 * </p>
                     * 
                     * @param forward
                     *            the order that certificates are presented to the
                     *            <code>check</code> method. If <code>true</code>,
                     *            certificates are presented from target to most-trusted CA
                     *            (forward); if <code>false</code>, from most-trusted CA to
                     *            target (reverse).
                     * @exception CertPathValidatorException
                     *                if this <code>PKIXCertPathChecker</code> is unable to
                     *                check certificates in the specified order; it should never
                     *                be thrown if the forward flag is false since reverse
                     *                checking must be supported
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathChecker.IsForwardCheckingSupported">
            Indicates if forward checking is supported. Forward checking refers to
            the ability of the <code>PKIXCertPathChecker</code> to perform its
            checks when certificates are presented to the <code>check</code> method
            in the forward direction (from target to most-trusted CA).
            
            @return <code>true</code> if forward checking is supported,
                    <code>false</code> otherwise
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathChecker.GetSupportedExtensions">
                     * Returns an immutable <code>Set</code> of X.509 certificate extensions
                     * that this <code>PKIXCertPathChecker</code> supports (i.e. recognizes,
                     * is able to process), or <code>null</code> if no extensions are
                     * supported.
                     * <p>
                     * Each element of the set is a <code>String</code> representing the
                     * Object Identifier (OID) of the X.509 extension that is supported. The OID
                     * is represented by a set of nonnegative integers separated by periods.
                     * </p><p>
                     * All X.509 certificate extensions that a <code>PKIXCertPathChecker</code>
                     * might possibly be able to process should be included in the set.
            		 * </p>
                     * 
                     * @return an immutable <code>Set</code> of X.509 extension OIDs (in
                     *         <code>String</code> format) supported by this
                     *         <code>PKIXCertPathChecker</code>, or <code>null</code> if no
                     *         extensions are supported
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathChecker.Check(Org.BouncyCastle.X509.X509Certificate,Org.BouncyCastle.Utilities.Collections.ISet)">
            Performs the check(s) on the specified certificate using its internal
            state and removes any critical extensions that it processes from the
            specified collection of OID strings that represent the unresolved
            critical extensions. The certificates are presented in the order
            specified by the <code>init</code> method.
            
            @param cert
                       the <code>Certificate</code> to be checked
            @param unresolvedCritExts
                       a <code>Collection</code> of OID strings representing the
                       current set of unresolved critical extensions
            @exception CertPathValidatorException
                           if the specified certificate does not pass the check
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathChecker.Clone">
            Returns a clone of this object. Calls the <code>Object.clone()</code>
            method. All subclasses which maintain state must support and override
            this method, if necessary.
            
            @return a copy of this <code>PKIXCertPathChecker</code>
        </member>
        <member name="T:Org.BouncyCastle.Pkix.PkixCertPathValidator">
            The <i>Service Provider Interface</i> (<b>SPI</b>)
            for the {@link CertPathValidator CertPathValidator} class. All
            <code>CertPathValidator</code> implementations must include a class (the
            SPI class) that extends this class (<code>CertPathValidatorSpi</code>)
            and implements all of its methods. In general, instances of this class
            should only be accessed through the <code>CertPathValidator</code> class.
            For details, see the Java Cryptography Architecture.<br />
            <br />
            <b>Concurrent Access</b><br />
            <br />
            Instances of this class need not be protected against concurrent
            access from multiple threads. Threads that need to access a single
            <code>CertPathValidatorSpi</code> instance concurrently should synchronize
            amongst themselves and provide the necessary locking before calling the
            wrapping <code>CertPathValidator</code> object.<br />
            <br />
            However, implementations of <code>CertPathValidatorSpi</code> may still
            encounter concurrency issues, since multiple threads each
            manipulating a different <code>CertPathValidatorSpi</code> instance need not
            synchronize.
            <summary>
            CertPathValidatorSpi implementation for X.509 Certificate validation a la RFC
            3280.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Pkix.PkixCertPathValidatorException">
             An exception indicating one of a variety of problems encountered when 
             validating a certification path. <br />
             <br />
             A <code>CertPathValidatorException</code> provides support for wrapping
             exceptions. The {@link #getCause getCause} method returns the throwable, 
             if any, that caused this exception to be thrown. <br />
             <br />
             A <code>CertPathValidatorException</code> may also include the 
             certification path that was being validated when the exception was thrown 
             and the index of the certificate in the certification path that caused the 
             exception to be thrown. Use the {@link #getCertPath getCertPath} and
             {@link #getIndex getIndex} methods to retrieve this information.<br />
             <br />
             <b>Concurrent Access</b><br />
             <br />
             Unless otherwise specified, the methods defined in this class are not
             thread-safe. Multiple threads that need to access a single
             object concurrently should synchronize amongst themselves and
             provide the necessary locking. Multiple threads each manipulating
             separate objects need not synchronize.
            
             @see CertPathValidator
            
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorException.#ctor(System.String)">
            <summary>
            Creates a <code>PkixCertPathValidatorException</code> with the given detail
            message. A detail message is a <code>String</code> that describes this
            particular exception. 
            </summary>
            <param name="message">the detail message</param>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a <code>PkixCertPathValidatorException</code> with the specified
            detail message and cause.
            </summary>
            <param name="message">the detail message</param>
            <param name="cause">the cause (which is saved for later retrieval by the
            {@link #getCause getCause()} method). (A <code>null</code>
            value is permitted, and indicates that the cause is
            nonexistent or unknown.)</param>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorException.#ctor(System.String,System.Exception,Org.BouncyCastle.Pkix.PkixCertPath,System.Int32)">
            <summary>
            Creates a <code>PkixCertPathValidatorException</code> with the specified
            detail message, cause, certification path, and index.
            </summary>
            <param name="message">the detail message (or <code>null</code> if none)</param>
            <param name="cause">the cause (or <code>null</code> if none)</param>
            <param name="certPath">the certification path that was in the process of being
            validated when the error was encountered</param>
            <param name="index">the index of the certificate in the certification path that</param>																																																																																   * 
        </member>
        <member name="P:Org.BouncyCastle.Pkix.PkixCertPathValidatorException.Message">
            <summary>
            Returns the detail message for this <code>CertPathValidatorException</code>.
            </summary>
            <returns>the detail message, or <code>null</code> if neither the message nor cause were specified</returns>
        </member>
        <member name="P:Org.BouncyCastle.Pkix.PkixCertPathValidatorException.CertPath">
            Returns the certification path that was being validated when the
            exception was thrown.
            
            @return the <code>CertPath</code> that was being validated when the
                    exception was thrown (or <code>null</code> if not specified)
        </member>
        <member name="P:Org.BouncyCastle.Pkix.PkixCertPathValidatorException.Index">
            Returns the index of the certificate in the certification path that
            caused the exception to be thrown. Note that the list of certificates in
            a <code>CertPath</code> is zero based. If no index has been set, -1 is
            returned.
            
            @return the index that has been set, or -1 if none has been set
        </member>
        <member name="T:Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities">
            <summary>
            Summary description for PkixCertPathValidatorUtilities.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.KEY_CERT_SIGN">
            <summary>
            key usage bits
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.FindTrustAnchor(Org.BouncyCastle.X509.X509Certificate,Org.BouncyCastle.Utilities.Collections.ISet)">
            <summary>
            Search the given Set of TrustAnchor's for one that is the
            issuer of the given X509 certificate.
            </summary>
            <param name="cert">the X509 certificate</param>
            <param name="trustAnchors">a Set of TrustAnchor's</param>
            <returns>the <code>TrustAnchor</code> object if found or
            <code>null</code> if not.
            </returns>
            @exception
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.GetIssuerPrincipal(System.Object)">
            <summary>
            Returns the issuer of an attribute certificate or certificate.
            </summary>
            <param name="cert">The attribute certificate or certificate.</param>
            <returns>The issuer as <code>X500Principal</code>.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.GetNextWorkingKey(System.Collections.IList,System.Int32)">
             Return the next working key inheriting DSA parameters if necessary.
             <p>
             This methods inherits DSA parameters from the indexed certificate or
             previous certificates in the certificate chain to the returned
             <code>PublicKey</code>. The list is searched upwards, meaning the end
             certificate is at position 0 and previous certificates are following.
             </p>
             <p>
             If the indexed certificate does not contain a DSA key this method simply
             returns the public key. If the DSA key already contains DSA parameters
             the key is also only returned.
             </p>
            
             @param certs The certification path.
             @param index The index of the certificate which contains the public key
                        which should be extended with DSA parameters.
             @return The public key of the certificate in list position
                     <code>index</code> extended with DSA parameters if applicable.
             @throws Exception if DSA parameters cannot be inherited.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.FindCertificates(Org.BouncyCastle.X509.Store.X509CertStoreSelector,System.Collections.IList)">
            <summary>
            Return a Collection of all certificates or attribute certificates found
            in the X509Store's that are matching the certSelect criteriums.
            </summary>
            <param name="certSelect">a {@link Selector} object that will be used to select
            the certificates</param>
            <param name="certStores">a List containing only X509Store objects. These
            are used to search for certificates.</param>
            <returns>a Collection of all found <see cref="T:Org.BouncyCastle.X509.X509Certificate"/> or
            <see cref="T:Org.BouncyCastle.X509.IX509AttributeCertificate"/> objects.
            May be empty but never <code>null</code>.</returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.GetCrlIssuersFromDistributionPoint(Org.BouncyCastle.Asn1.X509.DistributionPoint,System.Collections.ICollection,Org.BouncyCastle.X509.Store.X509CrlStoreSelector,Org.BouncyCastle.Pkix.PkixParameters)">
             Add the CRL issuers from the cRLIssuer field of the distribution point or
             from the certificate if not given to the issuer criterion of the
             <code>selector</code>.
             <p>
             The <code>issuerPrincipals</code> are a collection with a single
             <code>X500Principal</code> for <code>X509Certificate</code>s. For
             {@link X509AttributeCertificate}s the issuer may contain more than one
             <code>X500Principal</code>.
             </p>
            
             @param dp The distribution point.
             @param issuerPrincipals The issuers of the certificate or attribute
                        certificate which contains the distribution point.
             @param selector The CRL selector.
             @param pkixParams The PKIX parameters containing the cert stores.
             @throws Exception if an exception occurs while processing.
             @throws ClassCastException if <code>issuerPrincipals</code> does not
             contain only <code>X500Principal</code>s.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.GetCompleteCrls(Org.BouncyCastle.Asn1.X509.DistributionPoint,System.Object,System.DateTime,Org.BouncyCastle.Pkix.PkixParameters)">
             Fetches complete CRLs according to RFC 3280.
            
             @param dp The distribution point for which the complete CRL
             @param cert The <code>X509Certificate</code> or
                        {@link org.bouncycastle.x509.X509AttributeCertificate} for
                        which the CRL should be searched.
             @param currentDate The date for which the delta CRLs must be valid.
             @param paramsPKIX The extended PKIX parameters.
             @return A <code>Set</code> of <code>X509CRL</code>s with complete
                     CRLs.
             @throws Exception if an exception occurs while picking the CRLs
                         or no CRLs are found.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.GetDeltaCrls(System.DateTime,Org.BouncyCastle.Pkix.PkixParameters,Org.BouncyCastle.X509.X509Crl)">
             Fetches delta CRLs according to RFC 3280 section 5.2.4.
            
             @param currentDate The date for which the delta CRLs must be valid.
             @param paramsPKIX The extended PKIX parameters.
             @param completeCRL The complete CRL the delta CRL is for.
             @return A <code>Set</code> of <code>X509CRL</code>s with delta CRLs.
             @throws Exception if an exception occurs while picking the delta
                         CRLs.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.FindIssuerCerts(Org.BouncyCastle.X509.X509Certificate,Org.BouncyCastle.Pkix.PkixBuilderParameters)">
             Find the issuer certificates of a given certificate.
            
             @param cert
                        The certificate for which an issuer should be found.
             @param pkixParams
             @return A <code>Collection</code> object containing the issuer
                     <code>X509Certificate</code>s. Never <code>null</code>.
            
             @exception Exception
                            if an error occurs.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.GetExtensionValue(Org.BouncyCastle.X509.IX509Extension,Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>
            Extract the value of the given extension, if it exists.
            </summary>
            <param name="ext">The extension object.</param>
            <param name="oid">The object identifier to obtain.</param>
            <returns>Asn1Object</returns>
            <exception cref="T:System.Exception">if the extension cannot be read.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCrlUtilities.FindCrls(Org.BouncyCastle.X509.Store.X509CrlStoreSelector,System.Collections.IList)">
            <summary>
            crl checking
            Return a Collection of all CRLs found in the X509Store's that are
            matching the crlSelect criteriums.
            </summary>
            <param name="crlSelect">a {@link X509CRLStoreSelector} object that will be used
            to select the CRLs</param>
            <param name="crlStores">a List containing only {@link org.bouncycastle.x509.X509Store
            X509Store} objects. These are used to search for CRLs</param>
            <returns>a Collection of all found {@link X509CRL X509CRL} objects. May be
            empty but never <code>null</code>.
            </returns>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.IntersectIP(Org.BouncyCastle.Utilities.Collections.ISet,Org.BouncyCastle.Utilities.Collections.ISet)">
             Returns the intersection of the permitted IP ranges in
             <code>permitted</code> with <code>ip</code>.
            
             @param permitted A <code>Set</code> of permitted IP addresses with
                              their subnet mask as byte arrays.
             @param ips       The IP address with its subnet mask.
             @return The <code>Set</code> of permitted IP ranges intersected with
                     <code>ip</code>.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.UnionIP(Org.BouncyCastle.Utilities.Collections.ISet,System.Byte[])">
             Returns the union of the excluded IP ranges in <code>excluded</code>
             with <code>ip</code>.
            
             @param excluded A <code>Set</code> of excluded IP addresses with their
                             subnet mask as byte arrays.
             @param ip       The IP address with its subnet mask.
             @return The <code>Set</code> of excluded IP ranges unified with
                     <code>ip</code> as byte arrays.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.UnionIPRange(System.Byte[],System.Byte[])">
             Calculates the union if two IP ranges.
            
             @param ipWithSubmask1 The first IP address with its subnet mask.
             @param ipWithSubmask2 The second IP address with its subnet mask.
             @return A <code>Set</code> with the union of both addresses.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.IntersectIPRange(System.Byte[],System.Byte[])">
             Calculates the interesction if two IP ranges.
            
             @param ipWithSubmask1 The first IP address with its subnet mask.
             @param ipWithSubmask2 The second IP address with its subnet mask.
             @return A <code>Set</code> with the single IP address with its subnet
                     mask as a byte array or an empty <code>Set</code>.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.IpWithSubnetMask(System.Byte[],System.Byte[])">
             Concatenates the IP address with its subnet mask.
            
             @param ip         The IP address.
             @param subnetMask Its subnet mask.
             @return The concatenated IP address with its subnet mask.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.ExtractIPsAndSubnetMasks(System.Byte[],System.Byte[])">
             Splits the IP addresses and their subnet mask.
            
             @param ipWithSubmask1 The first IP address with the subnet mask.
             @param ipWithSubmask2 The second IP address with the subnet mask.
             @return An array with two elements. Each element contains the IP address
                     and the subnet mask in this order.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.MinMaxIPs(System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
             Based on the two IP addresses and their subnet masks the IP range is
             computed for each IP address - subnet mask pair and returned as the
             minimum IP address and the maximum address of the range.
            
             @param ip1         The first IP address.
             @param subnetmask1 The subnet mask of the first IP address.
             @param ip2         The second IP address.
             @param subnetmask2 The subnet mask of the second IP address.
             @return A array with two elements. The first/second element contains the
                     min and max IP address of the first/second IP address and its
                     subnet mask.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.CheckPermittedIP(Org.BouncyCastle.Utilities.Collections.ISet,System.Byte[])">
             Checks if the IP <code>ip</code> is included in the permitted ISet
             <code>permitted</code>.
            
             @param permitted A <code>Set</code> of permitted IP addresses with
                              their subnet mask as byte arrays.
             @param ip        The IP address.
             @throws PkixNameConstraintValidatorException
                      if the IP is not permitted.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.checkExcludedIP(Org.BouncyCastle.Utilities.Collections.ISet,System.Byte[])">
             Checks if the IP <code>ip</code> is included in the excluded ISet
             <code>excluded</code>.
            
             @param excluded A <code>Set</code> of excluded IP addresses with their
                             subnet mask as byte arrays.
             @param ip       The IP address.
             @throws PkixNameConstraintValidatorException
                      if the IP is excluded.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.IsIPConstrained(System.Byte[],System.Byte[])">
             Checks if the IP address <code>ip</code> is constrained by
             <code>constraint</code>.
            
             @param ip         The IP address.
             @param constraint The constraint. This is an IP address concatenated with
                               its subnetmask.
             @return <code>true</code> if constrained, <code>false</code>
                     otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.unionEmail(System.String,System.String,Org.BouncyCastle.Utilities.Collections.ISet)">
             The common part of <code>email1</code> and <code>email2</code> is
             added to the union <code>union</code>. If <code>email1</code> and
             <code>email2</code> have nothing in common they are added both.
            
             @param email1 Email address constraint 1.
             @param email2 Email address constraint 2.
             @param union  The union.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.intersectEmail(System.String,System.String,Org.BouncyCastle.Utilities.Collections.ISet)">
             The most restricting part from <code>email1</code> and
             <code>email2</code> is added to the intersection <code>intersect</code>.
            
             @param email1    Email address constraint 1.
             @param email2    Email address constraint 2.
             @param intersect The intersection.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.checkPermitted(Org.BouncyCastle.Asn1.X509.GeneralName)">
             Checks if the given GeneralName is in the permitted ISet.
            
             @param name The GeneralName
             @throws PkixNameConstraintValidatorException
                      If the <code>name</code>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.checkExcluded(Org.BouncyCastle.Asn1.X509.GeneralName)">
             Check if the given GeneralName is contained in the excluded ISet.
            
             @param name The GeneralName.
             @throws PkixNameConstraintValidatorException
                      If the <code>name</code> is
                      excluded.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.IntersectPermittedSubtree(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Updates the permitted ISet of these name constraints with the intersection
             with the given subtree.
            
             @param permitted The permitted subtrees
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.AddExcludedSubtree(Org.BouncyCastle.Asn1.X509.GeneralSubtree)">
             Adds a subtree to the excluded ISet of these name constraints.
            
             @param subtree A subtree with an excluded GeneralName.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.Max(System.Byte[],System.Byte[])">
             Returns the maximum IP address.
            
             @param ip1 The first IP address.
             @param ip2 The second IP address.
             @return The maximum IP address.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.Min(System.Byte[],System.Byte[])">
             Returns the minimum IP address.
            
             @param ip1 The first IP address.
             @param ip2 The second IP address.
             @return The minimum IP address.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.CompareTo(System.Byte[],System.Byte[])">
             Compares IP address <code>ip1</code> with <code>ip2</code>. If ip1
             is equal to ip2 0 is returned. If ip1 is bigger 1 is returned, -1
             otherwise.
            
             @param ip1 The first IP address.
             @param ip2 The second IP address.
             @return 0 if ip1 is equal to ip2, 1 if ip1 is bigger, -1 otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.Or(System.Byte[],System.Byte[])">
             Returns the logical OR of the IP addresses <code>ip1</code> and
             <code>ip2</code>.
            
             @param ip1 The first IP address.
             @param ip2 The second IP address.
             @return The OR of <code>ip1</code> and <code>ip2</code>.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.StringifyIP(System.Byte[])">
             Stringifies an IPv4 or v6 address with subnet mask.
            
             @param ip The IP with subnet mask.
             @return The stringified IP address.
        </member>
        <member name="T:Org.BouncyCastle.Pkix.PkixPolicyNode">
            <summary>
            Summary description for PkixPolicyNode.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixPolicyNode.#ctor(System.Collections.IList,System.Int32,Org.BouncyCastle.Utilities.Collections.ISet,Org.BouncyCastle.Pkix.PkixPolicyNode,Org.BouncyCastle.Utilities.Collections.ISet,System.String,System.Boolean)">
            Constructors
        </member>
        <member name="T:Org.BouncyCastle.Pkix.ReasonsMask">
            <summary>
            This class helps to handle CRL revocation reasons mask. Each CRL handles a
            certain set of revocation reasons.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.ReasonsMask.#ctor(System.Int32)">
            <summary>
            Constructs are reason mask with the reasons.
            </summary>
            <param name="reasons">The reasons.</param>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.ReasonsMask.#ctor">
            <summary>
            A reason mask with no reason.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Pkix.ReasonsMask.AllReasons">
            <summary>
            A mask with all revocation reasons.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.ReasonsMask.AddReasons(Org.BouncyCastle.Pkix.ReasonsMask)">
             Adds all reasons from the reasons mask to this mask.
            
             @param mask The reasons mask to add.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.ReasonsMask.Intersect(Org.BouncyCastle.Pkix.ReasonsMask)">
            <summary>
            Intersects this mask with the given reasons mask.
            </summary>
            <param name="mask">mask The mask to intersect with.</param>
            <returns>The intersection of this and teh given mask.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.ReasonsMask.HasNewReasons(Org.BouncyCastle.Pkix.ReasonsMask)">
            <summary>
            Returns <c>true</c> if the passed reasons mask has new reasons.
            </summary>
            <param name="mask">The reasons mask which should be tested for new reasons.</param>
            <returns><c>true</c> if the passed reasons mask has new reasons.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Pkix.ReasonsMask.IsAllReasons">
            <summary>
            Returns <code>true</code> if this reasons mask contains all possible
            reasons.
            </summary>
            <returns>true if this reasons mask contains all possible reasons.
            </returns>
        </member>
        <member name="P:Org.BouncyCastle.Pkix.ReasonsMask.Reasons">
            <summary>
            Returns the reasons in this mask.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.ProcessCrlB2(Org.BouncyCastle.Asn1.X509.DistributionPoint,System.Object,Org.BouncyCastle.X509.X509Crl)">
             If the complete CRL includes an issuing distribution point (IDP) CRL
             extension check the following:
             <p>
             (i) If the distribution point name is present in the IDP CRL extension
             and the distribution field is present in the DP, then verify that one of
             the names in the IDP matches one of the names in the DP. If the
             distribution point name is present in the IDP CRL extension and the
             distribution field is omitted from the DP, then verify that one of the
             names in the IDP matches one of the names in the cRLIssuer field of the
             DP.
             </p>
             <p>
             (ii) If the onlyContainsUserCerts boolean is asserted in the IDP CRL
             extension, verify that the certificate does not include the basic
             constraints extension with the cA boolean asserted.
             </p>
             <p>
             (iii) If the onlyContainsCACerts boolean is asserted in the IDP CRL
             extension, verify that the certificate includes the basic constraints
             extension with the cA boolean asserted.
             </p>
             <p>
             (iv) Verify that the onlyContainsAttributeCerts boolean is not asserted.
             </p>
            
             @param dp   The distribution point.
             @param cert The certificate.
             @param crl  The CRL.
             @throws AnnotatedException if one of the conditions is not met or an error occurs.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.ProcessCrlB1(Org.BouncyCastle.Asn1.X509.DistributionPoint,System.Object,Org.BouncyCastle.X509.X509Crl)">
             If the DP includes cRLIssuer, then verify that the issuer field in the
             complete CRL matches cRLIssuer in the DP and that the complete CRL
             contains an
                  g distribution point extension with the indirectCRL
             boolean asserted. Otherwise, verify that the CRL issuer matches the
             certificate issuer.
            
             @param dp   The distribution point.
             @param cert The certificate ot attribute certificate.
             @param crl  The CRL for <code>cert</code>.
             @throws AnnotatedException if one of the above conditions does not apply or an error
                                        occurs.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.ProcessCrlF(Org.BouncyCastle.X509.X509Crl,System.Object,Org.BouncyCastle.X509.X509Certificate,Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.Pkix.PkixParameters,System.Collections.IList)">
             Obtain and validate the certification path for the complete CRL issuer.
             If a key usage extension is present in the CRL issuer's certificate,
             verify that the cRLSign bit is set.
            
             @param crl                CRL which contains revocation information for the certificate
                                       <code>cert</code>.
             @param cert               The attribute certificate or certificate to check if it is
                                       revoked.
             @param defaultCRLSignCert The issuer certificate of the certificate <code>cert</code>.
             @param defaultCRLSignKey  The public key of the issuer certificate
                                       <code>defaultCRLSignCert</code>.
             @param paramsPKIX         paramsPKIX PKIX parameters.
             @param certPathCerts      The certificates on the certification path.
             @return A <code>Set</code> with all keys of possible CRL issuer
                     certificates.
             @throws AnnotatedException if the CRL is not valid or the status cannot be checked or
                                        some error occurs.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.CheckCrl(Org.BouncyCastle.Asn1.X509.DistributionPoint,Org.BouncyCastle.Pkix.PkixParameters,Org.BouncyCastle.X509.X509Certificate,System.DateTime,Org.BouncyCastle.X509.X509Certificate,Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.Pkix.CertStatus,Org.BouncyCastle.Pkix.ReasonsMask,System.Collections.IList)">
             Checks a distribution point for revocation information for the
             certificate <code>cert</code>.
            
             @param dp                 The distribution point to consider.
             @param paramsPKIX         PKIX parameters.
             @param cert               Certificate to check if it is revoked.
             @param validDate          The date when the certificate revocation status should be
                                       checked.
             @param defaultCRLSignCert The issuer certificate of the certificate <code>cert</code>.
             @param defaultCRLSignKey  The public key of the issuer certificate
                                       <code>defaultCRLSignCert</code>.
             @param certStatus         The current certificate revocation status.
             @param reasonMask         The reasons mask which is already checked.
             @param certPathCerts      The certificates of the certification path.
             @throws AnnotatedException if the certificate is revoked or the status cannot be checked
                                        or some error occurs.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.CheckCrls(Org.BouncyCastle.Pkix.PkixParameters,Org.BouncyCastle.X509.X509Certificate,System.DateTime,Org.BouncyCastle.X509.X509Certificate,Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Collections.IList)">
             Checks a certificate if it is revoked.
            
             @param paramsPKIX       PKIX parameters.
             @param cert             Certificate to check if it is revoked.
             @param validDate        The date when the certificate revocation status should be
                                     checked.
             @param sign             The issuer certificate of the certificate <code>cert</code>.
             @param workingPublicKey The public key of the issuer certificate <code>sign</code>.
             @param certPathCerts    The certificates of the certification path.
             @throws AnnotatedException if the certificate is revoked or the status cannot be checked
                                        or some error occurs.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.ProcessCrlC(Org.BouncyCastle.X509.X509Crl,Org.BouncyCastle.X509.X509Crl,Org.BouncyCastle.Pkix.PkixParameters)">
             If use-deltas is set, verify the issuer and scope of the delta CRL.
            
             @param deltaCRL    The delta CRL.
             @param completeCRL The complete CRL.
             @param pkixParams  The PKIX paramaters.
             @throws AnnotatedException if an exception occurs.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.Rfc3281CertPathUtilities.CheckCrls(Org.BouncyCastle.X509.IX509AttributeCertificate,Org.BouncyCastle.Pkix.PkixParameters,Org.BouncyCastle.X509.X509Certificate,System.DateTime,System.Collections.IList)">
            Checks if an attribute certificate is revoked.
            
            @param attrCert Attribute certificate to check if it is revoked.
            @param paramsPKIX PKIX parameters.
            @param issuerCert The issuer certificate of the attribute certificate
                       <code>attrCert</code>.
            @param validDate The date when the certificate revocation status should
                       be checked.
            @param certPathCerts The certificates of the certification path to be
                       checked.
            
            @throws CertPathValidatorException if the certificate is revoked or the
                        status cannot be checked or some error occurs.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.Rfc3281CertPathUtilities.ProcessAttrCert1(Org.BouncyCastle.X509.IX509AttributeCertificate,Org.BouncyCastle.Pkix.PkixParameters)">
            Searches for a holder public key certificate and verifies its
            certification path.
            
            @param attrCert the attribute certificate.
            @param pkixParams The PKIX parameters.
            @return The certificate path of the holder certificate.
            @throws Exception if
                        <ul>
                        <li>no public key certificate can be found although holder
                        information is given by an entity name or a base certificate
                        ID</li>
                        <li>support classes cannot be created</li>
                        <li>no certification path for the public key certificate can
                        be built</li>
                        </ul>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.Rfc3281CertPathUtilities.CheckCrl(Org.BouncyCastle.Asn1.X509.DistributionPoint,Org.BouncyCastle.X509.IX509AttributeCertificate,Org.BouncyCastle.Pkix.PkixParameters,System.DateTime,Org.BouncyCastle.X509.X509Certificate,Org.BouncyCastle.Pkix.CertStatus,Org.BouncyCastle.Pkix.ReasonsMask,System.Collections.IList)">
            
            Checks a distribution point for revocation information for the
            certificate <code>attrCert</code>.
            
            @param dp The distribution point to consider.
            @param attrCert The attribute certificate which should be checked.
            @param paramsPKIX PKIX parameters.
            @param validDate The date when the certificate revocation status should
                       be checked.
            @param issuerCert Certificate to check if it is revoked.
            @param reasonMask The reasons mask which is already checked.
            @param certPathCerts The certificates of the certification path to be
                       checked.
            @throws Exception if the certificate is revoked or the status
                        cannot be checked or some error occurs.
        </member>
        <member name="T:Org.BouncyCastle.Pkix.TrustAnchor">
            <summary>
            A trust anchor or most-trusted Certification Authority (CA).
            
            This class represents a "most-trusted CA", which is used as a trust anchor
            for validating X.509 certification paths. A most-trusted CA includes the
            public key of the CA, the CA's name, and any constraints upon the set of
            paths which may be validated using this key. These parameters can be
            specified in the form of a trusted X509Certificate or as individual
            parameters.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.TrustAnchor.#ctor(Org.BouncyCastle.X509.X509Certificate,System.Byte[])">
             <summary>
             Creates an instance of TrustAnchor with the specified X509Certificate and
             optional name constraints, which are intended to be used as additional
             constraints when validating an X.509 certification path.
            	The name constraints are specified as a byte array. This byte array
            	should contain the DER encoded form of the name constraints, as they
            	would appear in the NameConstraints structure defined in RFC 2459 and
            	X.509. The ASN.1 definition of this structure appears below.
            	
            	<pre>
            	NameConstraints ::= SEQUENCE {
            		permittedSubtrees       [0]     GeneralSubtrees OPTIONAL,
            		excludedSubtrees        [1]     GeneralSubtrees OPTIONAL }
            	   
             GeneralSubtrees ::= SEQUENCE SIZE (1..MAX) OF GeneralSubtree
             
            		GeneralSubtree ::= SEQUENCE {
            		base                    GeneralName,
            		minimum         [0]     BaseDistance DEFAULT 0,
            		maximum         [1]     BaseDistance OPTIONAL }
            		
            		BaseDistance ::= INTEGER (0..MAX)
            
            		GeneralName ::= CHOICE {
            		otherName                       [0]     OtherName,
            		rfc822Name                      [1]     IA5String,
            		dNSName                         [2]     IA5String,
            		x400Address                     [3]     ORAddress,
            		directoryName                   [4]     Name,
            		ediPartyName                    [5]     EDIPartyName,
            		uniformResourceIdentifier       [6]     IA5String,
            		iPAddress                       [7]     OCTET STRING,
            		registeredID                    [8]     OBJECT IDENTIFIER}
            	</pre>
            	
            	Note that the name constraints byte array supplied is cloned to protect
            	against subsequent modifications.
             </summary>
             <param name="trustedCert">a trusted X509Certificate</param>
             <param name="nameConstraints">a byte array containing the ASN.1 DER encoding of a
             NameConstraints extension to be used for checking name
             constraints. Only the value of the extension is included, not
             the OID or criticality flag. Specify null to omit the
             parameter.</param>
             <exception cref="T:System.ArgumentNullException">if the specified X509Certificate is null</exception>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.TrustAnchor.#ctor(Org.BouncyCastle.Asn1.X509.X509Name,Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[])">
            <summary>
            Creates an instance of <c>TrustAnchor</c> where the
            most-trusted CA is specified as an X500Principal and public key.
            </summary>
            <remarks>
            <p>
            Name constraints are an optional parameter, and are intended to be used
            as additional constraints when validating an X.509 certification path.
            </p><p>
            The name constraints are specified as a byte array. This byte array
            contains the DER encoded form of the name constraints, as they
            would appear in the NameConstraints structure defined in RFC 2459
            and X.509. The ASN.1 notation for this structure is supplied in the
            documentation for the other constructors.
            </p><p>
            Note that the name constraints byte array supplied here is cloned to
            protect against subsequent modifications.
            </p>
            </remarks>
            <param name="caPrincipal">the name of the most-trusted CA as X509Name</param>
            <param name="pubKey">the public key of the most-trusted CA</param>
            <param name="nameConstraints">
            a byte array containing the ASN.1 DER encoding of a NameConstraints extension to
            be used for checking name constraints. Only the value of the extension is included,
            not the OID or criticality flag. Specify <c>null</c> to omit the parameter.
            </param>
            <exception cref="T:System.ArgumentNullException">
            if <c>caPrincipal</c> or <c>pubKey</c> is null
            </exception>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.TrustAnchor.#ctor(System.String,Org.BouncyCastle.Crypto.AsymmetricKeyParameter,System.Byte[])">
            <summary>
            Creates an instance of <code>TrustAnchor</code> where the most-trusted
            CA is specified as a distinguished name and public key. Name constraints
            are an optional parameter, and are intended to be used as additional
            constraints when validating an X.509 certification path.
            <br/>
            The name constraints are specified as a byte array. This byte array
            contains the DER encoded form of the name constraints, as they would
            appear in the NameConstraints structure defined in RFC 2459 and X.509.
            </summary>
            <param name="caName">the X.500 distinguished name of the most-trusted CA in RFC
            2253 string format</param>
            <param name="pubKey">the public key of the most-trusted CA</param>
            <param name="nameConstraints">a byte array containing the ASN.1 DER encoding of a
            NameConstraints extension to be used for checking name
            constraints. Only the value of the extension is included, not 
            the OID or criticality flag. Specify null to omit the 
            parameter.</param>
            throws NullPointerException, IllegalArgumentException
        </member>
        <member name="M:Org.BouncyCastle.Pkix.TrustAnchor.setNameConstraints(System.Byte[])">
            <summary>
            Decode the name constraints and clone them if not null.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.TrustAnchor.ToString">
            <summary>
            Returns a formatted string describing the <code>TrustAnchor</code>.
            </summary>
            <returns>a formatted string describing the <code>TrustAnchor</code></returns>
        </member>
        <member name="P:Org.BouncyCastle.Pkix.TrustAnchor.TrustedCert">
            <summary>
            Returns the most-trusted CA certificate.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Pkix.TrustAnchor.CA">
            <summary>
            Returns the name of the most-trusted CA as an X509Name.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Pkix.TrustAnchor.CAName">
            <summary>
            Returns the name of the most-trusted CA in RFC 2253 string format.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Pkix.TrustAnchor.CAPublicKey">
            <summary>
            Returns the public key of the most-trusted CA.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Security.AgreementUtilities">
            <remarks>
             Utility class for creating IBasicAgreement objects from their names/Oids
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Security.CipherUtilities">
            <remarks>
             Cipher Utility class contains methods that can not be specifically grouped into other classes.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Security.CipherUtilities.GetObjectIdentifier(System.String)">
            <summary>
            Returns a ObjectIdentifier for a give encoding.
            </summary>
            <param name="mechanism">A string representation of the encoding.</param>
            <returns>A DerObjectIdentifier, null if the Oid is not available.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Security.DigestUtilities">
            <remarks>
             Utility class for creating IDigest objects from their names/Oids
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Security.DigestUtilities.GetObjectIdentifier(System.String)">
            <summary>
            Returns a ObjectIdentifier for a given digest mechanism.
            </summary>
            <param name="mechanism">A string representation of the digest meanism.</param>
            <returns>A DerObjectIdentifier, null if the Oid is not available.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Security.DotNetUtilities">
            <summary>
            A class containing methods to interface the BouncyCastle world to the .NET Crypto world.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Security.DotNetUtilities.ToX509Certificate(Org.BouncyCastle.Asn1.X509.X509CertificateStructure)">
            <summary>
            Create an System.Security.Cryptography.X509Certificate from an X509Certificate Structure.
            </summary>
            <param name="x509Struct"></param>
            <returns>A System.Security.Cryptography.X509Certificate.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Security.MacUtilities">
            <remarks>
             Utility class for creating HMac object from their names/Oids
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Security.PbeUtilities">
             <summary>
            
             </summary>
        </member>
        <member name="M:Org.BouncyCastle.Security.PbeUtilities.GetObjectIdentifier(System.String)">
            <summary>
            Returns a ObjectIdentifier for a give encoding.
            </summary>
            <param name="mechanism">A string representation of the encoding.</param>
            <returns>A DerObjectIdentifier, null if the Oid is not available.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Security.SecurityUtilityException.#ctor">
            base constructor.
        </member>
        <member name="M:Org.BouncyCastle.Security.SecurityUtilityException.#ctor(System.String)">
             create a SecurityUtilityException with the given message.
            
             @param message the message to be carried with the exception.
        </member>
        <member name="T:Org.BouncyCastle.Security.SignerUtilities">
            <summary>
             Signer Utility class contains methods that can not be specifically grouped into other classes.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Security.SignerUtilities.GetObjectIdentifier(System.String)">
            <summary>
            Returns an ObjectIdentifier for a given encoding.
            </summary>
            <param name="mechanism">A string representation of the encoding.</param>
            <returns>A DerObjectIdentifier, null if the OID is not available.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Security.WrapperUtilities">
            <remarks>
             Utility class for creating IWrapper objects from their names/Oids
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Tsp.TimeStampRequest">
            Base class for an RFC 3161 Time Stamp Request.
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampRequest.#ctor(System.Byte[])">
             Create a TimeStampRequest from the past in byte array.
            
             @param req byte array containing the request.
             @throws IOException if the request is malformed.
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampRequest.#ctor(System.IO.Stream)">
             Create a TimeStampRequest from the past in input stream.
            
             @param in input stream containing the request.
             @throws IOException if the request is malformed.
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampRequest.Validate(System.Collections.IList,System.Collections.IList,System.Collections.IList)">
             Validate the timestamp request, checking the digest to see if it is of an
             accepted type and whether it is of the correct length for the algorithm specified.
            
             @param algorithms a set of string OIDS giving accepted algorithms.
             @param policies if non-null a set of policies we are willing to sign under.
             @param extensions if non-null a set of extensions we are willing to accept.
             @throws TspException if the request is invalid, or processing fails.
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampRequest.GetEncoded">
            return the ASN.1 encoded representation of this object.
        </member>
        <member name="T:Org.BouncyCastle.Tsp.TimeStampRequestGenerator">
            Generator for RFC 3161 Time Stamp Request objects.
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampRequestGenerator.AddExtension(System.String,System.Boolean,Org.BouncyCastle.Asn1.Asn1Encodable)">
            add a given extension field for the standard extensions tag (tag 3)
            @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampRequestGenerator.AddExtension(System.String,System.Boolean,System.Byte[])">
            add a given extension field for the standard extensions tag
            The value parameter becomes the contents of the octet string associated
            with the extension.
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampRequestGenerator.AddExtension(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,Org.BouncyCastle.Asn1.Asn1Encodable)">
            add a given extension field for the standard extensions tag (tag 3)
            @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampRequestGenerator.AddExtension(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,System.Byte[])">
            add a given extension field for the standard extensions tag
            The value parameter becomes the contents of the octet string associated
            with the extension.
        </member>
        <member name="T:Org.BouncyCastle.Tsp.TimeStampResponse">
            Base class for an RFC 3161 Time Stamp Response object.
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampResponse.#ctor(System.Byte[])">
             Create a TimeStampResponse from a byte array containing an ASN.1 encoding.
            
             @param resp the byte array containing the encoded response.
             @throws TspException if the response is malformed.
             @throws IOException if the byte array doesn't represent an ASN.1 encoding.
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampResponse.#ctor(System.IO.Stream)">
             Create a TimeStampResponse from an input stream containing an ASN.1 encoding.
            
             @param input the input stream containing the encoded response.
             @throws TspException if the response is malformed.
             @throws IOException if the stream doesn't represent an ASN.1 encoding.
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampResponse.Validate(Org.BouncyCastle.Tsp.TimeStampRequest)">
             Check this response against to see if it a well formed response for
             the passed in request. Validation will include checking the time stamp
             token if the response status is GRANTED or GRANTED_WITH_MODS.
            
             @param request the request to be checked against
             @throws TspException if the request can not match this response.
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampResponse.GetEncoded">
            return the ASN.1 encoded representation of this object.
        </member>
        <member name="T:Org.BouncyCastle.Tsp.TimeStampResponseGenerator">
            Generator for RFC 3161 Time Stamp Responses.
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampResponseGenerator.Generate(Org.BouncyCastle.Tsp.TimeStampRequest,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Utilities.Date.DateTimeObject)">
             Return an appropriate TimeStampResponse.
             <p>
             If genTime is null a timeNotAvailable error response will be returned.
            
             @param request the request this response is for.
             @param serialNumber serial number for the response token.
             @param genTime generation time for the response token.
             @param provider provider to use for signature calculation.
             @return
             @throws NoSuchAlgorithmException
             @throws NoSuchProviderException
             @throws TSPException
             </p>
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampResponseGenerator.GenerateFailResponse(Org.BouncyCastle.Asn1.Cmp.PkiStatus,System.Int32,System.String)">
             Generate a TimeStampResponse with chosen status and FailInfoField.
            
             @param status the PKIStatus to set.
             @param failInfoField the FailInfoField to set.
             @param statusString an optional string describing the failure.
             @return a TimeStampResponse with a failInfoField and optional statusString
             @throws TSPException in case the response could not be created
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampToken.Validate(Org.BouncyCastle.X509.X509Certificate)">
            Validate the time stamp token.
            <p>
            To be valid the token must be signed by the passed in certificate and
            the certificate must be the one referred to by the SigningCertificate
            attribute included in the hashed attributes of the token. The
            certificate must also have the ExtendedKeyUsageExtension with only
            KeyPurposeID.IdKPTimeStamping and have been valid at the time the
            timestamp was created.
            </p>
            <p>
            A successful call to validate means all the above are true.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampToken.ToCmsSignedData">
             Return the underlying CmsSignedData object.
            
             @return the underlying CMS structure.
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampToken.GetEncoded">
             Return a ASN.1 encoded byte stream representing the encoded object.
            
             @throws IOException if encoding fails.
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampTokenGenerator.#ctor(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.X509.X509Certificate,System.String,System.String)">
            basic creation - only the default attributes will be included here.
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TimeStampTokenGenerator.#ctor(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.X509.X509Certificate,System.String,System.String,Org.BouncyCastle.Asn1.Cms.AttributeTable,Org.BouncyCastle.Asn1.Cms.AttributeTable)">
            create with a signer with extra signed/unsigned attributes.
        </member>
        <member name="P:Org.BouncyCastle.Tsp.TimeStampTokenInfo.Nonce">
            @return the nonce value, null if there isn't one.
        </member>
        <member name="T:Org.BouncyCastle.Tsp.TspAlgorithms">
            Recognised hash algorithms for the time stamp protocol.
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TspUtil.GetSignatureTimestamps(Org.BouncyCastle.Cms.SignerInformation)">
             Fetches the signature time-stamp attributes from a SignerInformation object.
             Checks that the MessageImprint for each time-stamp matches the signature field.
             (see RFC 3161 Appendix A).
            
             @param signerInfo a SignerInformation to search for time-stamps
             @return a collection of TimeStampToken objects
             @throws TSPValidationException
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TspUtil.ValidateCertificate(Org.BouncyCastle.X509.X509Certificate)">
             Validate the passed in certificate as being of the correct type to be used
             for time stamping. To be valid it must have an ExtendedKeyUsage extension
             which has a key purpose identifier of id-kp-timeStamping.
            
             @param cert the certificate of interest.
             @throws TspValidationException if the certicate fails on one of the check points.
        </member>
        <member name="M:Org.BouncyCastle.Tsp.TspUtil.GetDigestAlgName(System.String)">
            <summary>
            Return the digest algorithm using one of the standard JCA string
            representations rather than the algorithm identifier (if possible).
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Tsp.TspValidationException">
            Exception thrown if a TSP request or response fails to validate.
            <p>
            If a failure code is associated with the exception it can be retrieved using
            the getFailureCode() method.</p>
        </member>
        <member name="P:Org.BouncyCastle.Tsp.TspValidationException.FailureCode">
             Return the failure code associated with this exception - if one is set.
            
             @return the failure code if set, -1 otherwise.
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Arrays">
            <summary> General array utilities.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Arrays.AreEqual(System.Byte[],System.Byte[])">
            <summary>
            Are two arrays equal.
            </summary>
            <param name="a">Left side.</param>
            <param name="b">Right side.</param>
            <returns>True if equal.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Arrays.ConstantTimeAreEqual(System.Byte[],System.Byte[])">
            <summary>
            A constant time equals comparison - does not terminate early if
            test will fail.
            </summary>
            <param name="a">first array</param>
            <param name="b">second array</param>
            <returns>true if arrays equal, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Arrays.CopyOfRange(System.Byte[],System.Int32,System.Int32)">
             Make a copy of a range of bytes from the passed in data array. The range can
             extend beyond the end of the input array, in which case the return array will
             be padded with zeroes.
            
             @param data the array from which the data is to be copied.
             @param from the start index at which the copying should take place.
             @param to the final index of the range (exclusive).
            
             @return a new byte array containing the range given.
        </member>
        <member name="T:Org.BouncyCastle.Utilities.BigIntegers">
            BigInteger utilities.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.BigIntegers.AsUnsignedByteArray(Org.BouncyCastle.Math.BigInteger)">
             Return the passed in value as an unsigned byte array.
            
             @param value value to be converted.
             @return a byte array without a leading zero byte if present in the signed encoding.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.BigIntegers.AsUnsignedByteArray(System.Int32,Org.BouncyCastle.Math.BigInteger)">
             Return the passed in value as an unsigned byte array of specified length, zero-extended as necessary.
            
             @param length desired length of result array.
             @param n value to be converted.
             @return a byte array of specified length, with leading zeroes as necessary given the size of n.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.BigIntegers.CreateRandomInRange(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Security.SecureRandom)">
            Return a random BigInteger not less than 'min' and not greater than 'max'
            
            @param min the least value that may be generated
            @param max the greatest value that may be generated
            @param random the source of randomness
            @return a random BigInteger value in the range [min,max]
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Date.DateTimeUtilities.DateTimeToUnixMs(System.DateTime)">
            <summary>
            Return the number of milliseconds since the Unix epoch (1 Jan., 1970 UTC) for a given DateTime value.
            </summary>
            <param name="dateTime">A UTC DateTime value not before epoch.</param>
            <returns>Number of whole milliseconds after epoch.</returns>
            <exception cref="T:System.ArgumentException">'dateTime' is before epoch.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Date.DateTimeUtilities.UnixMsToDateTime(System.Int64)">
            <summary>
            Create a DateTime value from the number of milliseconds since the Unix epoch (1 Jan., 1970 UTC).
            </summary>
            <param name="unixMs">Number of milliseconds since the epoch.</param>
            <returns>A UTC DateTime value</returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Date.DateTimeUtilities.CurrentUnixMs">
            <summary>
            Return the current number of milliseconds since the Unix epoch (1 Jan., 1970 UTC).
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64.Encode(System.Byte[])">
             encode the input data producing a base 64 encoded byte array.
            
             @return a byte array containing the base 64 encoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64.Encode(System.Byte[],System.Int32,System.Int32)">
             encode the input data producing a base 64 encoded byte array.
            
             @return a byte array containing the base 64 encoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64.Encode(System.Byte[],System.IO.Stream)">
             Encode the byte data to base 64 writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64.Encode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             Encode the byte data to base 64 writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64.Decode(System.Byte[])">
             decode the base 64 encoded input data. It is assumed the input data is valid.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64.Decode(System.String)">
             decode the base 64 encoded string data - whitespace will be ignored.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64.Decode(System.String,System.IO.Stream)">
             decode the base 64 encoded string data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Encoders.IEncoder">
            Encode and decode byte arrays (typically from binary to 7-bit ASCII
            encodings).
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64Encoder.Encode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             encode the input data producing a base 64 output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64Encoder.Decode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             decode the base 64 encoded byte data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64Encoder.DecodeString(System.String,System.IO.Stream)">
             decode the base 64 encoded string data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Encoders.BufferedDecoder">
            <summary>
             A buffering class to allow translation from one format to another to
                be done in discrete chunks.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.BufferedDecoder.#ctor(Org.BouncyCastle.Utilities.Encoders.ITranslator,System.Int32)">
            <summary>
            Create a buffered Decoder.
            </summary>
            <param name="translator">The translater to use.</param>
            <param name="bufferSize">The size of the buffer.</param>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.BufferedDecoder.ProcessByte(System.Byte,System.Byte[],System.Int32)">
            <summary>
            Process one byte of data.
            </summary>
            <param name="input">Data in.</param>
            <param name="output">Byte array for the output.</param>
            <param name="outOff">The offset in the output byte array to start writing from.</param>
            <returns>The amount of output bytes.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.BufferedDecoder.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Process data from a byte array.
            </summary>
            <param name="input">The input data.</param>
            <param name="inOff">Start position within input data array.</param>
            <param name="len">Amount of data to process from input data array.</param>
            <param name="outBytes">Array to store output.</param>
            <param name="outOff">Position in output array to start writing from.</param>
            <returns>The amount of output bytes.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Encoders.BufferedEncoder">
            <summary>
            A class that allows encoding of data using a specific encoder to be processed in chunks.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.BufferedEncoder.#ctor(Org.BouncyCastle.Utilities.Encoders.ITranslator,System.Int32)">
            <summary>
            Create.
            </summary>
            <param name="translator">The translator to use.</param>
            <param name="bufferSize">Size of the chunks.</param>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.BufferedEncoder.ProcessByte(System.Byte,System.Byte[],System.Int32)">
            <summary>
            Process one byte of data.
            </summary>
            <param name="input">The byte.</param>
            <param name="outBytes">An array to store output in.</param>
            <param name="outOff">Offset within output array to start writing from.</param>
            <returns></returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.BufferedEncoder.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Process data from a byte array.
            </summary>
            <param name="input">Input data Byte array containing data to be processed.</param>
            <param name="inOff">Start position within input data array.</param>
            <param name="len">Amount of input data to be processed.</param>
            <param name="outBytes">Output data array.</param>
            <param name="outOff">Offset within output data array to start writing to.</param>
            <returns>The amount of data written.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Encoders.Hex">
            <summary>
            Class to decode and encode Hex.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[])">
             encode the input data producing a Hex encoded byte array.
            
             @return a byte array containing the Hex encoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[],System.Int32,System.Int32)">
             encode the input data producing a Hex encoded byte array.
            
             @return a byte array containing the Hex encoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[],System.IO.Stream)">
             Hex encode the byte data writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             Hex encode the byte data writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Decode(System.Byte[])">
             decode the Hex encoded input data. It is assumed the input data is valid.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Decode(System.String)">
             decode the Hex encoded string data - whitespace will be ignored.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Decode(System.String,System.IO.Stream)">
             decode the Hex encoded string data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.HexEncoder.Encode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             encode the input data producing a Hex output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.HexEncoder.Decode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             decode the Hex encoded byte data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.HexEncoder.DecodeString(System.String,System.IO.Stream)">
             decode the Hex encoded string data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Encoders.HexTranslator">
            <summary>
            A hex translator.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Encoders.ITranslator">
            <summary>
            Translator interface.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.HexTranslator.GetEncodedBlockSize">
            <summary>
            Return encoded block size.
            </summary>
            <returns>2</returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.HexTranslator.Encode(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encode some data.
            </summary>
            <param name="input">Input data array.</param>
            <param name="inOff">Start position within input data array.</param>
            <param name="length">The amount of data to process.</param>
            <param name="outBytes">The output data array.</param>
            <param name="outOff">The offset within the output data array to start writing from.</param>
            <returns>Amount of data encoded.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.HexTranslator.GetDecodedBlockSize">
            <summary>
            Returns the decoded block size.
            </summary>
            <returns>1</returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.HexTranslator.Decode(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decode data from a byte array.
            </summary>
            <param name="input">The input data array.</param>
            <param name="inOff">Start position within input data array.</param>
            <param name="length">The amounty of data to process.</param>
            <param name="outBytes">The output data array.</param>
            <param name="outOff">The position within the output data array to start writing from.</param>
            <returns>The amount of data written.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Encoders.UrlBase64">
            Convert binary data to and from UrlBase64 encoding.  This is identical to
            Base64 encoding, except that the padding character is "." and the other 
            non-alphanumeric characters are "-" and "_" instead of "+" and "/".
            <p>
            The purpose of UrlBase64 encoding is to provide a compact encoding of binary
            data that is safe for use as an URL parameter. Base64 encoding does not
            produce encoded values that are safe for use in URLs, since "/" can be 
            interpreted as a path delimiter; "+" is the encoded form of a space; and
            "=" is used to separate a name from the corresponding value in an URL 
            parameter.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.UrlBase64.Encode(System.Byte[])">
             Encode the input data producing a URL safe base 64 encoded byte array.
            
             @return a byte array containing the URL safe base 64 encoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.UrlBase64.Encode(System.Byte[],System.IO.Stream)">
             Encode the byte data writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.UrlBase64.Decode(System.Byte[])">
             Decode the URL safe base 64 encoded input data - white space will be ignored.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.UrlBase64.Decode(System.Byte[],System.IO.Stream)">
             decode the URL safe base 64 encoded byte data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.UrlBase64.Decode(System.String)">
             decode the URL safe base 64 encoded string data - whitespace will be ignored.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.UrlBase64.Decode(System.String,System.IO.Stream)">
             Decode the URL safe base 64 encoded string data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Encoders.UrlBase64Encoder">
            Convert binary data to and from UrlBase64 encoding.  This is identical to
            Base64 encoding, except that the padding character is "." and the other 
            non-alphanumeric characters are "-" and "_" instead of "+" and "/".
            <p>
            The purpose of UrlBase64 encoding is to provide a compact encoding of binary
            data that is safe for use as an URL parameter. Base64 encoding does not
            produce encoded values that are safe for use in URLs, since "/" can be 
            interpreted as a path delimiter; "+" is the encoded form of a space; and
            "=" is used to separate a name from the corresponding value in an URL 
            parameter.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IO.Pem.PemObjectParser.ParseObject(Org.BouncyCastle.Utilities.IO.Pem.PemObject)">
            <param name="obj">
            A <see cref="T:Org.BouncyCastle.Utilities.IO.Pem.PemObject"/>
            </param>
            <returns>
            A <see cref="T:System.Object"/>
            </returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IO.Streams.PipeAllLimited(System.IO.Stream,System.Int64,System.IO.Stream)">
            <summary>
            Pipe all bytes from <c>inStr</c> to <c>outStr</c>, throwing <c>StreamFlowException</c> if greater
            than <c>limit</c> bytes in <c>inStr</c>.
            </summary>
            <param name="inStr">
            A <see cref="T:System.IO.Stream"/>
            </param>
            <param name="limit">
            A <see cref="T:System.Int64"/>
            </param>
            <param name="outStr">
            A <see cref="T:System.IO.Stream"/>
            </param>
            <returns>The number of bytes actually transferred, if not greater than <c>limit</c></returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.MemoableResetException">
            Exception to be thrown on a failure to reset an object implementing Memoable.
            <p>
            The exception extends InvalidCastException to enable users to have a single handling case,
            only introducing specific handling of this one if required.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.MemoableResetException.#ctor(System.String)">
             Basic Constructor.
            
             @param msg message to be associated with this exception.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Net.IPAddress.IsValid(System.String)">
             Validate the given IPv4 or IPv6 address.
            
             @param address the IP address as a string.
            
             @return true if a valid address, false otherwise
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Net.IPAddress.IsValidWithNetMask(System.String)">
             Validate the given IPv4 or IPv6 address and netmask.
            
             @param address the IP address as a string.
            
             @return true if a valid address with netmask, false otherwise
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Net.IPAddress.IsValidIPv4(System.String)">
             Validate the given IPv4 address.
             
             @param address the IP address as a string.
            
             @return true if a valid IPv4 address, false otherwise
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Net.IPAddress.IsValidIPv6(System.String)">
             Validate the given IPv6 address.
            
             @param address the IP address as a string.
            
             @return true if a valid IPv4 address, false otherwise
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Strings">
            <summary> General string utilities.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Zlib.ZDeflaterOutputStream">
            <summary>
            Summary description for DeflaterOutputStream.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Zlib.ZInflaterInputStream">
            <summary>
            Summary description for DeflaterOutputStream.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.X509.AttributeCertificateHolder">
            <remarks>
            The Holder object.
            <pre>
            Holder ::= SEQUENCE {
            	baseCertificateID   [0] IssuerSerial OPTIONAL,
            		-- the issuer and serial number of
            		-- the holder's Public Key Certificate
            	entityName          [1] GeneralNames OPTIONAL,
            		-- the name of the claimant or role
            	objectDigestInfo    [2] ObjectDigestInfo OPTIONAL
            		-- used to directly authenticate the holder,
            		-- for example, an executable
            }
            </pre>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.X509.AttributeCertificateHolder.#ctor(System.Int32,System.String,System.String,System.Byte[])">
             Constructs a holder for v2 attribute certificates with a hash value for
             some type of object.
             <p>
             <code>digestedObjectType</code> can be one of the following:
             <ul>
             <li>0 - publicKey - A hash of the public key of the holder must be
             passed.</li>
             <li>1 - publicKeyCert - A hash of the public key certificate of the
             holder must be passed.</li>
             <li>2 - otherObjectDigest - A hash of some other object type must be
             passed. <code>otherObjectTypeID</code> must not be empty.</li>
             </ul>
             </p>
             <p>This cannot be used if a v1 attribute certificate is used.</p>
            
             @param digestedObjectType The digest object type.
             @param digestAlgorithm The algorithm identifier for the hash.
             @param otherObjectTypeID The object type ID if
                        <code>digestedObjectType</code> is
                        <code>otherObjectDigest</code>.
             @param objectDigest The hash value.
        </member>
        <member name="M:Org.BouncyCastle.X509.AttributeCertificateHolder.GetObjectDigest">
             Returns the hash if an object digest info is used.
            
             @return The hash or <code>null</code> if no object digest info is set.
        </member>
        <member name="M:Org.BouncyCastle.X509.AttributeCertificateHolder.GetEntityNames">
             Return any principal objects inside the attribute certificate holder entity names field.
            
             @return an array of IPrincipal objects (usually X509Name), null if no entity names field is set.
        </member>
        <member name="M:Org.BouncyCastle.X509.AttributeCertificateHolder.GetIssuer">
             Return the principals associated with the issuer attached to this holder
            
             @return an array of principals, null if no BaseCertificateID is set.
        </member>
        <member name="P:Org.BouncyCastle.X509.AttributeCertificateHolder.DigestedObjectType">
             Returns the digest object type if an object digest info is used.
             <p>
             <ul>
             <li>0 - publicKey - A hash of the public key of the holder must be
             passed.</li>
             <li>1 - publicKeyCert - A hash of the public key certificate of the
             holder must be passed.</li>
             <li>2 - otherObjectDigest - A hash of some other object type must be
             passed. <code>otherObjectTypeID</code> must not be empty.</li>
             </ul>
             </p>
            
             @return The digest object type or -1 if no object digest info is set.
        </member>
        <member name="P:Org.BouncyCastle.X509.AttributeCertificateHolder.DigestAlgorithm">
             Returns the other object type ID if an object digest info is used.
            
             @return The other object type ID or <code>null</code> if no object
                     digest info is set.
        </member>
        <member name="P:Org.BouncyCastle.X509.AttributeCertificateHolder.OtherObjectTypeID">
             Returns the digest algorithm ID if an object digest info is used.
            
             @return The digest algorithm ID or <code>null</code> if no object
                     digest info is set.
        </member>
        <member name="P:Org.BouncyCastle.X509.AttributeCertificateHolder.SerialNumber">
             Return the serial number associated with the issuer attached to this holder.
            
             @return the certificate serial number, null if no BaseCertificateID is set.
        </member>
        <member name="T:Org.BouncyCastle.X509.AttributeCertificateIssuer">
            Carrying class for an attribute certificate issuer.
        </member>
        <member name="M:Org.BouncyCastle.X509.AttributeCertificateIssuer.#ctor(Org.BouncyCastle.Asn1.X509.AttCertIssuer)">
             Set the issuer directly with the ASN.1 structure.
            
             @param issuer The issuer
        </member>
        <member name="M:Org.BouncyCastle.X509.AttributeCertificateIssuer.GetPrincipals">
            <summary>Return any principal objects inside the attribute certificate issuer object.</summary>
            <returns>An array of IPrincipal objects (usually X509Principal).</returns>
        </member>
        <member name="T:Org.BouncyCastle.X509.Extension.AuthorityKeyIdentifierStructure">
            <remarks>A high level authority key identifier.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.X509.Extension.AuthorityKeyIdentifierStructure.#ctor(Org.BouncyCastle.Asn1.Asn1OctetString)">
             Constructor which will take the byte[] returned from getExtensionValue()
            
             @param encodedValue a DER octet encoded string with the extension structure in it.
             @throws IOException on parsing errors.
        </member>
        <member name="M:Org.BouncyCastle.X509.Extension.AuthorityKeyIdentifierStructure.#ctor(Org.BouncyCastle.X509.X509Certificate)">
             Create an AuthorityKeyIdentifier using the passed in certificate's public
             key, issuer and serial number.
            
             @param certificate the certificate providing the information.
             @throws CertificateParsingException if there is a problem processing the certificate
        </member>
        <member name="M:Org.BouncyCastle.X509.Extension.AuthorityKeyIdentifierStructure.#ctor(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
             Create an AuthorityKeyIdentifier using just the hash of the
             public key.
            
             @param pubKey the key to generate the hash from.
             @throws InvalidKeyException if there is a problem using the key.
        </member>
        <member name="T:Org.BouncyCastle.X509.Extension.SubjectKeyIdentifierStructure">
            A high level subject key identifier.
        </member>
        <member name="M:Org.BouncyCastle.X509.Extension.SubjectKeyIdentifierStructure.#ctor(Org.BouncyCastle.Asn1.Asn1OctetString)">
             Constructor which will take the byte[] returned from getExtensionValue()
            
             @param encodedValue a DER octet encoded string with the extension structure in it.
             @throws IOException on parsing errors.
        </member>
        <member name="T:Org.BouncyCastle.X509.IX509AttributeCertificate">
            <remarks>Interface for an X.509 Attribute Certificate.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.X509.IX509AttributeCertificate.GetAttributes">
            <summary>Return the attributes contained in the attribute block in the certificate.</summary>
            <returns>An array of attributes.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.IX509AttributeCertificate.GetAttributes(System.String)">
            <summary>Return the attributes with the same type as the passed in oid.</summary>
            <param name="oid">The object identifier we wish to match.</param>
            <returns>An array of matched attributes, null if there is no match.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.IX509AttributeCertificate.GetEncoded">
            <summary>Return an ASN.1 encoded byte array representing the attribute certificate.</summary>
            <returns>An ASN.1 encoded byte array.</returns>
            <exception cref="T:System.IO.IOException">If the certificate cannot be encoded.</exception>
        </member>
        <member name="P:Org.BouncyCastle.X509.IX509AttributeCertificate.Version">
            <summary>The version number for the certificate.</summary>
        </member>
        <member name="P:Org.BouncyCastle.X509.IX509AttributeCertificate.SerialNumber">
            <summary>The serial number for the certificate.</summary>
        </member>
        <member name="P:Org.BouncyCastle.X509.IX509AttributeCertificate.NotBefore">
            <summary>The UTC DateTime before which the certificate is not valid.</summary>
        </member>
        <member name="P:Org.BouncyCastle.X509.IX509AttributeCertificate.NotAfter">
            <summary>The UTC DateTime after which the certificate is not valid.</summary>
        </member>
        <member name="P:Org.BouncyCastle.X509.IX509AttributeCertificate.Holder">
            <summary>The holder of the certificate.</summary>
        </member>
        <member name="P:Org.BouncyCastle.X509.IX509AttributeCertificate.Issuer">
            <summary>The issuer details for the certificate.</summary>
        </member>
        <member name="T:Org.BouncyCastle.X509.PrincipalUtilities">
            <remarks>
            A utility class that will extract X509Principal objects from X.509 certificates.
            <p>
            Use this in preference to trying to recreate a principal from a string, not all
            DNs are what they should be, so it's best to leave them encoded where they
            can be.</p>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.X509.PrincipalUtilities.GetIssuerX509Principal(Org.BouncyCastle.X509.X509Certificate)">
            <summary>Return the issuer of the given cert as an X509Principal.</summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.PrincipalUtilities.GetSubjectX509Principal(Org.BouncyCastle.X509.X509Certificate)">
            <summary>Return the subject of the given cert as an X509Principal.</summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.PrincipalUtilities.GetIssuerX509Principal(Org.BouncyCastle.X509.X509Crl)">
            <summary>Return the issuer of the given CRL as an X509Principal.</summary>
        </member>
        <member name="T:Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector">
             This class is an <code>Selector</code> like implementation to select
             attribute certificates from a given set of criteria.
            
             @see org.bouncycastle.x509.X509AttributeCertificate
             @see org.bouncycastle.x509.X509Store
        </member>
        <member name="M:Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.Match(System.Object)">
            <summary>
            Decides if the given attribute certificate should be selected.
            </summary>
            <param name="obj">The attribute certificate to be checked.</param>
            <returns><code>true</code> if the object matches this selector.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.AddTargetName(Org.BouncyCastle.Asn1.X509.GeneralName)">
             Adds a target name criterion for the attribute certificate to the target
             information extension criteria. The <code>X509AttributeCertificate</code>
             must contain at least one of the specified target names.
             <p>
             Each attribute certificate may contain a target information extension
             limiting the servers where this attribute certificate can be used. If
             this extension is not present, the attribute certificate is not targeted
             and may be accepted by any server.
             </p>
            
             @param name The name as a GeneralName (not <code>null</code>)
        </member>
        <member name="M:Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.AddTargetName(System.Byte[])">
             Adds a target name criterion for the attribute certificate to the target
             information extension criteria. The <code>X509AttributeCertificate</code>
             must contain at least one of the specified target names.
             <p>
             Each attribute certificate may contain a target information extension
             limiting the servers where this attribute certificate can be used. If
             this extension is not present, the attribute certificate is not targeted
             and may be accepted by any server.
             </p>
            
             @param name a byte array containing the name in ASN.1 DER encoded form of a GeneralName
             @throws IOException if a parsing error occurs.
        </member>
        <member name="M:Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.SetTargetNames(System.Collections.IEnumerable)">
            Adds a collection with target names criteria. If <code>null</code> is
            given any will do.
            <p>
            The collection consists of either GeneralName objects or byte[] arrays representing
            DER encoded GeneralName structures.
            </p>
            
            @param names A collection of target names.
            @throws IOException if a parsing error occurs.
            @see #AddTargetName(byte[])
            @see #AddTargetName(GeneralName)
        </member>
        <member name="M:Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.GetTargetNames">
            Gets the target names. The collection consists of <code>List</code>s
            made up of an <code>Integer</code> in the first entry and a DER encoded
            byte array or a <code>String</code> in the second entry.
            <p>The returned collection is immutable.</p>
            
            @return The collection of target names
            @see #setTargetNames(Collection)
        </member>
        <member name="M:Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.AddTargetGroup(Org.BouncyCastle.Asn1.X509.GeneralName)">
             Adds a target group criterion for the attribute certificate to the target
             information extension criteria. The <code>X509AttributeCertificate</code>
             must contain at least one of the specified target groups.
             <p>
             Each attribute certificate may contain a target information extension
             limiting the servers where this attribute certificate can be used. If
             this extension is not present, the attribute certificate is not targeted
             and may be accepted by any server.
             </p>
            
             @param group The group as GeneralName form (not <code>null</code>)
        </member>
        <member name="M:Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.AddTargetGroup(System.Byte[])">
             Adds a target group criterion for the attribute certificate to the target
             information extension criteria. The <code>X509AttributeCertificate</code>
             must contain at least one of the specified target groups.
             <p>
             Each attribute certificate may contain a target information extension
             limiting the servers where this attribute certificate can be used. If
             this extension is not present, the attribute certificate is not targeted
             and may be accepted by any server.
             </p>
            
             @param name a byte array containing the group in ASN.1 DER encoded form of a GeneralName
             @throws IOException if a parsing error occurs.
        </member>
        <member name="M:Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.SetTargetGroups(System.Collections.IEnumerable)">
             Adds a collection with target groups criteria. If <code>null</code> is
             given any will do.
             <p>
             The collection consists of <code>GeneralName</code> objects or <code>byte[]</code>
             representing DER encoded GeneralNames.
             </p>
            
             @param names A collection of target groups.
             @throws IOException if a parsing error occurs.
             @see #AddTargetGroup(byte[])
             @see #AddTargetGroup(GeneralName)
        </member>
        <member name="M:Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.GetTargetGroups">
             Gets the target groups. The collection consists of <code>List</code>s
             made up of an <code>Integer</code> in the first entry and a DER encoded
             byte array or a <code>String</code> in the second entry.
             <p>The returned collection is immutable.</p>
            
             @return The collection of target groups.
             @see #setTargetGroups(Collection)
        </member>
        <member name="P:Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.AttributeCert">
            <summary>The attribute certificate which must be matched.</summary>
            <remarks>If <c>null</c> is given, any will do.</remarks>
        </member>
        <member name="P:Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.AttributeCertificateValid">
            <summary>The criteria for validity</summary>
            <remarks>If <c>null</c> is given any will do.</remarks>
        </member>
        <member name="P:Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.Holder">
            <summary>The holder.</summary>
            <remarks>If <c>null</c> is given any will do.</remarks>
        </member>
        <member name="P:Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.Issuer">
            <summary>The issuer.</summary>
            <remarks>If <c>null</c> is given any will do.</remarks>
        </member>
        <member name="P:Org.BouncyCastle.X509.Store.X509AttrCertStoreSelector.SerialNumber">
            <summary>The serial number.</summary>
            <remarks>If <c>null</c> is given any will do.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.X509.Store.X509CertPairStoreSelector">
            <remarks>
            This class is an <code>IX509Selector</code> implementation to select
            certificate pairs, which are e.g. used for cross certificates. The set of
            criteria is given from two <code>X509CertStoreSelector</code> objects,
            each of which, if present, must match the respective component of a pair.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.X509.Store.X509CertPairStoreSelector.Match(System.Object)">
            <summary>
            Decides if the given certificate pair should be selected. If
            <c>obj</c> is not a <code>X509CertificatePair</code>, this method
            returns <code>false</code>.
            </summary>
            <param name="obj">The <code>X509CertificatePair</code> to be tested.</param>
            <returns><code>true</code> if the object matches this selector.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.Store.X509CertPairStoreSelector.CertPair">
            <summary>The certificate pair which is used for testing on equality.</summary>
        </member>
        <member name="P:Org.BouncyCastle.X509.Store.X509CertPairStoreSelector.ForwardSelector">
            <summary>The certificate selector for the forward part.</summary>
        </member>
        <member name="P:Org.BouncyCastle.X509.Store.X509CertPairStoreSelector.ReverseSelector">
            <summary>The certificate selector for the reverse part.</summary>
        </member>
        <member name="T:Org.BouncyCastle.X509.Store.X509CollectionStore">
            A simple collection backed store.
        </member>
        <member name="M:Org.BouncyCastle.X509.Store.X509CollectionStore.#ctor(System.Collections.ICollection)">
             Basic constructor.
            
             @param collection - initial contents for the store, this is copied.
        </member>
        <member name="M:Org.BouncyCastle.X509.Store.X509CollectionStore.GetMatches(Org.BouncyCastle.X509.Store.IX509Selector)">
             Return the matches in the collection for the passed in selector.
            
             @param selector the selector to match against.
             @return a possibly empty collection of matching objects.
        </member>
        <member name="T:Org.BouncyCastle.X509.Store.X509CollectionStoreParameters">
            <remarks>This class contains a collection for collection based <code>X509Store</code>s.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.X509.Store.X509CollectionStoreParameters.#ctor(System.Collections.ICollection)">
            <summary>
            Constructor.
            <p>
            The collection is copied.
            </p>
            </summary>
            <param name="collection">The collection containing X.509 object types.</param>
            <exception cref="T:System.ArgumentNullException">If collection is null.</exception>
        </member>
        <member name="M:Org.BouncyCastle.X509.Store.X509CollectionStoreParameters.GetCollection">
            <summary>Returns a copy of the <code>ICollection</code>.</summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.Store.X509CollectionStoreParameters.ToString">
            <summary>Returns a formatted string describing the parameters.</summary>
        </member>
        <member name="P:Org.BouncyCastle.X509.Store.X509CrlStoreSelector.Issuers">
            <summary>
            An <code>ICollection</code> of <code>X509Name</code> objects
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.X509.Store.X509CrlStoreSelector.AttrCertChecking">
             The attribute certificate being checked. This is not a criterion.
             Rather, it is optional information that may help a {@link X509Store} find
             CRLs that would be relevant when checking revocation for the specified
             attribute certificate. If <code>null</code> is specified, then no such
             optional information is provided.
            
             @param attrCert the <code>IX509AttributeCertificate</code> being checked (or
                         <code>null</code>)
             @see #getAttrCertificateChecking()
        </member>
        <member name="P:Org.BouncyCastle.X509.Store.X509CrlStoreSelector.CompleteCrlEnabled">
             If <code>true</code> only complete CRLs are returned. Defaults to
             <code>false</code>.
            
             @return <code>true</code> if only complete CRLs are returned.
        </member>
        <member name="P:Org.BouncyCastle.X509.Store.X509CrlStoreSelector.DeltaCrlIndicatorEnabled">
             Returns if this selector must match CRLs with the delta CRL indicator
             extension set. Defaults to <code>false</code>.
            
             @return Returns <code>true</code> if only CRLs with the delta CRL
                     indicator extension are selected.
        </member>
        <member name="P:Org.BouncyCastle.X509.Store.X509CrlStoreSelector.IssuingDistributionPoint">
             The issuing distribution point.
             <p>
             The issuing distribution point extension is a CRL extension which
             identifies the scope and the distribution point of a CRL. The scope
             contains among others information about revocation reasons contained in
             the CRL. Delta CRLs and complete CRLs must have matching issuing
             distribution points.</p>
             <p>
             The byte array is cloned to protect against subsequent modifications.</p>
             <p>
             You must also enable or disable this criteria with
             {@link #setIssuingDistributionPointEnabled(bool)}.</p>
            
             @param issuingDistributionPoint The issuing distribution point to set.
                                             This is the DER encoded OCTET STRING extension value.
             @see #getIssuingDistributionPoint()
        </member>
        <member name="P:Org.BouncyCastle.X509.Store.X509CrlStoreSelector.IssuingDistributionPointEnabled">
             Whether the issuing distribution point criteria should be applied.
             Defaults to <code>false</code>.
             <p>
             You may also set the issuing distribution point criteria if not a missing
             issuing distribution point should be assumed.</p>
            
             @return Returns if the issuing distribution point check is enabled.
        </member>
        <member name="P:Org.BouncyCastle.X509.Store.X509CrlStoreSelector.MaxBaseCrlNumber">
             The maximum base CRL number. Defaults to <code>null</code>.
            
             @return Returns the maximum base CRL number.
             @see #setMaxBaseCRLNumber(BigInteger)
        </member>
        <member name="T:Org.BouncyCastle.X509.SubjectPublicKeyInfoFactory">
            <summary>
            A factory to produce Public Key Info Objects.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.SubjectPublicKeyInfoFactory.CreateSubjectPublicKeyInfo(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Create a Subject Public Key Info object for a given public key.
            </summary>
            <param name="key">One of ElGammalPublicKeyParameters, DSAPublicKeyParameter, DHPublicKeyParameters, RsaKeyParameters or ECPublicKeyParameters</param>
            <returns>A subject public key info object.</returns>
            <exception cref="T:System.Exception">Throw exception if object provided is not one of the above.</exception>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509AttrCertParser.ReadAttrCert(System.Byte[])">
            <summary>
            Create loading data from byte array.
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509AttrCertParser.ReadAttrCerts(System.Byte[])">
            <summary>
            Create loading data from byte array.
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509AttrCertParser.ReadAttrCert(System.IO.Stream)">
            Generates a certificate object and initializes it with the data
            read from the input stream inStream.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509AttrCertParser.ReadAttrCerts(System.IO.Stream)">
            Returns a (possibly empty) collection view of the certificates
            read from the given input stream inStream.
        </member>
        <member name="T:Org.BouncyCastle.X509.X509Attribute">
            Class for carrying the values in an X.509 Attribute.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Attribute.#ctor(Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param at an object representing an attribute.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Attribute.#ctor(System.String,Org.BouncyCastle.Asn1.Asn1Encodable)">
             Create an X.509 Attribute with the type given by the passed in oid and
             the value represented by an ASN.1 Set containing value.
            
             @param oid type of the attribute
             @param value value object to go into the atribute's value set.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Attribute.#ctor(System.String,Org.BouncyCastle.Asn1.Asn1EncodableVector)">
             Create an X.59 Attribute with the type given by the passed in oid and the
             value represented by an ASN.1 Set containing the objects in value.
            
             @param oid type of the attribute
             @param value vector of values to go in the attribute's value set.
        </member>
        <member name="T:Org.BouncyCastle.X509.X509Certificate">
            <summary>
            An Object representing an X509 Certificate.
            Has static methods for loading Certificates encoded in many forms that return X509Certificate Objects.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.IsValid(System.DateTime)">
            <summary>
            Return true if the nominated time is within the start and end times nominated on the certificate.
            </summary>
            <param name="time">The time to test validity against.</param>
            <returns>True if certificate is valid for nominated time.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.CheckValidity">
            <summary>
            Checks if the current date is within certificate's validity period.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.CheckValidity(System.DateTime)">
            <summary>
            Checks if the given date is within certificate's validity period.
            </summary>
            <exception cref="T:Org.BouncyCastle.Security.Certificates.CertificateExpiredException">if the certificate is expired by given date</exception>
            <exception cref="T:Org.BouncyCastle.Security.Certificates.CertificateNotYetValidException">if the certificate is not yet valid on given date</exception>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.GetTbsCertificate">
            <summary>
            Return the Der encoded TbsCertificate data.
            This is the certificate component less the signature.
            To Get the whole certificate call the GetEncoded() member.
            </summary>
            <returns>A byte array containing the Der encoded Certificate component.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.GetSignature">
            <summary>
            The signature.
            </summary>
            <returns>A byte array containg the signature of the certificate.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.GetSigAlgParams">
            <summary>
            Get the signature algorithms parameters. (EG DSA Parameters)
            </summary>
            <returns>A byte array containing the Der encoded version of the parameters or null if there are none.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.GetKeyUsage">
            <summary>
            Get a key usage guidlines.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.GetPublicKey">
            <summary>
            Get the public key of the subject of the certificate.
            </summary>
            <returns>The public key parameters.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.GetEncoded">
            <summary>
            Return a Der encoded version of this certificate.
            </summary>
            <returns>A byte array.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.Verify(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Verify the certificate's signature using the nominated public key.
            </summary>
            <param name="key">An appropriate public key parameter object, RsaPublicKeyParameters, DsaPublicKeyParameters or ECDsaPublicKeyParameters</param>
            <returns>True if the signature is valid.</returns>
            <exception cref="T:System.Exception">If key submitted is not of the above nominated types.</exception>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.Verify(Org.BouncyCastle.Crypto.IVerifierFactoryProvider)">
            <summary>
            Verify the certificate's signature using a verifier created using the passed in verifier provider.
            </summary>
            <param name="verifierProvider">An appropriate provider for verifying the certificate's signature.</param>
            <returns>True if the signature is valid.</returns>
            <exception cref="T:System.Exception">If verifier provider is not appropriate or the certificate algorithm is invalid.</exception>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.IsValidNow">
            <summary>
            Return true if the current time is within the start and end times nominated on the certificate.
            </summary>
            <returns>true id certificate is valid for the current time.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.Version">
            <summary>
            Return the certificate's version.
            </summary>
            <returns>An integer whose value Equals the version of the cerficate.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.SerialNumber">
            <summary>
            Return a <see cref="T:Org.BouncyCastle.Math.BigInteger">BigInteger</see> containing the serial number.
            </summary>
            <returns>The Serial number.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.IssuerDN">
            <summary>
            Get the Issuer Distinguished Name. (Who signed the certificate.)
            </summary>
            <returns>And X509Object containing name and value pairs.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.SubjectDN">
            <summary>
            Get the subject of this certificate.
            </summary>
            <returns>An X509Name object containing name and value pairs.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.NotBefore">
            <summary>
            The time that this certificate is valid from.
            </summary>
            <returns>A DateTime object representing that time in the local time zone.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.NotAfter">
            <summary>
            The time that this certificate is valid up to.
            </summary>
            <returns>A DateTime object representing that time in the local time zone.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.SigAlgName">
            <summary>
            A meaningful version of the Signature Algorithm. (EG SHA1WITHRSA)
            </summary>
            <returns>A sting representing the signature algorithm.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.SigAlgOid">
            <summary>
            Get the Signature Algorithms Object ID.
            </summary>
            <returns>A string containg a '.' separated object id.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.IssuerUniqueID">
            <summary>
            Get the issuers UID.
            </summary>
            <returns>A DerBitString.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.SubjectUniqueID">
            <summary>
            Get the subjects UID.
            </summary>
            <returns>A DerBitString.</returns>
        </member>
        <member name="T:Org.BouncyCastle.X509.X509CertificatePair">
            <remarks>
            This class contains a cross certificate pair. Cross certificates pairs may
            contain two cross signed certificates from two CAs. A certificate from the
            other CA to this CA is contained in the forward certificate, the certificate
            from this CA to the other CA is contained in the reverse certificate.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CertificatePair.#ctor(Org.BouncyCastle.X509.X509Certificate,Org.BouncyCastle.X509.X509Certificate)">
            <summary>Constructor</summary>
            <param name="forward">Certificate from the other CA to this CA.</param>
            <param name="reverse">Certificate from this CA to the other CA.</param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CertificatePair.#ctor(Org.BouncyCastle.Asn1.X509.CertificatePair)">
            <summary>Constructor from a ASN.1 CertificatePair structure.</summary>
            <param name="pair">The <c>CertificatePair</c> ASN.1 object.</param>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509CertificatePair.Forward">
            <summary>Returns the certificate from the other CA to this CA.</summary>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509CertificatePair.Reverse">
            <summary>Returns the certificate from this CA to the other CA.</summary>
        </member>
        <member name="T:Org.BouncyCastle.X509.X509CertificateParser">
            class for dealing with X509 certificates.
            <p>
            At the moment this will deal with "-----BEGIN CERTIFICATE-----" to "-----END CERTIFICATE-----"
            base 64 encoded certs, as well as the BER binaries of certificates and some classes of PKCS#7
            objects.</p>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CertificateParser.ReadCertificate(System.Byte[])">
            <summary>
            Create loading data from byte array.
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CertificateParser.ReadCertificates(System.Byte[])">
            <summary>
            Create loading data from byte array.
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CertificateParser.ReadCertificate(System.IO.Stream)">
            Generates a certificate object and initializes it with the data
            read from the input stream inStream.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CertificateParser.ReadCertificates(System.IO.Stream)">
            Returns a (possibly empty) collection view of the certificates
            read from the given input stream inStream.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CertPairParser.ReadCertPair(System.Byte[])">
            <summary>
            Create loading data from byte array.
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CertPairParser.ReadCertPairs(System.Byte[])">
            <summary>
            Create loading data from byte array.
            </summary>
            <param name="input"></param>
        </member>
        <member name="T:Org.BouncyCastle.X509.X509Crl">
             The following extensions are listed in RFC 2459 as relevant to CRLs
            
             Authority Key Identifier
             Issuer Alternative Name
             CRL Number
             Delta CRL Indicator (critical)
             Issuing Distribution Point (critical)
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Crl.Verify(Org.BouncyCastle.Crypto.IVerifierFactoryProvider)">
            <summary>
            Verify the CRL's signature using a verifier created using the passed in verifier provider.
            </summary>
            <param name="verifierProvider">An appropriate provider for verifying the CRL's signature.</param>
            <returns>True if the signature is valid.</returns>
            <exception cref="T:System.Exception">If verifier provider is not appropriate or the CRL algorithm is invalid.</exception>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Crl.ToString">
             Returns a string representation of this CRL.
            
             @return a string representation of this CRL.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Crl.IsRevoked(Org.BouncyCastle.X509.X509Certificate)">
             Checks whether the given certificate is on this CRL.
            
             @param cert the certificate to check for.
             @return true if the given certificate is on this CRL,
             false otherwise.
        </member>
        <member name="T:Org.BouncyCastle.X509.X509CrlEntry">
             The following extensions are listed in RFC 2459 as relevant to CRL Entries
            
             ReasonCode Hode Instruction Code Invalidity Date Certificate Issuer
             (critical)
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CrlEntry.#ctor(Org.BouncyCastle.Asn1.X509.CrlEntry,System.Boolean,Org.BouncyCastle.Asn1.X509.X509Name)">
             Constructor for CRLEntries of indirect CRLs. If <code>isIndirect</code>
             is <code>false</code> {@link #getCertificateIssuer()} will always
             return <code>null</code>, <code>previousCertificateIssuer</code> is
             ignored. If this <code>isIndirect</code> is specified and this CrlEntry
             has no certificate issuer CRL entry extension
             <code>previousCertificateIssuer</code> is returned by
             {@link #getCertificateIssuer()}.
            
             @param c
                        TbsCertificateList.CrlEntry object.
             @param isIndirect
                        <code>true</code> if the corresponding CRL is a indirect
                        CRL.
             @param previousCertificateIssuer
                        Certificate issuer of the previous CrlEntry.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CrlParser.ReadCrl(System.Byte[])">
            <summary>
            Create loading data from byte array.
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CrlParser.ReadCrls(System.Byte[])">
            <summary>
            Create loading data from byte array.
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CrlParser.ReadCrl(System.IO.Stream)">
            Generates a certificate revocation list (CRL) object and initializes
            it with the data read from the input stream inStream.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CrlParser.ReadCrls(System.IO.Stream)">
             Returns a (possibly empty) collection view of the CRLs read from
             the given input stream inStream.
            
             The inStream may contain a sequence of DER-encoded CRLs, or
             a PKCS#7 CRL set.  This is a PKCS#7 SignedData object, with the
             only significant field being crls.  In particular the signature
             and the contents are ignored.
        </member>
        <member name="T:Org.BouncyCastle.X509.X509KeyUsage">
             A holding class for constructing an X509 Key Usage extension.
            
             <pre>
                id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 }
            
                KeyUsage ::= BIT STRING {
                     digitalSignature        (0),
                     nonRepudiation          (1),
                     keyEncipherment         (2),
                     dataEncipherment        (3),
                     keyAgreement            (4),
                     keyCertSign             (5),
                     cRLSign                 (6),
                     encipherOnly            (7),
                     decipherOnly            (8) }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509KeyUsage.#ctor(System.Int32)">
             Basic constructor.
            
             @param usage - the bitwise OR of the Key Usage flags giving the
             allowed uses for the key.
             e.g. (X509KeyUsage.keyEncipherment | X509KeyUsage.dataEncipherment)
        </member>
        <member name="M:Org.BouncyCastle.X509.X509SignatureUtilities.GetDigestAlgName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            Return the digest algorithm using one of the standard JCA string
            representations rather than the algorithm identifier (if possible).
        </member>
        <member name="T:Org.BouncyCastle.X509.X509V1CertificateGenerator">
            <summary>
            Class to Generate X509V1 Certificates.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V1CertificateGenerator.#ctor">
            <summary>
            Default Constructor.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V1CertificateGenerator.Reset">
            <summary>
            Reset the generator.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V1CertificateGenerator.SetSerialNumber(Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Set the certificate's serial number.
            </summary>
            <remarks>Make serial numbers long, if you have no serial number policy make sure the number is at least 16 bytes of secure random data.
            You will be surprised how ugly a serial number collision can get.</remarks>
            <param name="serialNumber">The serial number.</param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V1CertificateGenerator.SetIssuerDN(Org.BouncyCastle.Asn1.X509.X509Name)">
            <summary>
            Set the issuer distinguished name.
            The issuer is the entity whose private key is used to sign the certificate.
            </summary>
            <param name="issuer">The issuers DN.</param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V1CertificateGenerator.SetNotBefore(System.DateTime)">
            <summary>
            Set the date that this certificate is to be valid from.
            </summary>
            <param name="date"/>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V1CertificateGenerator.SetNotAfter(System.DateTime)">
            <summary>
            Set the date after which this certificate will no longer be valid.
            </summary>
            <param name="date"/>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V1CertificateGenerator.SetSubjectDN(Org.BouncyCastle.Asn1.X509.X509Name)">
            <summary>
            Set the subject distinguished name.
            The subject describes the entity associated with the public key.
            </summary>
            <param name="subject"/>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V1CertificateGenerator.SetPublicKey(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Set the public key that this certificate identifies.
            </summary>
            <param name="publicKey"/>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V1CertificateGenerator.SetSignatureAlgorithm(System.String)">
            <summary>
            Set the signature algorithm that will be used to sign this certificate.
            This can be either a name or an OID, names are treated as case insensitive.
            </summary>
            <param name="signatureAlgorithm">string representation of the algorithm name</param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V1CertificateGenerator.Generate(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Generate a new X509Certificate.
            </summary>
            <param name="privateKey">The private key of the issuer used to sign this certificate.</param>
            <returns>An X509Certificate.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V1CertificateGenerator.Generate(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Generate a new X509Certificate specifying a SecureRandom instance that you would like to use.
            </summary>
            <param name="privateKey">The private key of the issuer used to sign this certificate.</param>
            <param name="random">The Secure Random you want to use.</param>
            <returns>An X509Certificate.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V1CertificateGenerator.Generate(Org.BouncyCastle.Crypto.ISignatureFactory)">
            <summary>
            Generate a new X509Certificate using the passed in SignatureCalculator.
            </summary>
            <param name="signatureCalculatorFactory">A signature calculator factory with the necessary algorithm details.</param>
            <returns>An X509Certificate.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509V1CertificateGenerator.SignatureAlgNames">
            <summary>
            Allows enumeration of the signature names supported by the generator.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.X509.X509V2AttributeCertificate">
            <summary>An implementation of a version 2 X.509 Attribute Certificate.</summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2AttributeCertificate.Verify(Org.BouncyCastle.Crypto.IVerifierFactoryProvider)">
            <summary>
            Verify the certificate's signature using a verifier created using the passed in verifier provider.
            </summary>
            <param name="verifierProvider">An appropriate provider for verifying the certificate's signature.</param>
            <returns>True if the signature is valid.</returns>
            <exception cref="T:System.Exception">If verifier provider is not appropriate or the certificate algorithm is invalid.</exception>
        </member>
        <member name="T:Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator">
            <remarks>Class to produce an X.509 Version 2 AttributeCertificate.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator.Reset">
            <summary>Reset the generator</summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator.SetHolder(Org.BouncyCastle.X509.AttributeCertificateHolder)">
            <summary>Set the Holder of this Attribute Certificate.</summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator.SetIssuer(Org.BouncyCastle.X509.AttributeCertificateIssuer)">
            <summary>Set the issuer.</summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator.SetSerialNumber(Org.BouncyCastle.Math.BigInteger)">
            <summary>Set the serial number for the certificate.</summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator.SetSignatureAlgorithm(System.String)">
            <summary>
            Set the signature algorithm. This can be either a name or an OID, names
            are treated as case insensitive.
            </summary>
            <param name="signatureAlgorithm">The algorithm name.</param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator.AddAttribute(Org.BouncyCastle.X509.X509Attribute)">
            <summary>Add an attribute.</summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator.AddExtension(System.String,System.Boolean,Org.BouncyCastle.Asn1.Asn1Encodable)">
            <summary>Add a given extension field for the standard extensions tag.</summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator.AddExtension(System.String,System.Boolean,System.Byte[])">
            <summary>
            Add a given extension field for the standard extensions tag.
            The value parameter becomes the contents of the octet string associated
            with the extension.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator.Generate(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Generate an X509 certificate, based on the current issuer and subject.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator.Generate(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Generate an X509 certificate, based on the current issuer and subject,
            using the supplied source of randomness, if required.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator.Generate(Org.BouncyCastle.Crypto.ISignatureFactory)">
            <summary>
            Generate a new X.509 Attribute Certificate using the passed in SignatureCalculator.
            </summary>
            <param name="signatureCalculatorFactory">A signature calculator factory with the necessary algorithm details.</param>
            <returns>An IX509AttributeCertificate.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509V2AttributeCertificateGenerator.SignatureAlgNames">
            <summary>
            Allows enumeration of the signature names supported by the generator.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.X509.X509V2CrlGenerator">
            class to produce an X.509 Version 2 CRL.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2CrlGenerator.Reset">
            reset the generator
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2CrlGenerator.SetIssuerDN(Org.BouncyCastle.Asn1.X509.X509Name)">
            Set the issuer distinguished name - the issuer is the entity whose private key is used to sign the
            certificate.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2CrlGenerator.AddCrlEntry(Org.BouncyCastle.Math.BigInteger,System.DateTime,System.Int32)">
             Reason being as indicated by CrlReason, i.e. CrlReason.KeyCompromise
             or 0 if CrlReason is not to be used
            
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2CrlGenerator.AddCrlEntry(Org.BouncyCastle.Math.BigInteger,System.DateTime,System.Int32,System.DateTime)">
             Add a CRL entry with an Invalidity Date extension as well as a CrlReason extension.
             Reason being as indicated by CrlReason, i.e. CrlReason.KeyCompromise
             or 0 if CrlReason is not to be used
            
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2CrlGenerator.AddCrlEntry(Org.BouncyCastle.Math.BigInteger,System.DateTime,Org.BouncyCastle.Asn1.X509.X509Extensions)">
             Add a CRL entry with extensions.
            
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2CrlGenerator.AddCrl(Org.BouncyCastle.X509.X509Crl)">
             Add the CRLEntry objects contained in a previous CRL.
            
             @param other the X509Crl to source the other entries from.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2CrlGenerator.SetSignatureAlgorithm(System.String)">
            <summary>
            Set the signature algorithm that will be used to sign this CRL.
            </summary>
            <param name="signatureAlgorithm"/>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2CrlGenerator.AddExtension(System.String,System.Boolean,Org.BouncyCastle.Asn1.Asn1Encodable)">
            add a given extension field for the standard extensions tag (tag 0)
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2CrlGenerator.AddExtension(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,Org.BouncyCastle.Asn1.Asn1Encodable)">
            add a given extension field for the standard extensions tag (tag 0)
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2CrlGenerator.AddExtension(System.String,System.Boolean,System.Byte[])">
            add a given extension field for the standard extensions tag (tag 0)
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2CrlGenerator.AddExtension(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,System.Byte[])">
            add a given extension field for the standard extensions tag (tag 0)
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2CrlGenerator.Generate(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Generate an X.509 CRL, based on the current issuer and subject.
            </summary>
            <param name="privateKey">The private key of the issuer that is signing this certificate.</param>
            <returns>An X509Crl.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2CrlGenerator.Generate(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Generate an X.509 CRL, based on the current issuer and subject using the specified secure random.
            </summary>
            <param name="privateKey">The private key of the issuer that is signing this certificate.</param>
            <param name="random">Your Secure Random instance.</param>
            <returns>An X509Crl.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V2CrlGenerator.Generate(Org.BouncyCastle.Crypto.ISignatureFactory)">
            <summary>
            Generate a new X509Crl using the passed in SignatureCalculator.
            </summary>
            <param name="signatureCalculatorFactory">A signature calculator factory with the necessary algorithm details.</param>
            <returns>An X509Crl.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509V2CrlGenerator.SignatureAlgNames">
            <summary>
            Allows enumeration of the signature names supported by the generator.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.X509.X509V3CertificateGenerator">
            <summary>
            A class to Generate Version 3 X509Certificates.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.Reset">
            <summary>
            Reset the Generator.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.SetSerialNumber(Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Set the certificate's serial number.
            </summary>
            <remarks>Make serial numbers long, if you have no serial number policy make sure the number is at least 16 bytes of secure random data.
            You will be surprised how ugly a serial number collision can Get.</remarks>
            <param name="serialNumber">The serial number.</param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.SetIssuerDN(Org.BouncyCastle.Asn1.X509.X509Name)">
            <summary>
            Set the distinguished name of the issuer.
            The issuer is the entity which is signing the certificate.
            </summary>
            <param name="issuer">The issuer's DN.</param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.SetNotBefore(System.DateTime)">
            <summary>
            Set the date that this certificate is to be valid from.
            </summary>
            <param name="date"/>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.SetNotAfter(System.DateTime)">
            <summary>
            Set the date after which this certificate will no longer be valid.
            </summary>
            <param name="date"/>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.SetSubjectDN(Org.BouncyCastle.Asn1.X509.X509Name)">
            <summary>
            Set the DN of the entity that this certificate is about.
            </summary>
            <param name="subject"/>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.SetPublicKey(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Set the public key that this certificate identifies.
            </summary>
            <param name="publicKey"/>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.SetSignatureAlgorithm(System.String)">
            <summary>
            Set the signature algorithm that will be used to sign this certificate.
            </summary>
            <param name="signatureAlgorithm"/>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.SetSubjectUniqueID(System.Boolean[])">
            <summary>
            Set the subject unique ID - note: it is very rare that it is correct to do this.
            </summary>
            <param name="uniqueID"/>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.SetIssuerUniqueID(System.Boolean[])">
            <summary>
            Set the issuer unique ID - note: it is very rare that it is correct to do this.
            </summary>
            <param name="uniqueID"/>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.AddExtension(System.String,System.Boolean,Org.BouncyCastle.Asn1.Asn1Encodable)">
            <summary>
            Add a given extension field for the standard extensions tag (tag 3).
            </summary>
            <param name="oid">string containing a dotted decimal Object Identifier.</param>
            <param name="critical">Is it critical.</param>
            <param name="extensionValue">The value.</param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.AddExtension(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,Org.BouncyCastle.Asn1.Asn1Encodable)">
            <summary>
            Add an extension to this certificate.
            </summary>
            <param name="oid">Its Object Identifier.</param>
            <param name="critical">Is it critical.</param>
            <param name="extensionValue">The value.</param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.AddExtension(System.String,System.Boolean,System.Byte[])">
            <summary>
            Add an extension using a string with a dotted decimal OID.
            </summary>
            <param name="oid">string containing a dotted decimal Object Identifier.</param>
            <param name="critical">Is it critical.</param>
            <param name="extensionValue">byte[] containing the value of this extension.</param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.AddExtension(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,System.Byte[])">
            <summary>
            Add an extension to this certificate.
            </summary>
            <param name="oid">Its Object Identifier.</param>
            <param name="critical">Is it critical.</param>
            <param name="extensionValue">byte[] containing the value of this extension.</param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.CopyAndAddExtension(System.String,System.Boolean,Org.BouncyCastle.X509.X509Certificate)">
            <summary>
            Add a given extension field for the standard extensions tag (tag 3),
            copying the extension value from another certificate.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.CopyAndAddExtension(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,Org.BouncyCastle.X509.X509Certificate)">
            add a given extension field for the standard extensions tag (tag 3)
            copying the extension value from another certificate.
            @throws CertificateParsingException if the extension cannot be extracted.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.Generate(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Generate an X509Certificate.
            </summary>
            <param name="privateKey">The private key of the issuer that is signing this certificate.</param>
            <returns>An X509Certificate.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.Generate(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Generate an X509Certificate using your own SecureRandom.
            </summary>
            <param name="privateKey">The private key of the issuer that is signing this certificate.</param>
            <param name="random">You Secure Random instance.</param>
            <returns>An X509Certificate.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509V3CertificateGenerator.Generate(Org.BouncyCastle.Crypto.ISignatureFactory)">
            <summary>
            Generate a new X509Certificate using the passed in SignatureCalculator.
            </summary>
            <param name="signatureCalculatorFactory">A signature calculator factory with the necessary algorithm details.</param>
            <returns>An X509Certificate.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509V3CertificateGenerator.SignatureAlgNames">
            <summary>
            Allows enumeration of the signature names supported by the generator.
            </summary>
        </member>
        <member name="M:KernelExtensions.Digest(Org.BouncyCastle.Crypto.IDigest,System.Byte[],System.Int32,System.Int32)">
            <summary>
            IMPORTANT: USE THIS METHOD CAREFULLY.
            This method serves as replacement for the java method MessageDigest#digest(byte[] buf, int offset, int len).
            However for now, we simply omit len parameter, because it doesn't affect anything for all current usages
            (there are two of them at the moment of the method addition which are in StandardHandlerUsingAes256 class).
            This may be not true for future possible usages, so be aware.
            </summary>
        </member>
    </members>
</doc>
